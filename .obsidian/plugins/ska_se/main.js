/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/runtime.js
var require_runtime = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/runtime.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
    exports.BASE_PATH = "https://unknown-unknown.svc.unknown.pinecone.io".replace(/\/+$/, "");
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(configuration) {
          if (configuration === void 0) {
            configuration = {};
          }
          this.configuration = configuration;
        }
        Object.defineProperty(Configuration2.prototype, "config", {
          set: function(configuration) {
            this.configuration = configuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "basePath", {
          get: function() {
            return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fetchApi", {
          get: function() {
            return this.configuration.fetchApi;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "middleware", {
          get: function() {
            return this.configuration.middleware || [];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
          get: function() {
            return this.configuration.queryParamsStringify || querystring;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "username", {
          get: function() {
            return this.configuration.username;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "password", {
          get: function() {
            return this.configuration.password;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "apiKey", {
          get: function() {
            var apiKey = this.configuration.apiKey;
            if (apiKey) {
              return typeof apiKey === "function" ? apiKey : function() {
                return apiKey;
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "accessToken", {
          get: function() {
            var _this = this;
            var accessToken = this.configuration.accessToken;
            if (accessToken) {
              return typeof accessToken === "function" ? accessToken : function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    return [2, accessToken];
                  });
                });
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "headers", {
          get: function() {
            return this.configuration.headers;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "credentials", {
          get: function() {
            return this.configuration.credentials;
          },
          enumerable: false,
          configurable: true
        });
        return Configuration2;
      }()
    );
    exports.Configuration = Configuration;
    exports.DefaultConfig = new Configuration();
    var BaseAPI = (
      /** @class */
      function() {
        function BaseAPI2(configuration) {
          if (configuration === void 0) {
            configuration = exports.DefaultConfig;
          }
          var _this = this;
          this.configuration = configuration;
          this.fetchApi = function(url, init) {
            return __awaiter(_this, void 0, void 0, function() {
              var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
              return __generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    fetchParams = { url, init };
                    _i = 0, _a2 = this.middleware;
                    _f.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    middleware = _a2[_i];
                    if (!middleware.pre)
                      return [3, 3];
                    return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
                  case 2:
                    fetchParams = _f.sent() || fetchParams;
                    _f.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    response = void 0;
                    _f.label = 5;
                  case 5:
                    _f.trys.push([5, 7, , 12]);
                    return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
                  case 6:
                    response = _f.sent();
                    return [3, 12];
                  case 7:
                    e_1 = _f.sent();
                    _b = 0, _c = this.middleware;
                    _f.label = 8;
                  case 8:
                    if (!(_b < _c.length))
                      return [3, 11];
                    middleware = _c[_b];
                    if (!middleware.onError)
                      return [3, 10];
                    return [4, middleware.onError({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      error: e_1,
                      response: response ? response.clone() : void 0
                    })];
                  case 9:
                    response = _f.sent() || response;
                    _f.label = 10;
                  case 10:
                    _b++;
                    return [3, 8];
                  case 11:
                    if (response === void 0) {
                      if (e_1 instanceof Error) {
                        throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                      } else {
                        throw e_1;
                      }
                    }
                    return [3, 12];
                  case 12:
                    _d = 0, _e = this.middleware;
                    _f.label = 13;
                  case 13:
                    if (!(_d < _e.length))
                      return [3, 16];
                    middleware = _e[_d];
                    if (!middleware.post)
                      return [3, 15];
                    return [4, middleware.post({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      response: response.clone()
                    })];
                  case 14:
                    response = _f.sent() || response;
                    _f.label = 15;
                  case 15:
                    _d++;
                    return [3, 13];
                  case 16:
                    return [2, response];
                }
              });
            });
          };
          this.middleware = configuration.middleware;
        }
        BaseAPI2.prototype.withMiddleware = function() {
          var _a2;
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
          }
          var next = this.clone();
          next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
          return next;
        };
        BaseAPI2.prototype.withPreMiddleware = function() {
          var preMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            preMiddlewares[_i] = arguments[_i];
          }
          var middlewares = preMiddlewares.map(function(pre) {
            return { pre };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.withPostMiddleware = function() {
          var postMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            postMiddlewares[_i] = arguments[_i];
          }
          var middlewares = postMiddlewares.map(function(post) {
            return { post };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.isJsonMime = function(mime) {
          if (!mime) {
            return false;
          }
          return BaseAPI2.jsonRegex.test(mime);
        };
        BaseAPI2.prototype.request = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var _a2, url, init, response;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.createFetchParams(context, initOverrides)];
                case 1:
                  _a2 = _b.sent(), url = _a2.url, init = _a2.init;
                  return [4, this.fetchApi(url, init)];
                case 2:
                  response = _b.sent();
                  if (response && (response.status >= 200 && response.status < 300)) {
                    return [2, response];
                  }
                  throw new ResponseError(response, "Response returned an error code");
              }
            });
          });
        };
        BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var url, headers, initOverrideFn, initParams, overriddenInit, _a2, body, init;
            var _this = this;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  url = this.configuration.basePath + context.path;
                  if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
                    url += "?" + this.configuration.queryParamsStringify(context.query);
                  }
                  headers = Object.assign({}, this.configuration.headers, context.headers);
                  Object.keys(headers).forEach(function(key) {
                    return headers[key] === void 0 ? delete headers[key] : {};
                  });
                  initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a3) {
                        return [2, initOverrides];
                      });
                    });
                  };
                  initParams = {
                    method: context.method,
                    headers,
                    body: context.body,
                    credentials: this.configuration.credentials
                  };
                  _a2 = [__assign({}, initParams)];
                  return [4, initOverrideFn({
                    init: initParams,
                    context
                  })];
                case 1:
                  overriddenInit = __assign.apply(void 0, _a2.concat([_b.sent()]));
                  if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
                    body = overriddenInit.body;
                  } else if (this.isJsonMime(headers["Content-Type"])) {
                    body = JSON.stringify(overriddenInit.body);
                  } else {
                    body = overriddenInit.body;
                  }
                  init = __assign(__assign({}, overriddenInit), { body });
                  return [2, { url, init }];
              }
            });
          });
        };
        BaseAPI2.prototype.clone = function() {
          var constructor = this.constructor;
          var next = new constructor(this.configuration);
          next.middleware = this.middleware.slice();
          return next;
        };
        BaseAPI2.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
        return BaseAPI2;
      }()
    );
    exports.BaseAPI = BaseAPI;
    function isBlob(value) {
      return typeof Blob !== "undefined" && value instanceof Blob;
    }
    function isFormData(value) {
      return typeof FormData !== "undefined" && value instanceof FormData;
    }
    var ResponseError = (
      /** @class */
      function(_super) {
        __extends(ResponseError2, _super);
        function ResponseError2(response, msg) {
          var _this = _super.call(this, msg) || this;
          _this.response = response;
          _this.name = "ResponseError";
          return _this;
        }
        return ResponseError2;
      }(Error)
    );
    exports.ResponseError = ResponseError;
    var FetchError = (
      /** @class */
      function(_super) {
        __extends(FetchError2, _super);
        function FetchError2(cause, msg) {
          var _this = _super.call(this, msg) || this;
          _this.cause = cause;
          _this.name = "FetchError";
          return _this;
        }
        return FetchError2;
      }(Error)
    );
    exports.FetchError = FetchError;
    var RequiredError = (
      /** @class */
      function(_super) {
        __extends(RequiredError2, _super);
        function RequiredError2(field, msg) {
          var _this = _super.call(this, msg) || this;
          _this.field = field;
          _this.name = "RequiredError";
          return _this;
        }
        return RequiredError2;
      }(Error)
    );
    exports.RequiredError = RequiredError;
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    function exists(json, key) {
      var value = json[key];
      return value !== null && value !== void 0;
    }
    exports.exists = exists;
    function querystring(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.querystring = querystring;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (value instanceof Array) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return querystring(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
    function mapValues(data, fn) {
      return Object.keys(data).reduce(function(acc, key) {
        var _a2;
        return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
      }, {});
    }
    exports.mapValues = mapValues;
    function canConsumeForm(consumes) {
      for (var _i = 0, consumes_1 = consumes; _i < consumes_1.length; _i++) {
        var consume = consumes_1[_i];
        if ("multipart/form-data" === consume.contentType) {
          return true;
        }
      }
      return false;
    }
    exports.canConsumeForm = canConsumeForm;
    var JSONApiResponse = (
      /** @class */
      function() {
        function JSONApiResponse2(raw, transformer) {
          if (transformer === void 0) {
            transformer = function(jsonValue) {
              return jsonValue;
            };
          }
          this.raw = raw;
          this.transformer = transformer;
        }
        JSONApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a2 = this.transformer;
                  return [4, this.raw.json()];
                case 1:
                  return [2, _a2.apply(this, [_b.sent()])];
              }
            });
          });
        };
        return JSONApiResponse2;
      }()
    );
    exports.JSONApiResponse = JSONApiResponse;
    var VoidApiResponse = (
      /** @class */
      function() {
        function VoidApiResponse2(raw) {
          this.raw = raw;
        }
        VoidApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, void 0];
            });
          });
        };
        return VoidApiResponse2;
      }()
    );
    exports.VoidApiResponse = VoidApiResponse;
    var BlobApiResponse = (
      /** @class */
      function() {
        function BlobApiResponse2(raw) {
          this.raw = raw;
        }
        BlobApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.blob()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return BlobApiResponse2;
      }()
    );
    exports.BlobApiResponse = BlobApiResponse;
    var TextApiResponse = (
      /** @class */
      function() {
        function TextApiResponse2(raw) {
          this.raw = raw;
        }
        TextApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.text()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return TextApiResponse2;
      }()
    );
    exports.TextApiResponse = TextApiResponse;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ApproximatedConfig.js
var require_ApproximatedConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ApproximatedConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApproximatedConfigToJSON = exports.ApproximatedConfigFromJSONTyped = exports.ApproximatedConfigFromJSON = exports.instanceOfApproximatedConfig = void 0;
    var runtime_1 = require_runtime();
    function instanceOfApproximatedConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfApproximatedConfig = instanceOfApproximatedConfig;
    function ApproximatedConfigFromJSON(json) {
      return ApproximatedConfigFromJSONTyped(json, false);
    }
    exports.ApproximatedConfigFromJSON = ApproximatedConfigFromJSON;
    function ApproximatedConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "kBits": !(0, runtime_1.exists)(json, "k_bits") ? void 0 : json["k_bits"],
        "hybrid": !(0, runtime_1.exists)(json, "hybrid") ? void 0 : json["hybrid"]
      };
    }
    exports.ApproximatedConfigFromJSONTyped = ApproximatedConfigFromJSONTyped;
    function ApproximatedConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "k_bits": value.kBits,
        "hybrid": value.hybrid
      };
    }
    exports.ApproximatedConfigToJSON = ApproximatedConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionMeta.js
var require_CollectionMeta = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionMetaToJSON = exports.CollectionMetaFromJSONTyped = exports.CollectionMetaFromJSON = exports.instanceOfCollectionMeta = void 0;
    var runtime_1 = require_runtime();
    function instanceOfCollectionMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCollectionMeta = instanceOfCollectionMeta;
    function CollectionMetaFromJSON(json) {
      return CollectionMetaFromJSONTyped(json, false);
    }
    exports.CollectionMetaFromJSON = CollectionMetaFromJSON;
    function CollectionMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "size": !(0, runtime_1.exists)(json, "size") ? void 0 : json["size"],
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : json["status"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "vectorCount": !(0, runtime_1.exists)(json, "vector_count") ? void 0 : json["vector_count"]
      };
    }
    exports.CollectionMetaFromJSONTyped = CollectionMetaFromJSONTyped;
    function CollectionMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "size": value.size,
        "status": value.status,
        "dimension": value.dimension,
        "vector_count": value.vectorCount
      };
    }
    exports.CollectionMetaToJSON = CollectionMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js
var require_CreateCollectionRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = void 0;
    function instanceOfCreateCollectionRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "source" in value;
      return isInstance;
    }
    exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
    function CreateCollectionRequestFromJSON(json) {
      return CreateCollectionRequestFromJSONTyped(json, false);
    }
    exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
    function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "source": json["source"]
      };
    }
    exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
    function CreateCollectionRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "source": value.source
      };
    }
    exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js
var require_CreateRequestIndexConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestIndexConfigToJSON = exports.CreateRequestIndexConfigFromJSONTyped = exports.CreateRequestIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig();
    function CreateRequestIndexConfigFromJSON(json) {
      return CreateRequestIndexConfigFromJSONTyped(json, false);
    }
    exports.CreateRequestIndexConfigFromJSON = CreateRequestIndexConfigFromJSON;
    function CreateRequestIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.CreateRequestIndexConfigFromJSONTyped = CreateRequestIndexConfigFromJSONTyped;
    function CreateRequestIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.CreateRequestIndexConfigToJSON = CreateRequestIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequest.js
var require_CreateRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestToJSON = exports.CreateRequestFromJSONTyped = exports.CreateRequestFromJSON = exports.instanceOfCreateRequest = void 0;
    var runtime_1 = require_runtime();
    var CreateRequestIndexConfig_1 = require_CreateRequestIndexConfig();
    function instanceOfCreateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "dimension" in value;
      return isInstance;
    }
    exports.instanceOfCreateRequest = instanceOfCreateRequest;
    function CreateRequestFromJSON(json) {
      return CreateRequestFromJSONTyped(json, false);
    }
    exports.CreateRequestFromJSON = CreateRequestFromJSON;
    function CreateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "dimension": json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"],
        "sourceCollection": !(0, runtime_1.exists)(json, "source_collection") ? void 0 : json["source_collection"]
      };
    }
    exports.CreateRequestFromJSONTyped = CreateRequestFromJSONTyped;
    function CreateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig,
        "source_collection": value.sourceCollection
      };
    }
    exports.CreateRequestToJSON = CreateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DeleteRequest.js
var require_DeleteRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DeleteRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfDeleteRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
    function DeleteRequestFromJSON(json) {
      return DeleteRequestFromJSONTyped(json, false);
    }
    exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
    function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ids": !(0, runtime_1.exists)(json, "ids") ? void 0 : json["ids"],
        "deleteAll": !(0, runtime_1.exists)(json, "deleteAll") ? void 0 : json["deleteAll"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
    function DeleteRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ids": value.ids,
        "deleteAll": value.deleteAll,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.DeleteRequestToJSON = DeleteRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js
var require_DescribeIndexStatsRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfDescribeIndexStatsRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
    function DescribeIndexStatsRequestFromJSON(json) {
      return DescribeIndexStatsRequestFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
    function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
    function DescribeIndexStatsRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "filter": value.filter
      };
    }
    exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/NamespaceSummary.js
var require_NamespaceSummary = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/NamespaceSummary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = void 0;
    var runtime_1 = require_runtime();
    function instanceOfNamespaceSummary(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
    function NamespaceSummaryFromJSON(json) {
      return NamespaceSummaryFromJSONTyped(json, false);
    }
    exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
    function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectorCount": !(0, runtime_1.exists)(json, "vectorCount") ? void 0 : json["vectorCount"]
      };
    }
    exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
    function NamespaceSummaryToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectorCount": value.vectorCount
      };
    }
    exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js
var require_DescribeIndexStatsResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsResponseToJSON = exports.DescribeIndexStatsResponseFromJSONTyped = exports.DescribeIndexStatsResponseFromJSON = exports.instanceOfDescribeIndexStatsResponse = void 0;
    var runtime_1 = require_runtime();
    var NamespaceSummary_1 = require_NamespaceSummary();
    function instanceOfDescribeIndexStatsResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsResponse = instanceOfDescribeIndexStatsResponse;
    function DescribeIndexStatsResponseFromJSON(json) {
      return DescribeIndexStatsResponseFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsResponseFromJSON = DescribeIndexStatsResponseFromJSON;
    function DescribeIndexStatsResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespaces": !(0, runtime_1.exists)(json, "namespaces") ? void 0 : (0, runtime_1.mapValues)(json["namespaces"], NamespaceSummary_1.NamespaceSummaryFromJSON),
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexFullness": !(0, runtime_1.exists)(json, "indexFullness") ? void 0 : json["indexFullness"],
        "totalVectorCount": !(0, runtime_1.exists)(json, "totalVectorCount") ? void 0 : json["totalVectorCount"]
      };
    }
    exports.DescribeIndexStatsResponseFromJSONTyped = DescribeIndexStatsResponseFromJSONTyped;
    function DescribeIndexStatsResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespaces": value.namespaces === void 0 ? void 0 : (0, runtime_1.mapValues)(value.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
        "dimension": value.dimension,
        "indexFullness": value.indexFullness,
        "totalVectorCount": value.totalVectorCount
      };
    }
    exports.DescribeIndexStatsResponseToJSON = DescribeIndexStatsResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SparseValues.js
var require_SparseValues = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SparseValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = void 0;
    function instanceOfSparseValues(value) {
      var isInstance = true;
      isInstance = isInstance && "indices" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfSparseValues = instanceOfSparseValues;
    function SparseValuesFromJSON(json) {
      return SparseValuesFromJSONTyped(json, false);
    }
    exports.SparseValuesFromJSON = SparseValuesFromJSON;
    function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indices": json["indices"],
        "values": json["values"]
      };
    }
    exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
    function SparseValuesToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indices": value.indices,
        "values": value.values
      };
    }
    exports.SparseValuesToJSON = SparseValuesToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Vector.js
var require_Vector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfVector = instanceOfVector;
    function VectorFromJSON(json) {
      return VectorFromJSONTyped(json, false);
    }
    exports.VectorFromJSON = VectorFromJSON;
    function VectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.VectorFromJSONTyped = VectorFromJSONTyped;
    function VectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.VectorToJSON = VectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/FetchResponse.js
var require_FetchResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/FetchResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = void 0;
    var runtime_1 = require_runtime();
    var Vector_1 = require_Vector();
    function instanceOfFetchResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfFetchResponse = instanceOfFetchResponse;
    function FetchResponseFromJSON(json) {
      return FetchResponseFromJSONTyped(json, false);
    }
    exports.FetchResponseFromJSON = FetchResponseFromJSON;
    function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": !(0, runtime_1.exists)(json, "vectors") ? void 0 : (0, runtime_1.mapValues)(json["vectors"], Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
    function FetchResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors === void 0 ? void 0 : (0, runtime_1.mapValues)(value.vectors, Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.FetchResponseToJSON = FetchResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/HnswConfig.js
var require_HnswConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/HnswConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HnswConfigToJSON = exports.HnswConfigFromJSONTyped = exports.HnswConfigFromJSON = exports.instanceOfHnswConfig = void 0;
    var runtime_1 = require_runtime();
    function instanceOfHnswConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfHnswConfig = instanceOfHnswConfig;
    function HnswConfigFromJSON(json) {
      return HnswConfigFromJSONTyped(json, false);
    }
    exports.HnswConfigFromJSON = HnswConfigFromJSON;
    function HnswConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "efConstruction": !(0, runtime_1.exists)(json, "ef_construction") ? void 0 : json["ef_construction"],
        "ef": !(0, runtime_1.exists)(json, "ef") ? void 0 : json["ef"],
        "m": !(0, runtime_1.exists)(json, "M") ? void 0 : json["M"],
        "maxElements": !(0, runtime_1.exists)(json, "max_elements") ? void 0 : json["max_elements"]
      };
    }
    exports.HnswConfigFromJSONTyped = HnswConfigFromJSONTyped;
    function HnswConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ef_construction": value.efConstruction,
        "ef": value.ef,
        "M": value.m,
        "max_elements": value.maxElements
      };
    }
    exports.HnswConfigToJSON = HnswConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js
var require_IndexMetaDatabaseIndexConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseIndexConfigToJSON = exports.IndexMetaDatabaseIndexConfigFromJSONTyped = exports.IndexMetaDatabaseIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig();
    function IndexMetaDatabaseIndexConfigFromJSON(json) {
      return IndexMetaDatabaseIndexConfigFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseIndexConfigFromJSON = IndexMetaDatabaseIndexConfigFromJSON;
    function IndexMetaDatabaseIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.IndexMetaDatabaseIndexConfigFromJSONTyped = IndexMetaDatabaseIndexConfigFromJSONTyped;
    function IndexMetaDatabaseIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.IndexMetaDatabaseIndexConfigToJSON = IndexMetaDatabaseIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js
var require_IndexMetaDatabase = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseToJSON = exports.IndexMetaDatabaseFromJSONTyped = exports.IndexMetaDatabaseFromJSON = exports.instanceOfIndexMetaDatabase = void 0;
    var runtime_1 = require_runtime();
    var IndexMetaDatabaseIndexConfig_1 = require_IndexMetaDatabaseIndexConfig();
    function instanceOfIndexMetaDatabase(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaDatabase = instanceOfIndexMetaDatabase;
    function IndexMetaDatabaseFromJSON(json) {
      return IndexMetaDatabaseFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseFromJSON = IndexMetaDatabaseFromJSON;
    function IndexMetaDatabaseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"]
      };
    }
    exports.IndexMetaDatabaseFromJSONTyped = IndexMetaDatabaseFromJSONTyped;
    function IndexMetaDatabaseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig
      };
    }
    exports.IndexMetaDatabaseToJSON = IndexMetaDatabaseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaStatus.js
var require_IndexMetaStatus = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaStatusToJSON = exports.IndexMetaStatusFromJSONTyped = exports.IndexMetaStatusFromJSON = exports.instanceOfIndexMetaStatus = exports.IndexMetaStatusStateEnum = void 0;
    var runtime_1 = require_runtime();
    exports.IndexMetaStatusStateEnum = {
      Initializing: "Initializing",
      InitializationFailed: "InitializationFailed",
      ScalingUp: "ScalingUp",
      ScalingDown: "ScalingDown",
      ScalingUpPodSize: "ScalingUpPodSize",
      ScalingDownPodSize: "ScalingDownPodSize",
      Terminating: "Terminating",
      Ready: "Ready"
    };
    function instanceOfIndexMetaStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaStatus = instanceOfIndexMetaStatus;
    function IndexMetaStatusFromJSON(json) {
      return IndexMetaStatusFromJSONTyped(json, false);
    }
    exports.IndexMetaStatusFromJSON = IndexMetaStatusFromJSON;
    function IndexMetaStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ready": !(0, runtime_1.exists)(json, "ready") ? void 0 : json["ready"],
        "state": !(0, runtime_1.exists)(json, "state") ? void 0 : json["state"],
        "host": !(0, runtime_1.exists)(json, "host") ? void 0 : json["host"],
        "port": !(0, runtime_1.exists)(json, "port") ? void 0 : json["port"]
      };
    }
    exports.IndexMetaStatusFromJSONTyped = IndexMetaStatusFromJSONTyped;
    function IndexMetaStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ready": value.ready,
        "state": value.state,
        "host": value.host,
        "port": value.port
      };
    }
    exports.IndexMetaStatusToJSON = IndexMetaStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMeta.js
var require_IndexMeta = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaToJSON = exports.IndexMetaFromJSONTyped = exports.IndexMetaFromJSON = exports.instanceOfIndexMeta = void 0;
    var runtime_1 = require_runtime();
    var IndexMetaDatabase_1 = require_IndexMetaDatabase();
    var IndexMetaStatus_1 = require_IndexMetaStatus();
    function instanceOfIndexMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMeta = instanceOfIndexMeta;
    function IndexMetaFromJSON(json) {
      return IndexMetaFromJSONTyped(json, false);
    }
    exports.IndexMetaFromJSON = IndexMetaFromJSON;
    function IndexMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "database": !(0, runtime_1.exists)(json, "database") ? void 0 : (0, IndexMetaDatabase_1.IndexMetaDatabaseFromJSON)(json["database"]),
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : (0, IndexMetaStatus_1.IndexMetaStatusFromJSON)(json["status"])
      };
    }
    exports.IndexMetaFromJSONTyped = IndexMetaFromJSONTyped;
    function IndexMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "database": (0, IndexMetaDatabase_1.IndexMetaDatabaseToJSON)(value.database),
        "status": (0, IndexMetaStatus_1.IndexMetaStatusToJSON)(value.status)
      };
    }
    exports.IndexMetaToJSON = IndexMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PatchRequest.js
var require_PatchRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PatchRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatchRequestToJSON = exports.PatchRequestFromJSONTyped = exports.PatchRequestFromJSON = exports.instanceOfPatchRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfPatchRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfPatchRequest = instanceOfPatchRequest;
    function PatchRequestFromJSON(json) {
      return PatchRequestFromJSONTyped(json, false);
    }
    exports.PatchRequestFromJSON = PatchRequestFromJSON;
    function PatchRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"]
      };
    }
    exports.PatchRequestFromJSONTyped = PatchRequestFromJSONTyped;
    function PatchRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "replicas": value.replicas,
        "pod_type": value.podType
      };
    }
    exports.PatchRequestToJSON = PatchRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufAny.js
var require_ProtobufAny = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufAny.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = void 0;
    var runtime_1 = require_runtime();
    function instanceOfProtobufAny(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfProtobufAny = instanceOfProtobufAny;
    function ProtobufAnyFromJSON(json) {
      return ProtobufAnyFromJSONTyped(json, false);
    }
    exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
    function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "typeUrl": !(0, runtime_1.exists)(json, "typeUrl") ? void 0 : json["typeUrl"],
        "value": !(0, runtime_1.exists)(json, "value") ? void 0 : json["value"]
      };
    }
    exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
    function ProtobufAnyToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "typeUrl": value.typeUrl,
        "value": value.value
      };
    }
    exports.ProtobufAnyToJSON = ProtobufAnyToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufNullValue.js
var require_ProtobufNullValue = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufNullValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = void 0;
    exports.ProtobufNullValue = {
      NullValue: "NULL_VALUE"
    };
    function ProtobufNullValueFromJSON(json) {
      return ProtobufNullValueFromJSONTyped(json, false);
    }
    exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
    function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
      return json;
    }
    exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
    function ProtobufNullValueToJSON(value) {
      return value;
    }
    exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryVector.js
var require_QueryVector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfQueryVector(value) {
      var isInstance = true;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfQueryVector = instanceOfQueryVector;
    function QueryVectorFromJSON(json) {
      return QueryVectorFromJSONTyped(json, false);
    }
    exports.QueryVectorFromJSON = QueryVectorFromJSON;
    function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "topK": !(0, runtime_1.exists)(json, "topK") ? void 0 : json["topK"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
    function QueryVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "topK": value.topK,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.QueryVectorToJSON = QueryVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryRequest.js
var require_QueryRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = void 0;
    var runtime_1 = require_runtime();
    var QueryVector_1 = require_QueryVector();
    var SparseValues_1 = require_SparseValues();
    function instanceOfQueryRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "topK" in value;
      return isInstance;
    }
    exports.instanceOfQueryRequest = instanceOfQueryRequest;
    function QueryRequestFromJSON(json) {
      return QueryRequestFromJSONTyped(json, false);
    }
    exports.QueryRequestFromJSON = QueryRequestFromJSON;
    function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "topK": json["topK"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"],
        "includeValues": !(0, runtime_1.exists)(json, "includeValues") ? void 0 : json["includeValues"],
        "includeMetadata": !(0, runtime_1.exists)(json, "includeMetadata") ? void 0 : json["includeMetadata"],
        "queries": !(0, runtime_1.exists)(json, "queries") ? void 0 : json["queries"].map(QueryVector_1.QueryVectorFromJSON),
        "vector": !(0, runtime_1.exists)(json, "vector") ? void 0 : json["vector"],
        "sparseVector": !(0, runtime_1.exists)(json, "sparseVector") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseVector"]),
        "id": !(0, runtime_1.exists)(json, "id") ? void 0 : json["id"]
      };
    }
    exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
    function QueryRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespace": value.namespace,
        "topK": value.topK,
        "filter": value.filter,
        "includeValues": value.includeValues,
        "includeMetadata": value.includeMetadata,
        "queries": value.queries === void 0 ? void 0 : value.queries.map(QueryVector_1.QueryVectorToJSON),
        "vector": value.vector,
        "sparseVector": (0, SparseValues_1.SparseValuesToJSON)(value.sparseVector),
        "id": value.id
      };
    }
    exports.QueryRequestToJSON = QueryRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ScoredVector.js
var require_ScoredVector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ScoredVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfScoredVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfScoredVector = instanceOfScoredVector;
    function ScoredVectorFromJSON(json) {
      return ScoredVectorFromJSONTyped(json, false);
    }
    exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
    function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "score": !(0, runtime_1.exists)(json, "score") ? void 0 : json["score"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
    function ScoredVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "score": value.score,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.ScoredVectorToJSON = ScoredVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SingleQueryResults.js
var require_SingleQueryResults = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SingleQueryResults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = void 0;
    var runtime_1 = require_runtime();
    var ScoredVector_1 = require_ScoredVector();
    function instanceOfSingleQueryResults(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
    function SingleQueryResultsFromJSON(json) {
      return SingleQueryResultsFromJSONTyped(json, false);
    }
    exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
    function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
    function SingleQueryResultsToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryResponse.js
var require_QueryResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = void 0;
    var runtime_1 = require_runtime();
    var ScoredVector_1 = require_ScoredVector();
    var SingleQueryResults_1 = require_SingleQueryResults();
    function instanceOfQueryResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfQueryResponse = instanceOfQueryResponse;
    function QueryResponseFromJSON(json) {
      return QueryResponseFromJSONTyped(json, false);
    }
    exports.QueryResponseFromJSON = QueryResponseFromJSON;
    function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "results": !(0, runtime_1.exists)(json, "results") ? void 0 : json["results"].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
    function QueryResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "results": value.results === void 0 ? void 0 : value.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.QueryResponseToJSON = QueryResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/RpcStatus.js
var require_RpcStatus = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/RpcStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = void 0;
    var runtime_1 = require_runtime();
    var ProtobufAny_1 = require_ProtobufAny();
    function instanceOfRpcStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfRpcStatus = instanceOfRpcStatus;
    function RpcStatusFromJSON(json) {
      return RpcStatusFromJSONTyped(json, false);
    }
    exports.RpcStatusFromJSON = RpcStatusFromJSON;
    function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "code": !(0, runtime_1.exists)(json, "code") ? void 0 : json["code"],
        "message": !(0, runtime_1.exists)(json, "message") ? void 0 : json["message"],
        "details": !(0, runtime_1.exists)(json, "details") ? void 0 : json["details"].map(ProtobufAny_1.ProtobufAnyFromJSON)
      };
    }
    exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
    function RpcStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "code": value.code,
        "message": value.message,
        "details": value.details === void 0 ? void 0 : value.details.map(ProtobufAny_1.ProtobufAnyToJSON)
      };
    }
    exports.RpcStatusToJSON = RpcStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpdateRequest.js
var require_UpdateRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpdateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfUpdateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
    function UpdateRequestFromJSON(json) {
      return UpdateRequestFromJSONTyped(json, false);
    }
    exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
    function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "setMetadata": !(0, runtime_1.exists)(json, "setMetadata") ? void 0 : json["setMetadata"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
    function UpdateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "setMetadata": value.setMetadata,
        "namespace": value.namespace
      };
    }
    exports.UpdateRequestToJSON = UpdateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertRequest.js
var require_UpsertRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = void 0;
    var runtime_1 = require_runtime();
    var Vector_1 = require_Vector();
    function instanceOfUpsertRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "vectors" in value;
      return isInstance;
    }
    exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
    function UpsertRequestFromJSON(json) {
      return UpsertRequestFromJSONTyped(json, false);
    }
    exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
    function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": json["vectors"].map(Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
    function UpsertRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors.map(Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.UpsertRequestToJSON = UpsertRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertResponse.js
var require_UpsertResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = void 0;
    var runtime_1 = require_runtime();
    function instanceOfUpsertResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
    function UpsertResponseFromJSON(json) {
      return UpsertResponseFromJSONTyped(json, false);
    }
    exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
    function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "upsertedCount": !(0, runtime_1.exists)(json, "upsertedCount") ? void 0 : json["upsertedCount"]
      };
    }
    exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
    function UpsertResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "upsertedCount": value.upsertedCount
      };
    }
    exports.UpsertResponseToJSON = UpsertResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/index.js
var require_models = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApproximatedConfig(), exports);
    __exportStar(require_CollectionMeta(), exports);
    __exportStar(require_CreateCollectionRequest(), exports);
    __exportStar(require_CreateRequest(), exports);
    __exportStar(require_CreateRequestIndexConfig(), exports);
    __exportStar(require_DeleteRequest(), exports);
    __exportStar(require_DescribeIndexStatsRequest(), exports);
    __exportStar(require_DescribeIndexStatsResponse(), exports);
    __exportStar(require_FetchResponse(), exports);
    __exportStar(require_HnswConfig(), exports);
    __exportStar(require_IndexMeta(), exports);
    __exportStar(require_IndexMetaDatabase(), exports);
    __exportStar(require_IndexMetaDatabaseIndexConfig(), exports);
    __exportStar(require_IndexMetaStatus(), exports);
    __exportStar(require_NamespaceSummary(), exports);
    __exportStar(require_PatchRequest(), exports);
    __exportStar(require_ProtobufAny(), exports);
    __exportStar(require_ProtobufNullValue(), exports);
    __exportStar(require_QueryRequest(), exports);
    __exportStar(require_QueryResponse(), exports);
    __exportStar(require_QueryVector(), exports);
    __exportStar(require_RpcStatus(), exports);
    __exportStar(require_ScoredVector(), exports);
    __exportStar(require_SingleQueryResults(), exports);
    __exportStar(require_SparseValues(), exports);
    __exportStar(require_UpdateRequest(), exports);
    __exportStar(require_UpsertRequest(), exports);
    __exportStar(require_UpsertResponse(), exports);
    __exportStar(require_Vector(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js
var require_IndexOperationsApi = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexOperationsApi = void 0;
    var runtime = __importStar(require_runtime());
    var index_1 = require_models();
    var IndexOperationsApi = (
      /** @class */
      function(_super) {
        __extends(IndexOperationsApi2, _super);
        function IndexOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        IndexOperationsApi2.prototype.configureIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling configureIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "PATCH",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.PatchRequestToJSON)(requestParameters.patchRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.configureIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.configureIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollection = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.CreateRequestToJSON)(requestParameters.createRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndex = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.CollectionMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling describeIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.IndexMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollectionsRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollections = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listCollectionsRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexesRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexes = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listIndexesRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return IndexOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.IndexOperationsApi = IndexOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js
var require_VectorOperationsApi = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorOperationsApi = void 0;
    var runtime = __importStar(require_runtime());
    var index_1 = require_models();
    var VectorOperationsApi = (
      /** @class */
      function(_super) {
        __extends(VectorOperationsApi2, _super);
        function VectorOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        VectorOperationsApi2.prototype._deleteRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === void 0) {
                    throw new runtime.RequiredError("deleteRequest", "Required parameter requestParameters.deleteRequest was null or undefined when calling _delete.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype._delete = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._deleteRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1Raw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.deleteAll !== void 0) {
                    queryParameters["deleteAll"] = requestParameters.deleteAll;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1 = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.delete1Raw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStatsRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === void 0) {
                    throw new runtime.RequiredError("describeIndexStatsRequest", "Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStatsRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1Raw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1 = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStats1Raw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetchRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.ids === null || requestParameters.ids === void 0) {
                    throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling fetch.");
                  }
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/fetch",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.FetchResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetch = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetchRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.queryRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.queryRequest === null || requestParameters.queryRequest === void 0) {
                    throw new runtime.RequiredError("queryRequest", "Required parameter requestParameters.queryRequest was null or undefined when calling query.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/query",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.QueryRequestToJSON)(requestParameters.queryRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.QueryResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.query = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.queryRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.updateRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.updateRequest === null || requestParameters.updateRequest === void 0) {
                    throw new runtime.RequiredError("updateRequest", "Required parameter requestParameters.updateRequest was null or undefined when calling update.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/update",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.UpdateRequestToJSON)(requestParameters.updateRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.update = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.updateRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsertRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === void 0) {
                    throw new runtime.RequiredError("upsertRequest", "Required parameter requestParameters.upsertRequest was null or undefined when calling upsert.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/upsert",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.UpsertResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsert = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.upsertRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return VectorOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.VectorOperationsApi = VectorOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/index.js
var require_apis = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndexOperationsApi(), exports);
    __exportStar(require_VectorOperationsApi(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/index.js
var require_pinecone_generated_ts_fetch = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_runtime(), exports);
    __exportStar(require_apis(), exports);
    __exportStar(require_models(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/base.js
var require_base = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/base.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasePineconeError = void 0;
    var BasePineconeError = (
      /** @class */
      function(_super) {
        __extends(BasePineconeError2, _super);
        function BasePineconeError2(message) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget);
          }
          _this.name = _this.constructor.name;
          return _this;
        }
        return BasePineconeError2;
      }(Error)
    );
    exports.BasePineconeError = BasePineconeError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/config.js
var require_config = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/config.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeUnknownRequestFailure = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
    var base_1 = require_base();
    var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
    var PineconeConfigurationError = (
      /** @class */
      function(_super) {
        __extends(PineconeConfigurationError2, _super);
        function PineconeConfigurationError2(message) {
          var _this = _super.call(this, "".concat(message, " ").concat(CONFIG_HELP)) || this;
          _this.name = "PineconeConfigurationError";
          return _this;
        }
        return PineconeConfigurationError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConfigurationError = PineconeConfigurationError;
    var PineconeUnexpectedResponseError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnexpectedResponseError2, _super);
        function PineconeUnexpectedResponseError2(url, status, body, message) {
          var _this = _super.call(this, "Unexpected response while calling ".concat(url, ". ").concat(message ? message + " " : "", "Status: ").concat(status, ". Body: ").concat(body)) || this;
          _this.name = "PineconeUnexpectedResponseError";
          return _this;
        }
        return PineconeUnexpectedResponseError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnexpectedResponseError = PineconeUnexpectedResponseError;
    var PineconeEnvironmentVarsNotSupportedError = (
      /** @class */
      function(_super) {
        __extends(PineconeEnvironmentVarsNotSupportedError2, _super);
        function PineconeEnvironmentVarsNotSupportedError2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = "PineconeEnvironmentVarsNotSupportedError";
          return _this;
        }
        return PineconeEnvironmentVarsNotSupportedError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeEnvironmentVarsNotSupportedError = PineconeEnvironmentVarsNotSupportedError;
    var PineconeUnknownRequestFailure = (
      /** @class */
      function(_super) {
        __extends(PineconeUnknownRequestFailure2, _super);
        function PineconeUnknownRequestFailure2(url, underlyingError) {
          var _this = this;
          var message = "Something went wrong while attempting to call ".concat(url, ". Please check your configuration and try again later. Underlying error was ").concat(JSON.stringify(underlyingError.message));
          _this = _super.call(this, message) || this;
          _this.name = "PineconeUnknownRequestFailure";
          return _this;
        }
        return PineconeUnknownRequestFailure2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnknownRequestFailure = PineconeUnknownRequestFailure;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/http.js
var require_http = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/http.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHttpStatusError = exports.PineconeUnmappedHttpError = exports.PineconeNotImplementedError = exports.PineconeInternalServerError = exports.PineconeConflictError = exports.PineconeNotFoundError = exports.PineconeAuthorizationError = exports.PineconeBadRequestError = void 0;
    var base_1 = require_base();
    var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
    var PineconeBadRequestError = (
      /** @class */
      function(_super) {
        __extends(PineconeBadRequestError2, _super);
        function PineconeBadRequestError2(failedRequest) {
          var _this = this;
          var message = failedRequest.message;
          _this = _super.call(this, message) || this;
          _this.name = "PineconeBadRequestError";
          return _this;
        }
        return PineconeBadRequestError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeBadRequestError = PineconeBadRequestError;
    var PineconeAuthorizationError = (
      /** @class */
      function(_super) {
        __extends(PineconeAuthorizationError2, _super);
        function PineconeAuthorizationError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url;
          if (url) {
            _this = _super.call(this, "The API key you provided was rejected while calling ".concat(url, ". Please check your configuration values and try again. ").concat(CONFIG_HELP)) || this;
          } else {
            _this = _super.call(this, "The API key you provided was rejected. Please check your configuration values and try again. ".concat(CONFIG_HELP)) || this;
          }
          _this.name = "PineconeAuthorizationError";
          return _this;
        }
        return PineconeAuthorizationError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeAuthorizationError = PineconeAuthorizationError;
    var PineconeNotFoundError = (
      /** @class */
      function(_super) {
        __extends(PineconeNotFoundError2, _super);
        function PineconeNotFoundError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, message = failedRequest.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 404. ").concat(message ? message : "")) || this;
          } else if (message) {
            _this = _super.call(this, message) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeNotFoundError";
          return _this;
        }
        return PineconeNotFoundError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeNotFoundError = PineconeNotFoundError;
    var PineconeConflictError = (
      /** @class */
      function(_super) {
        __extends(PineconeConflictError2, _super);
        function PineconeConflictError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, message = failedRequest.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 409. ").concat(message ? message : "")) || this;
          } else if (message) {
            _this = _super.call(this, message) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeConflictError";
          return _this;
        }
        return PineconeConflictError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConflictError = PineconeConflictError;
    var PineconeInternalServerError = (
      /** @class */
      function(_super) {
        __extends(PineconeInternalServerError2, _super);
        function PineconeInternalServerError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, body = failedRequest.body;
          var intro = url ? "An internal server error occured while calling the ".concat(url, " endpoint.") : "";
          var help = "To see overall service health and learn whether this seems like a large-scale problem or one specific to your request, please go to https://status.pinecone.io/ to view our status page. If you believe the error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client";
          var bodyMessage = body ? "Body: ".concat(body) : "";
          _this = _super.call(this, [intro, help, bodyMessage].join(" ").trim()) || this;
          _this.name = "PineconeInternalServerError";
          return _this;
        }
        return PineconeInternalServerError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeInternalServerError = PineconeInternalServerError;
    var PineconeNotImplementedError = (
      /** @class */
      function(_super) {
        __extends(PineconeNotImplementedError2, _super);
        function PineconeNotImplementedError2(requestInfo) {
          var _this = this;
          var url = requestInfo.url, message = requestInfo.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 501. ").concat(message ? message : "")) || this;
          } else if (message) {
            _this = _super.call(this, message) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeNotImplementedError";
          return _this;
        }
        return PineconeNotImplementedError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeNotImplementedError = PineconeNotImplementedError;
    var PineconeUnmappedHttpError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnmappedHttpError2, _super);
        function PineconeUnmappedHttpError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, status = failedRequest.status, body = failedRequest.body, message = failedRequest.message;
          var intro = url ? "An unexpected error occured while calling the ".concat(url, " endpoint. ") : "";
          var statusMsg = status ? "Status: ".concat(status, ". ") : "";
          var bodyMsg = body ? "Body: ".concat(body) : "";
          _this = _super.call(this, [intro, message, statusMsg, bodyMsg].join(" ").trim()) || this;
          _this.name = "PineconeUnmappedHttpError";
          return _this;
        }
        return PineconeUnmappedHttpError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnmappedHttpError = PineconeUnmappedHttpError;
    var mapHttpStatusError = function(failedRequestInfo) {
      switch (failedRequestInfo.status) {
        case 400:
          return new PineconeBadRequestError(failedRequestInfo);
        case 401:
          return new PineconeAuthorizationError(failedRequestInfo);
        case 404:
          return new PineconeNotFoundError(failedRequestInfo);
        case 409:
          return new PineconeConflictError(failedRequestInfo);
        case 500:
          return new PineconeInternalServerError(failedRequestInfo);
        case 501:
          return new PineconeNotImplementedError(failedRequestInfo);
        default:
          throw new PineconeUnmappedHttpError(failedRequestInfo);
      }
    };
    exports.mapHttpStatusError = mapHttpStatusError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/request.js
var require_request = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/request.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeConnectionError = void 0;
    var base_1 = require_base();
    var PineconeConnectionError = (
      /** @class */
      function(_super) {
        __extends(PineconeConnectionError2, _super);
        function PineconeConnectionError2() {
          var _this = _super.call(this, "Request failed to reach Pinecone. Verify you have the correct environment, project id, and index name configured.") || this;
          _this.name = "PineconeConnectionError";
          return _this;
        }
        return PineconeConnectionError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConnectionError = PineconeConnectionError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/validation.js
var require_validation = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/validation.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeArgumentError = void 0;
    var base_1 = require_base();
    var PineconeArgumentError = (
      /** @class */
      function(_super) {
        __extends(PineconeArgumentError2, _super);
        function PineconeArgumentError2(message) {
          var _this = _super.call(this, "".concat(message)) || this;
          _this.name = "PineconeArgumentError";
          return _this;
        }
        return PineconeArgumentError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeArgumentError = PineconeArgumentError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/utils.js
var require_utils = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractMessage = void 0;
    var extractMessage = function(error) {
      return __awaiter(void 0, void 0, void 0, function() {
        var message, messageJSON;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, error.response.text()];
            case 1:
              message = _a2.sent();
              try {
                messageJSON = JSON.parse(message);
                if (messageJSON.message) {
                  message = messageJSON.message;
                }
              } catch (e) {
              }
              return [2, message];
          }
        });
      });
    };
    exports.extractMessage = extractMessage;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/handling.js
var require_handling = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/handling.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleApiError = exports.handleFetchError = void 0;
    var utils_1 = require_utils();
    var http_1 = require_http();
    var request_1 = require_request();
    var handleFetchError = function(e, handleResponseError) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(e instanceof Error && e.name === "FetchError"))
                return [3, 1];
              return [2, new request_1.PineconeConnectionError()];
            case 1:
              return [4, handleResponseError(e)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleFetchError = handleFetchError;
    var handleApiError = function(e, customMessage) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, (0, exports.handleFetchError)(e, function(responseError) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var rawMessage, statusCode, message, _a3;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        return [4, (0, utils_1.extractMessage)(responseError)];
                      case 1:
                        rawMessage = _b.sent();
                        statusCode = responseError.response.status;
                        if (!customMessage)
                          return [3, 3];
                        return [4, customMessage(statusCode, rawMessage)];
                      case 2:
                        _a3 = _b.sent();
                        return [3, 4];
                      case 3:
                        _a3 = rawMessage;
                        _b.label = 4;
                      case 4:
                        message = _a3;
                        return [2, (0, http_1.mapHttpStatusError)({
                          status: responseError.response.status,
                          url: responseError.response.url,
                          message
                        })];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleApiError = handleApiError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/upsert.js
var require_upsert = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/upsert.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeBatchUpsertError = void 0;
    var base_1 = require_base();
    var PineconeBatchUpsertError = (
      /** @class */
      function(_super) {
        __extends(PineconeBatchUpsertError2, _super);
        function PineconeBatchUpsertError2(successCount, failureCount, failures) {
          var _this = this;
          var maxErrors = 3;
          if (failures.length > maxErrors) {
            failures = failures.slice(0, maxErrors);
            failures.push("...and ".concat(failureCount - maxErrors, " other errors"));
          }
          _this = _super.call(this, "".concat(failureCount, " out of ").concat(failureCount + successCount, " upserts failed. \n	").concat(failures.join("\n	"))) || this;
          _this.name = "PineconeBatchUpsertError";
          return _this;
        }
        return PineconeBatchUpsertError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeBatchUpsertError = PineconeBatchUpsertError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/index.js
var require_errors = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeBatchUpsertError = exports.handleApiError = exports.extractMessage = exports.PineconeArgumentError = exports.PineconeConnectionError = exports.PineconeUnknownRequestFailure = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
    var config_1 = require_config();
    Object.defineProperty(exports, "PineconeConfigurationError", { enumerable: true, get: function() {
      return config_1.PineconeConfigurationError;
    } });
    Object.defineProperty(exports, "PineconeUnexpectedResponseError", { enumerable: true, get: function() {
      return config_1.PineconeUnexpectedResponseError;
    } });
    Object.defineProperty(exports, "PineconeEnvironmentVarsNotSupportedError", { enumerable: true, get: function() {
      return config_1.PineconeEnvironmentVarsNotSupportedError;
    } });
    Object.defineProperty(exports, "PineconeUnknownRequestFailure", { enumerable: true, get: function() {
      return config_1.PineconeUnknownRequestFailure;
    } });
    __exportStar(require_http(), exports);
    var request_1 = require_request();
    Object.defineProperty(exports, "PineconeConnectionError", { enumerable: true, get: function() {
      return request_1.PineconeConnectionError;
    } });
    var validation_1 = require_validation();
    Object.defineProperty(exports, "PineconeArgumentError", { enumerable: true, get: function() {
      return validation_1.PineconeArgumentError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "extractMessage", { enumerable: true, get: function() {
      return utils_1.extractMessage;
    } });
    var handling_1 = require_handling();
    Object.defineProperty(exports, "handleApiError", { enumerable: true, get: function() {
      return handling_1.handleApiError;
    } });
    var upsert_1 = require_upsert();
    Object.defineProperty(exports, "PineconeBatchUpsertError", { enumerable: true, get: function() {
      return upsert_1.PineconeBatchUpsertError;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        super.optimizeNames(names, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError2(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError2(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError2(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/json-schema-traverse/index.js"(exports, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/data.json"(exports, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports.default = Ajv;
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/ajv.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module2.exports = exports = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEdge = void 0;
    var isEdge = function() {
      return typeof EdgeRuntime === "string";
    };
    exports.isEdge = isEdge;
  }
});

// node_modules/@pinecone-database/pinecone/dist/validator.js
var require_validator = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/validator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildConfigValidator = exports.buildValidator = exports.errorFormatter = void 0;
    var ajv_1 = __importDefault(require_ajv());
    var errors_1 = require_errors();
    var environment_1 = require_environment();
    var prepend = function(prefix, message) {
      return "".concat(prefix, " ").concat(message);
    };
    var schemaPathPropNameRegex = /properties\/(.+)\//;
    var schemaPathArrayPropNameRegex = /properties\/(.+)\/items/;
    var schemaPathGroupNumberRegex = /anyOf\/(\d+)\/(.+)/;
    var instancePathItemIndexRegex = /(\d+)$/;
    var maxErrors = 3;
    var formatIndividualError = function(e, formattedMessageList) {
      if (e.schemaPath.indexOf("properties") > -1) {
        if (e.schemaPath.indexOf("items") > -1) {
          var propNameMatch = schemaPathArrayPropNameRegex.exec(e.schemaPath);
          var propName = propNameMatch ? propNameMatch[1] : "unknown";
          var itemIndexMatch = instancePathItemIndexRegex.exec(e.instancePath);
          var itemIndex = itemIndexMatch ? itemIndexMatch[1] : "unknown";
          formattedMessageList.push("item at index ".concat(itemIndex, " of the '").concat(propName, "' array ").concat(e.message));
        } else {
          var propNameMatch = schemaPathPropNameRegex.exec(e.schemaPath);
          var propName = propNameMatch ? propNameMatch[1] : "unknown";
          formattedMessageList.push("property '".concat(propName, "' ").concat(e.message));
        }
      } else if (e.schemaPath.indexOf("items") > -1) {
        var itemIndexMatch = instancePathItemIndexRegex.exec(e.instancePath);
        var itemIndex = itemIndexMatch ? itemIndexMatch[1] : "unknown";
        formattedMessageList.push("item at index ".concat(itemIndex, " of the array ").concat(e.message));
      } else if (e.instancePath === "") {
        formattedMessageList.push("argument ".concat(e.message));
      }
    };
    var missingPropertiesErrors = function(subject, errors, messageParts) {
      var missingPropertyNames = errors.filter(function(error) {
        return error.keyword === "required";
      }).map(function(error) {
        return error.params.missingProperty !== void 0 ? error.params.missingProperty : "unknown";
      });
      if (missingPropertyNames.length > 0) {
        var missingMessage = prepend(subject, "".concat(messageParts.length > 0 ? "M" : "m", "ust have required ").concat(missingPropertyNames.length > 1 ? "properties" : "property", ": ").concat(missingPropertyNames.join(", "), "."));
        messageParts.push(missingMessage);
      }
    };
    var neverErrors = function(subject, errors, messageParts) {
      var neverPropertyErrors = errors.filter(function(error) {
        return error.keyword === "not";
      }).map(function(error) {
        return error.instancePath.slice(1);
      });
      if (neverPropertyErrors.length > 0) {
        var neverMessage = prepend(subject, "must not have ".concat(neverPropertyErrors.length > 1 ? "properties" : "property", ": ").concat(neverPropertyErrors.join(", "), "."));
        messageParts.push(neverMessage);
      }
    };
    var typeErrors = function(subject, errors, messageParts) {
      var typeErrorsList = [];
      var errorCount = 0;
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e.keyword === "type") {
          errorCount += 1;
          if (errorCount <= maxErrors) {
            formatIndividualError(e, typeErrorsList);
          }
        }
      }
      if (errorCount > maxErrors) {
        typeErrorsList.push("and ".concat(errorCount - maxErrors, " other errors"));
      }
      if (typeErrorsList.length > 0) {
        var prefix = messageParts.length > 0 ? "There were also type errors:" : "".concat(subject, " had type errors:");
        var typeErrorMessage = prepend(prefix, typeErrorsList.join(", ")) + ".";
        messageParts.push(typeErrorMessage);
      }
    };
    var validationErrors = function(subject, errors, messageParts) {
      var validationErrors2 = [];
      var errorCount = 0;
      for (var _i = 0, errors_2 = errors; _i < errors_2.length; _i++) {
        var e = errors_2[_i];
        if (e.keyword === "minLength" && e.params.limit === 1) {
          e.message = "must not be blank";
        }
        switch (e.keyword) {
          case "minimum":
          case "maximum":
          case "exclusiveMinimum":
          case "exclusiveMaximum":
          case "minLength":
          case "maxLength":
          case "maxProperties":
          case "minProperties":
          case "minItems":
          case "maxItems":
          case "additionalItems":
          case "additionalProperties":
            errorCount += 1;
            if (errorCount > maxErrors) {
              continue;
            } else {
              formatIndividualError(e, validationErrors2);
            }
            break;
          default:
        }
      }
      if (errorCount > maxErrors) {
        validationErrors2.push("and ".concat(errorCount - maxErrors, " other errors"));
      }
      if (validationErrors2.length > 0) {
        var prefix = messageParts.length > 0 ? "There were also validation errors:" : "".concat(subject, " had validation errors:");
        var validationErrorMessage = prepend(prefix, validationErrors2.join(", ")) + ".";
        messageParts.push(validationErrorMessage);
      }
    };
    var errorFormatter = function(subject, errors) {
      var anyOfErrors = errors.filter(function(error2) {
        return error2.schemaPath.indexOf("anyOf") > -1 && error2.keyword !== "anyOf";
      });
      if (anyOfErrors.length > 0) {
        var groups = {};
        for (var _i = 0, anyOfErrors_1 = anyOfErrors; _i < anyOfErrors_1.length; _i++) {
          var error = anyOfErrors_1[_i];
          var schemaPathMatch = schemaPathGroupNumberRegex.exec(error.schemaPath);
          var groupNumber = schemaPathMatch ? schemaPathMatch[1] : "unknown";
          error.schemaPath = schemaPathMatch ? schemaPathMatch[2] : "unknown";
          if (groups[groupNumber]) {
            groups[groupNumber].push(error);
          } else {
            groups[groupNumber] = [error];
          }
        }
        return "".concat(subject, " accepts multiple types. Either ") + Object.entries(groups).map(function(_a2) {
          var key = _a2[0], group = _a2[1];
          return "".concat(parseInt(key) + 1, ")") + (0, exports.errorFormatter)("", group);
        }).join(" ");
      }
      var messageParts = [];
      neverErrors(subject, errors, messageParts);
      missingPropertiesErrors(subject, errors, messageParts);
      typeErrors(subject, errors, messageParts);
      validationErrors(subject, errors, messageParts);
      return messageParts.join(" ");
    };
    exports.errorFormatter = errorFormatter;
    var buildValidator = function(errorMessagePrefix, schema) {
      if ((0, environment_1.isEdge)()) {
        return function(data) {
        };
      }
      if (process && process.env && process.env.PINECONE_DISABLE_RUNTIME_VALIDATIONS) {
        return function(data) {
        };
      }
      var ajv = new ajv_1.default({ allErrors: true });
      var validate = ajv.compile(schema);
      return function(data) {
        var valid = validate(data);
        if (!valid) {
          var errors = validate.errors || [];
          var msg = (0, exports.errorFormatter)(errorMessagePrefix, errors);
          throw new errors_1.PineconeArgumentError(msg);
        }
        return data;
      };
    };
    exports.buildValidator = buildValidator;
    var buildConfigValidator = function(schema, methodName) {
      var prefix = "The argument to ".concat(methodName);
      return (0, exports.buildValidator)(prefix, schema);
    };
    exports.buildConfigValidator = buildConfigValidator;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/utils.js
var require_utils2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleCollectionRequestError = exports.handleIndexRequestError = exports.validCollectionMessage = exports.validIndexMessage = void 0;
    var errors_1 = require_errors();
    var validIndexMessage = function(api, name) {
      return __awaiter(void 0, void 0, void 0, function() {
        var validNames, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, api.listIndexes()];
            case 1:
              validNames = _a2.sent();
              return [2, "Index '".concat(name, "' does not exist. Valid index names: [").concat(validNames.map(function(n) {
                return "'".concat(n, "'");
              }).join(", "), "]")];
            case 2:
              e_1 = _a2.sent();
              return [2, "Index '".concat(name, "' does not exist.")];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.validIndexMessage = validIndexMessage;
    var validCollectionMessage = function(api, name) {
      return __awaiter(void 0, void 0, void 0, function() {
        var validNames, e_2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, api.listCollections()];
            case 1:
              validNames = _a2.sent();
              return [2, "Collection '".concat(name, "' does not exist. Valid collection names: [").concat(validNames.map(function(n) {
                return "'".concat(n, "'");
              }).join(", "), "]")];
            case 2:
              e_2 = _a2.sent();
              return [2, "Collection '".concat(name, "' does not exist.")];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.validCollectionMessage = validCollectionMessage;
    var handleIndexRequestError = function(e, api, indexName) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, (0, errors_1.handleApiError)(e, function(statusCode, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var _a3;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        if (!(statusCode === 404))
                          return [3, 2];
                        return [4, (0, exports.validIndexMessage)(api, indexName)];
                      case 1:
                        _a3 = _b.sent();
                        return [3, 3];
                      case 2:
                        _a3 = rawMessageText;
                        _b.label = 3;
                      case 3:
                        return [2, _a3];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleIndexRequestError = handleIndexRequestError;
    var handleCollectionRequestError = function(e, api, collectionName) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, (0, errors_1.handleApiError)(e, function(statusCode, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var _a3;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        if (!(statusCode === 404))
                          return [3, 2];
                        return [4, (0, exports.validCollectionMessage)(api, collectionName)];
                      case 1:
                        _a3 = _b.sent();
                        return [3, 3];
                      case 2:
                        _a3 = rawMessageText;
                        _b.label = 3;
                      case 3:
                        return [2, _a3];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleCollectionRequestError = handleCollectionRequestError;
  }
});

// node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "node_modules/@sinclair/typebox/typebox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;
    exports.Modifier = Symbol.for("TypeBox.Modifier");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Has(kind2) {
        return map.has(kind2);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind2, func) {
        map.set(kind2, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind2) {
        return map.get(kind2);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var TypeGuardUnknownTypeError = class extends Error {
      constructor(schema) {
        super("TypeGuard: Unknown type");
        this.schema = schema;
      }
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsObject(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
      }
      function IsArray(value) {
        return typeof value === "object" && value !== null && Array.isArray(value);
      }
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (typeof value !== "string")
          return false;
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      function IsString(value) {
        return typeof value === "string";
      }
      function IsNumber(value) {
        return typeof value === "number" && globalThis.Number.isFinite(value);
      }
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      function IsOptionalBigInt(value) {
        return value === void 0 || value !== void 0 && IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return value === void 0 || value !== void 0 && IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return value === void 0 || value !== void 0 && IsBoolean(value);
      }
      function IsOptionalString(value) {
        return value === void 0 || value !== void 0 && IsString(value);
      }
      function IsOptionalPattern(value) {
        return value === void 0 || value !== void 0 && IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return value === void 0 || value !== void 0 && IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return value === void 0 || TSchema(value);
      }
      function TAny(schema) {
        return TKind(schema) && schema[exports.Kind] === "Any" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema) {
        return TKind(schema) && schema[exports.Kind] === "Array" && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems);
      }
      TypeGuard2.TArray = TArray;
      function TBigInt(schema) {
        return TKind(schema) && schema[exports.Kind] === "BigInt" && schema.type === "null" && schema.typeOf === "BigInt" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema) {
        return TKind(schema) && schema[exports.Kind] === "Boolean" && schema.type === "boolean" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Constructor" && schema.type === "object" && schema.instanceOf === "Constructor" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {
          return false;
        }
        for (const parameter of schema.parameters) {
          if (!TSchema(parameter))
            return false;
        }
        return true;
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema) {
        return TKind(schema) && schema[exports.Kind] === "Date" && schema.type === "object" && schema.instanceOf === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Function" && schema.type === "object" && schema.instanceOf === "Function" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {
          return false;
        }
        for (const parameter of schema.parameters) {
          if (!TSchema(parameter))
            return false;
        }
        return true;
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema) {
        return TKind(schema) && schema[exports.Kind] === "Integer" && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Intersect" && IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id))) {
          return false;
        }
        if ("type" in schema && schema.type !== "object") {
          return false;
        }
        for (const inner of schema.allOf) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TIntersect = TIntersect;
      function TKind(schema) {
        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === "string";
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "string";
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "number";
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "boolean";
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema) {
        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema) {
        return TKind(schema) && schema[exports.Kind] === "Never" && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema) {
        return TKind(schema) && schema[exports.Kind] === "Not" && TSchema(schema.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema) {
        return TKind(schema) && schema[exports.Kind] === "Null" && schema.type === "null" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema) {
        return TKind(schema) && schema[exports.Kind] === "Number" && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Object" && schema.type === "object" && IsOptionalString(schema.$id) && IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) {
          return false;
        }
        for (const [key, value] of Object.entries(schema.properties)) {
          if (!IsControlCharacterFree(key))
            return false;
          if (!TSchema(value))
            return false;
        }
        return true;
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema) {
        return TKind(schema) && schema[exports.Kind] === "Promise" && schema.type === "object" && schema.instanceOf === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Record" && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && IsObject(schema.patternProperties))) {
          return false;
        }
        const keys = Object.keys(schema.patternProperties);
        if (keys.length !== 1) {
          return false;
        }
        if (!IsPattern(keys[0])) {
          return false;
        }
        if (!TSchema(schema.patternProperties[keys[0]])) {
          return false;
        }
        return true;
      }
      TypeGuard2.TRecord = TRecord;
      function TRef(schema) {
        return TKind(schema) && schema[exports.Kind] === "Ref" && IsOptionalString(schema.$id) && IsString(schema.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema) {
        return TKind(schema) && schema[exports.Kind] === "String" && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema) {
        return TKind(schema) && schema[exports.Kind] === "Symbol" && schema.type === "null" && schema.typeOf === "Symbol" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema) {
        return TKind(schema) && schema[exports.Kind] === "TemplateLiteral" && schema.type === "string" && IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema) {
        return TKind(schema) && schema[exports.Kind] === "This" && IsOptionalString(schema.$id) && IsString(schema.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTuple(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Tuple" && schema.type === "array" && IsOptionalString(schema.$id) && IsNumber(schema.minItems) && IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) {
          return false;
        }
        if (schema.items === void 0 && schema.additionalItems === void 0 && schema.minItems === 0) {
          return true;
        }
        if (!IsArray(schema.items)) {
          return false;
        }
        for (const inner of schema.items) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema) {
        return TKind(schema) && schema[exports.Kind] === "Undefined" && schema.type === "null" && schema.typeOf === "Undefined" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Union" && IsArray(schema.anyOf) && IsOptionalString(schema.$id))) {
          return false;
        }
        for (const inner of schema.anyOf) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema) {
        return TKind(schema) && schema[exports.Kind] === "Uint8Array" && schema.type === "object" && IsOptionalString(schema.$id) && schema.instanceOf === "Uint8Array" && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema) {
        return TKind(schema) && schema[exports.Kind] === "Unknown" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema) {
        return TKind(schema) && schema[exports.Kind] === "Unsafe";
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema) {
        return TKind(schema) && schema[exports.Kind] === "Void" && schema.type === "null" && schema.typeOf === "Void" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonlyOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "ReadonlyOptional";
      }
      TypeGuard2.TReadonlyOptional = TReadonlyOptional;
      function TReadonly(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema) {
        return typeof schema === "object" && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema) {
        if (schema[exports.Kind] === "Undefined")
          return true;
        if (schema[exports.Kind] === "Not") {
          return !Check(schema.not);
        }
        if (schema[exports.Kind] === "Intersect") {
          const intersect = schema;
          return intersect.allOf.every((schema2) => Check(schema2));
        }
        if (schema[exports.Kind] === "Union") {
          const union = schema;
          return union.anyOf.some((schema2) => Check(schema2));
        }
        return false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function AnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function Any(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))
          return TypeExtendsResult.True;
        if (TypeGuard.TUnion(right))
          return TypeExtendsResult.Union;
        if (TypeGuard.TUnknown(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TAny(right))
          return TypeExtendsResult.True;
        return TypeExtendsResult.Union;
      }
      function ArrayRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        return TypeExtendsResult.False;
      }
      function Array2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TArray(right))
          return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
      }
      function BigInt(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function BooleanRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "boolean")
          return TypeExtendsResult.True;
        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Boolean2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Constructor(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TConstructor(right))
          return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
          return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
          return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function Date2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Function2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TFunction(right))
          return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
          return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
          return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function IntegerRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "number")
          return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Integer(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Intersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsLiteralString(schema) {
        return typeof schema.const === "string";
      }
      function IsLiteralNumber(schema) {
        return typeof schema.const === "number";
      }
      function IsLiteralBoolean(schema) {
        return typeof schema.const === "boolean";
      }
      function Literal(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (TypeGuard.TString(right))
          return StringRight(left, right);
        if (TypeGuard.TNumber(right))
          return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
          return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
          return BooleanRight(left, right);
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function NeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function Never(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function Not(left, right) {
        if (TypeGuard.TNot(left))
          return Visit(UnwrapNot(left), right);
        if (TypeGuard.TNot(right))
          return Visit(left, UnwrapNot(right));
        throw new Error(`TypeExtends: Invalid fallthrough for Not`);
      }
      function Null(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function NumberRight(left, right) {
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))
          return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Number2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema, count) {
        return globalThis.Object.keys(schema.properties).length === count;
      }
      function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        if (Visit(left, right) === TypeExtendsResult.False)
          return TypeExtendsResult.False;
        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))
          return TypeExtendsResult.False;
        return TypeExtendsResult.True;
      }
      function ObjectRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TString(left) && IsObjectStringLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TDate(left) && IsObjectDateLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {
          return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        return TypeExtendsResult.False;
      }
      function Object2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (!TypeGuard.TObject(right))
          return TypeExtendsResult.False;
        for (const key of globalThis.Object.keys(right.properties)) {
          if (!(key in left.properties))
            return TypeExtendsResult.False;
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      }
      function Promise2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TPromise(right))
          return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
          return exports.Type.Number();
        if (exports.PatternStringExact in schema.patternProperties)
          return exports.Type.String();
        throw Error("TypeExtends: Cannot get record key");
      }
      function RecordValue(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
          return schema.patternProperties[exports.PatternNumberExact];
        if (exports.PatternStringExact in schema.patternProperties)
          return schema.patternProperties[exports.PatternStringExact];
        throw Error("TypeExtends: Cannot get record value");
      }
      function RecordRight(left, right) {
        const Key = RecordKey(right);
        const Value = RecordValue(right);
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)
          return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TObject(left)) {
          for (const key of globalThis.Object.keys(left.properties)) {
            if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        }
        return TypeExtendsResult.False;
      }
      function Record(left, right) {
        const Value = RecordValue(left);
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TRecord(right))
          return TypeExtendsResult.False;
        return Visit(Value, RecordValue(right));
      }
      function StringRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "string")
          return TypeExtendsResult.True;
        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function String2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Symbol2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TemplateLiteral(left, right) {
        if (TypeGuard.TTemplateLiteral(left))
          return Visit(TemplateLiteralResolver.Resolve(left), right);
        if (TypeGuard.TTemplateLiteral(right))
          return Visit(left, TemplateLiteralResolver.Resolve(right));
        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);
      }
      function TupleRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        return TypeExtendsResult.False;
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
      }
      function Tuple(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TTuple(right))
          return TypeExtendsResult.False;
        if (left.items === void 0 && right.items !== void 0 || left.items !== void 0 && right.items === void 0)
          return TypeExtendsResult.False;
        if (left.items === void 0 && right.items === void 0)
          return TypeExtendsResult.True;
        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Uint8Array2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Undefined(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (TypeGuard.TVoid(right))
          return VoidRight(left, right);
        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function UnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Union(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function UnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function Unknown(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TString(right))
          return StringRight(left, right);
        if (TypeGuard.TNumber(right))
          return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
          return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
          return BooleanRight(left, right);
        if (TypeGuard.TArray(right))
          return ArrayRight(left, right);
        if (TypeGuard.TTuple(right))
          return TupleRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        if (TypeGuard.TUndefined(left))
          return TypeExtendsResult.True;
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Void(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))
          return TemplateLiteral(left, right);
        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))
          return Not(left, right);
        if (TypeGuard.TAny(left))
          return Any(left, right);
        if (TypeGuard.TArray(left))
          return Array2(left, right);
        if (TypeGuard.TBigInt(left))
          return BigInt(left, right);
        if (TypeGuard.TBoolean(left))
          return Boolean2(left, right);
        if (TypeGuard.TConstructor(left))
          return Constructor(left, right);
        if (TypeGuard.TDate(left))
          return Date2(left, right);
        if (TypeGuard.TFunction(left))
          return Function2(left, right);
        if (TypeGuard.TInteger(left))
          return Integer(left, right);
        if (TypeGuard.TIntersect(left))
          return Intersect(left, right);
        if (TypeGuard.TLiteral(left))
          return Literal(left, right);
        if (TypeGuard.TNever(left))
          return Never(left, right);
        if (TypeGuard.TNull(left))
          return Null(left, right);
        if (TypeGuard.TNumber(left))
          return Number2(left, right);
        if (TypeGuard.TObject(left))
          return Object2(left, right);
        if (TypeGuard.TRecord(left))
          return Record(left, right);
        if (TypeGuard.TString(left))
          return String2(left, right);
        if (TypeGuard.TSymbol(left))
          return Symbol2(left, right);
        if (TypeGuard.TTuple(left))
          return Tuple(left, right);
        if (TypeGuard.TPromise(left))
          return Promise2(left, right);
        if (TypeGuard.TUint8Array(left))
          return Uint8Array2(left, right);
        if (TypeGuard.TUndefined(left))
          return Undefined(left, right);
        if (TypeGuard.TUnion(left))
          return Union(left, right);
        if (TypeGuard.TUnknown(left))
          return Unknown(left, right);
        if (TypeGuard.TVoid(left))
          return Void(left, right);
        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      function IsArray(value) {
        return globalThis.Array.isArray(value);
      }
      function Array2(value) {
        return value.map((value2) => Visit(value2));
      }
      function Object2(value) {
        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {
          return { ...acc, [key]: Visit(value[key]) };
        }, {});
        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {
          return { ...acc, [key]: Visit(value[key]) };
        }, {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        if (IsArray(value))
          return Array2(value);
        if (IsObject(value))
          return Object2(value);
        return value;
      }
      function Clone(schema, options) {
        return { ...Visit(schema), ...options };
      }
      TypeClone2.Clone = Clone;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema) {
        return schema.map((schema2) => {
          const { [exports.Modifier]: _, ...clone } = TypeClone.Clone(schema2, {});
          return clone;
        });
      }
      function IsIntersectOptional(schema) {
        return schema.every((schema2) => TypeGuard.TOptional(schema2));
      }
      function IsUnionOptional(schema) {
        return schema.some((schema2) => TypeGuard.TOptional(schema2));
      }
      function ResolveIntersect(schema) {
        const optional = IsIntersectOptional(schema.allOf);
        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
      }
      function ResolveUnion(schema) {
        const optional = IsUnionOptional(schema.anyOf);
        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
      }
      function ResolveOptional(schema) {
        if (schema[exports.Kind] === "Intersect")
          return ResolveIntersect(schema);
        if (schema[exports.Kind] === "Union")
          return ResolveUnion(schema);
        return schema;
      }
      function Intersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema2) => {
          const indexed = Visit(schema2, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function Union(schema, key) {
        const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function Object2(schema, key) {
        const property = schema.properties[key];
        return property === void 0 ? exports.Type.Never() : exports.Type.Union([property]);
      }
      function Tuple(schema, key) {
        const items = schema.items;
        if (items === void 0)
          return exports.Type.Never();
        const element = items[key];
        if (element === void 0)
          return exports.Type.Never();
        return element;
      }
      function Visit(schema, key) {
        if (schema[exports.Kind] === "Intersect")
          return Intersect(schema, key);
        if (schema[exports.Kind] === "Union")
          return Union(schema, key);
        if (schema[exports.Kind] === "Object")
          return Object2(schema, key);
        if (schema[exports.Kind] === "Tuple")
          return Tuple(schema, key);
        return exports.Type.Never();
      }
      function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function Intersect(schema, callback) {
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function Union(schema, callback) {
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function Object2(schema, callback) {
        return callback(schema);
      }
      function Visit(schema, callback) {
        if (schema[exports.Kind] === "Intersect")
          return Intersect(schema, callback);
        if (schema[exports.Kind] === "Union")
          return Union(schema, callback);
        if (schema[exports.Kind] === "Object")
          return Object2(schema, callback);
        return schema;
      }
      function Map2(schema, callback, options) {
        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function Intersect(schema, options) {
        return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
      }
      function Union(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function Object2(schema, options) {
        return globalThis.Object.keys(schema.properties);
      }
      function Record(schema, options) {
        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];
      }
      function Visit(schema, options) {
        if (TypeGuard.TIntersect(schema))
          return Intersect(schema, options);
        if (TypeGuard.TUnion(schema))
          return Union(schema, options);
        if (TypeGuard.TObject(schema))
          return Object2(schema, options);
        if (TypeGuard.TRecord(schema))
          return Record(schema, options);
        return [];
      }
      function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema) {
        if (globalThis.Array.isArray(schema))
          return schema;
        if (TypeGuard.TUnionLiteral(schema))
          return schema.anyOf.map((schema2) => schema2.const.toString());
        if (TypeGuard.TLiteral(schema))
          return [schema.const];
        if (TypeGuard.TTemplateLiteral(schema)) {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw Error("KeyArrayResolver: Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        }
        return [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* Union(union) {
        for (const schema of union.anyOf) {
          if (schema[exports.Kind] === "Union") {
            yield* Union(schema);
          } else {
            yield schema;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...Union(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema, acc) {
        if (TypeGuard.TTemplateLiteral(schema)) {
          const pattern = schema.pattern.slice(1, schema.pattern.length - 1);
          return pattern;
        } else if (TypeGuard.TUnion(schema)) {
          const tokens = schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|");
          return `(${tokens})`;
        } else if (TypeGuard.TNumber(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TInteger(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TBigInt(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TString(schema)) {
          return `${acc}${exports.PatternString}`;
        } else if (TypeGuard.TLiteral(schema)) {
          return `${acc}${Escape(schema.const.toString())}`;
        } else if (TypeGuard.TBoolean(schema)) {
          return `${acc}${exports.PatternBoolean}`;
        } else if (TypeGuard.TNever(schema)) {
          throw Error("TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever");
        } else {
          throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);
        }
      }
      function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    var TemplateLiteralParserError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
      }
      function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, "(");
      }
      function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ")");
      }
      function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, "|");
      }
      function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
          return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (count === 0 && index !== pattern.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
      }
      function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            return true;
        }
        return false;
      }
      function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0) {
            const range2 = pattern.slice(start, index);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            start = index + 1;
          }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
          expressions.push(Parse(range));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern) {
        function Group(value, index) {
          if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern2, index) {
          for (let scan = index; scan < pattern2.length; scan++) {
            if (IsOpenParen(pattern2, scan))
              return [index, scan];
          }
          return [index, pattern2.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(Parse(range));
            index = end;
          } else {
            const [start, end] = Range(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
              expressions.push(Parse(range));
            index = end - 1;
          }
        }
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "and", expr: expressions };
      }
      function Parse(pattern) {
        if (IsGroup(pattern))
          return Parse(InGroup(pattern));
        if (IsPrecedenceOr(pattern))
          return Or(pattern);
        if (IsPrecedenceAnd(pattern))
          return And(pattern);
        return { type: "const", const: pattern };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        if (IsBoolean(expression))
          return true;
        if (IsNumber(expression) || IsString(expression))
          return false;
        if (expression.type === "and")
          return expression.expr.every((expr) => Check(expr));
        if (expression.type === "or")
          return expression.expr.every((expr) => Check(expr));
        if (expression.type === "const")
          return true;
        throw Error(`TemplateLiteralFinite: Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1)
          return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        if (expression.type === "and")
          return yield* And(expression);
        if (expression.type === "or")
          return yield* Or(expression);
        if (expression.type === "const")
          return yield* Const(expression);
        throw Error("TemplateLiteralGenerator: Unknown expression");
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        if (trim === "boolean")
          return yield exports.Type.Boolean();
        if (trim === "number")
          return yield exports.Type.Number();
        if (trim === "bigint")
          return yield exports.Type.BigInt();
        if (trim === "string")
          return yield exports.Type.String();
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L = exports.Type.Literal("$");
          const R = ParseLiteral(template.slice(1));
          return yield* [L, ...R];
        }
        for (let i = 2; i < template.length; i++) {
          if (template[i] === "}") {
            const L = ParseUnion(template.slice(2, i));
            const R = ParseLiteral(template.slice(i + 1));
            return yield* [...L, ...R];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i = 0; i < template.length; i++) {
          if (template[i] === "$") {
            const L = exports.Type.Literal(template.slice(0, i));
            const R = ParseTerminal(template.slice(i));
            return yield* [L, ...R];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    var TypeOrdinal = 0;
    var TypeBuilder = class {
      /** `[Utility]` Creates a schema without `static` and `params` types */
      Create(schema) {
        return schema;
      }
      /** `[Standard]` Omits compositing symbols from this schema */
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var StandardTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Modifier]` Creates a Optional property */
      Optional(schema) {
        return { [exports.Modifier]: "Optional", ...TypeClone.Clone(schema, {}) };
      }
      /** `[Modifier]` Creates a ReadonlyOptional property */
      ReadonlyOptional(schema) {
        return { [exports.Modifier]: "ReadonlyOptional", ...TypeClone.Clone(schema, {}) };
      }
      /** `[Modifier]` Creates a Readonly object or property */
      Readonly(schema) {
        return { [exports.Modifier]: "Readonly", ...schema };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Standard]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Standard]` Creates an Array type */
      Array(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Clone(items, {}) });
      }
      /** `[Standard]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Standard]` Creates a Composite object type. */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
      }
      /** `[Standard]` Creates a Enum type */
      Enum(item, options = {}) {
        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const anyOf = values.map((value) => typeof value === "string" ? { [exports.Kind]: "Literal", type: "string", const: value } : { [exports.Kind]: "Literal", type: "number", const: value });
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf });
      }
      /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Clone(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Clone(falseType, options);
        }
      }
      /** `[Standard]` Excludes from the left type any type that is not assignable to the right */
      Exclude(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
          return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
          return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
          const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
        } else {
          return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options);
        }
      }
      /** `[Standard]` Extracts from the left type any type that is assignable to the right */
      Extract(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
          return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
          return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
          const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
        } else {
          return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options);
        }
      }
      /** `[Standard]` Returns indexed property types for the given keys */
      Index(schema, unresolved, options = {}) {
        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {
          return TypeClone.Clone(schema.items, options);
        } else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {
          const items = schema.items === void 0 ? [] : schema.items;
          const cloned = items.map((schema2) => TypeClone.Clone(schema2, {}));
          return this.Union(cloned, options);
        } else {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone = TypeClone.Clone(schema, {});
          return IndexedAccessor.Resolve(clone, keys, options);
        }
      }
      /** `[Standard]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
      }
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Clone(allOf[0], options);
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};
        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {
          return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned });
        } else {
          return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
        }
      }
      /** `[Standard]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        if (TypeGuard.TRecord(schema)) {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          if (pattern === exports.PatternNumberExact)
            return this.Number(options);
          if (pattern === exports.PatternStringExact)
            return this.String(options);
          throw Error("StandardTypeBuilder: Unable to resolve key type from Record key pattern");
        } else if (TypeGuard.TTuple(schema)) {
          const items = schema.items === void 0 ? [] : schema.items;
          const literals = items.map((_, index) => exports.Type.Literal(index));
          return this.Union(literals, options);
        } else if (TypeGuard.TArray(schema)) {
          return this.Number(options);
        } else {
          const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        }
      }
      /** `[Standard]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Standard]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Standard]` Creates a Not type */
      Not(not, options) {
        return this.Create({ ...options, [exports.Kind]: "Not", not });
      }
      /** `[Standard]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
      }
      /** `[Standard]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
      }
      /** `[Standard]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});
        if (requiredKeys.length > 0) {
          return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys });
        } else {
          return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
        }
      }
      Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          if (schema2.required) {
            schema2.required = schema2.required.filter((key) => !keys.includes(key));
            if (schema2.required.length === 0)
              delete schema2.required;
          }
          for (const key of globalThis.Object.keys(schema2.properties)) {
            if (keys.includes(key))
              delete schema2.properties[key];
          }
          return this.Create(schema2);
        }, options);
      }
      /** `[Standard]` Creates a mapped type where all properties are Optional */
      Partial(schema, options = {}) {
        function Apply(schema2) {
          switch (schema2[exports.Modifier]) {
            case "ReadonlyOptional":
              schema2[exports.Modifier] = "ReadonlyOptional";
              break;
            case "Readonly":
              schema2[exports.Modifier] = "ReadonlyOptional";
              break;
            case "Optional":
              schema2[exports.Modifier] = "Optional";
              break;
            default:
              schema2[exports.Modifier] = "Optional";
              break;
          }
        }
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          delete schema2.required;
          globalThis.Object.keys(schema2.properties).forEach((key) => Apply(schema2.properties[key]));
          return schema2;
        }, options);
      }
      Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          if (schema2.required) {
            schema2.required = schema2.required.filter((key) => keys.includes(key));
            if (schema2.required.length === 0)
              delete schema2.required;
          }
          for (const key of globalThis.Object.keys(schema2.properties)) {
            if (!keys.includes(key))
              delete schema2.properties[key];
          }
          return this.Create(schema2);
        }, options);
      }
      /** `[Standard]` Creates a Record type */
      Record(key, schema, options = {}) {
        if (TypeGuard.TTemplateLiteral(key)) {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Clone(schema, {}) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) } });
        } else if (TypeGuard.TUnion(key)) {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});
            return this.Object(properties, { ...options, [exports.Hint]: "Record" });
          } else
            throw Error("TypeBuilder: Record key of type union contains non-literal types");
        } else if (TypeGuard.TLiteral(key)) {
          if (typeof key.const === "string" || typeof key.const === "number") {
            return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);
          } else
            throw Error("TypeBuilder: Record key of type literal is not of type string or number");
        } else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {
          const pattern = exports.PatternNumberExact;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });
        } else if (TypeGuard.TString(key)) {
          const pattern = key.pattern === void 0 ? exports.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });
        } else {
          throw Error(`StandardTypeBuilder: Record key is an invalid type`);
        }
      }
      /** `[Standard]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (options.$id === void 0)
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
      }
      /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */
      Ref(schema, options = {}) {
        if (schema.$id === void 0)
          throw Error("StandardTypeBuilder.Ref: Target type must specify an $id");
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: schema.$id });
      }
      /** `[Standard]` Creates a mapped type where all properties are Required */
      Required(schema, options = {}) {
        function Apply(schema2) {
          switch (schema2[exports.Modifier]) {
            case "ReadonlyOptional":
              schema2[exports.Modifier] = "Readonly";
              break;
            case "Readonly":
              schema2[exports.Modifier] = "Readonly";
              break;
            case "Optional":
              delete schema2[exports.Modifier];
              break;
            default:
              delete schema2[exports.Modifier];
              break;
          }
        }
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          schema2.required = globalThis.Object.keys(schema2.properties);
          globalThis.Object.keys(schema2.properties).forEach((key) => Apply(schema2.properties[key]));
          return schema2;
        }, options);
      }
      /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */
      Rest(schema) {
        if (TypeGuard.TTuple(schema)) {
          if (schema.items === void 0)
            return [];
          return schema.items.map((schema2) => TypeClone.Clone(schema2, {}));
        } else {
          return [TypeClone.Clone(schema, {})];
        }
      }
      /** `[Standard]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
      }
      /** `[Standard]` Creates a template literal type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern = typeof unresolved === "string" ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
      }
      /** `[Standard]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));
        const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema);
      }
      Union(union, options = {}) {
        if (TypeGuard.TTemplateLiteral(union)) {
          return TemplateLiteralResolver.Resolve(union);
        } else {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Clone(anyOf[0], options));
          const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));
          return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
        }
      }
      /** `[Standard]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Standard]` Creates a Unsafe type that infers for the generic argument */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
      }
    };
    exports.StandardTypeBuilder = StandardTypeBuilder;
    var ExtendedTypeBuilder = class extends StandardTypeBuilder {
      /** `[Extended]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "BigInt", type: "null", typeOf: "BigInt" });
      }
      /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
      }
      /** `[Extended]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
        return this.Create({ ...options, [exports.Kind]: "Constructor", type: "object", instanceOf: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[Extended]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Date", type: "object", instanceOf: "Date" });
      }
      /** `[Extended]` Creates a Function type */
      Function(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
        return this.Create({ ...options, [exports.Kind]: "Function", type: "object", instanceOf: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[Extended]` Extracts the InstanceType from the given Constructor */
      InstanceType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
      }
      /** `[Extended]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
      }
      /** `[Extended]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Promise", type: "object", instanceOf: "Promise", item: TypeClone.Clone(item, {}) });
      }
      /** `[Extended]` Creates a regular expression type */
      RegEx(regex, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern: regex.source });
      }
      /** `[Extended]` Extracts the ReturnType from the given Function */
      ReturnType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
      }
      /** `[Extended]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: "Symbol", type: "null", typeOf: "Symbol" });
      }
      /** `[Extended]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Undefined", type: "null", typeOf: "Undefined" });
      }
      /** `[Extended]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "object", instanceOf: "Uint8Array" });
      }
      /** `[Extended]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Void", type: "null", typeOf: "Void" });
      }
    };
    exports.ExtendedTypeBuilder = ExtendedTypeBuilder;
    exports.StandardType = new StandardTypeBuilder();
    exports.Type = new ExtendedTypeBuilder();
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/types.js
var require_types2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionNameSchema = exports.MetadataConfigSchema = exports.DimensionSchema = exports.MetricSchema = exports.PodsSchema = exports.ReplicasSchema = exports.PodTypeSchema = exports.IndexNameSchema = void 0;
    var typebox_1 = require_typebox();
    var nonemptyString = typebox_1.Type.String({ minLength: 1 });
    var positiveInteger = typebox_1.Type.Integer({ minimum: 1 });
    exports.IndexNameSchema = nonemptyString;
    exports.PodTypeSchema = nonemptyString;
    exports.ReplicasSchema = positiveInteger;
    exports.PodsSchema = positiveInteger;
    exports.MetricSchema = nonemptyString;
    exports.DimensionSchema = positiveInteger;
    exports.MetadataConfigSchema = typebox_1.Type.Object({
      indexed: typebox_1.Type.Array(nonemptyString)
    }, { additionalProperties: false });
    exports.CollectionNameSchema = nonemptyString;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js
var require_configureIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureIndex = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var typebox_1 = require_typebox();
    var types_1 = require_types2();
    var ConfigureIndexOptionsSchema = typebox_1.Type.Object({
      replicas: typebox_1.Type.Optional(types_1.ReplicasSchema),
      podType: typebox_1.Type.Optional(types_1.PodTypeSchema)
    }, { additionalProperties: false });
    var configureIndex = function(api) {
      var indexNameValidator = (0, validator_1.buildValidator)("The first argument to configureIndex", types_1.IndexNameSchema);
      var patchRequestValidator = (0, validator_1.buildValidator)("The second argument to configureIndex", ConfigureIndexOptionsSchema);
      return function(name, options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                indexNameValidator(name);
                patchRequestValidator(options);
                if (Object.keys(options).length === 0) {
                  throw new errors_1.PineconeArgumentError("The second argument to configureIndex should not be empty object. Please specify at least one propert (replicas, podType) to update.");
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.configureIndex({ indexName: name, patchRequest: options })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, name)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.configureIndex = configureIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js
var require_debugLog = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debugLog = void 0;
    var debugLog = function(str) {
      if (process && process.env && process.env.PINECONE_DEBUG) {
        console.log(str);
      }
    };
    exports.debugLog = debugLog;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js
var require_queryParamsStringify = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queryParamsStringify = void 0;
    function queryParamsStringify(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.queryParamsStringify = queryParamsStringify;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (Array.isArray(value)) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return queryParamsStringify(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
  }
});

// node_modules/@pinecone-database/pinecone/dist/version.json
var require_version = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/version.json"(exports, module2) {
    module2.exports = {
      name: "@pinecone-database/pinecone",
      version: "1.0.1"
    };
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js
var require_user_agent = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildUserAgent = void 0;
    var environment_1 = require_environment();
    var packageInfo = __importStar(require_version());
    var buildUserAgent = function(isLegacy) {
      var userAgentParts = [
        "".concat(packageInfo.name, " v").concat(packageInfo.version),
        "lang=typescript"
      ];
      if ((0, environment_1.isEdge)()) {
        userAgentParts.push("Edge Runtime");
      }
      if (process && process.version) {
        userAgentParts.push("node ".concat(process.version));
      }
      userAgentParts.push("legacyExport=".concat(isLegacy));
      return userAgentParts.join("; ");
    };
    exports.buildUserAgent = buildUserAgent;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers3(headers) {
          this.map = {};
          if (headers instanceof Headers3) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers3.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers3.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers3.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers3.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers3.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers3.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers3.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers3.prototype[Symbol.iterator] = Headers3.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers3(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers3(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers3();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request3.prototype);
        function Response3(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers3(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response3.prototype);
        Response3.prototype.clone = function() {
          return new Response3(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers3(this.headers),
            url: this.url
          });
        };
        Response3.error = function() {
          var response = new Response3(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response3.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response3(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request3(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response3(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers3;
          self2.Request = Request3;
          self2.Response = Response3;
        }
        exports2.Headers = Headers3;
        exports2.Request = Request3;
        exports2.Response = Response3;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/fetch.js
var require_fetch = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/fetch.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetch = void 0;
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var getFetch = function(config) {
      if (config.fetchApi) {
        return config.fetchApi;
      } else if (global.fetch) {
        return global.fetch;
      } else {
        return cross_fetch_1.default;
      }
    };
    exports.getFetch = getFetch;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetch = exports.buildUserAgent = exports.queryParamsStringify = exports.debugLog = void 0;
    var debugLog_1 = require_debugLog();
    Object.defineProperty(exports, "debugLog", { enumerable: true, get: function() {
      return debugLog_1.debugLog;
    } });
    var queryParamsStringify_1 = require_queryParamsStringify();
    Object.defineProperty(exports, "queryParamsStringify", { enumerable: true, get: function() {
      return queryParamsStringify_1.queryParamsStringify;
    } });
    var user_agent_1 = require_user_agent();
    Object.defineProperty(exports, "buildUserAgent", { enumerable: true, get: function() {
      return user_agent_1.buildUserAgent;
    } });
    var fetch_1 = require_fetch();
    Object.defineProperty(exports, "getFetch", { enumerable: true, get: function() {
      return fetch_1.getFetch;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/createIndex.js
var require_createIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/createIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIndex = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils3();
    var errors_1 = require_errors();
    var utils_2 = require_utils2();
    var typebox_1 = require_typebox();
    var types_1 = require_types2();
    var CreateIndexOptionsSchema = typebox_1.Type.Object({
      name: types_1.IndexNameSchema,
      dimension: types_1.DimensionSchema,
      metric: typebox_1.Type.Optional(types_1.MetricSchema),
      pods: typebox_1.Type.Optional(types_1.PodsSchema),
      replicas: typebox_1.Type.Optional(types_1.ReplicasSchema),
      podType: typebox_1.Type.Optional(types_1.PodTypeSchema),
      metadataConfig: typebox_1.Type.Optional(types_1.MetadataConfigSchema),
      sourceCollection: typebox_1.Type.Optional(types_1.CollectionNameSchema),
      waitUntilReady: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      suppressConflicts: typebox_1.Type.Optional(typebox_1.Type.Boolean())
    }, { additionalProperties: false });
    var createIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(CreateIndexOptionsSchema, "createIndex");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 5, , 7]);
                return [4, api.createIndex({ createRequest: options })];
              case 2:
                _a2.sent();
                if (!options.waitUntilReady)
                  return [3, 4];
                return [4, waitUntilIndexIsReady(api, options.name)];
              case 3:
                return [2, _a2.sent()];
              case 4:
                return [
                  2
                  /*return*/
                ];
              case 5:
                e_1 = _a2.sent();
                return [4, (0, utils_2.handleIndexRequestError)(e_1, api, options.name)];
              case 6:
                err = _a2.sent();
                if (options.suppressConflicts && err.name === "PineconeConflictError") {
                  return [
                    2
                    /*return*/
                  ];
                }
                throw err;
              case 7:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.createIndex = createIndex;
    var waitUntilIndexIsReady = function(api, indexName, seconds) {
      if (seconds === void 0) {
        seconds = 0;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var indexDescription, e_2, err;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 6, , 8]);
              return [4, api.describeIndex({ indexName })];
            case 1:
              indexDescription = _b.sent();
              if (!!((_a2 = indexDescription.status) === null || _a2 === void 0 ? void 0 : _a2.ready))
                return [3, 4];
              return [4, new Promise(function(r) {
                return setTimeout(r, 1e3);
              })];
            case 2:
              _b.sent();
              return [4, waitUntilIndexIsReady(api, indexName, seconds + 1)];
            case 3:
              return [2, _b.sent()];
            case 4:
              (0, utils_1.debugLog)("Index ".concat(indexName, " is ready after ").concat(seconds));
              return [
                2
                /*return*/
              ];
            case 5:
              return [3, 8];
            case 6:
              e_2 = _b.sent();
              return [4, (0, errors_1.handleApiError)(e_2, function(_, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  return __generator(this, function(_a3) {
                    return [2, "Error creating index ".concat(indexName, ": ").concat(rawMessageText)];
                  });
                });
              })];
            case 7:
              err = _b.sent();
              throw err;
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js
var require_deleteIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteIndex = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var utils_1 = require_utils2();
    var deleteIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.IndexNameSchema, "deleteIndex");
      return function(indexName) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(indexName);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.deleteIndex({ indexName })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, indexName)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteIndex = deleteIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js
var require_describeIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeIndex = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var describeIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.IndexNameSchema, "describeIndex");
      var removeDeprecatedFields = function(result) {
        if (result.database) {
          for (var _i = 0, _a2 = Object.keys(result.database); _i < _a2.length; _i++) {
            var key = _a2[_i];
            if (result.database[key] === void 0) {
              delete result.database[key];
            }
          }
        }
      };
      return function(name) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(name);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.describeIndex({ indexName: name })];
              case 2:
                result = _a2.sent();
                removeDeprecatedFields(result);
                return [2, result];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, name)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.describeIndex = describeIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js
var require_listIndexes = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listIndexes = void 0;
    var errors_1 = require_errors();
    var listIndexes = function(api) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var names, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 4]);
                return [4, api.listIndexes()];
              case 1:
                names = _a2.sent();
                return [2, names.map(function(n) {
                  return { name: n };
                })];
              case 2:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 3:
                err = _a2.sent();
                throw err;
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.listIndexes = listIndexes;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/createCollection.js
var require_createCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/createCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCollection = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var typebox_1 = require_typebox();
    var CreateCollectionOptionsSchema = typebox_1.Type.Object({
      name: types_1.CollectionNameSchema,
      source: types_1.IndexNameSchema
    }, { additionalProperties: false });
    var createCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(CreateCollectionOptionsSchema, "createCollection");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.createCollection({ createCollectionRequest: options })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, options.source)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.createCollection = createCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js
var require_deleteCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteCollection = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var deleteCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.CollectionNameSchema, "deleteCollection");
      return function(collectionName) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(collectionName);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.deleteCollection({ collectionName })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleCollectionRequestError)(e_1, api, collectionName)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteCollection = deleteCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js
var require_describeCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeCollection = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var describeCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.CollectionNameSchema, "describeCollection");
      return function(name) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(name);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.describeCollection({ collectionName: name })];
              case 2:
                result = _a2.sent();
                return [2, {
                  name: result.name,
                  size: result.size,
                  status: result.status,
                  dimension: result.dimension,
                  recordCount: result.vectorCount
                }];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleCollectionRequestError)(e_1, api, name)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.describeCollection = describeCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/listCollections.js
var require_listCollections = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/listCollections.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listCollections = void 0;
    var errors_1 = require_errors();
    var listCollections = function(api) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var results, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 4]);
                return [4, api.listCollections()];
              case 1:
                results = _a2.sent();
                return [2, results.map(function(c) {
                  return { name: c };
                })];
              case 2:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 3:
                err = _a2.sent();
                throw err;
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.listCollections = listCollections;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/index.js
var require_control = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listCollections = exports.describeCollection = exports.deleteCollection = exports.createCollection = exports.listIndexes = exports.describeIndex = exports.deleteIndex = exports.createIndex = exports.configureIndex = void 0;
    var configureIndex_1 = require_configureIndex();
    Object.defineProperty(exports, "configureIndex", { enumerable: true, get: function() {
      return configureIndex_1.configureIndex;
    } });
    var createIndex_1 = require_createIndex();
    Object.defineProperty(exports, "createIndex", { enumerable: true, get: function() {
      return createIndex_1.createIndex;
    } });
    var deleteIndex_1 = require_deleteIndex();
    Object.defineProperty(exports, "deleteIndex", { enumerable: true, get: function() {
      return deleteIndex_1.deleteIndex;
    } });
    var describeIndex_1 = require_describeIndex();
    Object.defineProperty(exports, "describeIndex", { enumerable: true, get: function() {
      return describeIndex_1.describeIndex;
    } });
    var listIndexes_1 = require_listIndexes();
    Object.defineProperty(exports, "listIndexes", { enumerable: true, get: function() {
      return listIndexes_1.listIndexes;
    } });
    var createCollection_1 = require_createCollection();
    Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
      return createCollection_1.createCollection;
    } });
    var deleteCollection_1 = require_deleteCollection();
    Object.defineProperty(exports, "deleteCollection", { enumerable: true, get: function() {
      return deleteCollection_1.deleteCollection;
    } });
    var describeCollection_1 = require_describeCollection();
    Object.defineProperty(exports, "describeCollection", { enumerable: true, get: function() {
      return describeCollection_1.describeCollection;
    } });
    var listCollections_1 = require_listCollections();
    Object.defineProperty(exports, "listCollections", { enumerable: true, get: function() {
      return listCollections_1.listCollections;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/types.js
var require_types3 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeRecordSchema = exports.RecordSparseValuesSchema = exports.RecordValuesSchema = exports.RecordIdSchema = exports.PineconeConfigurationSchema = void 0;
    var typebox_1 = require_typebox();
    exports.PineconeConfigurationSchema = typebox_1.Type.Object({
      environment: typebox_1.Type.String({ minLength: 1 }),
      apiKey: typebox_1.Type.String({ minLength: 1 }),
      projectId: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 })),
      // fetchApi is a complex type that I don't really want to recreate in the
      // form of a json schema (seems difficult and error prone). So we will
      // rely on TypeScript to guide people in the right direction here.
      // But declaring it here as Type.Any() is needed to avoid getting caught
      // in the additionalProperties check.
      fetchApi: typebox_1.Type.Optional(typebox_1.Type.Any())
    }, { additionalProperties: false });
    exports.RecordIdSchema = typebox_1.Type.String({ minLength: 1 });
    exports.RecordValuesSchema = typebox_1.Type.Array(typebox_1.Type.Number());
    exports.RecordSparseValuesSchema = typebox_1.Type.Object({
      indices: typebox_1.Type.Array(typebox_1.Type.Integer()),
      values: typebox_1.Type.Array(typebox_1.Type.Number())
    }, { additionalProperties: false });
    exports.PineconeRecordSchema = typebox_1.Type.Object({
      id: exports.RecordIdSchema,
      values: exports.RecordValuesSchema,
      sparseValues: typebox_1.Type.Optional(exports.RecordSparseValuesSchema),
      metadata: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/upsert.js
var require_upsert2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/upsert.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var RecordArray = typebox_1.Type.Array(types_1.PineconeRecordSchema);
    var UpsertCommand = (
      /** @class */
      function() {
        function UpsertCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(RecordArray, "upsert");
        }
        UpsertCommand2.prototype.run = function(records) {
          return __awaiter(this, void 0, void 0, function() {
            var api, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(records);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.upsert({
                    upsertRequest: {
                      vectors: records,
                      namespace: this.namespace
                    }
                  })];
                case 3:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return UpsertCommand2;
      }()
    );
    exports.UpsertCommand = UpsertCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/fetch.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var RecordIdsArray = typebox_1.Type.Array(types_1.RecordIdSchema, { minItems: 1 });
    var FetchCommand = (
      /** @class */
      function() {
        function FetchCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(RecordIdsArray, "fetch");
        }
        FetchCommand2.prototype.run = function(ids) {
          return __awaiter(this, void 0, void 0, function() {
            var api, response, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(ids);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.fetch({ ids, namespace: this.namespace })];
                case 3:
                  response = _a2.sent();
                  return [2, {
                    records: response.vectors,
                    namespace: response.namespace
                  }];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return FetchCommand2;
      }()
    );
    exports.FetchCommand = FetchCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/update.js
var require_update = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/update.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types3();
    var UpdateRecordOptionsSchema = typebox_1.Type.Object({
      id: types_1.RecordIdSchema,
      values: typebox_1.Type.Optional(types_1.RecordValuesSchema),
      sparseValues: typebox_1.Type.Optional(types_1.RecordSparseValuesSchema),
      metadata: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
    var UpdateCommand = (
      /** @class */
      function() {
        function UpdateCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(UpdateRecordOptionsSchema, "update");
        }
        UpdateCommand2.prototype.run = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            var requestOptions, api, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(options);
                  requestOptions = {
                    id: options["id"],
                    values: options["values"],
                    sparseValues: options["sparseValues"],
                    setMetadata: options["metadata"]
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.update({
                    updateRequest: __assign(__assign({}, requestOptions), { namespace: this.namespace })
                  })];
                case 3:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return UpdateCommand2;
      }()
    );
    exports.UpdateCommand = UpdateCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/query.js
var require_query = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/query.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var shared = {
      topK: typebox_1.Type.Number(),
      includeValues: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      includeMetadata: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      filter: typebox_1.Type.Optional(typebox_1.Type.Object({}))
    };
    var QueryByRecordId = typebox_1.Type.Object(__assign(__assign({}, shared), { id: types_1.RecordIdSchema, vector: typebox_1.Type.Optional(typebox_1.Type.Never()), sparseVector: typebox_1.Type.Optional(typebox_1.Type.Never()) }), { additionalProperties: false });
    var QueryByVectorValues = typebox_1.Type.Object(__assign(__assign({}, shared), { vector: types_1.RecordValuesSchema, sparseVector: typebox_1.Type.Optional(types_1.RecordSparseValuesSchema), id: typebox_1.Type.Optional(typebox_1.Type.Never()) }), { additionalProperties: false });
    var QuerySchema = typebox_1.Type.Union([QueryByRecordId, QueryByVectorValues]);
    var QueryCommand = (
      /** @class */
      function() {
        function QueryCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(QuerySchema, "query");
        }
        QueryCommand2.prototype.run = function(query) {
          return __awaiter(this, void 0, void 0, function() {
            var api, results, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(query);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.query({
                    queryRequest: __assign(__assign({}, query), { namespace: this.namespace })
                  })];
                case 3:
                  results = _a2.sent();
                  return [2, {
                    matches: results.matches,
                    namespace: this.namespace
                  }];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return QueryCommand2;
      }()
    );
    exports.QueryCommand = QueryCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteOne.js
var require_deleteOne = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteOne.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteOne = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var deleteOne = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.RecordIdSchema, "deleteOne");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, , 6]);
                return [4, apiProvider.provide()];
              case 2:
                api = _a2.sent();
                return [4, api._delete({ deleteRequest: { ids: [options], namespace } })];
              case 3:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 4:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 5:
                err = _a2.sent();
                throw err;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteOne = deleteOne;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteMany.js
var require_deleteMany = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteMany.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteMany = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types3();
    var DeleteManyByRecordIdSchema = typebox_1.Type.Array(types_1.RecordIdSchema);
    var DeleteManyByFilterSchema = typebox_1.Type.Object({}, { additionalProperties: true, minProperties: 1 });
    var DeleteManySchema = typebox_1.Type.Union([
      DeleteManyByRecordIdSchema,
      DeleteManyByFilterSchema
    ]);
    var deleteMany = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(DeleteManySchema, "deleteMany");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var requestOptions, api, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                requestOptions = {};
                if (Array.isArray(options)) {
                  requestOptions.ids = options;
                } else {
                  requestOptions.filter = options;
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, , 6]);
                return [4, apiProvider.provide()];
              case 2:
                api = _a2.sent();
                return [4, api._delete({ deleteRequest: __assign(__assign({}, requestOptions), { namespace }) })];
              case 3:
                _a2.sent();
                return [3, 6];
              case 4:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 5:
                err = _a2.sent();
                throw err;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteMany = deleteMany;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteAll.js
var require_deleteAll = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteAll.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteAll = void 0;
    var errors_1 = require_errors();
    var deleteAll = function(apiProvider, namespace) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 3, , 5]);
                return [4, apiProvider.provide()];
              case 1:
                api = _a2.sent();
                return [4, api._delete({ deleteRequest: { deleteAll: true, namespace } })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteAll = deleteAll;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/describeIndexStats.js
var require_describeIndexStats = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/describeIndexStats.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeIndexStats = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var DescribeIndexStatsOptionsSchema = typebox_1.Type.Object({
      filter: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
    var describeIndexStats = function(apiProvider) {
      var validator = (0, validator_1.buildConfigValidator)(DescribeIndexStatsOptionsSchema, "describeIndexStats");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, results, mappedResult, key, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (options) {
                  validator(options);
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, , 6]);
                return [4, apiProvider.provide()];
              case 2:
                api = _a2.sent();
                return [4, api.describeIndexStats({
                  describeIndexStatsRequest: __assign({}, options)
                })];
              case 3:
                results = _a2.sent();
                mappedResult = {
                  namespaces: {},
                  dimension: results.dimension,
                  indexFullness: results.indexFullness,
                  totalRecordCount: results.totalVectorCount
                };
                if (results.namespaces) {
                  for (key in results.namespaces) {
                    mappedResult.namespaces[key] = {
                      recordCount: results.namespaces[key].vectorCount
                    };
                  }
                }
                return [2, mappedResult];
              case 4:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 5:
                err = _a2.sent();
                throw err;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.describeIndexStats = describeIndexStats;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/projectIdSingleton.js
var require_projectIdSingleton = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/projectIdSingleton.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectIdSingleton = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils3();
    exports.ProjectIdSingleton = function() {
      var _this = this;
      var projectIds = {};
      var _fetchProjectId = function(options) {
        return __awaiter(_this, void 0, void 0, function() {
          var apiKey, environment, fetch3, _a2, url, request, response, e_1, _b, json, e_2, _c, _d, _e, _f;
          var _g;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                apiKey = options.apiKey, environment = options.environment;
                fetch3 = (0, utils_1.getFetch)(options);
                _a2 = _buildWhoamiRequest(environment, apiKey), url = _a2.url, request = _a2.request;
                _h.label = 1;
              case 1:
                _h.trys.push([1, 3, , 4]);
                return [4, fetch3(url, request)];
              case 2:
                response = _h.sent();
                return [3, 4];
              case 3:
                e_1 = _h.sent();
                if (e_1 instanceof TypeError) {
                  throw new errors_1.PineconeConfigurationError("A network error occured while attempting to connect to ".concat(url, ". Are you sure you passed the correct environment? Please check your configuration values and try again. Visit https://status.pinecone.io for overall service health information."));
                } else {
                  throw new errors_1.PineconeUnknownRequestFailure(url, e_1);
                }
                return [3, 4];
              case 4:
                if (!(response.status >= 400))
                  return [3, 6];
                _b = errors_1.mapHttpStatusError;
                _g = {
                  status: response.status,
                  url
                };
                return [4, response.text()];
              case 5:
                throw _b.apply(void 0, [(_g.message = _h.sent(), _g)]);
              case 6:
                _h.trys.push([6, 8, , 10]);
                return [4, response.json()];
              case 7:
                json = _h.sent();
                return [3, 10];
              case 8:
                e_2 = _h.sent();
                _c = errors_1.PineconeUnexpectedResponseError.bind;
                _d = [
                  void 0,
                  url,
                  response.status
                ];
                return [4, response.text()];
              case 9:
                throw new (_c.apply(errors_1.PineconeUnexpectedResponseError, _d.concat([_h.sent(), "The HTTP call succeeded but the response could not be parsed as JSON."])))();
              case 10:
                if (!!json.project_name)
                  return [3, 12];
                _e = errors_1.PineconeUnexpectedResponseError.bind;
                _f = [
                  void 0,
                  url,
                  response.status
                ];
                return [4, response.text()];
              case 11:
                throw new (_e.apply(errors_1.PineconeUnexpectedResponseError, _f.concat([_h.sent(), "The HTTP call succeeded but response did not contain expected project_name."])))();
              case 12:
                return [2, json.project_name];
            }
          });
        });
      };
      var _buildWhoamiRequest = function(environment, apiKey) {
        var url = "https://controller.".concat(environment, ".pinecone.io/actions/whoami");
        var request = {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            "Api-Key": apiKey,
            "User-Agent": (0, utils_1.buildUserAgent)(false)
          }
        };
        return { url, request };
      };
      var key = function(config) {
        return "".concat(config.apiKey, ":").concat(config.environment);
      };
      return {
        getProjectId: function(config) {
          return __awaiter(this, void 0, void 0, function() {
            var cacheKey, projectId;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  cacheKey = key(config);
                  if (!(cacheKey in projectIds))
                    return [3, 1];
                  return [2, projectIds[cacheKey]];
                case 1:
                  return [4, _fetchProjectId(config)];
                case 2:
                  projectId = _a2.sent();
                  projectIds[cacheKey] = projectId;
                  return [2, projectId];
              }
            });
          });
        },
        _reset: function() {
          for (var _i = 0, _a2 = Object.keys(projectIds); _i < _a2.length; _i++) {
            var key_1 = _a2[_i];
            delete projectIds[key_1];
          }
        },
        _set: function(config, projectId) {
          var cacheKey = key(config);
          projectIds[cacheKey] = projectId;
        }
      };
    }();
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/vectorOperationsProvider.js
var require_vectorOperationsProvider = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/vectorOperationsProvider.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorOperationsProvider = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var utils_1 = require_utils3();
    var projectIdSingleton_1 = require_projectIdSingleton();
    var basePath = function(config, indexName) {
      return "https://".concat(indexName, "-").concat(config.projectId, ".svc.").concat(config.environment, ".pinecone.io");
    };
    var VectorOperationsProvider = (
      /** @class */
      function() {
        function VectorOperationsProvider2(config, indexName) {
          this.config = config;
          this.indexName = indexName;
        }
        VectorOperationsProvider2.prototype.provide = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this.vectorOperations) {
                    return [2, this.vectorOperations];
                  }
                  if (!this.config.projectId)
                    return [3, 1];
                  this.vectorOperations = this.buildVectorOperationsConfig(this.config, this.indexName);
                  return [3, 3];
                case 1:
                  _a2 = this.config;
                  return [4, projectIdSingleton_1.ProjectIdSingleton.getProjectId(this.config)];
                case 2:
                  _a2.projectId = _b.sent();
                  this.vectorOperations = this.buildVectorOperationsConfig(this.config, this.indexName);
                  _b.label = 3;
                case 3:
                  return [2, this.vectorOperations];
              }
            });
          });
        };
        VectorOperationsProvider2.prototype.buildVectorOperationsConfig = function(config, indexName) {
          var indexConfigurationParameters = {
            basePath: basePath(config, indexName),
            apiKey: config.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
              "User-Agent": (0, utils_1.buildUserAgent)(false)
            },
            fetchApi: (0, utils_1.getFetch)(config)
          };
          var indexConfiguration = new pinecone_generated_ts_fetch_1.Configuration(indexConfigurationParameters);
          var vectorOperations = new pinecone_generated_ts_fetch_1.VectorOperationsApi(indexConfiguration);
          return vectorOperations;
        };
        return VectorOperationsProvider2;
      }()
    );
    exports.VectorOperationsProvider = VectorOperationsProvider;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/index.js
var require_data2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.PineconeConfigurationSchema = void 0;
    var upsert_1 = require_upsert2();
    var fetch_1 = require_fetch2();
    var update_1 = require_update();
    var query_1 = require_query();
    var deleteOne_1 = require_deleteOne();
    var deleteMany_1 = require_deleteMany();
    var deleteAll_1 = require_deleteAll();
    var describeIndexStats_1 = require_describeIndexStats();
    var vectorOperationsProvider_1 = require_vectorOperationsProvider();
    var types_1 = require_types3();
    Object.defineProperty(exports, "PineconeConfigurationSchema", { enumerable: true, get: function() {
      return types_1.PineconeConfigurationSchema;
    } });
    var Index = (
      /** @class */
      function() {
        function Index2(indexName, config, namespace) {
          if (namespace === void 0) {
            namespace = "";
          }
          this.config = config;
          this.target = {
            index: indexName,
            namespace
          };
          var apiProvider = new vectorOperationsProvider_1.VectorOperationsProvider(config, indexName);
          this.deleteAll = (0, deleteAll_1.deleteAll)(apiProvider, namespace);
          this.deleteMany = (0, deleteMany_1.deleteMany)(apiProvider, namespace);
          this.deleteOne = (0, deleteOne_1.deleteOne)(apiProvider, namespace);
          this.describeIndexStats = (0, describeIndexStats_1.describeIndexStats)(apiProvider);
          this._fetchCommand = new fetch_1.FetchCommand(apiProvider, namespace);
          this._queryCommand = new query_1.QueryCommand(apiProvider, namespace);
          this._updateCommand = new update_1.UpdateCommand(apiProvider, namespace);
          this._upsertCommand = new upsert_1.UpsertCommand(apiProvider, namespace);
        }
        Index2.prototype.namespace = function(namespace) {
          return new Index2(this.target.index, this.config, namespace);
        };
        Index2.prototype.upsert = function(data) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._upsertCommand.run(data)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Index2.prototype.fetch = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._fetchCommand.run(options)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Index2.prototype.query = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._queryCommand.run(options)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Index2.prototype.update = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._updateCommand.run(options)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return Index2;
      }()
    );
    exports.Index = Index;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone.js
var require_pinecone = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pinecone = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var control_1 = require_control();
    var errors_1 = require_errors();
    var data_1 = require_data2();
    var validator_1 = require_validator();
    var utils_1 = require_utils3();
    var Pinecone2 = (
      /** @class */
      function() {
        function Pinecone3(options) {
          if (options === void 0) {
            options = this._readEnvironmentConfig();
          }
          this._validateConfig(options);
          this.config = options;
          var apiKey = options.apiKey, environment = options.environment;
          var controllerPath = "https://controller.".concat(environment, ".pinecone.io");
          var apiConfig = {
            basePath: controllerPath,
            apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
              "User-Agent": (0, utils_1.buildUserAgent)(false)
            },
            fetchApi: (0, utils_1.getFetch)(options)
          };
          var api = new pinecone_generated_ts_fetch_1.IndexOperationsApi(new pinecone_generated_ts_fetch_1.Configuration(apiConfig));
          this.describeIndex = (0, control_1.describeIndex)(api);
          this.listIndexes = (0, control_1.listIndexes)(api);
          this.createIndex = (0, control_1.createIndex)(api);
          this.deleteIndex = (0, control_1.deleteIndex)(api);
          this.configureIndex = (0, control_1.configureIndex)(api);
          this.createCollection = (0, control_1.createCollection)(api);
          this.listCollections = (0, control_1.listCollections)(api);
          this.describeCollection = (0, control_1.describeCollection)(api);
          this.deleteCollection = (0, control_1.deleteCollection)(api);
        }
        Pinecone3.prototype._readEnvironmentConfig = function() {
          if (!process || !process.env) {
            throw new errors_1.PineconeEnvironmentVarsNotSupportedError("Your execution environment does not support reading environment variables from process.env, so a configuration object is required when calling new Pinecone()");
          }
          var environmentConfig = {};
          var requiredEnvVarMap = {
            environment: "PINECONE_ENVIRONMENT",
            apiKey: "PINECONE_API_KEY"
          };
          var missingVars = [];
          for (var _i = 0, _a2 = Object.entries(requiredEnvVarMap); _i < _a2.length; _i++) {
            var _b = _a2[_i], key = _b[0], envVar = _b[1];
            var value = process.env[envVar] || "";
            if (!value) {
              missingVars.push(envVar);
            }
            environmentConfig[key] = value;
          }
          if (missingVars.length > 0) {
            throw new errors_1.PineconeConfigurationError("Since you called 'new Pinecone()' with no configuration object, we attempted to find client configuration in environment variables but the required environment variables were not set. Missing variables: ".concat(missingVars.join(", "), "."));
          }
          var optionalEnvVarMap = { projectId: "PINECONE_PROJECT_ID" };
          for (var _c = 0, _d = Object.entries(optionalEnvVarMap); _c < _d.length; _c++) {
            var _e = _d[_c], key = _e[0], envVar = _e[1];
            var value = process.env[envVar];
            if (value !== void 0) {
              environmentConfig[key] = value;
            }
          }
          return environmentConfig;
        };
        Pinecone3.prototype._validateConfig = function(options) {
          (0, validator_1.buildValidator)("The client configuration", data_1.PineconeConfigurationSchema)(options);
        };
        Pinecone3.prototype.getConfig = function() {
          return this.config;
        };
        Pinecone3.prototype.index = function(indexName) {
          return new data_1.Index(indexName, this.config);
        };
        Pinecone3.prototype.Index = function(indexName) {
          return this.index(indexName);
        };
        Pinecone3.prototype.__curlStarter = function() {
          console.log("Example curl command to list indexes: ");
          console.log('curl "https://controller.'.concat(this.config.environment, '.pinecone.io/databases" -H "Api-Key: ').concat(this.config.apiKey, '" -H "Accept: application/json"'));
        };
        return Pinecone3;
      }()
    );
    exports.Pinecone = Pinecone2;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/runtime.js
var require_runtime2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/runtime.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
    exports.BASE_PATH = "https://unknown-unknown.svc.unknown.pinecone.io".replace(/\/+$/, "");
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(configuration) {
          if (configuration === void 0) {
            configuration = {};
          }
          this.configuration = configuration;
        }
        Object.defineProperty(Configuration2.prototype, "config", {
          set: function(configuration) {
            this.configuration = configuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "basePath", {
          get: function() {
            return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fetchApi", {
          get: function() {
            return this.configuration.fetchApi;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "middleware", {
          get: function() {
            return this.configuration.middleware || [];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
          get: function() {
            return this.configuration.queryParamsStringify || querystring;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "username", {
          get: function() {
            return this.configuration.username;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "password", {
          get: function() {
            return this.configuration.password;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "apiKey", {
          get: function() {
            var apiKey = this.configuration.apiKey;
            if (apiKey) {
              return typeof apiKey === "function" ? apiKey : function() {
                return apiKey;
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "accessToken", {
          get: function() {
            var _this = this;
            var accessToken = this.configuration.accessToken;
            if (accessToken) {
              return typeof accessToken === "function" ? accessToken : function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    return [2, accessToken];
                  });
                });
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "headers", {
          get: function() {
            return this.configuration.headers;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "credentials", {
          get: function() {
            return this.configuration.credentials;
          },
          enumerable: false,
          configurable: true
        });
        return Configuration2;
      }()
    );
    exports.Configuration = Configuration;
    exports.DefaultConfig = new Configuration();
    var BaseAPI = (
      /** @class */
      function() {
        function BaseAPI2(configuration) {
          if (configuration === void 0) {
            configuration = exports.DefaultConfig;
          }
          var _this = this;
          this.configuration = configuration;
          this.fetchApi = function(url, init) {
            return __awaiter(_this, void 0, void 0, function() {
              var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
              return __generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    fetchParams = { url, init };
                    _i = 0, _a2 = this.middleware;
                    _f.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    middleware = _a2[_i];
                    if (!middleware.pre)
                      return [3, 3];
                    return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
                  case 2:
                    fetchParams = _f.sent() || fetchParams;
                    _f.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    response = void 0;
                    _f.label = 5;
                  case 5:
                    _f.trys.push([5, 7, , 12]);
                    return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
                  case 6:
                    response = _f.sent();
                    return [3, 12];
                  case 7:
                    e_1 = _f.sent();
                    _b = 0, _c = this.middleware;
                    _f.label = 8;
                  case 8:
                    if (!(_b < _c.length))
                      return [3, 11];
                    middleware = _c[_b];
                    if (!middleware.onError)
                      return [3, 10];
                    return [4, middleware.onError({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      error: e_1,
                      response: response ? response.clone() : void 0
                    })];
                  case 9:
                    response = _f.sent() || response;
                    _f.label = 10;
                  case 10:
                    _b++;
                    return [3, 8];
                  case 11:
                    if (response === void 0) {
                      if (e_1 instanceof Error) {
                        throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                      } else {
                        throw e_1;
                      }
                    }
                    return [3, 12];
                  case 12:
                    _d = 0, _e = this.middleware;
                    _f.label = 13;
                  case 13:
                    if (!(_d < _e.length))
                      return [3, 16];
                    middleware = _e[_d];
                    if (!middleware.post)
                      return [3, 15];
                    return [4, middleware.post({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      response: response.clone()
                    })];
                  case 14:
                    response = _f.sent() || response;
                    _f.label = 15;
                  case 15:
                    _d++;
                    return [3, 13];
                  case 16:
                    return [2, response];
                }
              });
            });
          };
          this.middleware = configuration.middleware;
        }
        BaseAPI2.prototype.withMiddleware = function() {
          var _a2;
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
          }
          var next = this.clone();
          next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
          return next;
        };
        BaseAPI2.prototype.withPreMiddleware = function() {
          var preMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            preMiddlewares[_i] = arguments[_i];
          }
          var middlewares = preMiddlewares.map(function(pre) {
            return { pre };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.withPostMiddleware = function() {
          var postMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            postMiddlewares[_i] = arguments[_i];
          }
          var middlewares = postMiddlewares.map(function(post) {
            return { post };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.request = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var _a2, url, init, response;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.createFetchParams(context, initOverrides)];
                case 1:
                  _a2 = _b.sent(), url = _a2.url, init = _a2.init;
                  return [4, this.fetchApi(url, init)];
                case 2:
                  response = _b.sent();
                  if (response && (response.status >= 200 && response.status < 300)) {
                    return [2, response];
                  }
                  throw new ResponseError(response, "Response returned an error code");
              }
            });
          });
        };
        BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var url, headers, initOverrideFn, initParams, overriddenInit, _a2, init;
            var _this = this;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  url = this.configuration.basePath + context.path;
                  if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
                    url += "?" + this.configuration.queryParamsStringify(context.query);
                  }
                  headers = Object.assign({}, this.configuration.headers, context.headers);
                  Object.keys(headers).forEach(function(key) {
                    return headers[key] === void 0 ? delete headers[key] : {};
                  });
                  initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a3) {
                        return [2, initOverrides];
                      });
                    });
                  };
                  initParams = {
                    method: context.method,
                    headers,
                    body: context.body,
                    credentials: this.configuration.credentials
                  };
                  _a2 = [__assign({}, initParams)];
                  return [4, initOverrideFn({
                    init: initParams,
                    context
                  })];
                case 1:
                  overriddenInit = __assign.apply(void 0, _a2.concat([_b.sent()]));
                  init = __assign(__assign({}, overriddenInit), { body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body) });
                  return [2, { url, init }];
              }
            });
          });
        };
        BaseAPI2.prototype.clone = function() {
          var constructor = this.constructor;
          var next = new constructor(this.configuration);
          next.middleware = this.middleware.slice();
          return next;
        };
        return BaseAPI2;
      }()
    );
    exports.BaseAPI = BaseAPI;
    function isBlob(value) {
      return typeof Blob !== "undefined" && value instanceof Blob;
    }
    function isFormData(value) {
      return typeof FormData !== "undefined" && value instanceof FormData;
    }
    var ResponseError = (
      /** @class */
      function(_super) {
        __extends(ResponseError2, _super);
        function ResponseError2(response, msg) {
          var _this = _super.call(this, msg) || this;
          _this.response = response;
          _this.name = "ResponseError";
          return _this;
        }
        return ResponseError2;
      }(Error)
    );
    exports.ResponseError = ResponseError;
    var FetchError = (
      /** @class */
      function(_super) {
        __extends(FetchError2, _super);
        function FetchError2(cause, msg) {
          var _this = _super.call(this, msg) || this;
          _this.cause = cause;
          _this.name = "FetchError";
          return _this;
        }
        return FetchError2;
      }(Error)
    );
    exports.FetchError = FetchError;
    var RequiredError = (
      /** @class */
      function(_super) {
        __extends(RequiredError2, _super);
        function RequiredError2(field, msg) {
          var _this = _super.call(this, msg) || this;
          _this.field = field;
          _this.name = "RequiredError";
          return _this;
        }
        return RequiredError2;
      }(Error)
    );
    exports.RequiredError = RequiredError;
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    function exists(json, key) {
      var value = json[key];
      return value !== null && value !== void 0;
    }
    exports.exists = exists;
    function querystring(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.querystring = querystring;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (value instanceof Array) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return querystring(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
    function mapValues(data, fn) {
      return Object.keys(data).reduce(function(acc, key) {
        var _a2;
        return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
      }, {});
    }
    exports.mapValues = mapValues;
    function canConsumeForm(consumes) {
      for (var _i = 0, consumes_1 = consumes; _i < consumes_1.length; _i++) {
        var consume = consumes_1[_i];
        if ("multipart/form-data" === consume.contentType) {
          return true;
        }
      }
      return false;
    }
    exports.canConsumeForm = canConsumeForm;
    var JSONApiResponse = (
      /** @class */
      function() {
        function JSONApiResponse2(raw, transformer) {
          if (transformer === void 0) {
            transformer = function(jsonValue) {
              return jsonValue;
            };
          }
          this.raw = raw;
          this.transformer = transformer;
        }
        JSONApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a2 = this.transformer;
                  return [4, this.raw.json()];
                case 1:
                  return [2, _a2.apply(this, [_b.sent()])];
              }
            });
          });
        };
        return JSONApiResponse2;
      }()
    );
    exports.JSONApiResponse = JSONApiResponse;
    var VoidApiResponse = (
      /** @class */
      function() {
        function VoidApiResponse2(raw) {
          this.raw = raw;
        }
        VoidApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, void 0];
            });
          });
        };
        return VoidApiResponse2;
      }()
    );
    exports.VoidApiResponse = VoidApiResponse;
    var BlobApiResponse = (
      /** @class */
      function() {
        function BlobApiResponse2(raw) {
          this.raw = raw;
        }
        BlobApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.blob()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return BlobApiResponse2;
      }()
    );
    exports.BlobApiResponse = BlobApiResponse;
    var TextApiResponse = (
      /** @class */
      function() {
        function TextApiResponse2(raw) {
          this.raw = raw;
        }
        TextApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.text()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return TextApiResponse2;
      }()
    );
    exports.TextApiResponse = TextApiResponse;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ApproximatedConfig.js
var require_ApproximatedConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ApproximatedConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApproximatedConfigToJSON = exports.ApproximatedConfigFromJSONTyped = exports.ApproximatedConfigFromJSON = exports.instanceOfApproximatedConfig = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfApproximatedConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfApproximatedConfig = instanceOfApproximatedConfig;
    function ApproximatedConfigFromJSON(json) {
      return ApproximatedConfigFromJSONTyped(json, false);
    }
    exports.ApproximatedConfigFromJSON = ApproximatedConfigFromJSON;
    function ApproximatedConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "kBits": !(0, runtime_1.exists)(json, "k_bits") ? void 0 : json["k_bits"],
        "hybrid": !(0, runtime_1.exists)(json, "hybrid") ? void 0 : json["hybrid"]
      };
    }
    exports.ApproximatedConfigFromJSONTyped = ApproximatedConfigFromJSONTyped;
    function ApproximatedConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "k_bits": value.kBits,
        "hybrid": value.hybrid
      };
    }
    exports.ApproximatedConfigToJSON = ApproximatedConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CollectionMeta.js
var require_CollectionMeta2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CollectionMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionMetaToJSON = exports.CollectionMetaFromJSONTyped = exports.CollectionMetaFromJSON = exports.instanceOfCollectionMeta = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfCollectionMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCollectionMeta = instanceOfCollectionMeta;
    function CollectionMetaFromJSON(json) {
      return CollectionMetaFromJSONTyped(json, false);
    }
    exports.CollectionMetaFromJSON = CollectionMetaFromJSON;
    function CollectionMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "size": !(0, runtime_1.exists)(json, "size") ? void 0 : json["size"],
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : json["status"]
      };
    }
    exports.CollectionMetaFromJSONTyped = CollectionMetaFromJSONTyped;
    function CollectionMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "size": value.size,
        "status": value.status
      };
    }
    exports.CollectionMetaToJSON = CollectionMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js
var require_CreateCollectionRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = void 0;
    function instanceOfCreateCollectionRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "source" in value;
      return isInstance;
    }
    exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
    function CreateCollectionRequestFromJSON(json) {
      return CreateCollectionRequestFromJSONTyped(json, false);
    }
    exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
    function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "source": json["source"]
      };
    }
    exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
    function CreateCollectionRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "source": value.source
      };
    }
    exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js
var require_CreateRequestIndexConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestIndexConfigToJSON = exports.CreateRequestIndexConfigFromJSONTyped = exports.CreateRequestIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig2();
    function CreateRequestIndexConfigFromJSON(json) {
      return CreateRequestIndexConfigFromJSONTyped(json, false);
    }
    exports.CreateRequestIndexConfigFromJSON = CreateRequestIndexConfigFromJSON;
    function CreateRequestIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.CreateRequestIndexConfigFromJSONTyped = CreateRequestIndexConfigFromJSONTyped;
    function CreateRequestIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.CreateRequestIndexConfigToJSON = CreateRequestIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequest.js
var require_CreateRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestToJSON = exports.CreateRequestFromJSONTyped = exports.CreateRequestFromJSON = exports.instanceOfCreateRequest = void 0;
    var runtime_1 = require_runtime2();
    var CreateRequestIndexConfig_1 = require_CreateRequestIndexConfig2();
    function instanceOfCreateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "dimension" in value;
      return isInstance;
    }
    exports.instanceOfCreateRequest = instanceOfCreateRequest;
    function CreateRequestFromJSON(json) {
      return CreateRequestFromJSONTyped(json, false);
    }
    exports.CreateRequestFromJSON = CreateRequestFromJSON;
    function CreateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "dimension": json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"],
        "sourceCollection": !(0, runtime_1.exists)(json, "source_collection") ? void 0 : json["source_collection"]
      };
    }
    exports.CreateRequestFromJSONTyped = CreateRequestFromJSONTyped;
    function CreateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig,
        "source_collection": value.sourceCollection
      };
    }
    exports.CreateRequestToJSON = CreateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DeleteRequest.js
var require_DeleteRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DeleteRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfDeleteRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
    function DeleteRequestFromJSON(json) {
      return DeleteRequestFromJSONTyped(json, false);
    }
    exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
    function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ids": !(0, runtime_1.exists)(json, "ids") ? void 0 : json["ids"],
        "deleteAll": !(0, runtime_1.exists)(json, "deleteAll") ? void 0 : json["deleteAll"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
    function DeleteRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ids": value.ids,
        "deleteAll": value.deleteAll,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.DeleteRequestToJSON = DeleteRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js
var require_DescribeIndexStatsRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfDescribeIndexStatsRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
    function DescribeIndexStatsRequestFromJSON(json) {
      return DescribeIndexStatsRequestFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
    function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
    function DescribeIndexStatsRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "filter": value.filter
      };
    }
    exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/NamespaceSummary.js
var require_NamespaceSummary2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/NamespaceSummary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfNamespaceSummary(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
    function NamespaceSummaryFromJSON(json) {
      return NamespaceSummaryFromJSONTyped(json, false);
    }
    exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
    function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectorCount": !(0, runtime_1.exists)(json, "vectorCount") ? void 0 : json["vectorCount"]
      };
    }
    exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
    function NamespaceSummaryToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectorCount": value.vectorCount
      };
    }
    exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js
var require_DescribeIndexStatsResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsResponseToJSON = exports.DescribeIndexStatsResponseFromJSONTyped = exports.DescribeIndexStatsResponseFromJSON = exports.instanceOfDescribeIndexStatsResponse = void 0;
    var runtime_1 = require_runtime2();
    var NamespaceSummary_1 = require_NamespaceSummary2();
    function instanceOfDescribeIndexStatsResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsResponse = instanceOfDescribeIndexStatsResponse;
    function DescribeIndexStatsResponseFromJSON(json) {
      return DescribeIndexStatsResponseFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsResponseFromJSON = DescribeIndexStatsResponseFromJSON;
    function DescribeIndexStatsResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespaces": !(0, runtime_1.exists)(json, "namespaces") ? void 0 : (0, runtime_1.mapValues)(json["namespaces"], NamespaceSummary_1.NamespaceSummaryFromJSON),
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexFullness": !(0, runtime_1.exists)(json, "indexFullness") ? void 0 : json["indexFullness"],
        "totalVectorCount": !(0, runtime_1.exists)(json, "totalVectorCount") ? void 0 : json["totalVectorCount"]
      };
    }
    exports.DescribeIndexStatsResponseFromJSONTyped = DescribeIndexStatsResponseFromJSONTyped;
    function DescribeIndexStatsResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespaces": value.namespaces === void 0 ? void 0 : (0, runtime_1.mapValues)(value.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
        "dimension": value.dimension,
        "indexFullness": value.indexFullness,
        "totalVectorCount": value.totalVectorCount
      };
    }
    exports.DescribeIndexStatsResponseToJSON = DescribeIndexStatsResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SparseValues.js
var require_SparseValues2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SparseValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = void 0;
    function instanceOfSparseValues(value) {
      var isInstance = true;
      isInstance = isInstance && "indices" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfSparseValues = instanceOfSparseValues;
    function SparseValuesFromJSON(json) {
      return SparseValuesFromJSONTyped(json, false);
    }
    exports.SparseValuesFromJSON = SparseValuesFromJSON;
    function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indices": json["indices"],
        "values": json["values"]
      };
    }
    exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
    function SparseValuesToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indices": value.indices,
        "values": value.values
      };
    }
    exports.SparseValuesToJSON = SparseValuesToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/Vector.js
var require_Vector2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/Vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfVector = instanceOfVector;
    function VectorFromJSON(json) {
      return VectorFromJSONTyped(json, false);
    }
    exports.VectorFromJSON = VectorFromJSON;
    function VectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.VectorFromJSONTyped = VectorFromJSONTyped;
    function VectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.VectorToJSON = VectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/FetchResponse.js
var require_FetchResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/FetchResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = void 0;
    var runtime_1 = require_runtime2();
    var Vector_1 = require_Vector2();
    function instanceOfFetchResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfFetchResponse = instanceOfFetchResponse;
    function FetchResponseFromJSON(json) {
      return FetchResponseFromJSONTyped(json, false);
    }
    exports.FetchResponseFromJSON = FetchResponseFromJSON;
    function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": !(0, runtime_1.exists)(json, "vectors") ? void 0 : (0, runtime_1.mapValues)(json["vectors"], Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
    function FetchResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors === void 0 ? void 0 : (0, runtime_1.mapValues)(value.vectors, Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.FetchResponseToJSON = FetchResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/HnswConfig.js
var require_HnswConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/HnswConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HnswConfigToJSON = exports.HnswConfigFromJSONTyped = exports.HnswConfigFromJSON = exports.instanceOfHnswConfig = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfHnswConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfHnswConfig = instanceOfHnswConfig;
    function HnswConfigFromJSON(json) {
      return HnswConfigFromJSONTyped(json, false);
    }
    exports.HnswConfigFromJSON = HnswConfigFromJSON;
    function HnswConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "efConstruction": !(0, runtime_1.exists)(json, "ef_construction") ? void 0 : json["ef_construction"],
        "ef": !(0, runtime_1.exists)(json, "ef") ? void 0 : json["ef"],
        "m": !(0, runtime_1.exists)(json, "M") ? void 0 : json["M"],
        "maxElements": !(0, runtime_1.exists)(json, "max_elements") ? void 0 : json["max_elements"]
      };
    }
    exports.HnswConfigFromJSONTyped = HnswConfigFromJSONTyped;
    function HnswConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ef_construction": value.efConstruction,
        "ef": value.ef,
        "M": value.m,
        "max_elements": value.maxElements
      };
    }
    exports.HnswConfigToJSON = HnswConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js
var require_IndexMetaDatabaseIndexConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseIndexConfigToJSON = exports.IndexMetaDatabaseIndexConfigFromJSONTyped = exports.IndexMetaDatabaseIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig2();
    function IndexMetaDatabaseIndexConfigFromJSON(json) {
      return IndexMetaDatabaseIndexConfigFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseIndexConfigFromJSON = IndexMetaDatabaseIndexConfigFromJSON;
    function IndexMetaDatabaseIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.IndexMetaDatabaseIndexConfigFromJSONTyped = IndexMetaDatabaseIndexConfigFromJSONTyped;
    function IndexMetaDatabaseIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.IndexMetaDatabaseIndexConfigToJSON = IndexMetaDatabaseIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js
var require_IndexMetaDatabase2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseToJSON = exports.IndexMetaDatabaseFromJSONTyped = exports.IndexMetaDatabaseFromJSON = exports.instanceOfIndexMetaDatabase = void 0;
    var runtime_1 = require_runtime2();
    var IndexMetaDatabaseIndexConfig_1 = require_IndexMetaDatabaseIndexConfig2();
    function instanceOfIndexMetaDatabase(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaDatabase = instanceOfIndexMetaDatabase;
    function IndexMetaDatabaseFromJSON(json) {
      return IndexMetaDatabaseFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseFromJSON = IndexMetaDatabaseFromJSON;
    function IndexMetaDatabaseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"]
      };
    }
    exports.IndexMetaDatabaseFromJSONTyped = IndexMetaDatabaseFromJSONTyped;
    function IndexMetaDatabaseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig
      };
    }
    exports.IndexMetaDatabaseToJSON = IndexMetaDatabaseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaStatus.js
var require_IndexMetaStatus2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaStatusToJSON = exports.IndexMetaStatusFromJSONTyped = exports.IndexMetaStatusFromJSON = exports.instanceOfIndexMetaStatus = exports.IndexMetaStatusStateEnum = void 0;
    var runtime_1 = require_runtime2();
    exports.IndexMetaStatusStateEnum = {
      Initializing: "Initializing",
      ScalingUp: "ScalingUp",
      ScalingDown: "ScalingDown",
      Terminating: "Terminating",
      Ready: "Ready"
    };
    function instanceOfIndexMetaStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaStatus = instanceOfIndexMetaStatus;
    function IndexMetaStatusFromJSON(json) {
      return IndexMetaStatusFromJSONTyped(json, false);
    }
    exports.IndexMetaStatusFromJSON = IndexMetaStatusFromJSON;
    function IndexMetaStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ready": !(0, runtime_1.exists)(json, "ready") ? void 0 : json["ready"],
        "state": !(0, runtime_1.exists)(json, "state") ? void 0 : json["state"]
      };
    }
    exports.IndexMetaStatusFromJSONTyped = IndexMetaStatusFromJSONTyped;
    function IndexMetaStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ready": value.ready,
        "state": value.state
      };
    }
    exports.IndexMetaStatusToJSON = IndexMetaStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMeta.js
var require_IndexMeta2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaToJSON = exports.IndexMetaFromJSONTyped = exports.IndexMetaFromJSON = exports.instanceOfIndexMeta = void 0;
    var runtime_1 = require_runtime2();
    var IndexMetaDatabase_1 = require_IndexMetaDatabase2();
    var IndexMetaStatus_1 = require_IndexMetaStatus2();
    function instanceOfIndexMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMeta = instanceOfIndexMeta;
    function IndexMetaFromJSON(json) {
      return IndexMetaFromJSONTyped(json, false);
    }
    exports.IndexMetaFromJSON = IndexMetaFromJSON;
    function IndexMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "database": !(0, runtime_1.exists)(json, "database") ? void 0 : (0, IndexMetaDatabase_1.IndexMetaDatabaseFromJSON)(json["database"]),
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : (0, IndexMetaStatus_1.IndexMetaStatusFromJSON)(json["status"])
      };
    }
    exports.IndexMetaFromJSONTyped = IndexMetaFromJSONTyped;
    function IndexMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "database": (0, IndexMetaDatabase_1.IndexMetaDatabaseToJSON)(value.database),
        "status": (0, IndexMetaStatus_1.IndexMetaStatusToJSON)(value.status)
      };
    }
    exports.IndexMetaToJSON = IndexMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/PatchRequest.js
var require_PatchRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/PatchRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatchRequestToJSON = exports.PatchRequestFromJSONTyped = exports.PatchRequestFromJSON = exports.instanceOfPatchRequest = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfPatchRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfPatchRequest = instanceOfPatchRequest;
    function PatchRequestFromJSON(json) {
      return PatchRequestFromJSONTyped(json, false);
    }
    exports.PatchRequestFromJSON = PatchRequestFromJSON;
    function PatchRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"]
      };
    }
    exports.PatchRequestFromJSONTyped = PatchRequestFromJSONTyped;
    function PatchRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "replicas": value.replicas,
        "pod_type": value.podType
      };
    }
    exports.PatchRequestToJSON = PatchRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufAny.js
var require_ProtobufAny2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufAny.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfProtobufAny(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfProtobufAny = instanceOfProtobufAny;
    function ProtobufAnyFromJSON(json) {
      return ProtobufAnyFromJSONTyped(json, false);
    }
    exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
    function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "typeUrl": !(0, runtime_1.exists)(json, "typeUrl") ? void 0 : json["typeUrl"],
        "value": !(0, runtime_1.exists)(json, "value") ? void 0 : json["value"]
      };
    }
    exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
    function ProtobufAnyToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "typeUrl": value.typeUrl,
        "value": value.value
      };
    }
    exports.ProtobufAnyToJSON = ProtobufAnyToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufNullValue.js
var require_ProtobufNullValue2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufNullValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = void 0;
    exports.ProtobufNullValue = {
      NullValue: "NULL_VALUE"
    };
    function ProtobufNullValueFromJSON(json) {
      return ProtobufNullValueFromJSONTyped(json, false);
    }
    exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
    function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
      return json;
    }
    exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
    function ProtobufNullValueToJSON(value) {
      return value;
    }
    exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryVector.js
var require_QueryVector2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfQueryVector(value) {
      var isInstance = true;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfQueryVector = instanceOfQueryVector;
    function QueryVectorFromJSON(json) {
      return QueryVectorFromJSONTyped(json, false);
    }
    exports.QueryVectorFromJSON = QueryVectorFromJSON;
    function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "topK": !(0, runtime_1.exists)(json, "topK") ? void 0 : json["topK"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
    function QueryVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "topK": value.topK,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.QueryVectorToJSON = QueryVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryRequest.js
var require_QueryRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = void 0;
    var runtime_1 = require_runtime2();
    var QueryVector_1 = require_QueryVector2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfQueryRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "topK" in value;
      return isInstance;
    }
    exports.instanceOfQueryRequest = instanceOfQueryRequest;
    function QueryRequestFromJSON(json) {
      return QueryRequestFromJSONTyped(json, false);
    }
    exports.QueryRequestFromJSON = QueryRequestFromJSON;
    function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "topK": json["topK"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"],
        "includeValues": !(0, runtime_1.exists)(json, "includeValues") ? void 0 : json["includeValues"],
        "includeMetadata": !(0, runtime_1.exists)(json, "includeMetadata") ? void 0 : json["includeMetadata"],
        "queries": !(0, runtime_1.exists)(json, "queries") ? void 0 : json["queries"].map(QueryVector_1.QueryVectorFromJSON),
        "vector": !(0, runtime_1.exists)(json, "vector") ? void 0 : json["vector"],
        "sparseVector": !(0, runtime_1.exists)(json, "sparseVector") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseVector"]),
        "id": !(0, runtime_1.exists)(json, "id") ? void 0 : json["id"]
      };
    }
    exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
    function QueryRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespace": value.namespace,
        "topK": value.topK,
        "filter": value.filter,
        "includeValues": value.includeValues,
        "includeMetadata": value.includeMetadata,
        "queries": value.queries === void 0 ? void 0 : value.queries.map(QueryVector_1.QueryVectorToJSON),
        "vector": value.vector,
        "sparseVector": (0, SparseValues_1.SparseValuesToJSON)(value.sparseVector),
        "id": value.id
      };
    }
    exports.QueryRequestToJSON = QueryRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ScoredVector.js
var require_ScoredVector2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ScoredVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfScoredVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfScoredVector = instanceOfScoredVector;
    function ScoredVectorFromJSON(json) {
      return ScoredVectorFromJSONTyped(json, false);
    }
    exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
    function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "score": !(0, runtime_1.exists)(json, "score") ? void 0 : json["score"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
    function ScoredVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "score": value.score,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.ScoredVectorToJSON = ScoredVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SingleQueryResults.js
var require_SingleQueryResults2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SingleQueryResults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = void 0;
    var runtime_1 = require_runtime2();
    var ScoredVector_1 = require_ScoredVector2();
    function instanceOfSingleQueryResults(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
    function SingleQueryResultsFromJSON(json) {
      return SingleQueryResultsFromJSONTyped(json, false);
    }
    exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
    function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
    function SingleQueryResultsToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryResponse.js
var require_QueryResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = void 0;
    var runtime_1 = require_runtime2();
    var ScoredVector_1 = require_ScoredVector2();
    var SingleQueryResults_1 = require_SingleQueryResults2();
    function instanceOfQueryResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfQueryResponse = instanceOfQueryResponse;
    function QueryResponseFromJSON(json) {
      return QueryResponseFromJSONTyped(json, false);
    }
    exports.QueryResponseFromJSON = QueryResponseFromJSON;
    function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "results": !(0, runtime_1.exists)(json, "results") ? void 0 : json["results"].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
    function QueryResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "results": value.results === void 0 ? void 0 : value.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.QueryResponseToJSON = QueryResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/RpcStatus.js
var require_RpcStatus2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/RpcStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = void 0;
    var runtime_1 = require_runtime2();
    var ProtobufAny_1 = require_ProtobufAny2();
    function instanceOfRpcStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfRpcStatus = instanceOfRpcStatus;
    function RpcStatusFromJSON(json) {
      return RpcStatusFromJSONTyped(json, false);
    }
    exports.RpcStatusFromJSON = RpcStatusFromJSON;
    function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "code": !(0, runtime_1.exists)(json, "code") ? void 0 : json["code"],
        "message": !(0, runtime_1.exists)(json, "message") ? void 0 : json["message"],
        "details": !(0, runtime_1.exists)(json, "details") ? void 0 : json["details"].map(ProtobufAny_1.ProtobufAnyFromJSON)
      };
    }
    exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
    function RpcStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "code": value.code,
        "message": value.message,
        "details": value.details === void 0 ? void 0 : value.details.map(ProtobufAny_1.ProtobufAnyToJSON)
      };
    }
    exports.RpcStatusToJSON = RpcStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpdateRequest.js
var require_UpdateRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpdateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfUpdateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
    function UpdateRequestFromJSON(json) {
      return UpdateRequestFromJSONTyped(json, false);
    }
    exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
    function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "setMetadata": !(0, runtime_1.exists)(json, "setMetadata") ? void 0 : json["setMetadata"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
    function UpdateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "setMetadata": value.setMetadata,
        "namespace": value.namespace
      };
    }
    exports.UpdateRequestToJSON = UpdateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertRequest.js
var require_UpsertRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = void 0;
    var runtime_1 = require_runtime2();
    var Vector_1 = require_Vector2();
    function instanceOfUpsertRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "vectors" in value;
      return isInstance;
    }
    exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
    function UpsertRequestFromJSON(json) {
      return UpsertRequestFromJSONTyped(json, false);
    }
    exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
    function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": json["vectors"].map(Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
    function UpsertRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors.map(Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.UpsertRequestToJSON = UpsertRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertResponse.js
var require_UpsertResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfUpsertResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
    function UpsertResponseFromJSON(json) {
      return UpsertResponseFromJSONTyped(json, false);
    }
    exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
    function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "upsertedCount": !(0, runtime_1.exists)(json, "upsertedCount") ? void 0 : json["upsertedCount"]
      };
    }
    exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
    function UpsertResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "upsertedCount": value.upsertedCount
      };
    }
    exports.UpsertResponseToJSON = UpsertResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/index.js
var require_models2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApproximatedConfig2(), exports);
    __exportStar(require_CollectionMeta2(), exports);
    __exportStar(require_CreateCollectionRequest2(), exports);
    __exportStar(require_CreateRequest2(), exports);
    __exportStar(require_CreateRequestIndexConfig2(), exports);
    __exportStar(require_DeleteRequest2(), exports);
    __exportStar(require_DescribeIndexStatsRequest2(), exports);
    __exportStar(require_DescribeIndexStatsResponse2(), exports);
    __exportStar(require_FetchResponse2(), exports);
    __exportStar(require_HnswConfig2(), exports);
    __exportStar(require_IndexMeta2(), exports);
    __exportStar(require_IndexMetaDatabase2(), exports);
    __exportStar(require_IndexMetaDatabaseIndexConfig2(), exports);
    __exportStar(require_IndexMetaStatus2(), exports);
    __exportStar(require_NamespaceSummary2(), exports);
    __exportStar(require_PatchRequest2(), exports);
    __exportStar(require_ProtobufAny2(), exports);
    __exportStar(require_ProtobufNullValue2(), exports);
    __exportStar(require_QueryRequest2(), exports);
    __exportStar(require_QueryResponse2(), exports);
    __exportStar(require_QueryVector2(), exports);
    __exportStar(require_RpcStatus2(), exports);
    __exportStar(require_ScoredVector2(), exports);
    __exportStar(require_SingleQueryResults2(), exports);
    __exportStar(require_SparseValues2(), exports);
    __exportStar(require_UpdateRequest2(), exports);
    __exportStar(require_UpsertRequest2(), exports);
    __exportStar(require_UpsertResponse2(), exports);
    __exportStar(require_Vector2(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js
var require_IndexOperationsApi2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexOperationsApi = void 0;
    var runtime = __importStar(require_runtime2());
    var models_1 = require_models2();
    var IndexOperationsApi = (
      /** @class */
      function(_super) {
        __extends(IndexOperationsApi2, _super);
        function IndexOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        IndexOperationsApi2.prototype.configureIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling configureIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "PATCH",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.PatchRequestToJSON)(requestParameters.patchRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.configureIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.configureIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollection = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.CreateRequestToJSON)(requestParameters.createRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndex = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.CollectionMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling describeIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.IndexMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollectionsRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollections = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listCollectionsRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexesRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexes = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listIndexesRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return IndexOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.IndexOperationsApi = IndexOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js
var require_VectorOperationsApi2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorOperationsApi = void 0;
    var runtime = __importStar(require_runtime2());
    var models_1 = require_models2();
    var VectorOperationsApi = (
      /** @class */
      function(_super) {
        __extends(VectorOperationsApi2, _super);
        function VectorOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        VectorOperationsApi2.prototype._deleteRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === void 0) {
                    throw new runtime.RequiredError("deleteRequest", "Required parameter requestParameters.deleteRequest was null or undefined when calling _delete.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype._delete = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._deleteRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1Raw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.deleteAll !== void 0) {
                    queryParameters["deleteAll"] = requestParameters.deleteAll;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1 = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.delete1Raw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStatsRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === void 0) {
                    throw new runtime.RequiredError("describeIndexStatsRequest", "Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStatsRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1Raw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1 = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStats1Raw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetchRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.ids === null || requestParameters.ids === void 0) {
                    throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling fetch.");
                  }
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/fetch",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.FetchResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetch = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetchRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.queryRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.queryRequest === null || requestParameters.queryRequest === void 0) {
                    throw new runtime.RequiredError("queryRequest", "Required parameter requestParameters.queryRequest was null or undefined when calling query.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/query",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.QueryRequestToJSON)(requestParameters.queryRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.QueryResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.query = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.queryRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.updateRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.updateRequest === null || requestParameters.updateRequest === void 0) {
                    throw new runtime.RequiredError("updateRequest", "Required parameter requestParameters.updateRequest was null or undefined when calling update.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/update",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.UpdateRequestToJSON)(requestParameters.updateRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.update = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.updateRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsertRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === void 0) {
                    throw new runtime.RequiredError("upsertRequest", "Required parameter requestParameters.upsertRequest was null or undefined when calling upsert.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/upsert",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.UpsertResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsert = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.upsertRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return VectorOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.VectorOperationsApi = VectorOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/index.js
var require_apis2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndexOperationsApi2(), exports);
    __exportStar(require_VectorOperationsApi2(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/index.js
var require_pinecone_generated_ts_fetch2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_runtime2(), exports);
    __exportStar(require_apis2(), exports);
    __exportStar(require_models2(), exports);
  }
});

// node_modules/cross-fetch/dist/browser-polyfill.js
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers3(headers) {
          this.map = {};
          if (headers instanceof Headers3) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers3.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers3.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers3.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers3.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers3.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers3.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers3.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers3.prototype[Symbol.iterator] = Headers3.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers3(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers3(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers3();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request3.prototype);
        function Response3(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers3(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response3.prototype);
        Response3.prototype.clone = function() {
          return new Response3(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers3(this.headers),
            url: this.url
          });
        };
        Response3.error = function() {
          var response = new Response3(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response3.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response3(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request3(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response3(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers3;
          self2.Request = Request3;
          self2.Response = Response3;
        }
        exports2.Headers = Headers3;
        exports2.Request = Request3;
        exports2.Response = Response3;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(typeof self !== "undefined" ? self : exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/index.js
var require_v0 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeClient = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch2();
    require_browser_polyfill();
    var utils_1 = require_utils3();
    var PineconeError = (
      /** @class */
      function(_super) {
        __extends(PineconeError2, _super);
        function PineconeError2(message) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          _this.name = "PineconeError";
          Object.setPrototypeOf(_this, _newTarget.prototype);
          _this.stack = "";
          return _this;
        }
        return PineconeError2;
      }(Error)
    );
    function streamToArrayBuffer(stream) {
      return __awaiter(this, void 0, void 0, function() {
        var result, reader, _a2, done, value, newResult;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              result = new Uint8Array(0);
              reader = stream.getReader();
              _b.label = 1;
            case 1:
              if (false)
                return [3, 3];
              return [4, reader.read()];
            case 2:
              _a2 = _b.sent(), done = _a2.done, value = _a2.value;
              if (done) {
                return [3, 3];
              }
              if (value) {
                newResult = new Uint8Array(result.length + value.length);
                newResult.set(result);
                newResult.set(value, result.length);
                result = newResult;
              }
              return [3, 1];
            case 3:
              return [2, result];
          }
        });
      });
    }
    function handler(func, args) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var e_1, error, body, buffer, _b, text, json;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 2, , 7]);
              return [4, func(args)];
            case 1:
              return [2, _c.sent()];
            case 2:
              e_1 = _c.sent();
              error = e_1;
              if (!(error && error.response))
                return [3, 5];
              body = (_a2 = error.response) === null || _a2 === void 0 ? void 0 : _a2.body;
              _b = body;
              if (!_b)
                return [3, 4];
              return [4, streamToArrayBuffer(body)];
            case 3:
              _b = _c.sent();
              _c.label = 4;
            case 4:
              buffer = _b;
              text = buffer && new TextDecoder().decode(buffer);
              try {
                json = text && JSON.parse(text);
                return [2, Promise.reject(new PineconeError("".concat(json === null || json === void 0 ? void 0 : json.message)))];
              } catch (e) {
                return [2, Promise.reject(new PineconeError("PineconeClient: Error calling ".concat(func.name.replace("bound ", ""), ": ").concat(text)))];
              }
              return [3, 6];
            case 5:
              return [2, Promise.reject(new PineconeError("PineconeClient: Error calling ".concat(func.name.replace("bound ", ""), ": ").concat(error)))];
            case 6:
              return [3, 7];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    function exposeMethods(instance, target) {
      var _this = this;
      var _loop_1 = function(prop2) {
        var descriptor = instance[prop2];
        if (descriptor && typeof descriptor === "function" && prop2 !== "constructor") {
          target[prop2] = function(args) {
            return __awaiter(_this, void 0, void 0, function() {
              var boundFunction;
              return __generator(this, function(_a3) {
                Object.defineProperty(descriptor, "name", { value: prop2 });
                boundFunction = descriptor.bind(instance);
                return [2, handler(boundFunction, args)];
              });
            });
          };
        }
      };
      for (var _i = 0, _a2 = Object.keys(Object.getPrototypeOf(instance)); _i < _a2.length; _i++) {
        var prop = _a2[_i];
        _loop_1(prop);
      }
    }
    function attachHandler(instance) {
      var _this = this;
      var _loop_2 = function(prop2) {
        var descriptor = instance[prop2];
        if (descriptor && typeof descriptor === "function" && prop2 !== "constructor") {
          instance[prop2] = function(args) {
            return __awaiter(_this, void 0, void 0, function() {
              var boundFunction;
              return __generator(this, function(_a3) {
                Object.defineProperty(descriptor, "name", { value: prop2 });
                boundFunction = descriptor.bind(instance);
                return [2, handler(boundFunction, args)];
              });
            });
          };
        }
      };
      for (var _i = 0, _a2 = Object.keys(Object.getPrototypeOf(instance)); _i < _a2.length; _i++) {
        var prop = _a2[_i];
        _loop_2(prop);
      }
      return instance;
    }
    var PineconeClient = (
      /** @class */
      function() {
        function PineconeClient2() {
          this.apiKey = null;
          this.projectName = null;
          this.environment = null;
        }
        PineconeClient2.prototype.getProjectName = function(controllerPath, apiKey) {
          return __awaiter(this, void 0, void 0, function() {
            var whoami, request, response, error, statusText, project_name, error_1;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  whoami = "".concat(controllerPath, "/actions/whoami");
                  request = {
                    method: "GET",
                    headers: {
                      "Content-Type": "application/json",
                      "Api-Key": apiKey
                    }
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 7, , 8]);
                  return [4, fetch(whoami, request)];
                case 2:
                  response = _a2.sent();
                  if (!(response.status !== 200))
                    return [3, 4];
                  return [4, response.text()];
                case 3:
                  error = _a2.sent();
                  statusText = response.statusText;
                  throw new Error("".concat(statusText, " - ").concat(error));
                case 4:
                  return [4, response.json()];
                case 5:
                  project_name = _a2.sent().project_name;
                  return [2, project_name];
                case 6:
                  return [3, 8];
                case 7:
                  error_1 = _a2.sent();
                  throw new PineconeError("Failed getting project name. ".concat(error_1));
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PineconeClient2.prototype.init = function(configuration) {
          return __awaiter(this, void 0, void 0, function() {
            var environment, apiKey, controllerPath, _a2, error_2, controllerConfigurationParameters, controllerConfiguration, indexOperations;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  environment = configuration.environment, apiKey = configuration.apiKey;
                  this.apiKey = apiKey;
                  this.environment = environment;
                  controllerPath = "https://controller.".concat(environment, ".pinecone.io");
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 3, , 4]);
                  _a2 = this;
                  return [4, this.getProjectName(controllerPath, apiKey)];
                case 2:
                  _a2.projectName = _b.sent();
                  return [3, 4];
                case 3:
                  error_2 = _b.sent();
                  throw error_2;
                case 4:
                  controllerConfigurationParameters = {
                    basePath: controllerPath,
                    apiKey,
                    queryParamsStringify: utils_1.queryParamsStringify,
                    headers: {
                      "User-Agent": (0, utils_1.buildUserAgent)(true)
                    }
                  };
                  controllerConfiguration = new pinecone_generated_ts_fetch_1.Configuration(controllerConfigurationParameters);
                  indexOperations = new pinecone_generated_ts_fetch_1.IndexOperationsApi(controllerConfiguration);
                  exposeMethods(indexOperations, this);
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PineconeClient2.prototype.Index = function(index) {
          if (!this.apiKey)
            throw new Error("PineconeClient: API key not set. Call init() first.");
          if (!this.projectName)
            throw new Error("PineconeClient: Project name not set. Call init() first.");
          if (!this.environment)
            throw new Error("PineconeClient: Environment not set. Call init() first.");
          var indexConfigurationParameters = {
            basePath: "https://".concat(index, "-").concat(this.projectName, ".svc.").concat(this.environment, ".pinecone.io"),
            apiKey: this.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
              "User-Agent": (0, utils_1.buildUserAgent)(true)
            }
          };
          var indexConfiguration = new pinecone_generated_ts_fetch_1.Configuration(indexConfigurationParameters);
          var vectorOperations = new pinecone_generated_ts_fetch_1.VectorOperationsApi(indexConfiguration);
          return attachHandler(vectorOperations);
        };
        return PineconeClient2;
      }()
    );
    exports.PineconeClient = PineconeClient;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/utils.js
var require_utils4 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = void 0;
    var waitUntilIndexIsReady = function(client, indexName, retries) {
      if (retries === void 0) {
        retries = 0;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var indexDescription, e_1;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 6, , 7]);
              return [4, client.describeIndex({ indexName })];
            case 1:
              indexDescription = _b.sent();
              if (!!((_a2 = indexDescription.status) === null || _a2 === void 0 ? void 0 : _a2.ready))
                return [3, 4];
              return [4, new Promise(function(r) {
                return setTimeout(r, 1e3);
              })];
            case 2:
              _b.sent();
              return [4, waitUntilIndexIsReady(client, indexName, retries + 1)];
            case 3:
              _b.sent();
              return [3, 5];
            case 4:
              console.log("Index ready after ".concat(retries, " seconds"));
              return [
                2
                /*return*/
              ];
            case 5:
              return [3, 7];
            case 6:
              e_1 = _b.sent();
              console.error("Error waiting until index is ready", e_1);
              return [3, 7];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var createIndexIfNotExists = function(client, indexName, dimension) {
      return __awaiter(void 0, void 0, void 0, function() {
        var indexList, e_2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 5, , 6]);
              return [4, client.listIndexes()];
            case 1:
              indexList = _a2.sent();
              if (!!indexList.includes(indexName))
                return [3, 4];
              console.log("Creating index", indexName);
              return [4, client.createIndex({
                createRequest: {
                  name: indexName,
                  dimension
                }
              })];
            case 2:
              _a2.sent();
              console.log("Waiting until index is ready...");
              return [4, waitUntilIndexIsReady(client, indexName)];
            case 3:
              _a2.sent();
              console.log("Index is ready.");
              _a2.label = 4;
            case 4:
              return [3, 6];
            case 5:
              e_2 = _a2.sent();
              console.error("Error creating index", e_2);
              return [3, 6];
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var sliceIntoChunks = function(arr, chunkSize) {
      return Array.from({ length: Math.ceil(arr.length / chunkSize) }, function(_, i) {
        return arr.slice(i * chunkSize, (i + 1) * chunkSize);
      });
    };
    var chunkedUpsert = function(index, vectors, namespace, chunkSize) {
      if (chunkSize === void 0) {
        chunkSize = 10;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var chunks, e_3;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              chunks = sliceIntoChunks(vectors, chunkSize);
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, Promise.allSettled(chunks.map(function(chunk) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var e_4;
                  return __generator(this, function(_a3) {
                    switch (_a3.label) {
                      case 0:
                        _a3.trys.push([0, 2, , 3]);
                        return [4, index.upsert({
                          upsertRequest: {
                            vectors: chunk,
                            namespace
                          }
                        })];
                      case 1:
                        _a3.sent();
                        return [3, 3];
                      case 2:
                        e_4 = _a3.sent();
                        console.log("Error upserting chunk", e_4);
                        return [3, 3];
                      case 3:
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }))];
            case 2:
              _a2.sent();
              return [2, true];
            case 3:
              e_3 = _a2.sent();
              throw new Error("Error upserting vectors into index: ".concat(e_3));
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var utils = {
      waitUntilIndexIsReady,
      createIndexIfNotExists,
      chunkedUpsert
    };
    exports.utils = utils;
  }
});

// node_modules/@pinecone-database/pinecone/dist/index.js
var require_dist = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.PineconeClient = exports.Errors = exports.Index = exports.Pinecone = void 0;
    var pinecone_1 = require_pinecone();
    Object.defineProperty(exports, "Pinecone", { enumerable: true, get: function() {
      return pinecone_1.Pinecone;
    } });
    var data_1 = require_data2();
    Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
      return data_1.Index;
    } });
    exports.Errors = __importStar(require_errors());
    var v0_1 = require_v0();
    Object.defineProperty(exports, "PineconeClient", { enumerable: true, get: function() {
      return v0_1.PineconeClient;
    } });
    var utils_1 = require_utils4();
    Object.defineProperty(exports, "utils", { enumerable: true, get: function() {
      return utils_1.utils;
    } });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_promises2 = require("fs/promises");
var import_http = require("http");

// utils/globalHandlers.ts
var PluginHandler = class {
  constructor() {
  }
  init(app2) {
    this.app = app2;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  getPlugins() {
    if (!this.plugins) {
      return {
        //@ts-ignore
        dataview: this.app.plugins.plugins["dataview"].api,
        //@ts-ignore
        frontmatter: this.app.plugins.plugins["metadata-menu"].api,
        ska_se: this.app.plugins.plugins["ska-se-obsidian-plugin"].api
      };
    }
    return this.plugins;
  }
};
var pluginHandler = new PluginHandler();
var globalHandlers_default = pluginHandler;

// utils/files.ts
async function removeError(file, app2) {
  await app2.fileManager.renameFile(
    file,
    file.path.split("\u274C").join("").trim()
  );
}
async function removeWarning(file, app2) {
  await app2.fileManager.renameFile(
    file,
    file.path.split("\u26A0\uFE0F").join("").trim()
  );
}
async function addError(file, app2) {
  if (file.path.includes("\u274C"))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(".md")[0].trim() + " \u274C.md"
  );
}
async function addWarning(file, app2) {
  if (file.path.includes("\u26A0\uFE0F"))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(".md")[0].trim() + " \u26A0\uFE0F.md"
  );
}
async function addIconToName(file, app2, icon) {
  if (file.path.includes(icon))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(".md")[0].trim() + ` ${icon}.md`
  );
}
async function removeIconFromName(file, app2, icon) {
  if (!file.path.includes(icon))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(icon).join("").trim()
  );
}
async function getSection(file, headingToSearch) {
  var _a2, _b, _c, _d, _e;
  const app2 = globalHandlers_default.app;
  const { metadataCache, vault } = app2;
  const headings = (_b = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.headings) != null ? _b : [];
  let text = await vault.cachedRead(file);
  const hIdx = headings.findIndex(
    ({ heading }) => heading === headingToSearch
  );
  if (hIdx === -1) {
    text = "";
  } else {
    text = text.split("\n").slice(
      headings[hIdx].position.start.line + 1,
      (_e = (_d = (_c = headings[hIdx + 1]) == null ? void 0 : _c.position) == null ? void 0 : _d.start) == null ? void 0 : _e.line
    ).join("\n").trim();
  }
  console.log(text);
  return text;
}
async function insertMarkdownUnderHeading(file, headingToSearch, markdown, offset = [], offsetLine = []) {
  var _a2, _b;
  if (!markdown)
    markdown = "";
  const app2 = globalHandlers_default.app;
  const { metadataCache, vault } = app2;
  const cache = metadataCache.getFileCache(file);
  const headings = (_a2 = cache == null ? void 0 : cache.headings) != null ? _a2 : [];
  const sections = (_b = cache == null ? void 0 : cache.sections) != null ? _b : [];
  let text = await vault.read(file);
  let dLength = text.length;
  const heading = headings.find(
    ({ heading: heading2 }) => heading2 === headingToSearch
  );
  if (!heading) {
    console.log("No heading found");
    return [offset, offsetLine];
  }
  const hIdx = sections.findIndex(
    ({ position }) => position.end.offset === heading.position.end.offset
  );
  const totalOffset = offset == null ? void 0 : offset.reduce((acc, curr, idx) => {
    if (offsetLine && heading.position.start.line >= offsetLine[idx]) {
      return acc + curr;
    }
    return acc;
  }, 0);
  if (!sections[hIdx + 1] || sections[hIdx + 1].type === "heading") {
    console.log("here");
    text = text.slice(0, heading.position.end.offset + totalOffset) + markdown + text.slice(heading.position.end.offset + totalOffset);
  } else {
    text = text.slice(0, heading.position.end.offset + totalOffset) + markdown + text.slice(
      sections[hIdx + 1].position.end.offset + 1 + totalOffset
    );
  }
  await app2.vault.modify(file, text);
  offset.push(text.length - dLength);
  offsetLine == null ? void 0 : offsetLine.push(heading.position.start.line);
  return [offset, offsetLine];
}

// node_modules/openai/version.mjs
var VERSION = "4.11.0";

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  OpenAIError: () => OpenAIError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${status} ${APIError.makeMessage(error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data === null || data === void 0 ? void 0 : data["code"];
    this.param = data === null || data === void 0 ? void 0 : data["param"];
    this.type = data === null || data === void 0 ? void 0 : data["type"];
  }
  static makeMessage(error, message) {
    return (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message || "status code (no body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message !== null && message !== void 0 ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(response, controller) {
    this.response = response;
    this.controller = controller;
    this.decoder = new SSEDecoder();
  }
  async *iterMessages() {
    if (!this.response.body) {
      this.controller.abort();
      throw new OpenAIError(`Attempted to iterate over a response with no body`);
    }
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(this.response.body);
    for await (const chunk of iter) {
      for (const line of lineDecoder.decode(chunk)) {
        const sse = this.decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = this.decoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async *[Symbol.asyncIterator]() {
    let done = false;
    try {
      for await (const sse of this.iterMessages()) {
        if (done)
          continue;
        if (sse.data.startsWith("[DONE]")) {
          done = true;
          continue;
        }
        if (sse.event === null) {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error(`Could not parse message into JSON:`, sse.data);
            console.error(`From chunk:`, sse.raw);
            throw e;
          }
        }
      }
      done = true;
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError")
        return;
      throw e;
    } finally {
      if (!done)
        this.controller.abort();
    }
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) !== null && _a2 !== void 0 ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) !== null && _a2 !== void 0 ? _a2 : "unknown_file");
    return new File2([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) !== null && _b !== void 0 ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) === null || _c === void 0 ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value === null || value === void 0 ? void 0 : value.constructor) === null || _a2 === void 0 ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) === null || _a2 === void 0 ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
var MAX_RETRIES = 2;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    return new Stream(response, props.controller);
  }
  const contentType = response.headers.get("content-type");
  if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries !== null && maxRetries !== void 0 ? maxRetries : MAX_RETRIES);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch !== null && overridenFetch !== void 0 ? overridenFetch : fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) !== null && _b !== void 0 ? _b : this.httpAgent) !== null && _c !== void 0 ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent === null || httpAgent === void 0 ? void 0 : httpAgent.options) === null || _d === void 0 ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) !== null && _e !== void 0 ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options),
      ...headers
    };
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) !== null && _f !== void 0 ? _f : null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    retriesRemaining -= 1;
    let timeoutMillis;
    const retryAfterHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader) {
      const timeoutSeconds = parseInt(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!timeoutMillis || !Number.isInteger(timeoutMillis) || timeoutMillis <= 0 || timeoutMillis > 60 * 1e3) {
      const maxRetries = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 2;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);
    const jitter = Math.random() - 0.5;
    return (sleepSeconds + jitter) * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2[env]) !== null && _b !== void 0 ? _b : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) === null || _c === void 0 ? void 0 : _c.get) === null || _d === void 0 ? void 0 : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.object = body.object;
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2, _b;
    if (!((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return null;
    }
    const next = (_b = this.data[this.data.length - 1]) === null || _b === void 0 ? void 0 : _b.id;
    if (!next)
      return null;
    return { params: { after: next } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this.client = client;
    this.get = client.get.bind(client);
    this.post = client.post.bind(client);
    this.patch = client.patch.bind(client);
    this.put = client.put.bind(client);
    this.delete = client.delete.bind(client);
    this.getAPIList = client.getAPIList.bind(client);
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this.client);
    this.translations = new Translations(this.client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false });
  }
};
(function(Completions3) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this.client);
  }
};
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/openai/resources/completions.mjs
var Completions2 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/completions", { body, ...options, stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false });
  }
};
(function(Completions3) {
})(Completions2 || (Completions2 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this.post("/embeddings", { body, ...options });
  }
};
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));

// node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   *
   * @deprecated The Edits API is deprecated; please use Chat Completions instead.
   *
   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api
   */
  create(body, options) {
    return this.post("/edits", { body, ...options });
  }
};
(function(Edits2) {
})(Edits || (Edits = {}));

// node_modules/openai/resources/files.mjs
var Files = class extends APIResource {
  /**
   * Upload a file that contains document(s) to be used across various
   * endpoints/features. Currently, the size of all the files uploaded by one
   * organization can be up to 1 GB. Please contact us if you need to increase the
   * storage limit.
   */
  create(body, options) {
    return this.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this.get(`/files/${fileId}`, options);
  }
  /**
   * Returns a list of files that belong to the user's organization.
   */
  list(options) {
    return this.getAPIList("/files", FileObjectsPage, options);
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  retrieveContent(fileId, options) {
    return this.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/json", ...options === null || options === void 0 ? void 0 : options.headers }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends Page {
};
(function(Files2) {
})(Files || (Files = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)
   */
  create(body, options) {
    return this.post("/fine-tunes", { body, ...options });
  }
  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)
   */
  retrieve(fineTuneId, options) {
    return this.get(`/fine-tunes/${fineTuneId}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   */
  list(options) {
    return this.getAPIList("/fine-tunes", FineTunesPage, options);
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuneId, options) {
    return this.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a2;
    return this.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream: (_a2 = query === null || query === void 0 ? void 0 : query.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
var FineTunesPage = class extends Page {
};
(function(FineTunes2) {
})(FineTunes || (FineTunes = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
(function(Jobs2) {
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this.client);
  }
};
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this.post("/images/generations", { body, ...options });
  }
};
(function(Images2) {
})(Images || (Images = {}));

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
(function(Models2) {
})(Models || (Models = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  create(body, options) {
    return this.post("/moderations", { body, ...options });
  }
};
(function(Moderations2) {
})(Moderations || (Moderations = {}));

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string} [opts.apiKey=process.env['OPENAI_API_KEY']] - The API Key to send to the API.
   * @param {string} [opts.baseURL] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * @param {string | null} [opts.organization]
   */
  constructor(_b) {
    var _c, _d, _e;
    var { apiKey = readEnv("OPENAI_API_KEY"), organization = (_c = readEnv("OPENAI_ORG_ID")) !== null && _c !== void 0 ? _c : null, ...opts } = _b === void 0 ? {} : _b;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'my apiKey' }).");
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: (_d = opts.baseURL) !== null && _d !== void 0 ? _d : `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_e = options.timeout) !== null && _e !== void 0 ? _e : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var { OpenAIError: OpenAIError2, APIError: APIError2, APIConnectionError: APIConnectionError2, APIConnectionTimeoutError: APIConnectionTimeoutError2, APIUserAbortError: APIUserAbortError2, NotFoundError: NotFoundError2, ConflictError: ConflictError2, RateLimitError: RateLimitError2, BadRequestError: BadRequestError2, AuthenticationError: AuthenticationError2, InternalServerError: InternalServerError2, PermissionDeniedError: PermissionDeniedError2, UnprocessableEntityError: UnprocessableEntityError2 } = error_exports;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions2;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// utils/requirements.ts
var import_pinecone = __toESM(require_dist());
var pinecone = new import_pinecone.Pinecone({
  apiKey: "81f56d81-b6ff-4af4-b3f5-3108d730bb88",
  environment: "gcp-starter"
});
var openai = new openai_default({
  apiKey: "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",
  // defaults to process.env["OPENAI_API_KEY"]
  dangerouslyAllowBrowser: true
});
async function getEmbedMarkdown({
  path,
  subpath
}) {
  var _a2, _b, _c, _d, _e;
  const { metadataCache, vault } = app;
  const file = metadataCache.getFirstLinkpathDest(path, "");
  const headings = (_b = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.headings) != null ? _b : [];
  let text = await vault.cachedRead(file);
  if (subpath) {
    const hIdx = headings.findIndex(
      ({ heading }) => heading === subpath
    );
    if (hIdx === -1) {
      text = "";
    } else {
      text = text.split("\n").slice(
        headings[hIdx].position.start.line + 1,
        (_e = (_d = (_c = headings[hIdx + 1]) == null ? void 0 : _c.position) == null ? void 0 : _d.start) == null ? void 0 : _e.line
      ).join(" ").trim();
    }
  }
  return text.split("\n").map((line) => line.trim()).join(" ");
}
async function interfacesTable(file) {
  const { dataview: dv } = globalHandlers_default.getPlugins();
  const app2 = globalHandlers_default.app;
  const render = [];
  const connectionsJson = JSON.parse(
    await app2.vault.read(
      app2.metadataCache.getFirstLinkpathDest(
        "System Diagram.canvas",
        ""
      )
    )
  );
  const thisNode = connectionsJson.nodes.find(
    (node) => file.path.includes(node.file)
  );
  const connectingTo = connectionsJson.edges.filter(
    (edge) => edge.fromNode === thisNode.id
  );
  const connectingFrom = connectionsJson.edges.filter(
    (edge) => edge.toNode === thisNode.id
  );
  const connections = [...connectingTo, ...connectingFrom];
  for (let connection of connections) {
    const int = app2.metadataCache.getFirstLinkpathDest(
      connection.label,
      ""
    );
    const node = connectionsJson.nodes.find(
      (node2) => connection.fromNode === node2.id && connection.toNode === thisNode.id || connection.toNode === node2.id && connection.fromNode === thisNode.id
    );
    const nodeFile = app2.metadataCache.getFirstLinkpathDest(node.file, "");
    render.push([
      int ? `[[${int.basename}]]` : "None\u26A0\uFE0F",
      `[[${nodeFile == null ? void 0 : nodeFile.basename}]]`
    ]);
  }
  const tableMarkdown = render.length ? "\n" + dv.markdownTable(["Interface Name", "Connecting To"], render) : "";
  return tableMarkdown;
}
async function testsTable(file) {
  var _a2, _b;
  const { dataview: dv, ska_se } = globalHandlers_default.getPlugins();
  const app2 = globalHandlers_default.app;
  const cache = app2.metadataCache.getFileCache(file);
  const tests = dv.pages(`"${ska_se.settings.test_documentation_root_folder}"`).where((test) => {
    return test.System && test.System.path.includes(file.path);
  }).values;
  if (tests.length === 0)
    return "";
  const testsSection = (_a2 = cache == null ? void 0 : cache.headings) == null ? void 0 : _a2.find(
    (h) => h.heading === "System Tests"
  );
  const testsHeadingIndex = (_b = cache == null ? void 0 : cache.sections) == null ? void 0 : _b.findIndex(
    (section) => section.position.start.line === (testsSection == null ? void 0 : testsSection.position.start.line)
  );
  const listData = "\n" + dv.markdownList(
    tests.map(
      (test) => `[[${test.file.path}|${test.file.name}]] ${test.Status === "success" ? "	\u2705" : "	\u274C"}`
    )
  );
  return listData != null ? listData : "";
}
async function requirementsTable2(file) {
  const { dataview: dv, ska_se } = globalHandlers_default.getPlugins();
  const app2 = globalHandlers_default.app;
  const cache = app2.metadataCache.getFileCache(file);
  const thisRequirements = dv.pages(`"${ska_se.settings.system_design_root_folder}/Requirements"`).where((req) => {
    var _a2;
    return req.System && req.System == ((_a2 = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a2.ID);
  }).values;
  if (thisRequirements.length === 0)
    return "";
  const tableValues = [];
  for (const req of thisRequirements) {
    const toReturn = ["", ""];
    toReturn[0] = await getEmbedMarkdown({
      path: req.file.path,
      subpath: "Description"
    });
    toReturn[1] = "[[" + req.file.path.split("/").pop() + "]]";
    tableValues.push(toReturn);
  }
  const tableHeaders = ["Description", "Source"];
  const tableMarkdown = "\n" + dv.markdownTable(tableHeaders, tableValues);
  return tableMarkdown != null ? tableMarkdown : "";
}
async function compareRequirements(res) {
  var _a2, _b;
  if (!res)
    return;
  const searchResult = await pinecone.index("requirements").query({
    vector: res.values,
    topK: 10,
    includeMetadata: true
  });
  const potentialConflicts = (_a2 = searchResult.matches) == null ? void 0 : _a2.filter(
    (match) => {
      var _a3, _b2;
      return match.score && match.score > 0.9 && match.score < 0.99 && ((_a3 = match.metadata) == null ? void 0 : _a3.description) !== ((_b2 = res.metadata) == null ? void 0 : _b2.description);
    }
  ).map(
    (match) => {
      var _a3, _b2;
      return "- " + ((_a3 = match.metadata) == null ? void 0 : _a3.description) + `
File path: ${(_b2 = match.metadata) == null ? void 0 : _b2.path}`;
    }
  ).join("\n\n");
  if (!potentialConflicts || potentialConflicts === "") {
    console.log("No conflicts found");
    return;
  }
  console.log(potentialConflicts);
  const prompt = `Given requirement:
		${(_b = res.metadata) == null ? void 0 : _b.description}
		
		Requirements to compare to:
		${potentialConflicts}

		---
		Are there any conflicts between the given requirement and the requirements to compare? YES/NO - short reasoning - [[file path]]`;
  const result = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: `You are an engineering assistant tasked with comparing a set of requirements and detecting if there are any potential conflicts between them.
					You should only respond in a following format: YES/NO/UNCLEAR - short reasoning - [[file path]]. Remember about the double brackets around the file path.
					Remember to provide reasoning in a short but clear way. If the answer is YES, you should also provide a brief description of a possible ways to resolve the issue.
					If the answer is UNCLEAR provide a short instruction on how the requirement can be improved. If there are multiple conflicts, provide a response only for the one that is conflicting`
      },
      {
        role: "user",
        content: prompt
      }
    ]
  });
  return result.choices[0].message.content;
}
async function addEmbed(value, file) {
  var _a2, _b, _c, _d;
  const text = `System: 
		${value.system}

		Description:
		${value.description}

		Source:
		${value.source}`;
  const res = (_a2 = (await pinecone.index("requirements").fetch([value.id])).records) == null ? void 0 : _a2[value.id];
  if (((_b = res == null ? void 0 : res.metadata) == null ? void 0 : _b.description) === value.description && res.metadata.source === value.source) {
    if (((_c = res == null ? void 0 : res.metadata) == null ? void 0 : _c.path) !== file.path) {
      await pinecone.index("requirements").update({ id: res.id, metadata: { path: file.path } });
      return {
        ...res,
        metadata: {
          ...res.metadata,
          path: file.path
        }
      };
    } else {
      return res;
    }
  }
  const embedding = await openai.embeddings.create({
    input: text,
    model: "text-embedding-ada-002"
  });
  await pinecone.index("requirements").upsert([
    {
      id: value.id,
      values: embedding.data[0].embedding,
      metadata: {
        description: value.description,
        source: value.source,
        system: value.system,
        path: file.path
      }
    }
  ]);
  const resAdded = (_d = (await pinecone.index("requirements").fetch([value.id])).records) == null ? void 0 : _d[value.id];
  return resAdded;
}

// utils/templates.ts
var import_promises = require("fs/promises");
async function addRequirement(args) {
  const app2 = globalHandlers_default.app;
  const { ska_se } = globalHandlers_default.getPlugins();
  const requirementTemplate = await (0, import_promises.readFile)(
    app2.vault.adapter.getBasePath() + "/.obsidian/plugins/ska_se/templates/requirement.template.md"
  );
  let data = requirementTemplate.toString().replace(/%system%/g, args.system).replace(/%description%/g, args.description).replace(/%source%/g, args.source);
  if (!args.id) {
    const num_equirements = app2.vault.getFiles().filter(
      (file) => file.basename.startsWith(`REQ.${args.system}.`)
    ).length;
    args.id = `REQ.${args.system}.${num_equirements + 1}`;
  }
  if (args.id) {
    data = data.replace(/%id%/g, args.id.toUpperCase().replace(/ /g, "_"));
  }
  const rootPath = ska_se.settings.system_design_root_folder;
  return await app2.vault.create(
    rootPath + "/Requirements/" + args.id + ".md",
    data
  );
}
async function addComponent({
  system,
  path,
  fileName,
  id
}) {
  const app2 = globalHandlers_default.app;
  const componentTemplate = await (0, import_promises.readFile)(
    app2.vault.adapter.getBasePath() + "/.obsidian/plugins/ska_se/templates/component.template.md"
  );
  let data = componentTemplate.toString().replace(/%system%/g, system);
  if (id) {
    data = data.replace(/%id%/g, id.toUpperCase().replace(/ /g, "_"));
  }
  await app2.vault.createFolder(path + "/" + fileName);
  return await app2.vault.create(
    path + "/" + fileName + "/" + fileName + ".md",
    data
  );
}
async function addToSystemDiagram({
  file,
  isComponent
}) {
  var _a2, _b, _c, _d, _e;
  const app2 = globalHandlers_default.app;
  const systemDiagram = app2.metadataCache.getFirstLinkpathDest(
    "System Diagram.canvas",
    ""
  );
  console.log(systemDiagram);
  if (!systemDiagram)
    throw new Error("No system diagram found");
  const d = await app2.vault.cachedRead(systemDiagram);
  const dataJson = JSON.parse(d);
  const canvasStyle = (_b = (_a2 = app2.workspace.getLeaf().getContainer()) == null ? void 0 : _a2.doc.getElementsByClassName("canvas")[0]) == null ? void 0 : _b.getAttribute("style");
  const canvasTranslate = (_e = (_d = (_c = canvasStyle == null ? void 0 : canvasStyle.split("translate(")[2]) == null ? void 0 : _c.split("px)")[0]) == null ? void 0 : _d.split("px, ")) != null ? _e : [0, 0];
  dataJson.nodes.push({
    type: isComponent ? "text" : "group",
    id: Math.random().toString(36).substring(14),
    file: file.path,
    x: Number(-canvasTranslate[0]) - 150,
    y: Number(-canvasTranslate[1]) - 100,
    width: 300,
    height: 200,
    label: file.basename,
    ...isComponent ? { text: file.basename } : {}
  });
  await app2.vault.modify(systemDiagram, JSON.stringify(dataJson));
}

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default",
  system_design_root_folder: "11-Systems_design",
  test_documentation_root_folder: "05-Test_documentation",
  interfaces_root_folder: "12-Interfaces"
};
var MyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    (0, import_http.createServer)(async (req, res) => {
      const reqUrl = req.url;
      console.log(reqUrl);
      if (!reqUrl) {
        res.end("No url provided");
        return;
      }
      res.writeHead(200, {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Origin, X-Requested-With, Content-Type, Accept"
      });
      const file = this.app.vault.getAbstractFileByPath(
        "models/Waddles_wm.stl"
      );
      const uint8View = new Uint8Array(
        await this.app.vault.readBinary(file)
      );
      res.end(uint8View);
    }).listen(5566);
    globalHandlers_default.init(this.app);
    this.app.workspace.onLayoutReady(() => {
      console.log(this.app.plugins.plugins);
      globalHandlers_default.setPlugins({
        //@ts-ignore
        dataview: this.app.plugins.plugins["dataview"].api,
        //@ts-ignore
        frontmatter: this.app.plugins.plugins["metadata-menu"].api,
        //@ts-ignore
        ska_se: this.app.plugins.plugins["ska-se-obsidian-plugin"]
      });
    });
    const ribbonIconEl = this.addRibbonIcon(
      "dice",
      "SKA SE",
      (evt) => {
        new import_obsidian.Notice("This is a notice!");
      }
    );
    ribbonIconEl.addClass("my-plugin-ribbon-class");
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Status Bar Text");
    this.addCommand({
      id: "add-requirements",
      name: "Add requirement",
      callback: async () => {
        var _a2, _b;
        const currentFile = this.app.workspace.getActiveFile();
        if (!currentFile) {
          new import_obsidian.Notice("Active file is not a component");
          return;
        }
        const system = (_b = (_a2 = app.metadataCache.getFileCache(currentFile)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b.ID;
        if (!system) {
          new import_obsidian.Notice("Active file is not a component");
          return;
        }
        const newRequirement = await addRequirement({
          description: "",
          source: "",
          system
        });
        app.workspace.createLeafBySplit(app.workspace.getLeaf(false)).openFile(newRequirement);
      }
    });
    this.addCommand({
      id: "add-component",
      name: "Add component",
      callback: async () => {
        new CreateComponentModal(this.app, this.settings).open();
      }
    });
    this.registerMarkdownCodeBlockProcessor(
      "stlrender",
      async (source, el, ctx) => {
        var _a2, _b;
        const frame = document.createElement("iframe");
        frame.id = "stlframe";
        el.appendChild(frame);
        const content = await (0, import_promises2.readFile)(
          app.vault.adapter.getBasePath() + "/.obsidian/plugins/ska_se/templates/index.html"
        );
        const doc = (_a2 = frame.contentWindow) == null ? void 0 : _a2.document;
        doc == null ? void 0 : doc.open();
        doc == null ? void 0 : doc.write(content.toString());
        doc == null ? void 0 : doc.close();
        frame.style.width = "100%";
        frame.style.minHeight = "400px";
        const f = document.getElementById("stlframe");
        (_b = f.contentWindow) == null ? void 0 : _b.addEventListener("load", () => {
          var _a3;
          (_a3 = f.contentWindow) == null ? void 0 : _a3.startRender("/" + source);
        });
      }
    );
    this.addCommand({
      id: "sample-editor-command",
      name: "Sample editor command",
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        editor.replaceSelection("Sample Editor Command");
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.app.workspace.on("file-open", () => {
      const thisFile = this.app.workspace.getActiveFile();
      if (!thisFile)
        return;
      if (thisFile.extension === "canvas")
        this.app.workspace.onLayoutReady(
          () => handleCanvas(thisFile, this)
        );
      else if (thisFile.extension === "md" && thisFile.path.includes(
        this.settings.system_design_root_folder
      ) && !thisFile.path.includes("Requirements")) {
        console.log("system design");
        this.app.workspace.onLayoutReady(() => {
          handleSystem(thisFile);
        });
      } else if (thisFile.extension === "md" && thisFile.path.includes(this.settings.interfaces_root_folder)) {
        console.log("interfaces");
        this.app.workspace.onLayoutReady(() => {
          handleInterface(thisFile);
        });
      } else if (thisFile.extension === "md" && thisFile.path.includes("Requirements") && thisFile.basename !== "Requirements") {
        console.log("handling requirement");
        handleRequirement(thisFile, this.app);
      }
    });
    this.app.workspace.on("file-open", async (file) => {
      if (!file)
        return;
      if (file.extension === "md") {
        const dv = globalHandlers_default.getPlugins().dataview;
        const pages = [...dv.pages('"Requirements"')];
        console.log(pages);
        if (!pages)
          return;
        const pageClass = Object.entries(pages).find(([, page]) => {
          return page.file.path === file.path;
        });
        if (pageClass && pageClass[1].Class.includes("Requirement")) {
          await handleRequirement(file, app);
        }
      }
    });
    const resolvedFiles = [];
    this.app.metadataCache.on("resolved", async () => {
      for (let i = 0; i < resolvedFiles.length; i++) {
        await resolvedFiles[i]();
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
async function handleCanvas(canvasFile, plugin) {
  const app2 = globalHandlers_default.app;
  const canvasFileRaw = await app2.vault.read(canvasFile);
  const canvasJson = JSON.parse(canvasFileRaw);
  if (canvasFile.basename !== "System Diagram")
    return;
  const nodes = document.getElementsByClassName("canvas-node");
  Array.from(nodes).forEach((node) => {
    resolveComponent(node);
  });
  const edges = canvasJson.edges;
  edges.forEach(
    (edge, idx) => {
      if (!edge.label) {
        canvasJson.edges[idx].label = "\u26A0\uFE0F";
      }
    }
  );
  await app2.vault.modify(canvasFile, JSON.stringify(canvasJson));
  const usedEdges = [];
  const newConnections = {};
  const edgesEls = Array.from(
    document.getElementsByClassName("canvas-path-label")
  );
  edges.forEach((edge, idx) => resolveEdge(edge, idx));
  await app2.vault.modify(canvasFile, JSON.stringify(canvasJson));
  const int = await globalHandlers_default.getPlugins().dataview.pages(`"${plugin.settings.interfaces_root_folder}"`);
  int.forEach(async (i) => {
    await globalHandlers_default.getPlugins().frontmatter.postValues(i.file.path, [
      { name: "Connections", payload: { value: "" } }
    ]);
  });
  Object.entries(newConnections).forEach(async ([file, connections]) => {
    const fileCache = app2.metadataCache.getCache(file);
    if (fileCache && fileCache.frontmatter && fileCache.frontmatter.Connections) {
      await globalHandlers_default.getPlugins().frontmatter.postValues(file, [
        {
          name: "Connections",
          payload: {
            value: connections.map((c) => `
 - ${c.trim()}`).join("")
          }
        }
      ]);
    }
  });
  async function resolveComponent(node) {
    var _a2;
    let isGroup = false;
    if (node.classList.contains("canvas-node-group"))
      isGroup = true;
    node.classList.add("canvas-node-subsystem");
    const groupContent = (_a2 = node.childNodes[0]) == null ? void 0 : _a2.childNodes[0];
    const groupLabel = node.childNodes[1];
    const nodeName = isGroup ? groupLabel == null ? void 0 : groupLabel.textContent : groupContent == null ? void 0 : groupContent.textContent;
    if (!nodeName)
      return;
    const nodeFile = app2.metadataCache.getFirstLinkpathDest(nodeName, "");
    if (!nodeFile)
      return;
    if (node.classList.contains("dom-event-registered"))
      return;
    plugin.registerDomEvent(node, "dblclick", () => {
      if (nodeFile && nodeFile.extension === "md") {
        app2.workspace.openLinkText(nodeFile.path, "", true);
      }
    });
    node.classList.add("dom-event-registered");
    let update = false;
    for (let i = 0; i < canvasJson.nodes.length; i++) {
      if (canvasJson.nodes[i].label === nodeName && canvasJson.nodes[i].file !== (nodeFile == null ? void 0 : nodeFile.path)) {
        update = true;
        canvasJson.nodes[i].file = nodeFile == null ? void 0 : nodeFile.path;
        break;
      }
    }
    update && await app2.vault.modify(canvasFile, JSON.stringify(canvasJson));
    if (isGroup) {
      plugin.registerDomEvent(
        groupLabel,
        "focusout",
        () => resolveComponent(node)
      );
    } else {
      plugin.registerDomEvent(
        groupContent,
        "mouseout",
        () => resolveComponent(node)
      );
    }
  }
  async function resolveEdge(edgeJson, index) {
    var _a2, _b, _c, _d, _e;
    const edge = Array.from(edgesEls).find((edge2) => {
      var _a3;
      return edgeJson.label === ((_a3 = edge2.childNodes[0]) == null ? void 0 : _a3.textContent) && !usedEdges.includes(edge2);
    });
    if (!edge)
      return;
    const edgeName = (_a2 = edge.childNodes[0]) == null ? void 0 : _a2.textContent;
    if (!edgeName || edgeName.length <= 3) {
      canvasJson.edges[index].label = "\u26A0\uFE0F";
      return;
    }
    let bestMatch = "";
    Object.entries(app2.vault.fileMap).forEach(([path, file]) => {
      if (path.includes(".md")) {
        if (file.basename.toLowerCase().includes(edgeName == null ? void 0 : edgeName.toLowerCase()) && file.basename.length > bestMatch.length) {
          bestMatch = file.basename;
        }
      }
    });
    const edgeFile = edgeName ? app2.metadataCache.getFirstLinkpathDest(bestMatch, "") : null;
    if (!edgeFile || edgeFile.extension !== "md")
      return;
    if (!edge.classList.contains("dom-event-registered")) {
      plugin.registerDomEvent(edge, "dblclick", () => {
        app2.workspace.openLinkText(edgeFile.path, "", true);
      });
      edge.classList.add("dom-event-registered");
    }
    const fromNode = canvasJson.nodes.find((node) => {
      return node.id === edgeJson.fromNode;
    }).file;
    const toNode = canvasJson.nodes.find((node) => {
      return node.id === edgeJson.toNode;
    }).file;
    const fromFile = app2.metadataCache.getFirstLinkpathDest(fromNode, "");
    const toFile2 = app2.metadataCache.getFirstLinkpathDest(toNode, "");
    const fromConenction = (_c = (_b = app2.metadataCache.getFileCache(fromFile)) == null ? void 0 : _b.frontmatter) == null ? void 0 : _c.ID;
    const toConnection = (_e = (_d = app2.metadataCache.getFileCache(toFile2)) == null ? void 0 : _d.frontmatter) == null ? void 0 : _e.ID;
    if (edgeFile) {
      const edgeFileCache = app2.metadataCache.getCache(edgeFile.path);
      if (edgeFileCache && edgeFileCache.frontmatter && edgeFileCache.frontmatter.Connections) {
        if (!newConnections[edgeFile.path]) {
          newConnections[edgeFile.path] = [];
        }
        newConnections[edgeFile.path].push(
          `${fromConenction} <=> ${toConnection}`
        );
      }
    }
    canvasJson.edges[index].label = edgeFile.basename;
    usedEdges.push(edge);
  }
}
async function handleSystem(file) {
  var _a2, _b, _c, _d;
  if (!file)
    return;
  const { frontmatter } = globalHandlers_default.getPlugins();
  const system = (_b = (_a2 = app.metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b.System;
  const alias = (_d = (_c = app.metadataCache.getFileCache(file)) == null ? void 0 : _c.frontmatter) == null ? void 0 : _d.aliases;
  await frontmatter.postValues(file, [
    {
      name: "ID",
      payload: {
        value: system + "." + (alias[0] ? alias[0].toUpperCase().trim() : file.basename.replace(/[^\w.,\s]/g, "").toUpperCase().trim().replace(/ /g, "_"))
      }
    }
  ]);
  let index = 0;
  async function resolveHeadingComponent(r_file) {
    if (r_file !== file)
      return;
    console.log("resolving heading component", index);
    switch (index) {
      case 0:
        const rtmk = await requirementsTable2(file);
        await insertMarkdownUnderHeading(file, "Requirements", rtmk);
        break;
      case 1:
        const ttmk = await testsTable(file);
        await insertMarkdownUnderHeading(file, "Tests", ttmk);
        break;
      case 2:
        const itmk = await interfacesTable(file);
        await insertMarkdownUnderHeading(file, "Interfaces", itmk);
        break;
      default:
        break;
    }
    index++;
    if (index > 2)
      app.metadataCache.off("resolve", resolveHeadingComponent);
  }
  app.metadataCache.on("resolve", resolveHeadingComponent);
}
async function handleInterface(file) {
  var _a2;
  const { metadataCache, vault } = app;
  const fm = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter;
  if (!fm.Type)
    return;
  if (fm.Type.includes("Electrical")) {
    await addIconToName(file, app, "\u26A1");
  } else {
    await removeIconFromName(file, app, "\u26A1");
  }
  if (fm.Type.includes("Mechanical")) {
    await addIconToName(file, app, "\u{1F6E0}\uFE0F");
  } else {
    await removeIconFromName(file, app, "\u{1F6E0}\uFE0F");
  }
  if (fm.Type.includes("Software")) {
    await addIconToName(file, app, "\u{1F4BB}");
  } else {
    await removeIconFromName(file, app, "\u{1F4BB}");
  }
}
async function handleRequirement(file, app2) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const { metadataCache, vault } = app2;
  const headings = (_b = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.headings) != null ? _b : [];
  let text = await vault.cachedRead(file);
  const dIdx = headings.findIndex(
    ({ heading }) => heading === "Description"
  );
  const hIdx = headings.findIndex(
    ({ heading }) => heading === "Source"
  );
  if (hIdx === -1) {
    text = "";
    await addWarning(file, app2);
  } else {
    text = text.split("\n").slice(
      headings[hIdx].position.start.line + 1,
      (_e = (_d = (_c = headings[hIdx + 1]) == null ? void 0 : _c.position) == null ? void 0 : _d.start) == null ? void 0 : _e.line
    ).join("\n").trim();
    if (text === "") {
      await addWarning(file, app2);
    } else {
      await removeWarning(file, app2);
    }
  }
  const text2 = await vault.cachedRead(file);
  const values = {
    id: file.basename.replace(/[^\w.,\s]/g, "").trim(),
    description: text2.split("\n").slice(
      headings[dIdx].position.start.line + 1,
      (_h = (_g = (_f = headings[dIdx + 1]) == null ? void 0 : _f.position) == null ? void 0 : _g.start) == null ? void 0 : _h.line
    ).join("\n").trim(),
    source: text2.split("\n").slice(
      headings[hIdx].position.start.line + 1,
      (_k = (_j = (_i = headings[hIdx + 1]) == null ? void 0 : _i.position) == null ? void 0 : _j.start) == null ? void 0 : _k.line
    ).join("\n").trim(),
    system: (_n = (_m = (_l = metadataCache.getFileCache(file)) == null ? void 0 : _l.frontmatter) == null ? void 0 : _m.System) != null ? _n : "Unspecified/General"
  };
  addEmbed(values, file).then(async (res) => {
    const data = await file.vault.read(file);
    const result = await compareRequirements(res);
    const { frontmatter } = globalHandlers_default.getPlugins();
    console.log(result);
    if (result == null ? void 0 : result.includes("YES")) {
      const newData = data.replace(
        await getSection(file, "Conflict"),
        ""
      );
      await this.app.vault.modify(file, newData);
      await addError(file, this.app);
      await app2.vault.modify(file, newData + `${result}`);
      frontmatter.postValues(file, [
        {
          name: "Status",
          payload: {
            value: "conflict"
          }
        },
        {
          name: "Conflicting With",
          payload: {
            value: result.substring(
              result.indexOf("[[") + 2,
              result.indexOf("]]")
            )
          }
        }
      ]);
    } else {
      await removeError(file, this.app);
      await this.app.vault.modify(
        file,
        data.replace(await getSection(file, "Conflict"), "")
      );
      frontmatter.postValues(file, [
        {
          name: "Status",
          payload: {
            value: "in-review"
          }
        },
        {
          name: "Conflicting With",
          payload: {
            value: ""
          }
        }
      ]);
    }
  });
  await new Promise((resolve) => setTimeout(resolve, 1e3));
}
var CreateComponentModal = class extends import_obsidian.Modal {
  constructor(app2, settings) {
    super(app2);
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    const app2 = this.app;
    const currentFile = this.app.workspace.getActiveFile();
    contentEl.innerHTML = `
		<h2>Create Component</h2>
		<p>Enter component name</p>
		<input type="text" id="component-name" placeholder="Component name" />
		<p>Select if this is a component</p>
		<input type="checkbox" id="is-component" />
		<br>
		<button id="create-component">Create</button>
		`;
    const button = contentEl.querySelector("#create-component");
    const input = contentEl.querySelector(
      "#component-name"
    );
    const isComponent = contentEl.querySelector(
      "#is-component"
    );
    const isCanvas = (currentFile == null ? void 0 : currentFile.extension) === "canvas";
    async function handleCreate() {
      if (!input.value)
        return;
      const name = input.value;
      if (!currentFile) {
        new import_obsidian.Notice("Active file is not a component");
        return;
      }
      let rootPath = currentFile.path.split(currentFile.name)[0];
      if (isCanvas) {
        rootPath = this.settings.system_design_root_folder;
      }
      const newComponent = await addComponent({
        system: "TWR2",
        path: rootPath,
        fileName: name
      });
      await addToSystemDiagram({
        file: newComponent,
        isComponent: isComponent.checked
      });
      app2.workspace.createLeafBySplit(app2.workspace.getLeaf()).openFile(newComponent);
      this.close();
    }
    button == null ? void 0 : button.addEventListener("click", handleCreate.bind(this));
    contentEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        handleCreate.bind(this)();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText(
      (text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
        this.plugin.settings.mySetting = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Systems design root folder").setDesc("The folder where the systems design files are stored").addText(
      (text) => text.setPlaceholder("Enter the folder path").setValue("11-System_design").onChange(async (value) => {
        this.plugin.settings.system_design_root_folder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Tests root folder").setDesc("The folder where the tests are stored").addText(
      (text) => text.setPlaceholder("Enter the folder path").setValue("05-Test_documentation").onChange(async (value) => {
        this.plugin.settings.test_documentation_root_folder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Interfaces root folder").setDesc("The folder where the interfaces are stored").addText(
      (text) => text.setPlaceholder("Enter the folder path").setValue("12-Interfaces").onChange(async (value) => {
        this.plugin.settings.interfaces_root_folder = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL3J1bnRpbWUudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9BcHByb3hpbWF0ZWRDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9Db2xsZWN0aW9uTWV0YS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0NyZWF0ZUNvbGxlY3Rpb25SZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvQ3JlYXRlUmVxdWVzdEluZGV4Q29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvQ3JlYXRlUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0RlbGV0ZVJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9EZXNjcmliZUluZGV4U3RhdHNSZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvTmFtZXNwYWNlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0Rlc2NyaWJlSW5kZXhTdGF0c1Jlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvU3BhcnNlVmFsdWVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvVmVjdG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvRmV0Y2hSZXNwb25zZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0huc3dDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGFEYXRhYmFzZUluZGV4Q29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvSW5kZXhNZXRhRGF0YWJhc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGFTdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGEudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9QYXRjaFJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9Qcm90b2J1ZkFueS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Byb3RvYnVmTnVsbFZhbHVlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvUXVlcnlWZWN0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9RdWVyeVJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9TY29yZWRWZWN0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9TaW5nbGVRdWVyeVJlc3VsdHMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9RdWVyeVJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvUnBjU3RhdHVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvVXBkYXRlUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Vwc2VydFJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9VcHNlcnRSZXNwb25zZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9hcGlzL0luZGV4T3BlcmF0aW9uc0FwaS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvYXBpcy9WZWN0b3JPcGVyYXRpb25zQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9hcGlzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvYmFzZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvY29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy9odHRwLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy9yZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy92YWxpZGF0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy91dGlscy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvaGFuZGxpbmcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZXJyb3JzL3Vwc2VydC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2NvZGVnZW4vY29kZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9zY29wZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvbmFtZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9ycy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcnVsZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb2RlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEudHMiLCAibm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3JlZl9lcnJvci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9kYXRhLmpzb24iLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy91cm4tdXVpZC50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3Vybi50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL21haWx0by50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3dzcy50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3dzLnRzIiwgIm5vZGVfbW9kdWxlcy91cmktanMvc3JjL3NjaGVtZXMvaHR0cHMudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy9odHRwLnRzIiwgIm5vZGVfbW9kdWxlcy91cmktanMvc3JjL3VyaS50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5lczYuanMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvcmVnZXhwcy1pcmkudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvcmVnZXhwcy11cmkudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3J1bnRpbWUvdXJpLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29yZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2lkLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2NvcmUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9ydW50aW1lL3VjczJsZW5ndGgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdFByb3BlcnRpZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9ydW50aW1lL2VxdWFsLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2VudW0udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9jb250YWlucy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsUHJvcGVydGllcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL25vdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hbGxPZi50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9tZXRhZGF0YS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kcmFmdDcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvbiIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy91dGlscy9lbnZpcm9ubWVudC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92YWxpZGF0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC91dGlscy50cyIsICJub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvdHlwZWJveC5qcyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2NvbnRyb2wvY29uZmlndXJlSW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvZGVidWdMb2cudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvcXVlcnlQYXJhbXNTdHJpbmdpZnkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9kaXN0L3ZlcnNpb24uanNvbiIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy91dGlscy91c2VyLWFnZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9jcmVhdGVJbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL2RlbGV0ZUluZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2NvbnRyb2wvZGVzY3JpYmVJbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL2xpc3RJbmRleGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2NvbnRyb2wvY3JlYXRlQ29sbGVjdGlvbi50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL2RlbGV0ZUNvbGxlY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9kZXNjcmliZUNvbGxlY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9saXN0Q29sbGVjdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9kYXRhL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2RhdGEvdXBzZXJ0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2RhdGEvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS91cGRhdGUudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9xdWVyeS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9kYXRhL2RlbGV0ZU9uZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9kYXRhL2RlbGV0ZU1hbnkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9kZWxldGVBbGwudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9kZXNjcmliZUluZGV4U3RhdHMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9wcm9qZWN0SWRTaW5nbGV0b24udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS92ZWN0b3JPcGVyYXRpb25zUHJvdmlkZXIudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvcnVudGltZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0FwcHJveGltYXRlZENvbmZpZy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0NvbGxlY3Rpb25NZXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvQ3JlYXRlQ29sbGVjdGlvblJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9DcmVhdGVSZXF1ZXN0SW5kZXhDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9DcmVhdGVSZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvRGVsZXRlUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0Rlc2NyaWJlSW5kZXhTdGF0c1JlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9OYW1lc3BhY2VTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvRGVzY3JpYmVJbmRleFN0YXRzUmVzcG9uc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9TcGFyc2VWYWx1ZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9WZWN0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9GZXRjaFJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvSG5zd0NvbmZpZy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0luZGV4TWV0YURhdGFiYXNlSW5kZXhDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGFEYXRhYmFzZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0luZGV4TWV0YVN0YXR1cy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0luZGV4TWV0YS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1BhdGNoUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Byb3RvYnVmQW55LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvUHJvdG9idWZOdWxsVmFsdWUudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9RdWVyeVZlY3Rvci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1F1ZXJ5UmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Njb3JlZFZlY3Rvci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1NpbmdsZVF1ZXJ5UmVzdWx0cy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1F1ZXJ5UmVzcG9uc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9ScGNTdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9VcGRhdGVSZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvVXBzZXJ0UmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Vwc2VydFJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL2FwaXMvSW5kZXhPcGVyYXRpb25zQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9hcGlzL1ZlY3Rvck9wZXJhdGlvbnNBcGkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL2FwaXMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvaW5kZXgudHMiLCAibWFpbi50cyIsICJ1dGlscy9nbG9iYWxIYW5kbGVycy50cyIsICJ1dGlscy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy92ZXJzaW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2Vycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvcmVnaXN0cnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vdHJhbnNjcmlwdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zbGF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vYXVkaW8udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY29tcGxldGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VtYmVkZGluZ3MudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VkaXRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5lcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbmRleC50cyIsICJ1dGlscy9yZXF1aXJlbWVudHMudHMiLCAidXRpbHMvdGVtcGxhdGVzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJleHBvcnQgYWJzdHJhY3QgY2xhc3MgX0NvZGVPck5hbWUge1xuICBhYnN0cmFjdCByZWFkb25seSBzdHI6IHN0cmluZ1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG4gIGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZ1xuICBhYnN0cmFjdCBlbXB0eVN0cigpOiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBJREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2lcblxuZXhwb3J0IGNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gIHJlYWRvbmx5IHN0cjogc3RyaW5nXG4gIGNvbnN0cnVjdG9yKHM6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICBpZiAoIUlERU5USUZJRVIudGVzdChzKSkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKVxuICAgIHRoaXMuc3RyID0gc1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJcbiAgfVxuXG4gIGVtcHR5U3RyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHtbdGhpcy5zdHJdOiAxfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgcmVhZG9ubHkgX2l0ZW1zOiByZWFkb25seSBDb2RlSXRlbVtdXG4gIHByaXZhdGUgX3N0cj86IHN0cmluZ1xuICBwcml2YXRlIF9uYW1lcz86IFVzZWROYW1lc1xuXG4gIGNvbnN0cnVjdG9yKGNvZGU6IHN0cmluZyB8IHJlYWRvbmx5IENvZGVJdGVtW10pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGVcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RyXG4gIH1cblxuICBlbXB0eVN0cigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdXG4gICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInXG4gIH1cblxuICBnZXQgc3RyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLl9zdHIgPz89IHRoaXMuX2l0ZW1zLnJlZHVjZSgoczogc3RyaW5nLCBjOiBDb2RlSXRlbSkgPT4gYCR7c30ke2N9YCwgXCJcIikpXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gKHRoaXMuX25hbWVzID8/PSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIGMpID0+IHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSkgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDFcbiAgICAgIHJldHVybiBuYW1lc1xuICAgIH0sIHt9KSlcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDb2RlSXRlbSA9IE5hbWUgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG5leHBvcnQgdHlwZSBVc2VkTmFtZXMgPSBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCB0eXBlIENvZGUgPSBfQ29kZSB8IE5hbWVcblxuZXhwb3J0IHR5cGUgU2FmZUV4cHIgPSBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxcblxuZXhwb3J0IGNvbnN0IG5pbCA9IG5ldyBfQ29kZShcIlwiKVxuXG50eXBlIENvZGVBcmcgPSBTYWZlRXhwciB8IHN0cmluZyB8IHVuZGVmaW5lZFxuXG5leHBvcnQgZnVuY3Rpb24gXyhzdHJzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogQ29kZUFyZ1tdKTogX0NvZGUge1xuICBjb25zdCBjb2RlOiBDb2RlSXRlbVtdID0gW3N0cnNbMF1dXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKVxuICAgIGNvZGUucHVzaChzdHJzWysraV0pXG4gIH1cbiAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKVxufVxuXG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyKHN0cnM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiAoQ29kZUFyZyB8IHN0cmluZ1tdKVtdKTogX0NvZGUge1xuICBjb25zdCBleHByOiBDb2RlSXRlbVtdID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgZXhwci5wdXNoKHBsdXMpXG4gICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKVxuICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpXG4gIH1cbiAgb3B0aW1pemUoZXhwcilcbiAgcmV0dXJuIG5ldyBfQ29kZShleHByKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlOiBDb2RlSXRlbVtdLCBhcmc6IENvZGVBcmcgfCBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKVxuICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKSBjb2RlLnB1c2goYXJnKVxuICBlbHNlIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKVxufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZShleHByOiBDb2RlSXRlbVtdKTogdm9pZCB7XG4gIGxldCBpID0gMVxuICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pXG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcylcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGV4cHJbaSsrXSA9IFwiK1wiXG4gICAgfVxuICAgIGkrK1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGE6IENvZGVJdGVtLCBiOiBDb2RlSXRlbSk6IENvZGVJdGVtIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGIgPT09ICdcIlwiJykgcmV0dXJuIGFcbiAgaWYgKGEgPT09ICdcIlwiJykgcmV0dXJuIGJcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIikgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImBcbiAgICBpZiAoYlswXSA9PT0gJ1wiJykgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWBcbiAgcmV0dXJuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJDb25jYXQoYzE6IENvZGUsIGMyOiBDb2RlKTogQ29kZSB7XG4gIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHJgJHtjMX0ke2MyfWBcbn1cblxuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHg/OiBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsKTogU2FmZUV4cHIgfCBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgPyB4XG4gICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh4OiB1bmtub3duKTogQ29kZSB7XG4gIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeDogdW5rbm93bik6IHN0cmluZyB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleTogQ29kZSB8IHN0cmluZyB8IG51bWJlcik6IENvZGUge1xuICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIElERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfYFske2tleX1dYFxufVxuXG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXNtRXhwb3J0TmFtZShrZXk6IENvZGUgfCBzdHJpbmcgfCBudW1iZXIpOiBDb2RlIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBJREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4cENvZGUocng6IFJlZ0V4cCk6IENvZGUge1xuICByZXR1cm4gbmV3IF9Db2RlKHJ4LnRvU3RyaW5nKCkpXG59XG4iLCAiaW1wb3J0IHtfLCBuaWwsIENvZGUsIE5hbWV9IGZyb20gXCIuL2NvZGVcIlxuXG5pbnRlcmZhY2UgTmFtZUdyb3VwIHtcbiAgcHJlZml4OiBzdHJpbmdcbiAgaW5kZXg6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVWYWx1ZSB7XG4gIHJlZjogVmFsdWVSZWZlcmVuY2UgLy8gdGhpcyBpcyB0aGUgcmVmZXJlbmNlIHRvIGFueSB2YWx1ZSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBmcm9tIGdlbmVyYXRlZCBjb2RlIHZpYSBgZ2xvYmFsc2AgdmFyIGluIHRoZSBjbG9zdXJlXG4gIGtleT86IHVua25vd24gLy8gYW55IGtleSB0byBpZGVudGlmeSBhIGdsb2JhbCB0byBhdm9pZCBkdXBsaWNhdGVzLCBpZiBub3QgcGFzc2VkIHJlZiBpcyB1c2VkXG4gIGNvZGU/OiBDb2RlIC8vIHRoaXMgaXMgdGhlIGNvZGUgY3JlYXRpbmcgdGhlIHZhbHVlIG5lZWRlZCBmb3Igc3RhbmRhbG9uZSBjb2RlIHdpdF9vdXQgY2xvc3VyZSAtIGNhbiBiZSBhIHByaW1pdGl2ZSB2YWx1ZSwgZnVuY3Rpb24gb3IgaW1wb3J0IChgcmVxdWlyZWApXG59XG5cbmV4cG9ydCB0eXBlIFZhbHVlUmVmZXJlbmNlID0gdW5rbm93biAvLyBwb3NzaWJseSBtYWtlIENvZGVHZW4gcGFyYW1ldGVyaXplZCB0eXBlIG9uIHRoaXMgdHlwZVxuXG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSB2YWx1ZT86IE5hbWVWYWx1ZVxuICBjb25zdHJ1Y3RvcihuYW1lOiBWYWx1ZVNjb3BlTmFtZSkge1xuICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApXG4gICAgdGhpcy52YWx1ZSA9IG5hbWUudmFsdWVcbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NvcGVPcHRpb25zIHtcbiAgcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwYXJlbnQ/OiBTY29wZVxufVxuXG5pbnRlcmZhY2UgVmFsdWVTY29wZU9wdGlvbnMgZXh0ZW5kcyBTY29wZU9wdGlvbnMge1xuICBzY29wZTogU2NvcGVTdG9yZVxuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBTY29wZVN0b3JlID0gUmVjb3JkPHN0cmluZywgVmFsdWVSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZD5cblxudHlwZSBTY29wZVZhbHVlcyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogTWFwPHVua25vd24sIFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgdHlwZSBTY29wZVZhbHVlU2V0cyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogU2V0PFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgZW51bSBVc2VkVmFsdWVTdGF0ZSB7XG4gIFN0YXJ0ZWQsXG4gIENvbXBsZXRlZCxcbn1cblxuZXhwb3J0IHR5cGUgVXNlZFNjb3BlVmFsdWVzID0ge1xuICBbUHJlZml4IGluIHN0cmluZ10/OiBNYXA8VmFsdWVTY29wZU5hbWUsIFVzZWRWYWx1ZVN0YXRlIHwgdW5kZWZpbmVkPlxufVxuXG5leHBvcnQgY29uc3QgdmFyS2luZHMgPSB7XG4gIGNvbnN0OiBuZXcgTmFtZShcImNvbnN0XCIpLFxuICBsZXQ6IG5ldyBOYW1lKFwibGV0XCIpLFxuICB2YXI6IG5ldyBOYW1lKFwidmFyXCIpLFxufVxuXG5leHBvcnQgY2xhc3MgU2NvcGUge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX25hbWVzOiB7W1ByZWZpeCBpbiBzdHJpbmddPzogTmFtZUdyb3VwfSA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3BhcmVudD86IFNjb3BlXG5cbiAgY29uc3RydWN0b3Ioe3ByZWZpeGVzLCBwYXJlbnR9OiBTY29wZU9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXNcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIHRvTmFtZShuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogTmFtZSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV3TmFtZShwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpXG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YFxuICB9XG5cbiAgcHJpdmF0ZSBfbmFtZUdyb3VwKHByZWZpeDogc3RyaW5nKTogTmFtZUdyb3VwIHtcbiAgICBpZiAodGhpcy5fcGFyZW50Py5fcHJlZml4ZXM/LmhhcyhwcmVmaXgpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7cHJlZml4LCBpbmRleDogMH0pXG4gIH1cbn1cblxuaW50ZXJmYWNlIFNjb3BlUGF0aCB7XG4gIHByb3BlcnR5OiBzdHJpbmdcbiAgaXRlbUluZGV4OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgTmFtZSB7XG4gIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nXG4gIHZhbHVlPzogTmFtZVZhbHVlXG4gIHNjb3BlUGF0aD86IENvZGVcblxuICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgbmFtZVN0cjogc3RyaW5nKSB7XG4gICAgc3VwZXIobmFtZVN0cilcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICB9XG5cbiAgc2V0VmFsdWUodmFsdWU6IE5hbWVWYWx1ZSwge3Byb3BlcnR5LCBpdGVtSW5kZXh9OiBTY29wZVBhdGgpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLnNjb3BlUGF0aCA9IF9gLiR7bmV3IE5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYFxuICB9XG59XG5cbmludGVyZmFjZSBWU09wdGlvbnMgZXh0ZW5kcyBWYWx1ZVNjb3BlT3B0aW9ucyB7XG4gIF9uOiBDb2RlXG59XG5cbmNvbnN0IGxpbmUgPSBfYFxcbmBcblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlcyA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfc2NvcGU6IFNjb3BlU3RvcmVcbiAgcmVhZG9ubHkgb3B0czogVlNPcHRpb25zXG5cbiAgY29uc3RydWN0b3Iob3B0czogVmFsdWVTY29wZU9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZVxuICAgIHRoaXMub3B0cyA9IHsuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBuaWx9XG4gIH1cblxuICBnZXQoKTogU2NvcGVTdG9yZSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njb3BlXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogVmFsdWVTY29wZU5hbWUge1xuICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpXG4gIH1cblxuICB2YWx1ZShuYW1lT3JQcmVmaXg6IFZhbHVlU2NvcGVOYW1lIHwgc3RyaW5nLCB2YWx1ZTogTmFtZVZhbHVlKTogVmFsdWVTY29wZU5hbWUge1xuICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpXG4gICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCkgYXMgVmFsdWVTY29wZU5hbWVcbiAgICBjb25zdCB7cHJlZml4fSA9IG5hbWVcbiAgICBjb25zdCB2YWx1ZUtleSA9IHZhbHVlLmtleSA/PyB2YWx1ZS5yZWZcbiAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XVxuICAgIGlmICh2cykge1xuICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpXG4gICAgICBpZiAoX25hbWUpIHJldHVybiBfbmFtZVxuICAgIH0gZWxzZSB7XG4gICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpXG4gICAgfVxuICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSlcblxuICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pXG4gICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGhcbiAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWZcbiAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7cHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4fSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0VmFsdWUocHJlZml4OiBzdHJpbmcsIGtleU9yUmVmOiB1bmtub3duKTogVmFsdWVTY29wZU5hbWUgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF1cbiAgICBpZiAoIXZzKSByZXR1cm5cbiAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKVxuICB9XG5cbiAgc2NvcGVSZWZzKHNjb3BlTmFtZTogTmFtZSwgdmFsdWVzOiBTY29wZVZhbHVlcyB8IFNjb3BlVmFsdWVTZXRzID0gdGhpcy5fdmFsdWVzKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lOiBWYWx1ZVNjb3BlTmFtZSkgPT4ge1xuICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKVxuICAgICAgcmV0dXJuIF9gJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gXG4gICAgfSlcbiAgfVxuXG4gIHNjb3BlQ29kZShcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMgPSB0aGlzLl92YWx1ZXMsXG4gICAgdXNlZFZhbHVlcz86IFVzZWRTY29wZVZhbHVlcyxcbiAgICBnZXRDb2RlPzogKG46IFZhbHVlU2NvcGVOYW1lKSA9PiBDb2RlIHwgdW5kZWZpbmVkXG4gICk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXMoXG4gICAgICB2YWx1ZXMsXG4gICAgICAobmFtZTogVmFsdWVTY29wZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApXG4gICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGVcbiAgICAgIH0sXG4gICAgICB1c2VkVmFsdWVzLFxuICAgICAgZ2V0Q29kZVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3JlZHVjZVZhbHVlcyhcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMsXG4gICAgdmFsdWVDb2RlOiAobjogVmFsdWVTY29wZU5hbWUpID0+IENvZGUgfCB1bmRlZmluZWQsXG4gICAgdXNlZFZhbHVlczogVXNlZFNjb3BlVmFsdWVzID0ge30sXG4gICAgZ2V0Q29kZT86IChuOiBWYWx1ZVNjb3BlTmFtZSkgPT4gQ29kZSB8IHVuZGVmaW5lZFxuICApOiBDb2RlIHtcbiAgICBsZXQgY29kZTogQ29kZSA9IG5pbFxuICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XVxuICAgICAgaWYgKCF2cykgY29udGludWVcbiAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSlcbiAgICAgIHZzLmZvckVhY2goKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSkgcmV0dXJuXG4gICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpXG4gICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmNvbnN0XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSBpZiAoKGMgPSBnZXRDb2RlPy4obmFtZSkpKSB7XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSlcbiAgICAgICAgfVxuICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1Njb3BlVmFsdWVTZXRzLCBOYW1lVmFsdWUsIFZhbHVlU2NvcGUsIFZhbHVlU2NvcGVOYW1lfSBmcm9tIFwiLi9zY29wZVwiXG5pbXBvcnQge18sIG5pbCwgX0NvZGUsIENvZGUsIE5hbWUsIFVzZWROYW1lcywgQ29kZUl0ZW0sIGFkZENvZGVBcmcsIF9Db2RlT3JOYW1lfSBmcm9tIFwiLi9jb2RlXCJcbmltcG9ydCB7U2NvcGUsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbmV4cG9ydCB7Xywgc3RyLCBzdHJDb25jYXQsIG5pbCwgZ2V0UHJvcGVydHksIHN0cmluZ2lmeSwgcmVnZXhwQ29kZSwgTmFtZSwgQ29kZX0gZnJvbSBcIi4vY29kZVwiXG5leHBvcnQge1Njb3BlLCBTY29wZVN0b3JlLCBWYWx1ZVNjb3BlLCBWYWx1ZVNjb3BlTmFtZSwgU2NvcGVWYWx1ZVNldHMsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbi8vIHR5cGUgZm9yIGV4cHJlc3Npb25zIHRoYXQgY2FuIGJlIHNhZmVseSBpbnNlcnRlZCBpbiBjb2RlIHdpdGhvdXQgcXVvdGVzXG5leHBvcnQgdHlwZSBTYWZlRXhwciA9IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG4vLyB0eXBlIHRoYXQgaXMgZWl0aGVyIENvZGUgb2YgZnVuY3Rpb24gdGhhdCBhZGRzIGNvZGUgdG8gQ29kZUdlbiBpbnN0YW5jZSB1c2luZyBpdHMgbWV0aG9kc1xuZXhwb3J0IHR5cGUgQmxvY2sgPSBDb2RlIHwgKCgpID0+IHZvaWQpXG5cbmV4cG9ydCBjb25zdCBvcGVyYXRvcnMgPSB7XG4gIEdUOiBuZXcgX0NvZGUoXCI+XCIpLFxuICBHVEU6IG5ldyBfQ29kZShcIj49XCIpLFxuICBMVDogbmV3IF9Db2RlKFwiPFwiKSxcbiAgTFRFOiBuZXcgX0NvZGUoXCI8PVwiKSxcbiAgRVE6IG5ldyBfQ29kZShcIj09PVwiKSxcbiAgTkVROiBuZXcgX0NvZGUoXCIhPT1cIiksXG4gIE5PVDogbmV3IF9Db2RlKFwiIVwiKSxcbiAgT1I6IG5ldyBfQ29kZShcInx8XCIpLFxuICBBTkQ6IG5ldyBfQ29kZShcIiYmXCIpLFxuICBBREQ6IG5ldyBfQ29kZShcIitcIiksXG59XG5cbmFic3RyYWN0IGNsYXNzIE5vZGUge1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKF9uYW1lczogVXNlZE5hbWVzLCBfY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIDFcbiAgLy8gfVxufVxuXG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLCBwcml2YXRlIHJlYWRvbmx5IG5hbWU6IE5hbWUsIHByaXZhdGUgcmhzPzogU2FmZUV4cHIpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe2VzNSwgX259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyB2YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmRcbiAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWBcbiAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfblxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pIHJldHVyblxuICAgIGlmICh0aGlzLnJocykgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fVxuICB9XG59XG5cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBsaHM6IENvZGUsIHB1YmxpYyByaHM6IFNhZmVFeHByLCBwcml2YXRlIHJlYWRvbmx5IHNpZGVFZmZlY3RzPzogYm9vbGVhbikge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBOYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKSByZXR1cm5cbiAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIE5hbWUgPyB7fSA6IHsuLi50aGlzLmxocy5uYW1lc31cbiAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocylcbiAgfVxufVxuXG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gIGNvbnN0cnVjdG9yKGxoczogQ29kZSwgcHJpdmF0ZSByZWFkb25seSBvcDogQ29kZSwgcmhzOiBTYWZlRXhwciwgc2lkZUVmZmVjdHM/OiBib29sZWFuKSB7XG4gICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX25cbiAgfVxufVxuXG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICByZWFkb25seSBuYW1lczogVXNlZE5hbWVzID0ge31cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbGFiZWw6IE5hbWUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uXG4gIH1cbn1cblxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgcmVhZG9ubHkgbmFtZXM6IFVzZWROYW1lcyA9IHt9XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGxhYmVsPzogQ29kZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiXG4gICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfblxuICB9XG59XG5cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGVycm9yOiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfblxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXNcbiAgfVxufVxuXG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29kZTogU2FmZUV4cHIpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMge1xuICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBfQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9XG4gIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBub2RlczogQ2hpbGROb2RlW10gPSBbXSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKVxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtub2Rlc30gPSB0aGlzXG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSkgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pXG4gICAgICBlbHNlIGlmIChuKSBub2Rlc1tpXSA9IG5cbiAgICAgIGVsc2Ugbm9kZXMuc3BsaWNlKGksIDEpXG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtub2Rlc30gPSB0aGlzXG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXVxuICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgY29udGludWVcbiAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpXG4gICAgICBub2Rlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGMsIG4pID0+IGMgKyBuLmNvdW50LCAxKVxuICAvLyB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uXG4gIH1cbn1cblxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge31cblxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJlbHNlXCJcbn1cblxuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiaWZcIlxuICBlbHNlPzogSWYgfCBFbHNlXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbiwgbm9kZXM/OiBDaGlsZE5vZGVbXSkge1xuICAgIHN1cGVyKG5vZGVzKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmVsc2UpIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKVxuICAgIHJldHVybiBjb2RlXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IElmIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKVxuICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvblxuICAgIGlmIChjb25kID09PSB0cnVlKSByZXR1cm4gdGhpcy5ub2RlcyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgIGxldCBlID0gdGhpcy5lbHNlXG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IChucyBhcyBFbHNlIHwgdW5kZWZpbmVkKVxuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKSByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXNcbiAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCkgcmV0dXJuIHRoaXNcbiAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKVxuICAgIH1cbiAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICB0aGlzLmVsc2UgPSB0aGlzLmVsc2U/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpIHJldHVyblxuICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzXG4gICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbilcbiAgICBpZiAodGhpcy5lbHNlKSBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKVxuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHN1cGVyLmNvdW50ICsgKHRoaXMuZWxzZT8uY291bnQgfHwgMClcbiAgLy8gfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiZm9yXCJcbn1cblxuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlcmF0aW9uOiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgcmV0dXJuXG4gICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpXG4gIH1cbn1cblxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhcktpbmQ6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnJvbTogU2FmZUV4cHIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0bzogU2FmZUV4cHJcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kXG4gICAgY29uc3Qge25hbWUsIGZyb20sIHRvfSA9IHRoaXNcbiAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pXG4gICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50bylcbiAgfVxufVxuXG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb29wOiBcIm9mXCIgfCBcImluXCIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogTmFtZSxcbiAgICBwcml2YXRlIGl0ZXJhYmxlOiBDb2RlXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgcmV0dXJuXG4gICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpXG4gIH1cbn1cblxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmdW5jXCJcbiAgY29uc3RydWN0b3IocHVibGljIG5hbWU6IE5hbWUsIHB1YmxpYyBhcmdzOiBDb2RlLCBwdWJsaWMgYXN5bmM/OiBib29sZWFuKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiXG4gICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcInJldHVyblwiXG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgY2F0Y2g/OiBDYXRjaFxuICBmaW5hbGx5PzogRmluYWxseVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmNhdGNoKSBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuZmluYWxseSkgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpXG4gICAgcmV0dXJuIGNvZGVcbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB7XG4gICAgc3VwZXIub3B0aW1pemVOb2RlcygpXG4gICAgdGhpcy5jYXRjaD8ub3B0aW1pemVOb2RlcygpIGFzIENhdGNoIHwgdW5kZWZpbmVkXG4gICAgdGhpcy5maW5hbGx5Py5vcHRpbWl6ZU5vZGVzKCkgYXMgRmluYWxseSB8IHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB7XG4gICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIHRoaXMuY2F0Y2g/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICB0aGlzLmZpbmFsbHk/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lc1xuICAgIGlmICh0aGlzLmNhdGNoKSBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcylcbiAgICBpZiAodGhpcy5maW5hbGx5KSBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKVxuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHN1cGVyLmNvdW50ICsgKHRoaXMuY2F0Y2g/LmNvdW50IHx8IDApICsgKHRoaXMuZmluYWxseT8uY291bnQgfHwgMClcbiAgLy8gfVxufVxuXG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJjYXRjaFwiXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGVycm9yOiBOYW1lKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImZpbmFsbHlcIlxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG50eXBlIFN0YXJ0QmxvY2tOb2RlID0gSWYgfCBGb3IgfCBGdW5jIHwgUmV0dXJuIHwgVHJ5XG5cbnR5cGUgTGVhZk5vZGUgPSBEZWYgfCBBc3NpZ24gfCBMYWJlbCB8IEJyZWFrIHwgVGhyb3cgfCBBbnlDb2RlXG5cbnR5cGUgQ2hpbGROb2RlID0gU3RhcnRCbG9ja05vZGUgfCBMZWFmTm9kZVxuXG50eXBlIEVuZEJsb2NrTm9kZVR5cGUgPVxuICB8IHR5cGVvZiBJZlxuICB8IHR5cGVvZiBFbHNlXG4gIHwgdHlwZW9mIEZvclxuICB8IHR5cGVvZiBGdW5jXG4gIHwgdHlwZW9mIFJldHVyblxuICB8IHR5cGVvZiBDYXRjaFxuICB8IHR5cGVvZiBGaW5hbGx5XG5cbnR5cGUgQ29uc3RhbnRzID0gUmVjb3JkPHN0cmluZywgU2FmZUV4cHIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUdlbk9wdGlvbnMge1xuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgQ0dPcHRpb25zIGV4dGVuZHMgQ29kZUdlbk9wdGlvbnMge1xuICBfbjogXCJcXG5cIiB8IFwiXCJcbn1cblxuZXhwb3J0IGNsYXNzIENvZGVHZW4ge1xuICByZWFkb25seSBfc2NvcGU6IFNjb3BlXG4gIHJlYWRvbmx5IF9leHRTY29wZTogVmFsdWVTY29wZVxuICByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlU2V0cyA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX25vZGVzOiBQYXJlbnROb2RlW11cbiAgcHJpdmF0ZSByZWFkb25seSBfYmxvY2tTdGFydHM6IG51bWJlcltdID0gW11cbiAgcHJpdmF0ZSByZWFkb25seSBfY29uc3RhbnRzOiBDb25zdGFudHMgPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG9wdHM6IENHT3B0aW9uc1xuXG4gIGNvbnN0cnVjdG9yKGV4dFNjb3BlOiBWYWx1ZVNjb3BlLCBvcHRzOiBDb2RlR2VuT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRzID0gey4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCJ9XG4gICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZVxuICAgIHRoaXMuX3Njb3BlID0gbmV3IFNjb3BlKHtwYXJlbnQ6IGV4dFNjb3BlfSlcbiAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXVxuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKVxuICB9XG5cbiAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgbmFtZShwcmVmaXg6IHN0cmluZyk6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeClcbiAgfVxuXG4gIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICBzY29wZU5hbWUocHJlZml4OiBzdHJpbmcpOiBWYWx1ZVNjb3BlTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KVxuICB9XG5cbiAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lOiBWYWx1ZVNjb3BlTmFtZSB8IHN0cmluZywgdmFsdWU6IE5hbWVWYWx1ZSk6IE5hbWUge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKVxuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSlcbiAgICB2cy5hZGQobmFtZSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0U2NvcGVWYWx1ZShwcmVmaXg6IHN0cmluZywga2V5T3JSZWY6IHVua25vd24pOiBWYWx1ZVNjb3BlTmFtZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpXG4gIH1cblxuICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICBzY29wZVJlZnMoc2NvcGVOYW1lOiBOYW1lKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcylcbiAgfVxuXG4gIHNjb3BlQ29kZSgpOiBDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcylcbiAgfVxuXG4gIHByaXZhdGUgX2RlZihcbiAgICB2YXJLaW5kOiBOYW1lLFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICByaHM/OiBTYWZlRXhwcixcbiAgICBjb25zdGFudD86IGJvb2xlYW5cbiAgKTogTmFtZSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KSB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzXG4gICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgY29uc3QobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLCByaHM6IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gIGxldChuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsIHJocz86IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgdmFyKG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZywgcmhzPzogU2FmZUV4cHIsIF9jb25zdGFudD86IGJvb2xlYW4pOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmKHZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGFzc2lnbm1lbnQgY29kZVxuICBhc3NpZ24obGhzOiBDb2RlLCByaHM6IFNhZmVFeHByLCBzaWRlRWZmZWN0cz86IGJvb2xlYW4pOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKVxuICB9XG5cbiAgLy8gYCs9YCBjb2RlXG4gIGFkZChsaHM6IENvZGUsIHJoczogU2FmZUV4cHIpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgb3BlcmF0b3JzLkFERCwgcmhzKSlcbiAgfVxuXG4gIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgY29kZShjOiBCbG9jayB8IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIikgYygpXG4gICAgZWxzZSBpZiAoYyAhPT0gbmlsKSB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICBvYmplY3QoLi4ua2V5VmFsdWVzOiBbTmFtZSB8IHN0cmluZywgU2FmZUV4cHIgfCBzdHJpbmddW10pOiBfQ29kZSB7XG4gICAgY29uc3QgY29kZTogQ29kZUl0ZW1bXSA9IFtcIntcIl1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpIGNvZGUucHVzaChcIixcIilcbiAgICAgIGNvZGUucHVzaChrZXkpXG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgIGNvZGUucHVzaChcIjpcIilcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSlcbiAgfVxuXG4gIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgaWYoY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbiwgdGhlbkJvZHk/OiBCbG9jaywgZWxzZUJvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSlcblxuICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKVxuICAgIH0gZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKVxuICAgIH0gZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gIGVsc2VJZihjb25kaXRpb246IENvZGUgfCBib29sZWFuKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKVxuICB9XG5cbiAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICBlbHNlKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKVxuICB9XG5cbiAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gIGVuZElmKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpXG4gIH1cblxuICBwcml2YXRlIF9mb3Iobm9kZTogRm9yLCBmb3JCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICBpZiAoZm9yQm9keSkgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICBmb3IoaXRlcmF0aW9uOiBDb2RlLCBmb3JCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpXG4gIH1cblxuICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gIGZvclJhbmdlKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBmcm9tOiBTYWZlRXhwcixcbiAgICB0bzogU2FmZUV4cHIsXG4gICAgZm9yQm9keTogKGluZGV4OiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB0aGlzLm9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdmFyS2luZHMubGV0XG4gICk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSlcbiAgfVxuXG4gIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICBmb3JPZihcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgaXRlcmFibGU6IENvZGUsXG4gICAgZm9yQm9keTogKGl0ZW06IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHZhcktpbmRzLmNvbnN0XG4gICk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIE5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSlcbiAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgX2Ake2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgdGhpcy52YXIobmFtZSwgX2Ake2Fycn1bJHtpfV1gKVxuICAgICAgICBmb3JCb2R5KG5hbWUpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKVxuICB9XG5cbiAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gIGZvckluKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBvYmo6IENvZGUsXG4gICAgZm9yQm9keTogKGl0ZW06IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHRoaXMub3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB2YXJLaW5kcy5jb25zdFxuICApOiBDb2RlR2VuIHtcbiAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgX2BPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSlcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpXG4gIH1cblxuICAvLyBlbmQgYGZvcmAgbG9vcFxuICBlbmRGb3IoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpXG4gIH1cblxuICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICBsYWJlbChsYWJlbDogTmFtZSk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKVxuICB9XG5cbiAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgYnJlYWsobGFiZWw/OiBDb2RlKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpXG4gIH1cblxuICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgcmV0dXJuKHZhbHVlOiBCbG9jayB8IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKVxuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIHRoaXMuY29kZSh2YWx1ZSlcbiAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pXG4gIH1cblxuICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgdHJ5KHRyeUJvZHk6IEJsb2NrLCBjYXRjaENvZGU/OiAoZTogTmFtZSkgPT4gdm9pZCwgZmluYWxseUNvZGU/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSkgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKVxuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIHRoaXMuY29kZSh0cnlCb2R5KVxuICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKVxuICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKVxuICAgICAgY2F0Y2hDb2RlKGVycm9yKVxuICAgIH1cbiAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKVxuICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KVxuICB9XG5cbiAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgdGhyb3coZXJyb3I6IENvZGUpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSlcbiAgfVxuXG4gIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gIGJsb2NrKGJvZHk/OiBCbG9jaywgbm9kZUNvdW50PzogbnVtYmVyKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpXG4gICAgaWYgKGJvZHkpIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICBlbmRCbG9jayhub2RlQ291bnQ/OiBudW1iZXIpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKVxuICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpXG4gICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlblxuICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYClcbiAgICB9XG4gICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gIGZ1bmMobmFtZTogTmFtZSwgYXJnczogQ29kZSA9IG5pbCwgYXN5bmM/OiBib29sZWFuLCBmdW5jQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSlcbiAgICBpZiAoZnVuY0JvZHkpIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gIGVuZEZ1bmMoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKVxuICB9XG5cbiAgb3B0aW1pemUobiA9IDEpOiB2b2lkIHtcbiAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbGVhZk5vZGUobm9kZTogTGVhZk5vZGUpOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgX2Jsb2NrTm9kZShub2RlOiBTdGFydEJsb2NrTm9kZSk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSlcbiAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpXG4gIH1cblxuICBwcml2YXRlIF9lbmRCbG9ja05vZGUoTjE6IEVuZEJsb2NrTm9kZVR5cGUsIE4yPzogRW5kQmxvY2tOb2RlVHlwZSk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZVxuICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgIHRoaXMuX25vZGVzLnBvcCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKVxuICB9XG5cbiAgcHJpdmF0ZSBfZWxzZU5vZGUobm9kZTogSWYgfCBFbHNlKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlXG4gICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpXG4gICAgfVxuICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdldCBfcm9vdCgpOiBSb290IHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0gYXMgUm9vdFxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX2N1cnJOb2RlKCk6IFBhcmVudE5vZGUge1xuICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXNcbiAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV1cbiAgfVxuXG4gIHByaXZhdGUgc2V0IF9jdXJyTm9kZShub2RlOiBQYXJlbnROb2RlKSB7XG4gICAgY29uc3QgbnMgPSB0aGlzLl9ub2Rlc1xuICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZVxuICB9XG5cbiAgLy8gZ2V0IG5vZGVDb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiB0aGlzLl9yb290LmNvdW50XG4gIC8vIH1cbn1cblxuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogVXNlZE5hbWVzKTogVXNlZE5hbWVzIHtcbiAgZm9yIChjb25zdCBuIGluIGZyb20pIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMClcbiAgcmV0dXJuIG5hbWVzXG59XG5cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBmcm9tOiBTYWZlRXhwcik6IFVzZWROYW1lcyB7XG4gIHJldHVybiBmcm9tIGluc3RhbmNlb2YgX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lc1xufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHI8VCBleHRlbmRzIFNhZmVFeHByIHwgQ29kZT4oZXhwcjogVCwgbmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiBUXG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwcjogU2FmZUV4cHIsIG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogU2FmZUV4cHIge1xuICBpZiAoZXhwciBpbnN0YW5jZW9mIE5hbWUpIHJldHVybiByZXBsYWNlTmFtZShleHByKVxuICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKSByZXR1cm4gZXhwclxuICByZXR1cm4gbmV3IF9Db2RlKFxuICAgIGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXM6IENvZGVJdGVtW10sIGM6IFNhZmVFeHByIHwgc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpIGMgPSByZXBsYWNlTmFtZShjKVxuICAgICAgaWYgKGMgaW5zdGFuY2VvZiBfQ29kZSkgaXRlbXMucHVzaCguLi5jLl9pdGVtcylcbiAgICAgIGVsc2UgaXRlbXMucHVzaChjKVxuICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfSwgW10pXG4gIClcblxuICBmdW5jdGlvbiByZXBsYWNlTmFtZShuOiBOYW1lKTogU2FmZUV4cHIge1xuICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdXG4gICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpIHJldHVybiBuXG4gICAgZGVsZXRlIG5hbWVzW24uc3RyXVxuICAgIHJldHVybiBjXG4gIH1cblxuICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlOiBTYWZlRXhwcik6IGUgaXMgX0NvZGUge1xuICAgIHJldHVybiAoXG4gICAgICBlIGluc3RhbmNlb2YgX0NvZGUgJiZcbiAgICAgIGUuX2l0ZW1zLnNvbWUoXG4gICAgICAgIChjKSA9PiBjIGluc3RhbmNlb2YgTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkXG4gICAgICApXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogVXNlZE5hbWVzKTogdm9pZCB7XG4gIGZvciAoY29uc3QgbiBpbiBmcm9tKSBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Q8VCBleHRlbmRzIENvZGUgfCBTYWZlRXhwcj4oeDogVCk6IFRcbmV4cG9ydCBmdW5jdGlvbiBub3QoeDogQ29kZSB8IFNhZmVFeHByKTogQ29kZSB8IFNhZmVFeHByIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogX2AhJHtwYXIoeCl9YFxufVxuXG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChvcGVyYXRvcnMuQU5EKVxuXG4vLyBib29sZWFuIEFORCAoJiYpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGFuZCguLi5hcmdzOiBDb2RlW10pOiBDb2RlIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpXG59XG5cbmNvbnN0IG9yQ29kZSA9IG1hcHBlbmQob3BlcmF0b3JzLk9SKVxuXG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gb3IoLi4uYXJnczogQ29kZVtdKTogQ29kZSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZShvckNvZGUpXG59XG5cbnR5cGUgTUFwcGVuZCA9ICh4OiBDb2RlLCB5OiBDb2RlKSA9PiBDb2RlXG5cbmZ1bmN0aW9uIG1hcHBlbmQob3A6IENvZGUpOiBNQXBwZW5kIHtcbiAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gbmlsID8geSA6IHkgPT09IG5pbCA/IHggOiBfYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKVxufVxuXG5mdW5jdGlvbiBwYXIoeDogQ29kZSk6IENvZGUge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE5hbWUgPyB4IDogX2AoJHt4fSlgXG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYSwgRXZhbHVhdGVkUHJvcGVydGllcywgRXZhbHVhdGVkSXRlbXN9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IHtfQ29kZX0gZnJvbSBcIi4vY29kZWdlbi9jb2RlXCJcbmltcG9ydCB0eXBlIHtSdWxlLCBWYWxpZGF0aW9uUnVsZXN9IGZyb20gXCIuL3J1bGVzXCJcblxuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5leHBvcnQgZnVuY3Rpb24gdG9IYXNoPFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KGFycjogVFtdKToge1tLIGluIFRdPzogdHJ1ZX0ge1xuICBjb25zdCBoYXNoOiB7W0sgaW4gVF0/OiB0cnVlfSA9IHt9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIGhhc2hbaXRlbV0gPSB0cnVlXG4gIHJldHVybiBoYXNoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdDogU2NoZW1hQ3h0LCBzY2hlbWE6IEFueVNjaGVtYSk6IGJvb2xlYW4gfCB2b2lkIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiBzY2hlbWFcbiAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZVxuICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKVxuICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdDogU2NoZW1hQ3h0LCBzY2hlbWE6IEFueVNjaGVtYSA9IGl0LnNjaGVtYSk6IHZvaWQge1xuICBjb25zdCB7b3B0cywgc2VsZn0gPSBpdFxuICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKSByZXR1cm5cbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSByZXR1cm5cbiAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmICghcnVsZXNba2V5XSkgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoXG4gIHNjaGVtYTogQW55U2NoZW1hLFxuICBydWxlczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW4gfCBSdWxlfVxuKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChydWxlc1trZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYTogQW55U2NoZW1hLCBSVUxFUzogVmFsaWRhdGlvblJ1bGVzKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKFxuICB7dG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRofTogU2NoZW1hT2JqQ3h0LFxuICBzY2hlbWE6IHVua25vd24sXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgJGRhdGE/OiBzdHJpbmcgfCBmYWxzZVxuKTogQ29kZSB8IG51bWJlciB8IGJvb2xlYW4ge1xuICBpZiAoISRkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gc2NoZW1hXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIF9gJHtzY2hlbWF9YFxuICB9XG4gIHJldHVybiBfYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cjogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKSByZXR1cm4gYCR7c3RyfWBcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hJdGVtPFQ+KHhzOiBUIHwgVFtdLCBmOiAoeDogVCkgPT4gdm9pZCk6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICBmb3IgKGNvbnN0IHggb2YgeHMpIGYoeClcbiAgfSBlbHNlIHtcbiAgICBmKHhzKVxuICB9XG59XG5cbnR5cGUgU29tZUV2YWx1YXRlZCA9IEV2YWx1YXRlZFByb3BlcnRpZXMgfCBFdmFsdWF0ZWRJdGVtc1xuXG50eXBlIE1lcmdlRXZhbHVhdGVkRnVuYzxUIGV4dGVuZHMgU29tZUV2YWx1YXRlZD4gPSAoXG4gIGdlbjogQ29kZUdlbixcbiAgZnJvbTogTmFtZSB8IFQsXG4gIHRvOiBOYW1lIHwgRXhjbHVkZTxULCB0cnVlPiB8IHVuZGVmaW5lZCxcbiAgdG9OYW1lPzogdHlwZW9mIE5hbWVcbikgPT4gTmFtZSB8IFRcblxuaW50ZXJmYWNlIE1ha2VNZXJnZUZ1bmNBcmdzPFQgZXh0ZW5kcyBTb21lRXZhbHVhdGVkPiB7XG4gIG1lcmdlTmFtZXM6IChnZW46IENvZGVHZW4sIGZyb206IE5hbWUsIHRvOiBOYW1lKSA9PiB2b2lkXG4gIG1lcmdlVG9OYW1lOiAoZ2VuOiBDb2RlR2VuLCBmcm9tOiBULCB0bzogTmFtZSkgPT4gdm9pZFxuICBtZXJnZVZhbHVlczogKGZyb206IFQsIHRvOiBFeGNsdWRlPFQsIHRydWU+KSA9PiBUXG4gIHJlc3VsdFRvTmFtZTogKGdlbjogQ29kZUdlbiwgcmVzPzogVCkgPT4gTmFtZVxufVxuXG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQ8VCBleHRlbmRzIFNvbWVFdmFsdWF0ZWQ+KHtcbiAgbWVyZ2VOYW1lcyxcbiAgbWVyZ2VUb05hbWUsXG4gIG1lcmdlVmFsdWVzLFxuICByZXN1bHRUb05hbWUsXG59OiBNYWtlTWVyZ2VGdW5jQXJnczxUPik6IE1lcmdlRXZhbHVhdGVkRnVuYzxUPiB7XG4gIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgY29uc3QgcmVzID1cbiAgICAgIHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBmcm9tXG4gICAgICAgIDogdG8gaW5zdGFuY2VvZiBOYW1lXG4gICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBOYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgTmFtZVxuICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0bylcbiAgICByZXR1cm4gdG9OYW1lID09PSBOYW1lICYmICEocmVzIGluc3RhbmNlb2YgTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzXG4gIH1cbn1cblxuaW50ZXJmYWNlIE1lcmdlRXZhbHVhdGVkIHtcbiAgcHJvcHM6IE1lcmdlRXZhbHVhdGVkRnVuYzxFdmFsdWF0ZWRQcm9wZXJ0aWVzPlxuICBpdGVtczogTWVyZ2VFdmFsdWF0ZWRGdW5jPEV2YWx1YXRlZEl0ZW1zPlxufVxuXG5leHBvcnQgY29uc3QgbWVyZ2VFdmFsdWF0ZWQ6IE1lcmdlRXZhbHVhdGVkID0ge1xuICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmlmKFxuICAgICAgICAgIF9gJHtmcm9tfSA9PT0gdHJ1ZWAsXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbih0bywgX2Ake3RvfSB8fCB7fWApLmNvZGUoX2BPYmplY3QuYXNzaWduKCR7dG99LCAke2Zyb219KWApXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih0bywgX2Ake3RvfSB8fCB7fWApXG4gICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsuLi5mcm9tLCAuLi50b30pLFxuICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gIH0pLFxuICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odG8sIF9gJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKVxuICAgICAgKSxcbiAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZWAsICgpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogX2Ake3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKVxuICAgICAgKSxcbiAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gIH0pLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuOiBDb2RlR2VuLCBwcz86IEV2YWx1YXRlZFByb3BlcnRpZXMpOiBOYW1lIHtcbiAgaWYgKHBzID09PSB0cnVlKSByZXR1cm4gZ2VuLnZhcihcInByb3BzXCIsIHRydWUpXG4gIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIF9ge31gKVxuICBpZiAocHMgIT09IHVuZGVmaW5lZCkgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKVxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW46IENvZGVHZW4sIHByb3BzOiBOYW1lLCBwczoge1tLIGluIHN0cmluZ10/OiB0cnVlfSk6IHZvaWQge1xuICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbihfYCR7cHJvcHN9JHtnZXRQcm9wZXJ0eShwKX1gLCB0cnVlKSlcbn1cblxuY29uc3Qgc25pcHBldHM6IHtbUyBpbiBzdHJpbmddPzogX0NvZGV9ID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZ1bmMoZ2VuOiBDb2RlR2VuLCBmOiB7Y29kZTogc3RyaW5nfSk6IE5hbWUge1xuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICByZWY6IGYsXG4gICAgY29kZTogc25pcHBldHNbZi5jb2RlXSB8fCAoc25pcHBldHNbZi5jb2RlXSA9IG5ldyBfQ29kZShmLmNvZGUpKSxcbiAgfSlcbn1cblxuZXhwb3J0IGVudW0gVHlwZSB7XG4gIE51bSxcbiAgU3RyLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKFxuICBkYXRhUHJvcDogTmFtZSB8IHN0cmluZyB8IG51bWJlcixcbiAgZGF0YVByb3BUeXBlPzogVHlwZSxcbiAganNQcm9wZXJ0eVN5bnRheD86IGJvb2xlYW5cbik6IENvZGUgfCBzdHJpbmcge1xuICAvLyBsZXQgcGF0aFxuICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBOYW1lKSB7XG4gICAgY29uc3QgaXNOdW1iZXIgPSBkYXRhUHJvcFR5cGUgPT09IFR5cGUuTnVtXG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgPyBfYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgOiBfYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgOiBpc051bWJlclxuICAgICAgPyBfYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICA6IF9gXCIvXCIgKyAke2RhdGFQcm9wfS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWAgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgfVxuICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/IGdldFByb3BlcnR5KGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShcbiAgaXQ6IFNjaGVtYUN4dCxcbiAgbXNnOiBzdHJpbmcsXG4gIG1vZGU6IGJvb2xlYW4gfCBcImxvZ1wiID0gaXQub3B0cy5zdHJpY3RTY2hlbWFcbik6IHZvaWQge1xuICBpZiAoIW1vZGUpIHJldHVyblxuICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWBcbiAgaWYgKG1vZGUgPT09IHRydWUpIHRocm93IG5ldyBFcnJvcihtc2cpXG4gIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKVxufVxuIiwgImltcG9ydCB7TmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5cbmNvbnN0IG5hbWVzID0ge1xuICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICBkYXRhOiBuZXcgTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgLy8gYXJncyBwYXNzZWQgZnJvbSByZWZlcmVuY2luZyBzY2hlbWFcbiAgdmFsQ3h0OiBuZXcgTmFtZShcInZhbEN4dFwiKSwgLy8gdmFsaWRhdGlvbi9kYXRhIGNvbnRleHQgLSBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIGRlc3RydWN0dXJlZCB0byB0aGUgbmFtZXMgYmVsb3dcbiAgaW5zdGFuY2VQYXRoOiBuZXcgTmFtZShcImluc3RhbmNlUGF0aFwiKSxcbiAgcGFyZW50RGF0YTogbmV3IE5hbWUoXCJwYXJlbnREYXRhXCIpLFxuICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBOYW1lKFwicGFyZW50RGF0YVByb3BlcnR5XCIpLFxuICByb290RGF0YTogbmV3IE5hbWUoXCJyb290RGF0YVwiKSwgLy8gcm9vdCBkYXRhIC0gc2FtZSBhcyB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGZpcnN0L3RvcCB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGR5bmFtaWNBbmNob3JzOiBuZXcgTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLCAvLyB1c2VkIHRvIHN1cHBvcnQgcmVjdXJzaXZlUmVmIGFuZCBkeW5hbWljUmVmXG4gIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgdkVycm9yczogbmV3IE5hbWUoXCJ2RXJyb3JzXCIpLCAvLyBudWxsIG9yIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gIGVycm9yczogbmV3IE5hbWUoXCJlcnJvcnNcIiksIC8vIGNvdW50ZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgdGhpczogbmV3IE5hbWUoXCJ0aGlzXCIpLFxuICAvLyBcImdsb2JhbHNcIlxuICBzZWxmOiBuZXcgTmFtZShcInNlbGZcIiksXG4gIHNjb3BlOiBuZXcgTmFtZShcInNjb3BlXCIpLFxuICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICBqc29uOiBuZXcgTmFtZShcImpzb25cIiksXG4gIGpzb25Qb3M6IG5ldyBOYW1lKFwianNvblBvc1wiKSxcbiAganNvbkxlbjogbmV3IE5hbWUoXCJqc29uTGVuXCIpLFxuICBqc29uUGFydDogbmV3IE5hbWUoXCJqc29uUGFydFwiKSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmFtZXNcbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEVycm9yQ3h0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4vaW5kZXhcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBzdHIsIHN0ckNvbmNhdCwgQ29kZSwgTmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5pbXBvcnQge1NhZmVFeHByfSBmcm9tIFwiLi9jb2RlZ2VuL2NvZGVcIlxuaW1wb3J0IHtnZXRFcnJvclBhdGgsIFR5cGV9IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0IE4gZnJvbSBcIi4vbmFtZXNcIlxuXG5leHBvcnQgY29uc3Qga2V5d29yZEVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmR9KSA9PiBzdHJgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59XG5cbmV4cG9ydCBjb25zdCBrZXl3b3JkJERhdGFFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkLCBzY2hlbWFUeXBlfSkgPT5cbiAgICBzY2hlbWFUeXBlXG4gICAgICA/IHN0cmBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIG11c3QgYmUgJHtzY2hlbWFUeXBlfSAoJGRhdGEpYFxuICAgICAgOiBzdHJgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUGF0aHMge1xuICBpbnN0YW5jZVBhdGg/OiBDb2RlXG4gIHNjaGVtYVBhdGg/OiBzdHJpbmdcbiAgcGFyZW50U2NoZW1hPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0RXJyb3IoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IGtleXdvcmRFcnJvcixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHMsXG4gIG92ZXJyaWRlQWxsRXJyb3JzPzogYm9vbGVhblxuKTogdm9pZCB7XG4gIGNvbnN0IHtpdH0gPSBjeHRcbiAgY29uc3Qge2dlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzfSA9IGl0XG4gIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKVxuICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgPz8gKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKVxuICB9IGVsc2Uge1xuICAgIHJldHVybkVycm9ycyhpdCwgX2BbJHtlcnJPYmp9XWApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IGtleXdvcmRFcnJvcixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHNcbik6IHZvaWQge1xuICBjb25zdCB7aXR9ID0gY3h0XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9yc30gPSBpdFxuICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocylcbiAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopXG4gIGlmICghKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgIHJldHVybkVycm9ycyhpdCwgTi52RXJyb3JzKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbjogQ29kZUdlbiwgZXJyc0NvdW50OiBOYW1lKTogdm9pZCB7XG4gIGdlbi5hc3NpZ24oTi5lcnJvcnMsIGVycnNDb3VudClcbiAgZ2VuLmlmKF9gJHtOLnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT5cbiAgICBnZW4uaWYoXG4gICAgICBlcnJzQ291bnQsXG4gICAgICAoKSA9PiBnZW4uYXNzaWduKF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksXG4gICAgICAoKSA9PiBnZW4uYXNzaWduKE4udkVycm9ycywgbnVsbClcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7XG4gIGdlbixcbiAga2V5d29yZCxcbiAgc2NoZW1hVmFsdWUsXG4gIGRhdGEsXG4gIGVycnNDb3VudCxcbiAgaXQsXG59OiBLZXl3b3JkRXJyb3JDeHQpOiB2b2lkIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpXG4gIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBOLmVycm9ycywgKGkpID0+IHtcbiAgICBnZW4uY29uc3QoZXJyLCBfYCR7Ti52RXJyb3JzfVske2l9XWApXG4gICAgZ2VuLmlmKF9gJHtlcnJ9Lmluc3RhbmNlUGF0aCA9PT0gdW5kZWZpbmVkYCwgKCkgPT5cbiAgICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uaW5zdGFuY2VQYXRoYCwgc3RyQ29uY2F0KE4uaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKVxuICAgIClcbiAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LnNjaGVtYVBhdGhgLCBzdHJgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YClcbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LnNjaGVtYWAsIHNjaGVtYVZhbHVlKVxuICAgICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5kYXRhYCwgZGF0YSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZEVycm9yKGdlbjogQ29kZUdlbiwgZXJyT2JqOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IGVyciA9IGdlbi5jb25zdChcImVyclwiLCBlcnJPYmopXG4gIGdlbi5pZihcbiAgICBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbGAsXG4gICAgKCkgPT4gZ2VuLmFzc2lnbihOLnZFcnJvcnMsIF9gWyR7ZXJyfV1gKSxcbiAgICBfYCR7Ti52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgXG4gIClcbiAgZ2VuLmNvZGUoX2Ake04uZXJyb3JzfSsrYClcbn1cblxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0OiBTY2hlbWFDeHQsIGVycnM6IENvZGUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnZ9ID0gaXRcbiAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICBnZW4udGhyb3coX2BuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0oJHtlcnJzfSlgKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgZXJycylcbiAgICBnZW4ucmV0dXJuKGZhbHNlKVxuICB9XG59XG5cbmNvbnN0IEUgPSB7XG4gIGtleXdvcmQ6IG5ldyBOYW1lKFwia2V5d29yZFwiKSxcbiAgc2NoZW1hUGF0aDogbmV3IE5hbWUoXCJzY2hlbWFQYXRoXCIpLCAvLyBhbHNvIHVzZWQgaW4gSlREIGVycm9yc1xuICBwYXJhbXM6IG5ldyBOYW1lKFwicGFyYW1zXCIpLFxuICBwcm9wZXJ0eU5hbWU6IG5ldyBOYW1lKFwicHJvcGVydHlOYW1lXCIpLFxuICBtZXNzYWdlOiBuZXcgTmFtZShcIm1lc3NhZ2VcIiksXG4gIHNjaGVtYTogbmV3IE5hbWUoXCJzY2hlbWFcIiksXG4gIHBhcmVudFNjaGVtYTogbmV3IE5hbWUoXCJwYXJlbnRTY2hlbWFcIiksXG59XG5cbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBlcnJvclBhdGhzPzogRXJyb3JQYXRoc1xuKTogQ29kZSB7XG4gIGNvbnN0IHtjcmVhdGVFcnJvcnN9ID0gY3h0Lml0XG4gIGlmIChjcmVhdGVFcnJvcnMgPT09IGZhbHNlKSByZXR1cm4gX2B7fWBcbiAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIGVycm9yUGF0aHM6IEVycm9yUGF0aHMgPSB7fVxuKTogQ29kZSB7XG4gIGNvbnN0IHtnZW4sIGl0fSA9IGN4dFxuICBjb25zdCBrZXlWYWx1ZXM6IFtOYW1lLCBTYWZlRXhwciB8IHN0cmluZ11bXSA9IFtcbiAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gIF1cbiAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcylcbiAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKVxufVxuXG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7ZXJyb3JQYXRofTogU2NoZW1hQ3h0LCB7aW5zdGFuY2VQYXRofTogRXJyb3JQYXRocyk6IFtOYW1lLCBDb2RlXSB7XG4gIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgPyBzdHJgJHtlcnJvclBhdGh9JHtnZXRFcnJvclBhdGgoaW5zdGFuY2VQYXRoLCBUeXBlLlN0cil9YFxuICAgIDogZXJyb3JQYXRoXG4gIHJldHVybiBbTi5pbnN0YW5jZVBhdGgsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXVxufVxuXG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoXG4gIHtrZXl3b3JkLCBpdDoge2VyclNjaGVtYVBhdGh9fTogS2V5d29yZEVycm9yQ3h0LFxuICB7c2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hfTogRXJyb3JQYXRoc1xuKTogW05hbWUsIHN0cmluZyB8IENvZGVdIHtcbiAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogc3RyYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWBcbiAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICBzY2hQYXRoID0gc3RyYCR7c2NoUGF0aH0ke2dldEVycm9yUGF0aChzY2hlbWFQYXRoLCBUeXBlLlN0cil9YFxuICB9XG4gIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXVxufVxuXG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICB7cGFyYW1zLCBtZXNzYWdlfTogS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAga2V5VmFsdWVzOiBbTmFtZSwgU2FmZUV4cHIgfCBzdHJpbmddW11cbik6IHZvaWQge1xuICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0fSA9IGN4dFxuICBjb25zdCB7b3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGh9ID0gaXRcbiAga2V5VmFsdWVzLnB1c2goXG4gICAgW0Uua2V5d29yZCwga2V5d29yZF0sXG4gICAgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8IF9ge31gXVxuICApXG4gIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAga2V5VmFsdWVzLnB1c2goW0UubWVzc2FnZSwgdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShjeHQpIDogbWVzc2FnZV0pXG4gIH1cbiAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgIGtleVZhbHVlcy5wdXNoKFxuICAgICAgW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sXG4gICAgICBbRS5wYXJlbnRTY2hlbWEsIF9gJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLFxuICAgICAgW04uZGF0YSwgZGF0YV1cbiAgICApXG4gIH1cbiAgaWYgKHByb3BlcnR5TmFtZSkga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKVxufVxuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkRXJyb3JEZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JDeHR9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtyZXBvcnRFcnJvcn0gZnJvbSBcIi4uL2Vycm9yc1wiXG5pbXBvcnQge18sIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5cbmNvbnN0IGJvb2xFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZX0gPSBpdFxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQsIGZhbHNlKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgZ2VuLnJldHVybihOLmRhdGEpXG4gIH0gZWxzZSB7XG4gICAgZ2VuLmFzc2lnbihfYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKVxuICAgIGdlbi5yZXR1cm4odHJ1ZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hfSA9IGl0XG4gIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpIC8vIFRPRE8gdmFyXG4gICAgZmFsc2VTY2hlbWFFcnJvcihpdClcbiAgfSBlbHNlIHtcbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICB9XG59XG5cbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQ6IFNjaGVtYUN4dCwgb3ZlcnJpZGVBbGxFcnJvcnM/OiBib29sZWFuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGF9ID0gaXRcbiAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgY29uc3QgY3h0OiBLZXl3b3JkRXJyb3JDeHQgPSB7XG4gICAgZ2VuLFxuICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgZGF0YSxcbiAgICBzY2hlbWE6IGZhbHNlLFxuICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIGl0LFxuICB9XG4gIHJlcG9ydEVycm9yKGN4dCwgYm9vbEVycm9yLCB1bmRlZmluZWQsIG92ZXJyaWRlQWxsRXJyb3JzKVxufVxuIiwgImltcG9ydCB0eXBlIHtBZGRlZEtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgSlNPTlR5cGUgPSB0eXBlb2YgX2pzb25UeXBlc1tudW1iZXJdXG5cbmNvbnN0IGpzb25UeXBlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KF9qc29uVHlwZXMpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pTT05UeXBlKHg6IHVua25vd24pOiB4IGlzIEpTT05UeXBlIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KVxufVxuXG50eXBlIFZhbGlkYXRpb25UeXBlcyA9IHtcbiAgW0sgaW4gSlNPTlR5cGVdOiBib29sZWFuIHwgUnVsZUdyb3VwIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJ1bGVzIHtcbiAgcnVsZXM6IFJ1bGVHcm91cFtdXG4gIHBvc3Q6IFJ1bGVHcm91cFxuICBhbGw6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFuIHwgUnVsZX0gLy8gcnVsZXMgdGhhdCBoYXZlIHRvIGJlIHZhbGlkYXRlZFxuICBrZXl3b3Jkczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW59IC8vIGFsbCBrbm93biBrZXl3b3JkcyAoc3VwZXJzZXQgb2YgXCJhbGxcIilcbiAgdHlwZXM6IFZhbGlkYXRpb25UeXBlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVHcm91cCB7XG4gIHR5cGU/OiBKU09OVHlwZVxuICBydWxlczogUnVsZVtdXG59XG5cbi8vIFRoaXMgaW50ZXJmYWNlIHdyYXBzIEtleXdvcmREZWZpbml0aW9uIGJlY2F1c2UgZGVmaW5pdGlvbiBjYW4gaGF2ZSBtdWx0aXBsZSBrZXl3b3Jkc1xuZXhwb3J0IGludGVyZmFjZSBSdWxlIHtcbiAga2V5d29yZDogc3RyaW5nXG4gIGRlZmluaXRpb246IEFkZGVkS2V5d29yZERlZmluaXRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bGVzKCk6IFZhbGlkYXRpb25SdWxlcyB7XG4gIGNvbnN0IGdyb3VwczogUmVjb3JkPFwibnVtYmVyXCIgfCBcInN0cmluZ1wiIHwgXCJhcnJheVwiIHwgXCJvYmplY3RcIiwgUnVsZUdyb3VwPiA9IHtcbiAgICBudW1iZXI6IHt0eXBlOiBcIm51bWJlclwiLCBydWxlczogW119LFxuICAgIHN0cmluZzoge3R5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXX0sXG4gICAgYXJyYXk6IHt0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXX0sXG4gICAgb2JqZWN0OiB7dHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdfSxcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVzOiB7Li4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlfSxcbiAgICBydWxlczogW3tydWxlczogW119LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgIHBvc3Q6IHtydWxlczogW119LFxuICAgIGFsbDoge30sXG4gICAga2V5d29yZHM6IHt9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYU9iamVjdH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGUsIFJ1bGVHcm91cCwgUnVsZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZShcbiAge3NjaGVtYSwgc2VsZn06IFNjaGVtYU9iakN4dCxcbiAgdHlwZTogSlNPTlR5cGVcbik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV1cbiAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgZ3JvdXA6IFJ1bGVHcm91cCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgcnVsZTogUnVsZSk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gKFxuICAgIHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cz8uc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKVxuICApXG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JDeHQsXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtpc0pTT05UeXBlLCBKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNGb3JUeXBlfSBmcm9tIFwiLi9hcHBsaWNhYmlsaXR5XCJcbmltcG9ydCB7cmVwb3J0RXJyb3J9IGZyb20gXCIuLi9lcnJvcnNcIlxuaW1wb3J0IHtfLCBuaWwsIGFuZCwgbm90LCBvcGVyYXRvcnMsIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7dG9IYXNoLCBzY2hlbWFSZWZPclZhbH0gZnJvbSBcIi4uL3V0aWxcIlxuXG5leHBvcnQgZW51bSBEYXRhVHlwZSB7XG4gIENvcnJlY3QsXG4gIFdyb25nLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpXG4gIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIilcbiAgaWYgKGhhc051bGwpIHtcbiAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIilcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpXG4gICAgfVxuICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpIHR5cGVzLnB1c2goXCJudWxsXCIpXG4gIH1cbiAgcmV0dXJuIHR5cGVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRKU09OVHlwZXModHM6IHVua25vd24gfCB1bmtub3duW10pOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXM6IHVua25vd25bXSA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXVxuICBpZiAodHlwZXMuZXZlcnkoaXNKU09OVHlwZSkpIHJldHVybiB0eXBlc1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgSlNPTlR5cGUgb3IgSlNPTlR5cGVbXTogXCIgKyB0eXBlcy5qb2luKFwiLFwiKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiBib29sZWFuIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgb3B0c30gPSBpdFxuICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpXG4gIGNvbnN0IGNoZWNrVHlwZXMgPVxuICAgIHR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgc2NoZW1hSGFzUnVsZXNGb3JUeXBlKGl0LCB0eXBlc1swXSkpXG4gIGlmIChjaGVja1R5cGVzKSB7XG4gICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpXG4gICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aCkgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKVxuICAgICAgZWxzZSByZXBvcnRUeXBlRXJyb3IoaXQpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY2hlY2tUeXBlc1xufVxuXG5jb25zdCBDT0VSQ0lCTEU6IFNldDxKU09OVHlwZT4gPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSlcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXM6IEpTT05UeXBlW10sIGNvZXJjZVR5cGVzPzogYm9vbGVhbiB8IFwiYXJyYXlcIik6IEpTT05UeXBlW10ge1xuICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gY29lcmNlRGF0YShpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSwgY29lcmNlVG86IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgb3B0c30gPSBpdFxuICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCBfYHR5cGVvZiAke2RhdGF9YClcbiAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsIF9gdW5kZWZpbmVkYClcbiAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgIGdlbi5pZihfYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+XG4gICAgICBnZW5cbiAgICAgICAgLmFzc2lnbihkYXRhLCBfYCR7ZGF0YX1bMF1gKVxuICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCBfYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKVxuICAgIClcbiAgfVxuICBnZW4uaWYoX2Ake2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKVxuICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KVxuICAgIH1cbiAgfVxuICBnZW4uZWxzZSgpXG4gIHJlcG9ydFR5cGVFcnJvcihpdClcbiAgZ2VuLmVuZElmKClcblxuICBnZW4uaWYoX2Ake2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKVxuICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhVHlwZX0gPT0gXCJudW1iZXJcIiB8fCAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cImApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFwiXCJgKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihcbiAgICAgICAgICAgIF9gJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gKyR7ZGF0YX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoXG4gICAgICAgICAgICBfYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gKyR7ZGF0YX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBcInRydWVcIiB8fCAke2RhdGF9ID09PSAxYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgZ2VuLmVsc2VJZihfYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApXG4gICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbClcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKFxuICAgICAgICAgICAgX2Ake2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFske2RhdGF9XWApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoe2dlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5fTogU2NoZW1hT2JqQ3h0LCBleHByOiBOYW1lKTogdm9pZCB7XG4gIC8vIFRPRE8gdXNlIGdlbi5wcm9wZXJ0eVxuICBnZW4uaWYoX2Ake3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PlxuICAgIGdlbi5hc3NpZ24oX2Ake3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RhdGFUeXBlKFxuICBkYXRhVHlwZTogSlNPTlR5cGUsXG4gIGRhdGE6IE5hbWUsXG4gIHN0cmljdE51bXM/OiBib29sZWFuIHwgXCJsb2dcIixcbiAgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3Rcbik6IENvZGUge1xuICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBvcGVyYXRvcnMuRVEgOiBvcGVyYXRvcnMuTkVRXG4gIGxldCBjb25kOiBDb2RlXG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgcmV0dXJuIF9gJHtkYXRhfSAke0VRfSBudWxsYFxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgY29uZCA9IF9gQXJyYXkuaXNBcnJheSgke2RhdGF9KWBcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgY29uZCA9IF9gJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYFxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgY29uZCA9IG51bUNvbmQoX2AhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjb25kID0gbnVtQ29uZCgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX2B0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWBcbiAgfVxuICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiBub3QoY29uZClcblxuICBmdW5jdGlvbiBudW1Db25kKF9jb25kOiBDb2RlID0gbmlsKTogQ29kZSB7XG4gICAgcmV0dXJuIGFuZChfYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/IF9gaXNGaW5pdGUoJHtkYXRhfSlgIDogbmlsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhcbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdLFxuICBkYXRhOiBOYW1lLFxuICBzdHJpY3ROdW1zPzogYm9vbGVhbiB8IFwibG9nXCIsXG4gIGNvcnJlY3Q/OiBEYXRhVHlwZVxuKTogQ29kZSB7XG4gIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KVxuICB9XG4gIGxldCBjb25kOiBDb2RlXG4gIGNvbnN0IHR5cGVzID0gdG9IYXNoKGRhdGFUeXBlcylcbiAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgIGNvbnN0IG5vdE9iaiA9IF9gdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImBcbiAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6IF9gISR7ZGF0YX0gfHwgJHtub3RPYmp9YFxuICAgIGRlbGV0ZSB0eXBlcy5udWxsXG4gICAgZGVsZXRlIHR5cGVzLmFycmF5XG4gICAgZGVsZXRlIHR5cGVzLm9iamVjdFxuICB9IGVsc2Uge1xuICAgIGNvbmQgPSBuaWxcbiAgfVxuICBpZiAodHlwZXMubnVtYmVyKSBkZWxldGUgdHlwZXMuaW50ZWdlclxuICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpIGNvbmQgPSBhbmQoY29uZCwgY2hlY2tEYXRhVHlwZSh0IGFzIEpTT05UeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSlcbiAgcmV0dXJuIGNvbmRcbn1cblxuZXhwb3J0IHR5cGUgVHlwZUVycm9yID0gRXJyb3JPYmplY3Q8XCJ0eXBlXCIsIHt0eXBlOiBzdHJpbmd9PlxuXG5jb25zdCB0eXBlRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hfSkgPT4gYG11c3QgYmUgJHtzY2hlbWF9YCxcbiAgcGFyYW1zOiAoe3NjaGVtYSwgc2NoZW1hVmFsdWV9KSA9PlxuICAgIHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/IF9ge3R5cGU6ICR7c2NoZW1hfX1gIDogX2B7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpXG4gIHJlcG9ydEVycm9yKGN4dCwgdHlwZUVycm9yKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0OiBTY2hlbWFPYmpDeHQpOiBLZXl3b3JkRXJyb3JDeHQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWF9ID0gaXRcbiAgY29uc3Qgc2NoZW1hQ29kZSA9IHNjaGVtYVJlZk9yVmFsKGl0LCBzY2hlbWEsIFwidHlwZVwiKVxuICByZXR1cm4ge1xuICAgIGdlbixcbiAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICBkYXRhLFxuICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgc2NoZW1hQ29kZSxcbiAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIGl0LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIHN0cmluZ2lmeX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IHtjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi91dGlsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0OiBTY2hlbWFPYmpDeHQsIHR5Pzogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHtwcm9wZXJ0aWVzLCBpdGVtc30gPSBpdC5zY2hlbWFcbiAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpOiBudW1iZXIpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0OiBTY2hlbWFPYmpDeHQsIHByb3A6IHN0cmluZyB8IG51bWJlciwgZGVmYXVsdFZhbHVlOiB1bmtub3duKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHN9ID0gaXRcbiAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgY29uc3QgY2hpbGREYXRhID0gX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eShwcm9wKX1gXG4gIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjb25kaXRpb24gPSBfYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYFxuICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgY29uZGl0aW9uID0gX2Ake2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImBcbiAgfVxuICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgLy8gKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIiA/IGAgfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImAgOiBcIlwiKVxuICBnZW4uaWYoY29uZGl0aW9uLCBfYCR7Y2hpbGREYXRhfSA9ICR7c3RyaW5naWZ5KGRlZmF1bHRWYWx1ZSl9YClcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hLCBTY2hlbWFNYXB9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi4vY29tcGlsZVwiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBhbmQsIG9yLCBub3QsIG5pbCwgc3RyQ29uY2F0LCBnZXRQcm9wZXJ0eSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBUeXBlfSBmcm9tIFwiLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBOIGZyb20gXCIuLi9jb21waWxlL25hbWVzXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uL2NvbXBpbGUvdXRpbFwiXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQ6IEtleXdvcmRDeHQsIHByb3A6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBfYCR7cHJvcH1gfSwgdHJ1ZSlcbiAgICBjeHQuZXJyb3IoKVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcChcbiAge2dlbiwgZGF0YSwgaXQ6IHtvcHRzfX06IEtleXdvcmRDeHQsXG4gIHByb3BlcnRpZXM6IHN0cmluZ1tdLFxuICBtaXNzaW5nOiBOYW1lXG4pOiBDb2RlIHtcbiAgcmV0dXJuIG9yKFxuICAgIC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PlxuICAgICAgYW5kKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCBfYCR7bWlzc2luZ30gPSAke3Byb3B9YClcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dDogS2V5d29yZEN4dCwgbWlzc2luZzogTmFtZSk6IHZvaWQge1xuICBjeHQuc2V0UGFyYW1zKHttaXNzaW5nUHJvcGVydHk6IG1pc3Npbmd9LCB0cnVlKVxuICBjeHQuZXJyb3IoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUHJvcEZ1bmMoZ2VuOiBDb2RlR2VuKTogTmFtZSB7XG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgY29kZTogX2BPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuOiBDb2RlR2VuLCBkYXRhOiBOYW1lLCBwcm9wZXJ0eTogTmFtZSB8IHN0cmluZyk6IENvZGUge1xuICByZXR1cm4gX2Ake2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoXG4gIGdlbjogQ29kZUdlbixcbiAgZGF0YTogTmFtZSxcbiAgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcsXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgY29uZCA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYFxuICByZXR1cm4gb3duUHJvcGVydGllcyA/IF9gJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoXG4gIGdlbjogQ29kZUdlbixcbiAgZGF0YTogTmFtZSxcbiAgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcsXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgY29uZCA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYFxuICByZXR1cm4gb3duUHJvcGVydGllcyA/IG9yKGNvbmQsIG5vdChpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcD86IFNjaGVtYU1hcCk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0OiBTY2hlbWFDeHQsIHNjaGVtYU1hcDogU2NoZW1hTWFwKTogc3RyaW5nW10ge1xuICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcihcbiAgICAocCkgPT4gIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFNYXBbcF0gYXMgQW55U2NoZW1hKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKFxuICB7c2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHtnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRofSwgaXR9OiBLZXl3b3JkQ3h0LFxuICBmdW5jOiBDb2RlLFxuICBjb250ZXh0OiBDb2RlLFxuICBwYXNzU2NoZW1hPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gX2Ake3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGFcbiAgY29uc3QgdmFsQ3h0OiBbTmFtZSwgQ29kZSB8IG51bWJlcl1bXSA9IFtcbiAgICBbTi5pbnN0YW5jZVBhdGgsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgW04ucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgW04ucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgIFtOLnJvb3REYXRhLCBOLnJvb3REYXRhXSxcbiAgXVxuICBpZiAoaXQub3B0cy5keW5hbWljUmVmKSB2YWxDeHQucHVzaChbTi5keW5hbWljQW5jaG9ycywgTi5keW5hbWljQW5jaG9yc10pXG4gIGNvbnN0IGFyZ3MgPSBfYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWBcbiAgcmV0dXJuIGNvbnRleHQgIT09IG5pbCA/IF9gJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6IF9gJHtmdW5jfSgke2FyZ3N9KWBcbn1cblxuY29uc3QgbmV3UmVnRXhwID0gX2BuZXcgUmVnRXhwYFxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGF0dGVybih7Z2VuLCBpdDoge29wdHN9fTogS2V5d29yZEN4dCwgcGF0dGVybjogc3RyaW5nKTogTmFtZSB7XG4gIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCJcbiAgY29uc3Qge3JlZ0V4cH0gPSBvcHRzLmNvZGVcbiAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSlcblxuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICBrZXk6IHJ4LnRvU3RyaW5nKCksXG4gICAgcmVmOiByeCxcbiAgICBjb2RlOiBfYCR7cmVnRXhwLmNvZGUgPT09IFwibmV3IFJlZ0V4cFwiID8gbmV3UmVnRXhwIDogdXNlRnVuYyhnZW4sIHJlZ0V4cCl9KCR7cGF0dGVybn0sICR7dX0pYCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0OiBLZXl3b3JkQ3h0KTogTmFtZSB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpXG4gICAgcmV0dXJuIHZhbGlkQXJyXG4gIH1cbiAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSlcbiAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSlcbiAgcmV0dXJuIHZhbGlkXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5OdW0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgICBnZW4uaWYobm90KHZhbGlkKSwgbm90VmFsaWQpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoOiBBbnlTY2hlbWEpID0+IGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuXG4gIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG5cbiAgZ2VuLmJsb2NrKCgpID0+XG4gICAgc2NoZW1hLmZvckVhY2goKF9zY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHNjaFZhbGlkXG4gICAgICApXG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCBfYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YClcbiAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpXG4gICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgIGlmICghbWVyZ2VkKSBnZW4uaWYobm90KHZhbGlkKSlcbiAgICB9KVxuICApXG5cbiAgY3h0LnJlc3VsdChcbiAgICB2YWxpZCxcbiAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAoKSA9PiBjeHQuZXJyb3IodHJ1ZSlcbiAgKVxufVxuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLlwiXG5pbXBvcnQgdHlwZSB7XG4gIEFueVNjaGVtYSxcbiAgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7XywgbmlsLCBub3QsIHN0cmluZ2lmeSwgQ29kZSwgTmFtZSwgQ29kZUdlbn0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uL25hbWVzXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7Y2FsbFZhbGlkYXRlQ29kZX0gZnJvbSBcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCJcbmltcG9ydCB7ZXh0ZW5kRXJyb3JzfSBmcm9tIFwiLi4vZXJyb3JzXCJcblxudHlwZSBLZXl3b3JkQ29tcGlsYXRpb25SZXN1bHQgPSBBbnlTY2hlbWEgfCBTY2hlbWFWYWxpZGF0ZUZ1bmN0aW9uIHwgQW55VmFsaWRhdGVGdW5jdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQ6IEtleXdvcmRDeHQsIGRlZjogTWFjcm9LZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gIGNvbnN0IG1hY3JvU2NoZW1hID0gZGVmLm1hY3JvLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KVxuICBjb25zdCBzY2hlbWFSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgbWFjcm9TY2hlbWEpXG4gIGlmIChpdC5vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSkgaXQuc2VsZi52YWxpZGF0ZVNjaGVtYShtYWNyb1NjaGVtYSwgdHJ1ZSlcblxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgY3h0LnN1YnNjaGVtYShcbiAgICB7XG4gICAgICBzY2hlbWE6IG1hY3JvU2NoZW1hLFxuICAgICAgc2NoZW1hUGF0aDogbmlsLFxuICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgfSxcbiAgICB2YWxpZFxuICApXG4gIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0OiBLZXl3b3JkQ3h0LCBkZWY6IEZ1bmNLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0fSA9IGN4dFxuICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKVxuICBjb25zdCB2YWxpZGF0ZSA9XG4gICAgISRkYXRhICYmIGRlZi5jb21waWxlID8gZGVmLmNvbXBpbGUuY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIDogZGVmLnZhbGlkYXRlXG4gIGNvbnN0IHZhbGlkYXRlUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHZhbGlkYXRlKVxuICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVLZXl3b3JkKVxuICBjeHQub2soZGVmLnZhbGlkID8/IHZhbGlkKVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpOiB2b2lkIHtcbiAgICBpZiAoZGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgIGFzc2lnblZhbGlkKClcbiAgICAgIGlmIChkZWYubW9kaWZ5aW5nKSBtb2RpZnlEYXRhKGN4dClcbiAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZGVmLmFzeW5jID8gdmFsaWRhdGVBc3luYygpIDogdmFsaWRhdGVTeW5jKClcbiAgICAgIGlmIChkZWYubW9kaWZ5aW5nKSBtb2RpZnlEYXRhKGN4dClcbiAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCk6IE5hbWUge1xuICAgIGNvbnN0IHJ1bGVFcnJzID0gZ2VuLmxldChcInJ1bGVFcnJzXCIsIG51bGwpXG4gICAgZ2VuLnRyeShcbiAgICAgICgpID0+IGFzc2lnblZhbGlkKF9gYXdhaXQgYCksXG4gICAgICAoZSkgPT5cbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKFxuICAgICAgICAgIF9gJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9YCxcbiAgICAgICAgICAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCBfYCR7ZX0uZXJyb3JzYCksXG4gICAgICAgICAgKCkgPT4gZ2VuLnRocm93KGUpXG4gICAgICAgIClcbiAgICApXG4gICAgcmV0dXJuIHJ1bGVFcnJzXG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMoKTogQ29kZSB7XG4gICAgY29uc3QgdmFsaWRhdGVFcnJzID0gX2Ake3ZhbGlkYXRlUmVmfS5lcnJvcnNgXG4gICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpXG4gICAgYXNzaWduVmFsaWQobmlsKVxuICAgIHJldHVybiB2YWxpZGF0ZUVycnNcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdDogQ29kZSA9IGRlZi5hc3luYyA/IF9gYXdhaXQgYCA6IG5pbCk6IHZvaWQge1xuICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gTi50aGlzIDogTi5zZWxmXG4gICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKVxuICAgIGdlbi5hc3NpZ24oXG4gICAgICB2YWxpZCxcbiAgICAgIF9gJHtfYXdhaXR9JHtjYWxsVmFsaWRhdGVDb2RlKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsXG4gICAgICBkZWYubW9kaWZ5aW5nXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBnZW4uaWYobm90KGRlZi52YWxpZCA/PyB2YWxpZCksIGVycm9ycylcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dDogS2V5d29yZEN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgX2Ake2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSlcbn1cblxuZnVuY3Rpb24gYWRkRXJycyhjeHQ6IEtleXdvcmRDeHQsIGVycnM6IENvZGUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbn0gPSBjeHRcbiAgZ2VuLmlmKFxuICAgIF9gQXJyYXkuaXNBcnJheSgke2VycnN9KWAsXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuXG4gICAgICAgIC5hc3NpZ24oTi52RXJyb3JzLCBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke04udkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgLmFzc2lnbihOLmVycm9ycywgX2Ake04udkVycm9yc30ubGVuZ3RoYClcbiAgICAgIGV4dGVuZEVycm9ycyhjeHQpXG4gICAgfSxcbiAgICAoKSA9PiBjeHQuZXJyb3IoKVxuICApXG59XG5cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHtzY2hlbWFFbnZ9OiBTY2hlbWFPYmpDeHQsIGRlZjogRnVuY0tleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIilcbn1cblxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW46IENvZGVHZW4sIGtleXdvcmQ6IHN0cmluZywgcmVzdWx0PzogS2V5d29yZENvbXBpbGF0aW9uUmVzdWx0KTogTmFtZSB7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYClcbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFxuICAgIFwia2V5d29yZFwiLFxuICAgIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8ge3JlZjogcmVzdWx0fSA6IHtyZWY6IHJlc3VsdCwgY29kZTogc3RyaW5naWZ5KHJlc3VsdCl9XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShcbiAgc2NoZW1hOiB1bmtub3duLFxuICBzY2hlbWFUeXBlOiBKU09OVHlwZVtdLFxuICBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlXG4pOiBib29sZWFuIHtcbiAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgcmV0dXJuIChcbiAgICAhc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PlxuICAgICAgc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKVxuICAgIClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoXG4gIHtzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGh9OiBTY2hlbWFPYmpDeHQsXG4gIGRlZjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAga2V5d29yZDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIH1cblxuICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llc1xuICBpZiAoZGVwcz8uc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YClcbiAgfVxuXG4gIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpXG4gICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIikgc2VsZi5sb2dnZXIuZXJyb3IobXNnKVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtfLCBzdHIsIGdldFByb3BlcnR5LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQge2VzY2FwZUZyYWdtZW50LCBnZXRFcnJvclBhdGgsIFR5cGV9IGZyb20gXCIuLi91dGlsXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY2hlbWFDb250ZXh0IHtcbiAgLy8gVE9ETyB1c2UgT3B0aW9uYWw/IGFsaWduIHdpdGggU2NoZW1DeHQgcHJvcGVydHkgdHlwZXNcbiAgc2NoZW1hOiBBbnlTY2hlbWFcbiAgc2NoZW1hUGF0aDogQ29kZVxuICBlcnJTY2hlbWFQYXRoOiBzdHJpbmdcbiAgdG9wU2NoZW1hUmVmPzogQ29kZVxuICBlcnJvclBhdGg/OiBDb2RlXG4gIGRhdGFMZXZlbD86IG51bWJlclxuICBkYXRhVHlwZXM/OiBKU09OVHlwZVtdXG4gIGRhdGE/OiBOYW1lXG4gIHBhcmVudERhdGE/OiBOYW1lXG4gIHBhcmVudERhdGFQcm9wZXJ0eT86IENvZGUgfCBudW1iZXJcbiAgZGF0YU5hbWVzPzogTmFtZVtdXG4gIGRhdGFQYXRoQXJyPzogKENvZGUgfCBudW1iZXIpW11cbiAgcHJvcGVydHlOYW1lPzogTmFtZVxuICBqdGREaXNjcmltaW5hdG9yPzogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhPzogYm9vbGVhblxuICBjb21wb3NpdGVSdWxlPzogdHJ1ZVxuICBjcmVhdGVFcnJvcnM/OiBib29sZWFuXG4gIGFsbEVycm9ycz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU3Vic2NoZW1hQXJncyA9IFBhcnRpYWw8e1xuICBrZXl3b3JkOiBzdHJpbmdcbiAgc2NoZW1hUHJvcDogc3RyaW5nIHwgbnVtYmVyXG4gIHNjaGVtYTogQW55U2NoZW1hXG4gIHNjaGVtYVBhdGg6IENvZGVcbiAgZXJyU2NoZW1hUGF0aDogc3RyaW5nXG4gIHRvcFNjaGVtYVJlZjogQ29kZVxuICBkYXRhOiBOYW1lIHwgQ29kZVxuICBkYXRhUHJvcDogQ29kZSB8IHN0cmluZyB8IG51bWJlclxuICBkYXRhVHlwZXM6IEpTT05UeXBlW11cbiAgZGVmaW5lZFByb3BlcnRpZXM6IFNldDxzdHJpbmc+XG4gIHByb3BlcnR5TmFtZTogTmFtZVxuICBkYXRhUHJvcFR5cGU6IFR5cGVcbiAganRkRGlzY3JpbWluYXRvcjogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhOiBib29sZWFuXG4gIGNvbXBvc2l0ZVJ1bGU6IHRydWVcbiAgY3JlYXRlRXJyb3JzOiBib29sZWFuXG4gIGFsbEVycm9yczogYm9vbGVhblxufT5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1YnNjaGVtYShcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAge2tleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmfTogU3Vic2NoZW1hQXJnc1xuKTogU3Vic2NoZW1hQ29udGV4dCB7XG4gIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJylcbiAgfVxuXG4gIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHtcbiAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICBzY2hlbWFQYXRoOiBfYCR7aXQuc2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfWAsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIH1cbiAgICAgIDoge1xuICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IF9gJHtpdC5zY2hlbWFQYXRofSR7Z2V0UHJvcGVydHkoa2V5d29yZCl9JHtnZXRQcm9wZXJ0eShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHtlc2NhcGVGcmFnbWVudChzY2hlbWFQcm9wKX1gLFxuICAgICAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWEsXG4gICAgICBzY2hlbWFQYXRoLFxuICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoXG4gIHN1YnNjaGVtYTogU3Vic2NoZW1hQ29udGV4dCxcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAge2RhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWV9OiBTdWJzY2hlbWFBcmdzXG4pOiB2b2lkIHtcbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJylcbiAgfVxuXG4gIGNvbnN0IHtnZW59ID0gaXRcblxuICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzfSA9IGl0XG4gICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCBfYCR7aXQuZGF0YX0ke2dldFByb3BlcnR5KGRhdGFQcm9wKX1gLCB0cnVlKVxuICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpXG4gICAgc3Vic2NoZW1hLmVycm9yUGF0aCA9IHN0cmAke2Vycm9yUGF0aH0ke2dldEVycm9yUGF0aChkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWBcbiAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gX2Ake2RhdGFQcm9wfWBcbiAgICBzdWJzY2hlbWEuZGF0YVBhdGhBcnIgPSBbLi4uZGF0YVBhdGhBcnIsIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHldXG4gIH1cblxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKSAvLyByZXBsYWNlYWJsZSBpZiB1c2VkIG9uY2U/XG4gICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSlcbiAgICBpZiAocHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVcbiAgICAvLyBUT0RPIHNvbWV0aGluZyBpcyBwb3NzaWJseSB3cm9uZyBoZXJlIHdpdGggbm90IGNoYW5naW5nIHBhcmVudERhdGFQcm9wZXJ0eSBhbmQgbm90IGFwcGVuZGluZyBkYXRhUGF0aEFyclxuICB9XG5cbiAgaWYgKGRhdGFUeXBlcykgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlc1xuXG4gIGZ1bmN0aW9uIGRhdGFDb250ZXh0UHJvcHMoX25leHREYXRhOiBOYW1lKTogdm9pZCB7XG4gICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGFcbiAgICBzdWJzY2hlbWEuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMVxuICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXVxuICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGFcbiAgICBzdWJzY2hlbWEuZGF0YU5hbWVzID0gWy4uLml0LmRhdGFOYW1lcywgX25leHREYXRhXVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKFxuICBzdWJzY2hlbWE6IFN1YnNjaGVtYUNvbnRleHQsXG4gIHtqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnN9OiBTdWJzY2hlbWFBcmdzXG4pOiB2b2lkIHtcbiAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlXG4gIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9yc1xuICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnNcbiAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yIC8vIG5vdCBpbmhlcml0ZWRcbiAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGEgLy8gbm90IGluaGVyaXRlZFxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWEsIEFueVNjaGVtYU9iamVjdCwgVXJpUmVzb2x2ZXJ9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcIi4uL2FqdlwiXG5pbXBvcnQgdHlwZSB7VVJJQ29tcG9uZW50c30gZnJvbSBcInVyaS1qc1wiXG5pbXBvcnQge2VhY2hJdGVtfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCAqIGFzIGVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIlxuaW1wb3J0ICogYXMgdHJhdmVyc2UgZnJvbSBcImpzb24tc2NoZW1hLXRyYXZlcnNlXCJcblxuLy8gdGhlIGhhc2ggb2YgbG9jYWwgcmVmZXJlbmNlcyBpbnNpZGUgdGhlIHNjaGVtYSAoY3JlYXRlZCBieSBnZXRTY2hlbWFSZWZzKSwgdXNlZCBmb3IgaW5saW5lIHJlc29sdXRpb25cbmV4cG9ydCB0eXBlIExvY2FsUmVmcyA9IHtbUmVmIGluIHN0cmluZ10/OiBBbnlTY2hlbWFPYmplY3R9XG5cbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIGtleXdvcmQgZGVmaW5pdGlvbnNcbmNvbnN0IFNJTVBMRV9JTkxJTkVEID0gbmV3IFNldChbXG4gIFwidHlwZVwiLFxuICBcImZvcm1hdFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJtYXhMZW5ndGhcIixcbiAgXCJtaW5MZW5ndGhcIixcbiAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gIFwibWluUHJvcGVydGllc1wiLFxuICBcIm1heEl0ZW1zXCIsXG4gIFwibWluSXRlbXNcIixcbiAgXCJtYXhpbXVtXCIsXG4gIFwibWluaW11bVwiLFxuICBcInVuaXF1ZUl0ZW1zXCIsXG4gIFwibXVsdGlwbGVPZlwiLFxuICBcInJlcXVpcmVkXCIsXG4gIFwiZW51bVwiLFxuICBcImNvbnN0XCIsXG5dKVxuXG5leHBvcnQgZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYTogQW55U2NoZW1hLCBsaW1pdDogYm9vbGVhbiB8IG51bWJlciA9IHRydWUpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB0cnVlXG4gIGlmIChsaW1pdCA9PT0gdHJ1ZSkgcmV0dXJuICFoYXNSZWYoc2NoZW1hKVxuICBpZiAoIWxpbWl0KSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0XG59XG5cbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICBcIiRyZWZcIixcbiAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICBcIiRkeW5hbWljUmVmXCIsXG4gIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pXG5cbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IGJvb2xlYW4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKSByZXR1cm4gdHJ1ZVxuICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKSByZXR1cm4gdHJ1ZVxuICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IG51bWJlciB7XG4gIGxldCBjb3VudCA9IDBcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpIHJldHVybiBJbmZpbml0eVxuICAgIGNvdW50KytcbiAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpIGNvbnRpbnVlXG4gICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBlYWNoSXRlbShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSlcbiAgICB9XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5XG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsUGF0aChyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplPzogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChub3JtYWxpemUgIT09IGZhbHNlKSBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICBjb25zdCBwID0gcmVzb2x2ZXIucGFyc2UoaWQpXG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBwOiBVUklDb21wb25lbnRzKTogc3RyaW5nIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHJlc29sdmVyLnNlcmlhbGl6ZShwKVxuICByZXR1cm4gc2VyaWFsaXplZC5zcGxpdChcIiNcIilbMF0gKyBcIiNcIlxufVxuXG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVJZChpZDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVVcmwocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBiYXNlSWQ6IHN0cmluZywgaWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpXG59XG5cbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHRoaXM6IEFqdiwgc2NoZW1hOiBBbnlTY2hlbWEsIGJhc2VJZDogc3RyaW5nKTogTG9jYWxSZWZzIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB7fVxuICBjb25zdCB7c2NoZW1hSWQsIHVyaVJlc29sdmVyfSA9IHRoaXMub3B0c1xuICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKVxuICBjb25zdCBiYXNlSWRzOiB7W0pzb25QdHIgaW4gc3RyaW5nXT86IHN0cmluZ30gPSB7XCJcIjogc2NoSWR9XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKVxuICBjb25zdCBsb2NhbFJlZnM6IExvY2FsUmVmcyA9IHt9XG4gIGNvbnN0IHNjaGVtYVJlZnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG5cbiAgdHJhdmVyc2Uoc2NoZW1hLCB7YWxsS2V5czogdHJ1ZX0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICBpZiAocGFyZW50SnNvblB0ciA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhQcmVmaXggKyBqc29uUHRyXG4gICAgbGV0IGJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl1cbiAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIikgYmFzZUlkID0gYWRkUmVmLmNhbGwodGhpcywgc2NoW3NjaGVtYUlkXSlcbiAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcilcbiAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpXG4gICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZFxuXG4gICAgZnVuY3Rpb24gYWRkUmVmKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZVxuICAgICAgcmVmID0gbm9ybWFsaXplSWQoYmFzZUlkID8gX3Jlc29sdmUoYmFzZUlkLCByZWYpIDogcmVmKVxuICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpIHRocm93IGFtYmlndW9zKHJlZilcbiAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZilcbiAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdXG4gICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXVxuICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZilcbiAgICAgIH0gZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZilcbiAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEFuY2hvcih0aGlzOiBBanYsIGFuY2hvcjogdW5rbm93bik6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApXG4gICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGxvY2FsUmVmc1xuXG4gIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMTogQW55U2NoZW1hLCBzY2gyOiBBbnlTY2hlbWEgfCB1bmRlZmluZWQsIHJlZjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpIHRocm93IGFtYmlndW9zKHJlZilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFtYmlndW9zKHJlZjogc3RyaW5nKTogRXJyb3Ige1xuICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYClcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEtleXdvcmRFcnJvckN4dCxcbiAgS2V5d29yZEN4dFBhcmFtcyxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB0eXBlIHtJbnN0YW5jZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jb3JlXCJcbmltcG9ydCB7Ym9vbE9yRW1wdHlTY2hlbWEsIHRvcEJvb2xPckVtcHR5U2NoZW1hfSBmcm9tIFwiLi9ib29sU2NoZW1hXCJcbmltcG9ydCB7Y29lcmNlQW5kQ2hlY2tEYXRhVHlwZSwgZ2V0U2NoZW1hVHlwZXN9IGZyb20gXCIuL2RhdGFUeXBlXCJcbmltcG9ydCB7c2hvdWxkVXNlR3JvdXAsIHNob3VsZFVzZVJ1bGV9IGZyb20gXCIuL2FwcGxpY2FiaWxpdHlcIlxuaW1wb3J0IHtjaGVja0RhdGFUeXBlLCBjaGVja0RhdGFUeXBlcywgcmVwb3J0VHlwZUVycm9yLCBEYXRhVHlwZX0gZnJvbSBcIi4vZGF0YVR5cGVcIlxuaW1wb3J0IHthc3NpZ25EZWZhdWx0c30gZnJvbSBcIi4vZGVmYXVsdHNcIlxuaW1wb3J0IHtmdW5jS2V5d29yZENvZGUsIG1hY3JvS2V5d29yZENvZGUsIHZhbGlkYXRlS2V5d29yZFVzYWdlLCB2YWxpZFNjaGVtYVR5cGV9IGZyb20gXCIuL2tleXdvcmRcIlxuaW1wb3J0IHtnZXRTdWJzY2hlbWEsIGV4dGVuZFN1YnNjaGVtYURhdGEsIFN1YnNjaGVtYUFyZ3MsIGV4dGVuZFN1YnNjaGVtYU1vZGV9IGZyb20gXCIuL3N1YnNjaGVtYVwiXG5pbXBvcnQge18sIG5pbCwgc3RyLCBvciwgbm90LCBnZXRQcm9wZXJ0eSwgQmxvY2ssIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5pbXBvcnQge3Jlc29sdmVVcmx9IGZyb20gXCIuLi9yZXNvbHZlXCJcbmltcG9ydCB7XG4gIHNjaGVtYVJlZk9yVmFsLFxuICBzY2hlbWFIYXNSdWxlc0J1dFJlZixcbiAgY2hlY2tVbmtub3duUnVsZXMsXG4gIGNoZWNrU3RyaWN0TW9kZSxcbiAgdW5lc2NhcGVKc29uUG9pbnRlcixcbiAgbWVyZ2VFdmFsdWF0ZWQsXG59IGZyb20gXCIuLi91dGlsXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZSwgUnVsZSwgUnVsZUdyb3VwfSBmcm9tIFwiLi4vcnVsZXNcIlxuaW1wb3J0IHtcbiAgRXJyb3JQYXRocyxcbiAgcmVwb3J0RXJyb3IsXG4gIHJlcG9ydEV4dHJhRXJyb3IsXG4gIHJlc2V0RXJyb3JzQ291bnQsXG4gIGtleXdvcmQkRGF0YUVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3JzXCJcblxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgY2hlY2tLZXl3b3JkcyhpdClcbiAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbihcbiAge2dlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0c306IFNjaGVtYUN4dCxcbiAgYm9keTogQmxvY2tcbik6IHZvaWQge1xuICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgX2Ake04uZGF0YX0sICR7Ti52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgZ2VuLmNvZGUoX2BcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YClcbiAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cylcbiAgICAgIGdlbi5jb2RlKGJvZHkpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIF9gJHtOLmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+XG4gICAgICBnZW4uY29kZShmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykpLmNvZGUoYm9keSlcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0czogSW5zdGFuY2VPcHRpb25zKTogQ29kZSB7XG4gIHJldHVybiBfYHske04uaW5zdGFuY2VQYXRofT1cIlwiLCAke04ucGFyZW50RGF0YX0sICR7Ti5wYXJlbnREYXRhUHJvcGVydHl9LCAke04ucm9vdERhdGF9PSR7XG4gICAgTi5kYXRhXG4gIH0ke29wdHMuZHluYW1pY1JlZiA/IF9gLCAke04uZHluYW1pY0FuY2hvcnN9PXt9YCA6IG5pbH19PXt9YFxufVxuXG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW46IENvZGVHZW4sIG9wdHM6IEluc3RhbmNlT3B0aW9ucyk6IHZvaWQge1xuICBnZW4uaWYoXG4gICAgTi52YWxDeHQsXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuLnZhcihOLmluc3RhbmNlUGF0aCwgX2Ake04udmFsQ3h0fS4ke04uaW5zdGFuY2VQYXRofWApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YSwgX2Ake04udmFsQ3h0fS4ke04ucGFyZW50RGF0YX1gKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGFQcm9wZXJ0eSwgX2Ake04udmFsQ3h0fS4ke04ucGFyZW50RGF0YVByb3BlcnR5fWApXG4gICAgICBnZW4udmFyKE4ucm9vdERhdGEsIF9gJHtOLnZhbEN4dH0uJHtOLnJvb3REYXRhfWApXG4gICAgICBpZiAob3B0cy5keW5hbWljUmVmKSBnZW4udmFyKE4uZHluYW1pY0FuY2hvcnMsIF9gJHtOLnZhbEN4dH0uJHtOLmR5bmFtaWNBbmNob3JzfWApXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBnZW4udmFyKE4uaW5zdGFuY2VQYXRoLCBfYFwiXCJgKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGEsIF9gdW5kZWZpbmVkYClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhUHJvcGVydHksIF9gdW5kZWZpbmVkYClcbiAgICAgIGdlbi52YXIoTi5yb290RGF0YSwgTi5kYXRhKVxuICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZikgZ2VuLnZhcihOLmR5bmFtaWNBbmNob3JzLCBfYHt9YClcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIG9wdHMsIGdlbn0gPSBpdFxuICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KSBjb21tZW50S2V5d29yZChpdClcbiAgICBjaGVja05vRGVmYXVsdChpdClcbiAgICBnZW4ubGV0KE4udkVycm9ycywgbnVsbClcbiAgICBnZW4ubGV0KE4uZXJyb3JzLCAwKVxuICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKSByZXNldEV2YWx1YXRlZChpdClcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQpXG4gICAgcmV0dXJuUmVzdWx0cyhpdClcbiAgfSlcbiAgcmV0dXJuXG59XG5cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICBjb25zdCB7Z2VuLCB2YWxpZGF0ZU5hbWV9ID0gaXRcbiAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsIF9gJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApXG4gIGdlbi5pZihfYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKF9gJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgX2B1bmRlZmluZWRgKSlcbiAgZ2VuLmlmKF9gJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oX2Ake2l0LmV2YWx1YXRlZH0uaXRlbXNgLCBfYHVuZGVmaW5lZGApKVxufVxuXG5mdW5jdGlvbiBmdW5jU291cmNlVXJsKHNjaGVtYTogQW55U2NoZW1hLCBvcHRzOiBJbnN0YW5jZU9wdGlvbnMpOiBDb2RlIHtcbiAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdXG4gIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyBfYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogbmlsXG59XG5cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdDogU2NoZW1hQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgY2hlY2tLZXl3b3JkcyhpdClcbiAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpXG59XG5cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHtzY2hlbWEsIHNlbGZ9OiBTY2hlbWFDeHQpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiAhc2NoZW1hXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdDogU2NoZW1hQ3h0KTogaXQgaXMgU2NoZW1hT2JqQ3h0IHtcbiAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCJcbn1cblxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdDogU2NoZW1hT2JqQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBnZW4sIG9wdHN9ID0gaXRcbiAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KSBjb21tZW50S2V5d29yZChpdClcbiAgdXBkYXRlQ29udGV4dChpdClcbiAgY2hlY2tBc3luY1NjaGVtYShpdClcbiAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgTi5lcnJvcnMpXG4gIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KVxuICAvLyBUT0RPIHZhclxuICBnZW4udmFyKHZhbGlkLCBfYCR7ZXJyc0NvdW50fSA9PT0gJHtOLmVycm9yc31gKVxufVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY2hlY2tVbmtub3duUnVsZXMoaXQpXG4gIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KVxufVxuXG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCwgZXJyc0NvdW50PzogTmFtZSk6IHZvaWQge1xuICBpZiAoaXQub3B0cy5qdGQpIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpXG4gIGNvbnN0IHR5cGVzID0gZ2V0U2NoZW1hVHlwZXMoaXQuc2NoZW1hKVxuICBjb25zdCBjaGVja2VkVHlwZXMgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcylcbiAgc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCAhY2hlY2tlZFR5cGVzLCBlcnJzQ291bnQpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cywgc2VsZn0gPSBpdFxuICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9EZWZhdWx0KGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgb3B0c30gPSBpdFxuICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIilcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF1cbiAgaWYgKHNjaElkKSBpdC5iYXNlSWQgPSByZXNvbHZlVXJsKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQXN5bmNTY2hlbWEoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBpZiAoaXQuc2NoZW1hLiRhc3luYyAmJiAhaXQuc2NoZW1hRW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hXCIpXG59XG5cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHtnZW4sIHNjaGVtYUVudiwgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzfTogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudFxuICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgIGdlbi5jb2RlKF9gJHtOLnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IHN0cmAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YFxuICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHtyZWY6IHNjaGVtYUVudi5yb290fSlcbiAgICBnZW4uY29kZShfYCR7Ti5zZWxmfS5vcHRzLiRjb21tZW50KCR7bXNnfSwgJHtzY2hlbWFQYXRofSwgJHtyb290TmFtZX0uc2NoZW1hKWApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdDogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHN9ID0gaXRcbiAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgIGdlbi5pZihcbiAgICAgIF9gJHtOLmVycm9yc30gPT09IDBgLFxuICAgICAgKCkgPT4gZ2VuLnJldHVybihOLmRhdGEpLFxuICAgICAgKCkgPT4gZ2VuLnRocm93KF9gbmV3ICR7VmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9KCR7Ti52RXJyb3JzfSlgKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBnZW4uYXNzaWduKF9gJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIE4udkVycm9ycylcbiAgICBpZiAob3B0cy51bmV2YWx1YXRlZCkgYXNzaWduRXZhbHVhdGVkKGl0KVxuICAgIGdlbi5yZXR1cm4oX2Ake04uZXJyb3JzfSA9PT0gMGApXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHtnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zfTogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGlmIChwcm9wcyBpbnN0YW5jZW9mIE5hbWUpIGdlbi5hc3NpZ24oX2Ake2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcylcbiAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgTmFtZSkgZ2VuLmFzc2lnbihfYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKVxufVxuXG5mdW5jdGlvbiBzY2hlbWFLZXl3b3JkcyhcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAgdHlwZXM6IEpTT05UeXBlW10sXG4gIHR5cGVFcnJvcnM6IGJvb2xlYW4sXG4gIGVycnNDb3VudD86IE5hbWVcbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGFsbEVycm9ycywgb3B0cywgc2VsZn0gPSBpdFxuICBjb25zdCB7UlVMRVN9ID0gc2VsZlxuICBpZiAoc2NoZW1hLiRyZWYgJiYgKG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmIHx8ICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSkpIHtcbiAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCAoUlVMRVMuYWxsLiRyZWYgYXMgUnVsZSkuZGVmaW5pdGlvbikpIC8vIFRPRE8gdHlwZWNhc3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW9wdHMuanRkKSBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcylcbiAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSBncm91cEtleXdvcmRzKGdyb3VwKVxuICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdClcbiAgfSlcblxuICBmdW5jdGlvbiBncm91cEtleXdvcmRzKGdyb3VwOiBSdWxlR3JvdXApOiB2b2lkIHtcbiAgICBpZiAoIXNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApKSByZXR1cm5cbiAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgZ2VuLmlmKGNoZWNrRGF0YVR5cGUoZ3JvdXAudHlwZSwgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSlcbiAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApXG4gICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgZ2VuLmVsc2UoKVxuICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpXG4gICAgICB9XG4gICAgICBnZW4uZW5kSWYoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKVxuICAgIH1cbiAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5pZihfYCR7Ti5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApXG4gIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQsIGdyb3VwOiBSdWxlR3JvdXApOiB2b2lkIHtcbiAgY29uc3Qge1xuICAgIGdlbixcbiAgICBzY2hlbWEsXG4gICAgb3B0czoge3VzZURlZmF1bHRzfSxcbiAgfSA9IGl0XG4gIGlmICh1c2VEZWZhdWx0cykgYXNzaWduRGVmYXVsdHMoaXQsIGdyb3VwLnR5cGUpXG4gIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICBpZiAoc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgIGtleXdvcmRDb2RlKGl0LCBydWxlLmtleXdvcmQsIHJ1bGUuZGVmaW5pdGlvbiwgZ3JvdXAudHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RyaWN0VHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgaWYgKGl0LnNjaGVtYUVudi5tZXRhIHx8ICFpdC5vcHRzLnN0cmljdFR5cGVzKSByZXR1cm5cbiAgY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKVxuICBpZiAoIWl0Lm9wdHMuYWxsb3dVbmlvblR5cGVzKSBjaGVja011bHRpcGxlVHlwZXMoaXQsIHR5cGVzKVxuICBjaGVja0tleXdvcmRUeXBlcyhpdCwgaXQuZGF0YVR5cGVzKVxufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAoIXR5cGVzLmxlbmd0aCkgcmV0dXJuXG4gIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgIGl0LmRhdGFUeXBlcyA9IHR5cGVzXG4gICAgcmV0dXJuXG4gIH1cbiAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApXG4gICAgfVxuICB9KVxuICBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgdHlwZXMpXG59XG5cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0czogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHRzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGxcbiAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdXG4gICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgc2hvdWxkVXNlUnVsZShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICBjb25zdCB7dHlwZX0gPSBydWxlLmRlZmluaXRpb25cbiAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGBtaXNzaW5nIHR5cGUgXCIke3R5cGUuam9pbihcIixcIil9XCIgZm9yIGtleXdvcmQgXCIke2tleXdvcmR9XCJgKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUczogSlNPTlR5cGVbXSwga3dkVDogSlNPTlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNjaFRzLmluY2x1ZGVzKGt3ZFQpIHx8IChrd2RUID09PSBcIm51bWJlclwiICYmIHNjaFRzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSlcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzOiBKU09OVHlwZVtdLCB0OiBKU09OVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHMuaW5jbHVkZXModCkgfHwgKHQgPT09IFwiaW50ZWdlclwiICYmIHRzLmluY2x1ZGVzKFwibnVtYmVyXCIpKVxufVxuXG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB3aXRoVHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3QgdHM6IEpTT05UeXBlW10gPSBbXVxuICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgaWYgKGluY2x1ZGVzVHlwZSh3aXRoVHlwZXMsIHQpKSB0cy5wdXNoKHQpXG4gICAgZWxzZSBpZiAod2l0aFR5cGVzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSAmJiB0ID09PSBcIm51bWJlclwiKSB0cy5wdXNoKFwiaW50ZWdlclwiKVxuICB9XG4gIGl0LmRhdGFUeXBlcyA9IHRzXG59XG5cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQ6IFNjaGVtYU9iakN4dCwgbXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoXG4gIG1zZyArPSBgIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RUeXBlcylgXG4gIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKVxufVxuXG5leHBvcnQgY2xhc3MgS2V5d29yZEN4dCBpbXBsZW1lbnRzIEtleXdvcmRFcnJvckN4dCB7XG4gIHJlYWRvbmx5IGdlbjogQ29kZUdlblxuICByZWFkb25seSBhbGxFcnJvcnM/OiBib29sZWFuXG4gIHJlYWRvbmx5IGtleXdvcmQ6IHN0cmluZ1xuICByZWFkb25seSBkYXRhOiBOYW1lIC8vIE5hbWUgcmVmZXJlbmNpbmcgdGhlIGN1cnJlbnQgbGV2ZWwgb2YgdGhlIGRhdGEgaW5zdGFuY2VcbiAgcmVhZG9ubHkgJGRhdGE/OiBzdHJpbmcgfCBmYWxzZVxuICBzY2hlbWE6IGFueSAvLyBrZXl3b3JkIHZhbHVlIGluIHRoZSBzY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hVmFsdWU6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIC8vIENvZGUgcmVmZXJlbmNlIHRvIGtleXdvcmQgc2NoZW1hIHZhbHVlIG9yIHByaW1pdGl2ZSB2YWx1ZVxuICByZWFkb25seSBzY2hlbWFDb2RlOiBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiAvLyBDb2RlIHJlZmVyZW5jZSB0byByZXNvbHZlZCBzY2hlbWEgdmFsdWUgKGRpZmZlcmVudCBpZiBzY2hlbWEgaXMgJGRhdGEpXG4gIHJlYWRvbmx5IHNjaGVtYVR5cGU6IEpTT05UeXBlW10gLy8gYWxsb3dlZCB0eXBlKHMpIG9mIGtleXdvcmQgdmFsdWUgaW4gdGhlIHNjaGVtYVxuICByZWFkb25seSBwYXJlbnRTY2hlbWE6IEFueVNjaGVtYU9iamVjdFxuICByZWFkb25seSBlcnJzQ291bnQ/OiBOYW1lIC8vIE5hbWUgcmVmZXJlbmNlIHRvIHRoZSBudW1iZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnMgY29sbGVjdGVkIGJlZm9yZSB0aGlzIGtleXdvcmQsXG4gIC8vIHJlcXVpcmVzIG9wdGlvbiB0cmFja0Vycm9ycyBpbiBrZXl3b3JkIGRlZmluaXRpb25cbiAgcGFyYW1zOiBLZXl3b3JkQ3h0UGFyYW1zIC8vIG9iamVjdCB0byBwYXNzIHBhcmFtZXRlcnMgdG8gZXJyb3IgbWVzc2FnZXMgZnJvbSBrZXl3b3JkIGNvZGVcbiAgcmVhZG9ubHkgaXQ6IFNjaGVtYU9iakN4dCAvLyBzY2hlbWEgY29tcGlsYXRpb24gY29udGV4dCAoc2NoZW1hIGlzIGd1YXJhbnRlZWQgdG8gYmUgYW4gb2JqZWN0LCBub3QgYm9vbGVhbilcbiAgcmVhZG9ubHkgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uXG5cbiAgY29uc3RydWN0b3IoaXQ6IFNjaGVtYU9iakN4dCwgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLCBrZXl3b3JkOiBzdHJpbmcpIHtcbiAgICB2YWxpZGF0ZUtleXdvcmRVc2FnZShpdCwgZGVmLCBrZXl3b3JkKVxuICAgIHRoaXMuZ2VuID0gaXQuZ2VuXG4gICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnNcbiAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgdGhpcy5kYXRhID0gaXQuZGF0YVxuICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhXG4gICAgdGhpcy5zY2hlbWFWYWx1ZSA9IHNjaGVtYVJlZk9yVmFsKGl0LCB0aGlzLnNjaGVtYSwga2V5d29yZCwgdGhpcy4kZGF0YSlcbiAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZVxuICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hXG4gICAgdGhpcy5wYXJhbXMgPSB7fVxuICAgIHRoaXMuaXQgPSBpdFxuICAgIHRoaXMuZGVmID0gZGVmXG5cbiAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2hlbWFDb2RlID0gdGhpcy5zY2hlbWFWYWx1ZVxuICAgICAgaWYgKCF2YWxpZFNjaGVtYVR5cGUodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIE4uZXJyb3JzKVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdChjb25kaXRpb246IENvZGUsIHN1Y2Nlc3NBY3Rpb24/OiAoKSA9PiB2b2lkLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbFJlc3VsdChub3QoY29uZGl0aW9uKSwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbilcbiAgfVxuXG4gIGZhaWxSZXN1bHQoY29uZGl0aW9uOiBDb2RlLCBzdWNjZXNzQWN0aW9uPzogKCkgPT4gdm9pZCwgZmFpbEFjdGlvbj86ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pXG4gICAgaWYgKGZhaWxBY3Rpb24pIGZhaWxBY3Rpb24oKVxuICAgIGVsc2UgdGhpcy5lcnJvcigpXG4gICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgIHRoaXMuZ2VuLmVsc2UoKVxuICAgICAgc3VjY2Vzc0FjdGlvbigpXG4gICAgICBpZiAodGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmVuZElmKClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5lbmRJZigpXG4gICAgICBlbHNlIHRoaXMuZ2VuLmVsc2UoKVxuICAgIH1cbiAgfVxuXG4gIHBhc3MoY29uZGl0aW9uOiBDb2RlLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbFJlc3VsdChub3QoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKVxuICB9XG5cbiAgZmFpbChjb25kaXRpb24/OiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yKClcbiAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmlmKGZhbHNlKSAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKVxuICAgIHRoaXMuZXJyb3IoKVxuICAgIGlmICh0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uZW5kSWYoKVxuICAgIGVsc2UgdGhpcy5nZW4uZWxzZSgpXG4gIH1cblxuICBmYWlsJGRhdGEoY29uZGl0aW9uOiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLiRkYXRhKSByZXR1cm4gdGhpcy5mYWlsKGNvbmRpdGlvbilcbiAgICBjb25zdCB7c2NoZW1hQ29kZX0gPSB0aGlzXG4gICAgdGhpcy5mYWlsKF9gJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgke29yKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApXG4gIH1cblxuICBlcnJvcihhcHBlbmQ/OiBib29sZWFuLCBlcnJvclBhcmFtcz86IEtleXdvcmRDeHRQYXJhbXMsIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzKTogdm9pZCB7XG4gICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcylcbiAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocylcbiAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocylcbiAgfVxuXG4gIHByaXZhdGUgX2Vycm9yKGFwcGVuZD86IGJvb2xlYW4sIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzKTogdm9pZCB7XG4gICAgOyhhcHBlbmQgPyByZXBvcnRFeHRyYUVycm9yIDogcmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLmVycm9yLCBlcnJvclBhdGhzKVxuICB9XG5cbiAgJGRhdGFFcnJvcigpOiB2b2lkIHtcbiAgICByZXBvcnRFcnJvcih0aGlzLCB0aGlzLmRlZi4kZGF0YUVycm9yIHx8IGtleXdvcmQkRGF0YUVycm9yKVxuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKVxuICAgIHJlc2V0RXJyb3JzQ291bnQodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KVxuICB9XG5cbiAgb2soY29uZDogQ29kZSB8IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5pZihjb25kKVxuICB9XG5cbiAgc2V0UGFyYW1zKG9iajogS2V5d29yZEN4dFBhcmFtcywgYXNzaWduPzogdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChhc3NpZ24pIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iailcbiAgICBlbHNlIHRoaXMucGFyYW1zID0gb2JqXG4gIH1cblxuICBibG9jayRkYXRhKHZhbGlkOiBOYW1lLCBjb2RlQmxvY2s6ICgpID0+IHZvaWQsICRkYXRhVmFsaWQ6IENvZGUgPSBuaWwpOiB2b2lkIHtcbiAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpXG4gICAgICBjb2RlQmxvY2soKVxuICAgIH0pXG4gIH1cblxuICBjaGVjayRkYXRhKHZhbGlkOiBOYW1lID0gbmlsLCAkZGF0YVZhbGlkOiBDb2RlID0gbmlsKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLiRkYXRhKSByZXR1cm5cbiAgICBjb25zdCB7Z2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWZ9ID0gdGhpc1xuICAgIGdlbi5pZihvcihfYCR7c2NoZW1hQ29kZX0gPT09IHVuZGVmaW5lZGAsICRkYXRhVmFsaWQpKVxuICAgIGlmICh2YWxpZCAhPT0gbmlsKSBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCB8fCBkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgIGdlbi5lbHNlSWYodGhpcy5pbnZhbGlkJGRhdGEoKSlcbiAgICAgIHRoaXMuJGRhdGFFcnJvcigpXG4gICAgICBpZiAodmFsaWQgIT09IG5pbCkgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgfVxuICAgIGdlbi5lbHNlKClcbiAgfVxuXG4gIGludmFsaWQkZGF0YSgpOiBDb2RlIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0fSA9IHRoaXNcbiAgICByZXR1cm4gb3Iod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpXG5cbiAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpOiBDb2RlIHtcbiAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIE5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXVxuICAgICAgICByZXR1cm4gX2Ake2NoZWNrRGF0YVR5cGVzKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKX1gXG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCk6IENvZGUge1xuICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZVNjaGVtYVJlZiA9IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGUkZGF0YVwiLCB7cmVmOiBkZWYudmFsaWRhdGVTY2hlbWF9KSAvLyBUT0RPIHZhbHVlLmNvZGUgZm9yIHN0YW5kYWxvbmVcbiAgICAgICAgcmV0dXJuIF9gISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYFxuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbFxuICAgIH1cbiAgfVxuXG4gIHN1YnNjaGVtYShhcHBsOiBTdWJzY2hlbWFBcmdzLCB2YWxpZDogTmFtZSk6IFNjaGVtYUN4dCB7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hKHRoaXMuaXQsIGFwcGwpXG4gICAgZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpXG4gICAgZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIGFwcGwpXG4gICAgY29uc3QgbmV4dENvbnRleHQgPSB7Li4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkfVxuICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKVxuICAgIHJldHVybiBuZXh0Q29udGV4dFxuICB9XG5cbiAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0OiBTY2hlbWFDeHQsIHRvTmFtZT86IHR5cGVvZiBOYW1lKTogdm9pZCB7XG4gICAgY29uc3Qge2l0LCBnZW59ID0gdGhpc1xuICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZCkgcmV0dXJuXG4gICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKVxuICAgIH1cbiAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpXG4gICAgfVxuICB9XG5cbiAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiBib29sZWFuIHwgdm9pZCB7XG4gICAgY29uc3Qge2l0LCBnZW59ID0gdGhpc1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIE5hbWUpKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5d29yZENvZGUoXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBydWxlVHlwZT86IEpTT05UeXBlXG4pOiB2b2lkIHtcbiAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZClcbiAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpXG4gIH0gZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfSBlbHNlIGlmIChcIm1hY3JvXCIgaW4gZGVmKSB7XG4gICAgbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfSBlbHNlIGlmIChkZWYuY29tcGlsZSB8fCBkZWYudmFsaWRhdGUpIHtcbiAgICBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpXG4gIH1cbn1cblxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokL1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKFxuICAkZGF0YTogc3RyaW5nLFxuICB7ZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyfTogU2NoZW1hQ3h0XG4pOiBDb2RlIHwgbnVtYmVyIHtcbiAgbGV0IGpzb25Qb2ludGVyXG4gIGxldCBkYXRhOiBDb2RlXG4gIGlmICgkZGF0YSA9PT0gXCJcIikgcmV0dXJuIE4ucm9vdERhdGFcbiAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApXG4gICAganNvblBvaW50ZXIgPSAkZGF0YVxuICAgIGRhdGEgPSBOLnJvb3REYXRhXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKVxuICAgIGlmICghbWF0Y2hlcykgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKVxuICAgIGNvbnN0IHVwOiBudW1iZXIgPSArbWF0Y2hlc1sxXVxuICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXVxuICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSlcbiAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF1cbiAgICB9XG4gICAgaWYgKHVwID4gZGF0YUxldmVsKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSlcbiAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXVxuICAgIGlmICghanNvblBvaW50ZXIpIHJldHVybiBkYXRhXG4gIH1cblxuICBsZXQgZXhwciA9IGRhdGFcbiAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIilcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgIGRhdGEgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpfWBcbiAgICAgIGV4cHIgPSBfYCR7ZXhwcn0gJiYgJHtkYXRhfWBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cHJcblxuICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZTogc3RyaW5nLCB1cDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWBcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtFcnJvck9iamVjdH0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBlcnJvcnM6IFBhcnRpYWw8RXJyb3JPYmplY3Q+W11cbiAgcmVhZG9ubHkgYWp2OiB0cnVlXG4gIHJlYWRvbmx5IHZhbGlkYXRpb246IHRydWVcblxuICBjb25zdHJ1Y3RvcihlcnJvcnM6IFBhcnRpYWw8RXJyb3JPYmplY3Q+W10pIHtcbiAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcbiAgICB0aGlzLmFqdiA9IHRoaXMudmFsaWRhdGlvbiA9IHRydWVcbiAgfVxufVxuIiwgImltcG9ydCB7cmVzb2x2ZVVybCwgbm9ybWFsaXplSWQsIGdldEZ1bGxQYXRofSBmcm9tIFwiLi9yZXNvbHZlXCJcbmltcG9ydCB0eXBlIHtVcmlSZXNvbHZlcn0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBtaXNzaW5nUmVmOiBzdHJpbmdcbiAgcmVhZG9ubHkgbWlzc2luZ1NjaGVtYTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBiYXNlSWQ6IHN0cmluZywgcmVmOiBzdHJpbmcsIG1zZz86IHN0cmluZykge1xuICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YClcbiAgICB0aGlzLm1pc3NpbmdSZWYgPSByZXNvbHZlVXJsKHJlc29sdmVyLCBiYXNlSWQsIHJlZilcbiAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSBub3JtYWxpemVJZChnZXRGdWxsUGF0aChyZXNvbHZlciwgdGhpcy5taXNzaW5nUmVmKSlcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgRXZhbHVhdGVkUHJvcGVydGllcyxcbiAgRXZhbHVhdGVkSXRlbXMsXG59IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcIi4uL2NvcmVcIlxuaW1wb3J0IHR5cGUge0luc3RhbmNlT3B0aW9uc30gZnJvbSBcIi4uL2NvcmVcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBuaWwsIHN0cmluZ2lmeSwgTmFtZSwgQ29kZSwgVmFsdWVTY29wZU5hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IFZhbGlkYXRpb25FcnJvciBmcm9tIFwiLi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCJcbmltcG9ydCBOIGZyb20gXCIuL25hbWVzXCJcbmltcG9ydCB7TG9jYWxSZWZzLCBnZXRGdWxsUGF0aCwgX2dldEZ1bGxQYXRoLCBpbmxpbmVSZWYsIG5vcm1hbGl6ZUlkLCByZXNvbHZlVXJsfSBmcm9tIFwiLi9yZXNvbHZlXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNCdXRSZWYsIHVuZXNjYXBlRnJhZ21lbnR9IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0IHt2YWxpZGF0ZUZ1bmN0aW9uQ29kZX0gZnJvbSBcIi4vdmFsaWRhdGVcIlxuaW1wb3J0ICogYXMgVVJJIGZyb20gXCJ1cmktanNcIlxuaW1wb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vcnVsZXNcIlxuXG5leHBvcnQgdHlwZSBTY2hlbWFSZWZzID0ge1xuICBbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBBbnlTY2hlbWFcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFDeHQge1xuICByZWFkb25seSBnZW46IENvZGVHZW5cbiAgcmVhZG9ubHkgYWxsRXJyb3JzPzogYm9vbGVhbiAvLyB2YWxpZGF0aW9uIG1vZGUgLSB3aGV0aGVyIHRvIGNvbGxlY3QgYWxsIGVycm9ycyBvciBicmVhayBvbiBlcnJvclxuICByZWFkb25seSBkYXRhOiBOYW1lIC8vIE5hbWUgd2l0aCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGFydCBvZiBkYXRhIGluc3RhbmNlXG4gIHJlYWRvbmx5IHBhcmVudERhdGE6IE5hbWUgLy8gc2hvdWxkIGJlIHVzZWQgaW4ga2V5d29yZHMgbW9kaWZ5aW5nIGRhdGFcbiAgcmVhZG9ubHkgcGFyZW50RGF0YVByb3BlcnR5OiBDb2RlIHwgbnVtYmVyIC8vIHNob3VsZCBiZSB1c2VkIGluIGtleXdvcmRzIG1vZGlmeWluZyBkYXRhXG4gIHJlYWRvbmx5IGRhdGFOYW1lczogTmFtZVtdXG4gIHJlYWRvbmx5IGRhdGFQYXRoQXJyOiAoQ29kZSB8IG51bWJlcilbXVxuICByZWFkb25seSBkYXRhTGV2ZWw6IG51bWJlciAvLyB0aGUgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSB2YWxpZGF0ZWQgZGF0YSxcbiAgLy8gaXQgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIGJvdGggdGhlIHByb3BlcnR5IG5hbWVzIGFuZCB0aGUgZGF0YSBvbiBhbGwgbGV2ZWxzIGZyb20gdGhlIHRvcC5cbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdIC8vIGRhdGEgdHlwZXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBwYXJ0IG9mIGRhdGEgaW5zdGFuY2VcbiAgZGVmaW5lZFByb3BlcnRpZXM6IFNldDxzdHJpbmc+IC8vIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGtlZXAgdHJhY2sgb2YgZm9yIHJlcXVpcmVkIGNoZWNrc1xuICByZWFkb25seSB0b3BTY2hlbWFSZWY6IENvZGVcbiAgcmVhZG9ubHkgdmFsaWRhdGVOYW1lOiBOYW1lXG4gIGV2YWx1YXRlZD86IE5hbWVcbiAgcmVhZG9ubHkgVmFsaWRhdGlvbkVycm9yPzogTmFtZVxuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYSAvLyBjdXJyZW50IHNjaGVtYSBvYmplY3QgLSBlcXVhbCB0byBwYXJlbnRTY2hlbWEgcGFzc2VkIHZpYSBLZXl3b3JkQ3h0XG4gIHJlYWRvbmx5IHNjaGVtYUVudjogU2NoZW1hRW52XG4gIHJlYWRvbmx5IHJvb3RJZDogc3RyaW5nXG4gIGJhc2VJZDogc3RyaW5nIC8vIHRoZSBjdXJyZW50IHNjaGVtYSBiYXNlIFVSSSB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciByZXNvbHZpbmcgVVJJcyBpbiByZWZlcmVuY2VzIChcXCRyZWYpXG4gIHJlYWRvbmx5IHNjaGVtYVBhdGg6IENvZGUgLy8gdGhlIHJ1bi10aW1lIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGN1cnJlbnQgc2NoZW1hXG4gIHJlYWRvbmx5IGVyclNjaGVtYVBhdGg6IHN0cmluZyAvLyB0aGlzIGlzIGFjdHVhbCBzdHJpbmcsIHNob3VsZCBub3QgYmUgY2hhbmdlZCB0byBDb2RlXG4gIHJlYWRvbmx5IGVycm9yUGF0aDogQ29kZVxuICByZWFkb25seSBwcm9wZXJ0eU5hbWU/OiBOYW1lXG4gIHJlYWRvbmx5IGNvbXBvc2l0ZVJ1bGU/OiBib29sZWFuIC8vIHRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgc2NoZW1hIGlzIGluc2lkZSB0aGUgY29tcG91bmQga2V5d29yZCxcbiAgLy8gd2hlcmUgZmFpbGluZyBzb21lIHJ1bGUgZG9lc24ndCBtZWFuIHZhbGlkYXRpb24gZmFpbHVyZSAoYGFueU9mYCwgYG9uZU9mYCwgYG5vdGAsIGBpZmApLlxuICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB5b3UgY2FuIHJldHVybiB2YWxpZGF0aW9uIHJlc3VsdCBpbW1lZGlhdGVseSBhZnRlciBhbnkgZXJyb3IgaW4gY2FzZSB0aGUgb3B0aW9uIGBhbGxFcnJvcnNgIGlzIG5vdCBgdHJ1ZS5cbiAgLy8gWW91IG9ubHkgbmVlZCB0byB1c2UgaXQgaWYgeW91IGhhdmUgbWFueSBzdGVwcyBpbiB5b3VyIGtleXdvcmRzIGFuZCBwb3RlbnRpYWxseSBjYW4gZGVmaW5lIG11bHRpcGxlIGVycm9ycy5cbiAgcHJvcHM/OiBFdmFsdWF0ZWRQcm9wZXJ0aWVzIHwgTmFtZSAvLyBwcm9wZXJ0aWVzIGV2YWx1YXRlZCBieSB0aGlzIHNjaGVtYSAtIHVzZWQgYnkgcGFyZW50IHNjaGVtYSBvciBhc3NpZ25lZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGl0ZW1zPzogRXZhbHVhdGVkSXRlbXMgfCBOYW1lIC8vIGxhc3QgaXRlbSBldmFsdWF0ZWQgYnkgdGhpcyBzY2hlbWEgLSB1c2VkIGJ5IHBhcmVudCBzY2hlbWEgb3IgYXNzaWduZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICBqdGREaXNjcmltaW5hdG9yPzogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhPzogYm9vbGVhblxuICByZWFkb25seSBjcmVhdGVFcnJvcnM/OiBib29sZWFuXG4gIHJlYWRvbmx5IG9wdHM6IEluc3RhbmNlT3B0aW9ucyAvLyBBanYgaW5zdGFuY2Ugb3B0aW9uLlxuICByZWFkb25seSBzZWxmOiBBanYgLy8gY3VycmVudCBBanYgaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFPYmpDeHQgZXh0ZW5kcyBTY2hlbWFDeHQge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYU9iamVjdFxufVxuaW50ZXJmYWNlIFNjaGVtYUVudkFyZ3Mge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYVxuICByZWFkb25seSBzY2hlbWFJZD86IFwiJGlkXCIgfCBcImlkXCJcbiAgcmVhZG9ubHkgcm9vdD86IFNjaGVtYUVudlxuICByZWFkb25seSBiYXNlSWQ/OiBzdHJpbmdcbiAgcmVhZG9ubHkgc2NoZW1hUGF0aD86IHN0cmluZ1xuICByZWFkb25seSBsb2NhbFJlZnM/OiBMb2NhbFJlZnNcbiAgcmVhZG9ubHkgbWV0YT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFNjaGVtYUVudiBpbXBsZW1lbnRzIFNjaGVtYUVudkFyZ3Mge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYVxuICByZWFkb25seSBzY2hlbWFJZD86IFwiJGlkXCIgfCBcImlkXCJcbiAgcmVhZG9ubHkgcm9vdDogU2NoZW1hRW52XG4gIGJhc2VJZDogc3RyaW5nIC8vIFRPRE8gcG9zc2libHksIGl0IHNob3VsZCBiZSByZWFkb25seVxuICBzY2hlbWFQYXRoPzogc3RyaW5nXG4gIGxvY2FsUmVmcz86IExvY2FsUmVmc1xuICByZWFkb25seSBtZXRhPzogYm9vbGVhblxuICByZWFkb25seSAkYXN5bmM/OiBib29sZWFuIC8vIHRydWUgaWYgdGhlIGN1cnJlbnQgc2NoZW1hIGlzIGFzeW5jaHJvbm91cy5cbiAgcmVhZG9ubHkgcmVmczogU2NoZW1hUmVmcyA9IHt9XG4gIHJlYWRvbmx5IGR5bmFtaWNBbmNob3JzOiB7W1JlZiBpbiBzdHJpbmddPzogdHJ1ZX0gPSB7fVxuICB2YWxpZGF0ZT86IEFueVZhbGlkYXRlRnVuY3Rpb25cbiAgdmFsaWRhdGVOYW1lPzogVmFsdWVTY29wZU5hbWVcbiAgc2VyaWFsaXplPzogKGRhdGE6IHVua25vd24pID0+IHN0cmluZ1xuICBzZXJpYWxpemVOYW1lPzogVmFsdWVTY29wZU5hbWVcbiAgcGFyc2U/OiAoZGF0YTogc3RyaW5nKSA9PiB1bmtub3duXG4gIHBhcnNlTmFtZT86IFZhbHVlU2NvcGVOYW1lXG5cbiAgY29uc3RydWN0b3IoZW52OiBTY2hlbWFFbnZBcmdzKSB7XG4gICAgbGV0IHNjaGVtYTogQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpIHNjaGVtYSA9IGVudi5zY2hlbWFcbiAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWFcbiAgICB0aGlzLnNjaGVtYUlkID0gZW52LnNjaGVtYUlkXG4gICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpc1xuICAgIHRoaXMuYmFzZUlkID0gZW52LmJhc2VJZCA/PyBub3JtYWxpemVJZChzY2hlbWE/LltlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pXG4gICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGhcbiAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnNcbiAgICB0aGlzLm1ldGEgPSBlbnYubWV0YVxuICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hPy4kYXN5bmNcbiAgICB0aGlzLnJlZnMgPSB7fVxuICB9XG59XG5cbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG5cbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlU2NoZW1hKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBTY2hlbWFFbnYge1xuICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKVxuICBpZiAoX3NjaCkgcmV0dXJuIF9zY2hcbiAgY29uc3Qgcm9vdElkID0gZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBzY2gucm9vdC5iYXNlSWQpIC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gIGNvbnN0IHtlczUsIGxpbmVzfSA9IHRoaXMub3B0cy5jb2RlXG4gIGNvbnN0IHtvd25Qcm9wZXJ0aWVzfSA9IHRoaXMub3B0c1xuICBjb25zdCBnZW4gPSBuZXcgQ29kZUdlbih0aGlzLnNjb3BlLCB7ZXM1LCBsaW5lcywgb3duUHJvcGVydGllc30pXG4gIGxldCBfVmFsaWRhdGlvbkVycm9yXG4gIGlmIChzY2guJGFzeW5jKSB7XG4gICAgX1ZhbGlkYXRpb25FcnJvciA9IGdlbi5zY29wZVZhbHVlKFwiRXJyb3JcIiwge1xuICAgICAgcmVmOiBWYWxpZGF0aW9uRXJyb3IsXG4gICAgICBjb2RlOiBfYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKVxuICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lXG5cbiAgY29uc3Qgc2NoZW1hQ3h0OiBTY2hlbWFDeHQgPSB7XG4gICAgZ2VuLFxuICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICBkYXRhOiBOLmRhdGEsXG4gICAgcGFyZW50RGF0YTogTi5wYXJlbnREYXRhLFxuICAgIHBhcmVudERhdGFQcm9wZXJ0eTogTi5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgZGF0YU5hbWVzOiBbTi5kYXRhXSxcbiAgICBkYXRhUGF0aEFycjogW25pbF0sIC8vIFRPRE8gY2FuIGl0cyBsZW5ndGggYmUgdXNlZCBhcyBkYXRhTGV2ZWwgaWYgbmlsIGlzIHJlbW92ZWQ/XG4gICAgZGF0YUxldmVsOiAwLFxuICAgIGRhdGFUeXBlczogW10sXG4gICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQ8c3RyaW5nPigpLFxuICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXG4gICAgICBcInNjaGVtYVwiLFxuICAgICAgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgID8ge3JlZjogc2NoLnNjaGVtYSwgY29kZTogc3RyaW5naWZ5KHNjaC5zY2hlbWEpfVxuICAgICAgICA6IHtyZWY6IHNjaC5zY2hlbWF9XG4gICAgKSxcbiAgICB2YWxpZGF0ZU5hbWUsXG4gICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgIHNjaGVtYTogc2NoLnNjaGVtYSxcbiAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICByb290SWQsXG4gICAgYmFzZUlkOiBzY2guYmFzZUlkIHx8IHJvb3RJZCxcbiAgICBzY2hlbWFQYXRoOiBuaWwsXG4gICAgZXJyU2NoZW1hUGF0aDogc2NoLnNjaGVtYVBhdGggfHwgKHRoaXMub3B0cy5qdGQgPyBcIlwiIDogXCIjXCIpLFxuICAgIGVycm9yUGF0aDogX2BcIlwiYCxcbiAgICBvcHRzOiB0aGlzLm9wdHMsXG4gICAgc2VsZjogdGhpcyxcbiAgfVxuXG4gIGxldCBzb3VyY2VDb2RlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgdHJ5IHtcbiAgICB0aGlzLl9jb21waWxhdGlvbnMuYWRkKHNjaClcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShzY2hlbWFDeHQpXG4gICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKVxuICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpXG4gICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMoTi5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWBcbiAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKSBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtOLnNlbGZ9YCwgYCR7Ti5zY29wZX1gLCBzb3VyY2VDb2RlKVxuICAgIGNvbnN0IHZhbGlkYXRlOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpXG4gICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHtyZWY6IHZhbGlkYXRlfSlcblxuICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGxcbiAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hXG4gICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoXG4gICAgaWYgKHNjaC4kYXN5bmMpICh2YWxpZGF0ZSBhcyBBc3luY1ZhbGlkYXRlRnVuY3Rpb24pLiRhc3luYyA9IHRydWVcbiAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7dmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlc31cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgY29uc3Qge3Byb3BzLCBpdGVtc30gPSBzY2hlbWFDeHRcbiAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBOYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBOYW1lLFxuICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgTmFtZSxcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSBzdHJpbmdpZnkodmFsaWRhdGUuZXZhbHVhdGVkKVxuICAgIH1cbiAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZVxuICAgIHJldHVybiBzY2hcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVcbiAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZVxuICAgIGlmIChzb3VyY2VDb2RlKSB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgdGhyb3cgZVxuICB9IGZpbmFsbHkge1xuICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUmVmKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudixcbiAgYmFzZUlkOiBzdHJpbmcsXG4gIHJlZjogc3RyaW5nXG4pOiBBbnlTY2hlbWEgfCBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICByZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpXG4gIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdXG4gIGlmIChzY2hPckZ1bmMpIHJldHVybiBzY2hPckZ1bmNcblxuICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpXG4gIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSByb290LmxvY2FsUmVmcz8uW3JlZl0gLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGlmIChzY2hlbWEpIF9zY2ggPSBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICB9XG5cbiAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSlcbn1cblxuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBBbnlTY2hlbWEgfCBTY2hlbWFFbnYge1xuICBpZiAoaW5saW5lUmVmKHNjaC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKSkgcmV0dXJuIHNjaC5zY2hlbWFcbiAgcmV0dXJuIHNjaC52YWxpZGF0ZSA/IHNjaCA6IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG59XG5cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEodGhpczogQWp2LCBzY2hFbnY6IFNjaGVtYUVudik6IFNjaGVtYUVudiB8IHZvaWQge1xuICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICBpZiAoc2FtZVNjaGVtYUVudihzY2gsIHNjaEVudikpIHJldHVybiBzY2hcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxOiBTY2hlbWFFbnYsIHMyOiBTY2hlbWFFbnYpOiBib29sZWFuIHtcbiAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWRcbn1cblxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUoXG4gIHRoaXM6IEFqdixcbiAgcm9vdDogU2NoZW1hRW52LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxuICByZWY6IHN0cmluZyAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgbGV0IHNjaFxuICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIikgcmVmID0gc2NoXG4gIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZilcbn1cblxuLy8gUmVzb2x2ZSBzY2hlbWEsIGl0cyByb290IGFuZCBiYXNlSWRcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudiwgLy8gcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmcyBUT0RPIGJlbG93IFNjaGVtYUVudiBpcyBhc3NpZ25lZCB0byBpdFxuICByZWY6IHN0cmluZyAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpXG4gIGNvbnN0IHJlZlBhdGggPSBfZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKVxuICBsZXQgYmFzZUlkID0gZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKVxuICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpXG4gIH1cblxuICBjb25zdCBpZCA9IG5vcm1hbGl6ZUlkKHJlZlBhdGgpXG4gIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdXG4gIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBzY2hPclJlZilcbiAgICBpZiAodHlwZW9mIHNjaD8uc2NoZW1hICE9PSBcIm9iamVjdFwiKSByZXR1cm5cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2gpXG4gIH1cblxuICBpZiAodHlwZW9mIHNjaE9yUmVmPy5zY2hlbWEgIT09IFwib2JqZWN0XCIpIHJldHVyblxuICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpXG4gIGlmIChpZCA9PT0gbm9ybWFsaXplSWQocmVmKSkge1xuICAgIGNvbnN0IHtzY2hlbWF9ID0gc2NoT3JSZWZcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgaWYgKHNjaElkKSBiYXNlSWQgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZClcbiAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkfSlcbiAgfVxuICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZilcbn1cblxuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgXCJwcm9wZXJ0aWVzXCIsXG4gIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgXCJlbnVtXCIsXG4gIFwiZGVwZW5kZW5jaWVzXCIsXG4gIFwiZGVmaW5pdGlvbnNcIixcbl0pXG5cbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKFxuICB0aGlzOiBBanYsXG4gIHBhcnNlZFJlZjogVVJJLlVSSUNvbXBvbmVudHMsXG4gIHtiYXNlSWQsIHNjaGVtYSwgcm9vdH06IFNjaGVtYUVudlxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBhcnNlZFJlZi5mcmFnbWVudD8uWzBdICE9PSBcIi9cIikgcmV0dXJuXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSByZXR1cm5cbiAgICBjb25zdCBwYXJ0U2NoZW1hID0gc2NoZW1hW3VuZXNjYXBlRnJhZ21lbnQocGFydCldXG4gICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgc2NoZW1hID0gcGFydFNjaGVtYVxuICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF1cbiAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgYmFzZUlkID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpXG4gICAgfVxuICB9XG4gIGxldCBlbnY6IFNjaGVtYUVudiB8IHVuZGVmaW5lZFxuICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgIGNvbnN0ICRyZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hlbWEuJHJlZilcbiAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZilcbiAgfVxuICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKSByZXR1cm4gZW52XG4gIHJldHVybiB1bmRlZmluZWRcbn1cbiIsICJ7XG4gIFwiJGlkXCI6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJNZXRhLXNjaGVtYSBmb3IgJGRhdGEgcmVmZXJlbmNlIChKU09OIEFueVNjaGVtYSBleHRlbnNpb24gcHJvcG9zYWwpXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInJlcXVpcmVkXCI6IFtcIiRkYXRhXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGRhdGFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImFueU9mXCI6IFt7XCJmb3JtYXRcIjogXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIn0sIHtcImZvcm1hdFwiOiBcImpzb24tcG9pbnRlclwifV1cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBTQ0hFTUVTIH0gZnJvbSBcIi4vdXJpXCI7XG5cbmltcG9ydCBodHRwIGZyb20gXCIuL3NjaGVtZXMvaHR0cFwiO1xuU0NIRU1FU1todHRwLnNjaGVtZV0gPSBodHRwO1xuXG5pbXBvcnQgaHR0cHMgZnJvbSBcIi4vc2NoZW1lcy9odHRwc1wiO1xuU0NIRU1FU1todHRwcy5zY2hlbWVdID0gaHR0cHM7XG5cbmltcG9ydCB3cyBmcm9tIFwiLi9zY2hlbWVzL3dzXCI7XG5TQ0hFTUVTW3dzLnNjaGVtZV0gPSB3cztcblxuaW1wb3J0IHdzcyBmcm9tIFwiLi9zY2hlbWVzL3dzc1wiO1xuU0NIRU1FU1t3c3Muc2NoZW1lXSA9IHdzcztcblxuaW1wb3J0IG1haWx0byBmcm9tIFwiLi9zY2hlbWVzL21haWx0b1wiO1xuU0NIRU1FU1ttYWlsdG8uc2NoZW1lXSA9IG1haWx0bztcblxuaW1wb3J0IHVybiBmcm9tIFwiLi9zY2hlbWVzL3VyblwiO1xuU0NIRU1FU1t1cm4uc2NoZW1lXSA9IHVybjtcblxuaW1wb3J0IHV1aWQgZnJvbSBcIi4vc2NoZW1lcy91cm4tdXVpZFwiO1xuU0NIRU1FU1t1dWlkLnNjaGVtZV0gPSB1dWlkO1xuXG5leHBvcnQgKiBmcm9tIFwiLi91cmlcIjtcbiIsICJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgVVJOQ29tcG9uZW50cyB9IGZyb20gXCIuL3VyblwiO1xuaW1wb3J0IHsgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVVUlEQ29tcG9uZW50cyBleHRlbmRzIFVSTkNvbXBvbmVudHMge1xuXHR1dWlkPzogc3RyaW5nO1xufVxuXG5jb25zdCBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuY29uc3QgVVVJRF9QQVJTRSA9IC9eWzAtOUEtRmEtZlxcLV17MzZ9LztcblxuLy9SRkMgNDEyMlxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVVSURDb21wb25lbnRzLCBVUklPcHRpb25zLCBVUk5Db21wb25lbnRzPiA9IHtcblx0c2NoZW1lIDogXCJ1cm46dXVpZFwiLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKHVybkNvbXBvbmVudHM6VVJOQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVVUlEQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzIGFzIFVVSURDb21wb25lbnRzO1xuXHRcdHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG5cdFx0dXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcblx0XHRcdHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXVpZENvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHV1aWRDb21wb25lbnRzOlVVSURDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cyBhcyBVUk5Db21wb25lbnRzO1xuXHRcdC8vbm9ybWFsaXplIFVVSURcblx0XHR1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIHVybkNvbXBvbmVudHM7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsICJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgcGN0RW5jQ2hhciwgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUk5Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdG5pZD86c3RyaW5nO1xuXHRuc3M/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUk5PcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyB7XG5cdG5pZD86c3RyaW5nO1xufVxuXG5jb25zdCBOSUQkID0gXCIoPzpbMC05QS1aYS16XVswLTlBLVphLXpcXFxcLV17MSwzMX0pXCI7XG5jb25zdCBQQ1RfRU5DT0RFRCQgPSBcIig/OlxcXFwlWzAtOUEtRmEtZl17Mn0pXCI7XG5jb25zdCBUUkFOUyQkID0gXCJbMC05QS1aYS16XFxcXChcXFxcKVxcXFwrXFxcXCxcXFxcLVxcXFwuXFxcXDpcXFxcPVxcXFxAXFxcXDtcXFxcJFxcXFxfXFxcXCFcXFxcKlxcXFwnXFxcXC9cXFxcP1xcXFwjXVwiO1xuY29uc3QgTlNTJCA9IFwiKD86KD86XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFRSQU5TJCQgKyBcIikrKVwiO1xuY29uc3QgVVJOX1NDSEVNRSA9IG5ldyBSZWdFeHAoXCJedXJuXFxcXDooXCIgKyBOSUQkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVRIID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBOSUQkICsgXCIpXFxcXDooXCIgKyBOU1MkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG5jb25zdCBVUk5fRVhDTFVERUQgPSAvW1xceDAwLVxceDIwXFxcXFxcXCJcXCZcXDxcXD5cXFtcXF1cXF5cXGBcXHtcXHxcXH1cXH5cXHg3Ri1cXHhGRl0vZztcblxuLy9SRkMgMjE0MVxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVSTkNvbXBvbmVudHMsVVJOT3B0aW9ucz4gPSB7XG5cdHNjaGVtZSA6IFwidXJuXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG5cdFx0bGV0IHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIFVSTkNvbXBvbmVudHM7XG5cblx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0Y29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcblx0XHRcdGNvbnN0IG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvbnN0IG5zcyA9IG1hdGNoZXNbMl07XG5cdFx0XHRjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWA7XG5cdFx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuXG5cdFx0XHR1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcblx0XHRcdHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuXHRcdFx0dXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0XHR1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSBhcyBVUk5Db21wb25lbnRzO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJuQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAodXJuQ29tcG9uZW50czpVUk5Db21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG5cdFx0Y29uc3QgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG5cdFx0Y29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gO1xuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG5cblx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0dXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHMgYXMgVVJJQ29tcG9uZW50cztcblx0XHRjb25zdCBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcblx0XHR1cmlDb21wb25lbnRzLnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWA7XG5cblx0XHRyZXR1cm4gdXJpQ29tcG9uZW50cztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwgImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBwY3RFbmNDaGFyLCBwY3REZWNDaGFycywgdW5lc2NhcGVDb21wb25lbnQgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgcHVueWNvZGUgZnJvbSBcInB1bnljb2RlXCI7XG5pbXBvcnQgeyBtZXJnZSwgc3ViZXhwLCB0b1VwcGVyQ2FzZSwgdG9BcnJheSB9IGZyb20gXCIuLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFpbHRvSGVhZGVycyB7XG5cdFtoZm5hbWU6c3RyaW5nXTpzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYWlsdG9Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdHRvOkFycmF5PHN0cmluZz4sXG5cdGhlYWRlcnM/Ok1haWx0b0hlYWRlcnMsXG5cdHN1YmplY3Q/OnN0cmluZyxcblx0Ym9keT86c3RyaW5nXG59XG5cbmNvbnN0IE86TWFpbHRvSGVhZGVycyA9IHt9O1xuY29uc3QgaXNJUkkgPSB0cnVlO1xuXG4vL1JGQyAzOTg2XG5jb25zdCBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG5jb25zdCBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuY29uc3QgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAgLy9leHBhbmRlZFxuXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG5jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbmNvbnN0IFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbmNvbnN0IFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbmNvbnN0IERPVF9BVE9NX1RFWFQkID0gc3ViZXhwKEFURVhUJCQgKyBcIitcIiArIHN1YmV4cChcIlxcXFwuXCIgKyBBVEVYVCQkICsgXCIrXCIpICsgXCIqXCIpO1xuY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIFZDSEFSJCQpO1xuY29uc3QgUUNPTlRFTlQkID0gc3ViZXhwKFFURVhUJCQgKyBcInxcIiArIFFVT1RFRF9QQUlSJCk7XG5jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIFFDT05URU5UJCArIFwiKlwiICsgJ1xcXFxcIicpO1xuXG4vL1JGQyA2MDY4XG5jb25zdCBEVEVYVF9OT19PQlMkJCA9IFwiW1xcXFx4MjEtXFxcXHg1QVxcXFx4NUUtXFxcXHg3RV1cIjsgIC8vJWQzMy05MCAvICVkOTQtMTI2XG5jb25zdCBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbmNvbnN0IFFDSEFSJCA9IHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCArIFwifFwiICsgU09NRV9ERUxJTVMkJCk7XG5jb25zdCBET01BSU4kID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBcIlxcXFxbXCIgKyBEVEVYVF9OT19PQlMkJCArIFwiKlwiICsgXCJcXFxcXVwiKTtcbmNvbnN0IExPQ0FMX1BBUlQkID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBRVU9URURfU1RSSU5HJCk7XG5jb25zdCBBRERSX1NQRUMkID0gc3ViZXhwKExPQ0FMX1BBUlQkICsgXCJcXFxcQFwiICsgRE9NQUlOJCk7XG5jb25zdCBUTyQgPSBzdWJleHAoQUREUl9TUEVDJCArIHN1YmV4cChcIlxcXFwsXCIgKyBBRERSX1NQRUMkKSArIFwiKlwiKTtcbmNvbnN0IEhGTkFNRSQgPSBzdWJleHAoUUNIQVIkICsgXCIqXCIpO1xuY29uc3QgSEZWQUxVRSQgPSBIRk5BTUUkO1xuY29uc3QgSEZJRUxEJCA9IHN1YmV4cChIRk5BTUUkICsgXCJcXFxcPVwiICsgSEZWQUxVRSQpO1xuY29uc3QgSEZJRUxEUzIkID0gc3ViZXhwKEhGSUVMRCQgKyBzdWJleHAoXCJcXFxcJlwiICsgSEZJRUxEJCkgKyBcIipcIik7XG5jb25zdCBIRklFTERTJCA9IHN1YmV4cChcIlxcXFw/XCIgKyBIRklFTERTMiQpO1xuY29uc3QgTUFJTFRPX1VSSSA9IG5ldyBSZWdFeHAoXCJebWFpbHRvXFxcXDpcIiArIFRPJCArIFwiP1wiICsgSEZJRUxEUyQgKyBcIj8kXCIpO1xuXG5jb25zdCBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbmNvbnN0IFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbmNvbnN0IE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbmNvbnN0IE5PVF9ET01BSU4gPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCBcIltcXFxcW11cIiwgRFRFWFRfTk9fT0JTJCQsIFwiW1xcXFxdXVwiKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuY29uc3QgVE8gPSBuZXcgUmVnRXhwKFwiXlwiICsgVE8kICsgXCIkXCIpO1xuY29uc3QgSEZJRUxEUyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIRklFTERTMiQgKyBcIiRcIik7XG5cbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcblx0cmV0dXJuICghZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcbn1cblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPE1haWx0b0NvbXBvbmVudHM+ID0gIHtcblx0c2NoZW1lIDogXCJtYWlsdG9cIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6TWFpbHRvQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgTWFpbHRvQ29tcG9uZW50cztcblx0XHRjb25zdCB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSAobWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdKTtcblx0XHRtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuXHRcdFx0bGV0IHVua25vd25IZWFkZXJzID0gZmFsc2Vcblx0XHRcdGNvbnN0IGhlYWRlcnM6TWFpbHRvSGVhZGVycyA9IHt9O1xuXHRcdFx0Y29uc3QgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuXG5cdFx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0Y29uc3QgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG5cblx0XHRcdFx0c3dpdGNoIChoZmllbGRbMF0pIHtcblx0XHRcdFx0XHRjYXNlIFwidG9cIjpcblx0XHRcdFx0XHRcdGNvbnN0IHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG9BZGRycy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdHRvLnB1c2godG9BZGRyc1t4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic3ViamVjdFwiOlxuXHRcdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJib2R5XCI6XG5cdFx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHVua25vd25IZWFkZXJzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdH1cblxuXHRcdG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG5cblx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRjb25zdCBhZGRyID0gdG9beF0uc3BsaXQoXCJAXCIpO1xuXG5cdFx0XHRhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG5cblx0XHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRvW3hdID0gYWRkci5qb2luKFwiQFwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAobWFpbHRvQ29tcG9uZW50czpNYWlsdG9Db21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzIGFzIFVSSUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuXHRcdGlmICh0bykge1xuXHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRjb25zdCB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuXHRcdFx0XHRjb25zdCBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG5cdFx0XHRcdGNvbnN0IGxvY2FsUGFydCA9ICh0b0FkZHIuc2xpY2UoMCwgYXRJZHgpKS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG5cdFx0XHRcdGxldCBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcblxuXHRcdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRvbWFpbiA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcblxuXHRcdGNvbnN0IGZpZWxkcyA9IFtdO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBoZWFkZXJzKSB7XG5cdFx0XHRpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuXHRcdFx0XHRmaWVsZHMucHVzaChcblx0XHRcdFx0XHRuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICtcblx0XHRcdFx0XHRcIj1cIiArXG5cdFx0XHRcdFx0aGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcilcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZpZWxkcy5sZW5ndGgpIHtcblx0XHRcdGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB3cyBmcm9tIFwiLi93c1wiO1xuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwid3NzXCIsXG5cdGRvbWFpbkhvc3QgOiB3cy5kb21haW5Ib3N0LFxuXHRwYXJzZSA6IHdzLnBhcnNlLFxuXHRzZXJpYWxpemUgOiB3cy5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXU0NvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzIHtcblx0cmVzb3VyY2VOYW1lPzogc3RyaW5nO1xuXHRzZWN1cmU/OiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHM6V1NDb21wb25lbnRzKTpib29sZWFuIHtcblx0cmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicgPyB3c0NvbXBvbmVudHMuc2VjdXJlIDogU3RyaW5nKHdzQ29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwid3NzXCI7XG59XG5cbi8vUkZDIDY0NTVcbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlciA9IHtcblx0c2NoZW1lIDogXCJ3c1wiLFxuXG5cdGRvbWFpbkhvc3QgOiB0cnVlLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpXU0NvbXBvbmVudHMge1xuXHRcdGNvbnN0IHdzQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgV1NDb21wb25lbnRzO1xuXG5cdFx0Ly9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG5cdFx0d3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG5cblx0XHQvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcblx0XHR3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuXHRcdHdzQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXHRcdHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcblxuXHRcdHJldHVybiB3c0NvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHdzQ29tcG9uZW50czpXU0NvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuXHRcdGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcblx0XHRcdHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG5cdFx0aWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdHdzQ29tcG9uZW50cy5zY2hlbWUgPSAod3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJyk7XG5cdFx0XHR3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcblx0XHRpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuXHRcdFx0Y29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKTtcblx0XHRcdHdzQ29tcG9uZW50cy5wYXRoID0gKHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZCk7XG5cdFx0XHR3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcblx0XHRcdHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG5cdFx0d3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuXG5cdFx0cmV0dXJuIHdzQ29tcG9uZW50cztcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCBodHRwIGZyb20gXCIuL2h0dHBcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBzXCIsXG5cdGRvbWFpbkhvc3QgOiBodHRwLmRvbWFpbkhvc3QsXG5cdHBhcnNlIDogaHR0cC5wYXJzZSxcblx0c2VyaWFsaXplIDogaHR0cC5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBcIixcblxuXHRkb21haW5Ib3N0IDogdHJ1ZSxcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9yZXBvcnQgbWlzc2luZyBob3N0XG5cdFx0aWYgKCFjb21wb25lbnRzLmhvc3QpIHtcblx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcblxuXHRcdC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcblx0XHRpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRcblx0XHQvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuXHRcdGlmICghY29tcG9uZW50cy5wYXRoKSB7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcblx0XHR9XG5cblx0XHQvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcblx0XHQvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuXHRcdC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwgIi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMSBHYXJ5IENvdXJ0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxuICogcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAqICAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogICAgICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEdBUlkgQ09VUlQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGFyZSB0aG9zZSBvZiB0aGVcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXG4gKiBvciBpbXBsaWVkLCBvZiBHYXJ5IENvdXJ0LlxuICovXG5cbmltcG9ydCBVUklfUFJPVE9DT0wgZnJvbSBcIi4vcmVnZXhwcy11cmlcIjtcbmltcG9ydCBJUklfUFJPVE9DT0wgZnJvbSBcIi4vcmVnZXhwcy1pcmlcIjtcbmltcG9ydCBwdW55Y29kZSBmcm9tIFwicHVueWNvZGVcIjtcbmltcG9ydCB7IHRvVXBwZXJDYXNlLCB0eXBlT2YsIGFzc2lnbiB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUklDb21wb25lbnRzIHtcblx0c2NoZW1lPzpzdHJpbmc7XG5cdHVzZXJpbmZvPzpzdHJpbmc7XG5cdGhvc3Q/OnN0cmluZztcblx0cG9ydD86bnVtYmVyfHN0cmluZztcblx0cGF0aD86c3RyaW5nO1xuXHRxdWVyeT86c3RyaW5nO1xuXHRmcmFnbWVudD86c3RyaW5nO1xuXHRyZWZlcmVuY2U/OnN0cmluZztcblx0ZXJyb3I/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUklPcHRpb25zIHtcblx0c2NoZW1lPzpzdHJpbmc7XG5cdHJlZmVyZW5jZT86c3RyaW5nO1xuXHR0b2xlcmFudD86Ym9vbGVhbjtcblx0YWJzb2x1dGVQYXRoPzpib29sZWFuO1xuXHRpcmk/OmJvb2xlYW47XG5cdHVuaWNvZGVTdXBwb3J0Pzpib29sZWFuO1xuXHRkb21haW5Ib3N0Pzpib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSVNjaGVtZUhhbmRsZXI8Q29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMgPSBVUklDb21wb25lbnRzLCBPcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyA9IFVSSU9wdGlvbnMsIFBhcmVudENvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzID0gVVJJQ29tcG9uZW50cz4ge1xuXHRzY2hlbWU6c3RyaW5nO1xuXHRwYXJzZShjb21wb25lbnRzOlBhcmVudENvbXBvbmVudHMsIG9wdGlvbnM6T3B0aW9ucyk6Q29tcG9uZW50cztcblx0c2VyaWFsaXplKGNvbXBvbmVudHM6Q29tcG9uZW50cywgb3B0aW9uczpPcHRpb25zKTpQYXJlbnRDb21wb25lbnRzO1xuXHR1bmljb2RlU3VwcG9ydD86Ym9vbGVhbjtcblx0ZG9tYWluSG9zdD86Ym9vbGVhbjtcblx0YWJzb2x1dGVQYXRoPzpib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSVJlZ0V4cHMge1xuXHROT1RfU0NIRU1FIDogUmVnRXhwLFxuXHROT1RfVVNFUklORk8gOiBSZWdFeHAsXG5cdE5PVF9IT1NUIDogUmVnRXhwLFxuXHROT1RfUEFUSCA6IFJlZ0V4cCxcblx0Tk9UX1BBVEhfTk9TQ0hFTUUgOiBSZWdFeHAsXG5cdE5PVF9RVUVSWSA6IFJlZ0V4cCxcblx0Tk9UX0ZSQUdNRU5UIDogUmVnRXhwLFxuXHRFU0NBUEUgOiBSZWdFeHAsXG5cdFVOUkVTRVJWRUQgOiBSZWdFeHAsXG5cdE9USEVSX0NIQVJTIDogUmVnRXhwLFxuXHRQQ1RfRU5DT0RFRCA6IFJlZ0V4cCxcblx0SVBWNEFERFJFU1MgOiBSZWdFeHAsXG5cdElQVjZBRERSRVNTIDogUmVnRXhwLFxufVxuXG5leHBvcnQgY29uc3QgU0NIRU1FUzp7W3NjaGVtZTpzdHJpbmddOlVSSVNjaGVtZUhhbmRsZXJ9ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBwY3RFbmNDaGFyKGNocjpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcblx0bGV0IGU6c3RyaW5nO1xuXG5cdGlmIChjIDwgMTYpIGUgPSBcIiUwXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKChjID4+IDYpIHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKChjICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ZWxzZSBlID0gXCIlXCIgKyAoKGMgPj4gMTIpIHwgMjI0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArICgoYyAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cblx0cmV0dXJuIGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwY3REZWNDaGFycyhzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRsZXQgbmV3U3RyID0gXCJcIjtcblx0bGV0IGkgPSAwO1xuXHRjb25zdCBpbCA9IHN0ci5sZW5ndGg7XG5cblx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdGNvbnN0IGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuXG5cdFx0aWYgKGMgPCAxMjgpIHtcblx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuXHRcdFx0aSArPSAzO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG5cdFx0XHRpZiAoKGlsIC0gaSkgPj0gNikge1xuXHRcdFx0XHRjb25zdCBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG5cdFx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcblx0XHRcdH1cblx0XHRcdGkgKz0gNjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoYyA+PSAyMjQpIHtcblx0XHRcdGlmICgoaWwgLSBpKSA+PSA5KSB7XG5cdFx0XHRcdGNvbnN0IGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcblx0XHRcdFx0Y29uc3QgYzMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA3LCAyKSwgMTYpO1xuXHRcdFx0XHRuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcblx0XHRcdH1cblx0XHRcdGkgKz0gOTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcblx0XHRcdGkgKz0gMztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3U3RyO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBwcm90b2NvbDpVUklSZWdFeHBzKSB7XG5cdGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0XHRjb25zdCBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuXHRcdHJldHVybiAoIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cik7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5zY2hlbWUpIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG5cdGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKChjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUpLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cdGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucXVlcnkgPSBTdHJpbmcoY29tcG9uZW50cy5xdWVyeSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXG5cdHJldHVybiBjb21wb25lbnRzO1xufTtcblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3Q6c3RyaW5nLCBwcm90b2NvbDpVUklSZWdFeHBzKTpzdHJpbmcge1xuXHRjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cdGNvbnN0IFssIGFkZHJlc3NdID0gbWF0Y2hlcztcblx0XG5cdGlmIChhZGRyZXNzKSB7XG5cdFx0cmV0dXJuIGFkZHJlc3Muc3BsaXQoXCIuXCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpLmpvaW4oXCIuXCIpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBob3N0O1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY2KGhvc3Q6c3RyaW5nLCBwcm90b2NvbDpVUklSZWdFeHBzKTpzdHJpbmcge1xuXHRjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cdGNvbnN0IFssIGFkZHJlc3MsIHpvbmVdID0gbWF0Y2hlcztcblxuXHRpZiAoYWRkcmVzcykge1xuXHRcdGNvbnN0IFtsYXN0LCBmaXJzdF0gPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpO1xuXHRcdGNvbnN0IGZpcnN0RmllbGRzID0gZmlyc3QgPyBmaXJzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykgOiBbXTtcblx0XHRjb25zdCBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG5cdFx0Y29uc3QgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcblx0XHRjb25zdCBmaWVsZENvdW50ID0gaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA/IDcgOiA4O1xuXHRcdGNvbnN0IGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcblx0XHRjb25zdCBmaWVsZHMgPSBBcnJheTxzdHJpbmc+KGZpZWxkQ291bnQpO1xuXG5cdFx0Zm9yIChsZXQgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcblx0XHRcdGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG5cdFx0fVxuXG5cdFx0aWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcblx0XHRcdGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2U8QXJyYXk8e2luZGV4Om51bWJlcixsZW5ndGg6bnVtYmVyfT4+KChhY2MsIGZpZWxkLCBpbmRleCkgPT4ge1xuXHRcdFx0aWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcblx0XHRcdFx0Y29uc3QgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAobGFzdExvbmdlc3QgJiYgbGFzdExvbmdlc3QuaW5kZXggKyBsYXN0TG9uZ2VzdC5sZW5ndGggPT09IGluZGV4KSB7XG5cdFx0XHRcdFx0bGFzdExvbmdlc3QubGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWNjLnB1c2goeyBpbmRleCwgbGVuZ3RoIDogMSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCBbXSk7XG5cblx0XHRjb25zdCBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClbMF07XG5cblx0XHRsZXQgbmV3SG9zdDpzdHJpbmc7XG5cdFx0aWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGNvbnN0IG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KSA7XG5cdFx0XHRjb25zdCBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcblx0XHRcdG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0hvc3QgPSBmaWVsZHMuam9pbihcIjpcIik7XG5cdFx0fVxuXG5cdFx0aWYgKHpvbmUpIHtcblx0XHRcdG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdIb3N0O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBob3N0O1xuXHR9XG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xuY29uc3QgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gKDxSZWdFeHBNYXRjaEFycmF5PihcIlwiKS5tYXRjaCgvKCl7MH0vKSlbMV0gPT09IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZzpzdHJpbmcsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9KTpVUklDb21wb25lbnRzIHtcblx0Y29uc3QgY29tcG9uZW50czpVUklDb21wb25lbnRzID0ge307XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cblx0aWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG5cblx0Y29uc3QgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xuXG5cdGlmIChtYXRjaGVzKSB7XG5cdFx0aWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuXHRcdFx0Ly9zdG9yZSBlYWNoIGNvbXBvbmVudFxuXHRcdFx0Y29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuXHRcdFx0Y29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG5cdFx0XHRjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG5cdFx0XHRjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcblxuXHRcdFx0Ly9maXggcG9ydCBudW1iZXJcblx0XHRcdGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcblx0XHRcdC8vc3RvcmUgZWFjaCBjb21wb25lbnRcblx0XHRcdGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRjb21wb25lbnRzLnVzZXJpbmZvID0gKHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xID8gbWF0Y2hlc1s3XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLmZyYWdtZW50ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkKTtcblxuXHRcdFx0Ly9maXggcG9ydCBudW1iZXJcblx0XHRcdGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMucG9ydCA9ICh1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNvbXBvbmVudHMuaG9zdCkge1xuXHRcdFx0Ly9ub3JtYWxpemUgSVAgaG9zdHNcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Ly9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcblx0XHRpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG5cdFx0fSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcblx0XHR9XG5cblx0XHQvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG5cdFx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xuXHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcblx0XHR9XG5cblx0XHQvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcblx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG5cblx0XHQvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuXHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG5cdFx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcblx0XHRcdGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vY29udmVydCBJUkkgLT4gVVJJXG5cdFx0XHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9ub3JtYWxpemUgZW5jb2RpbmdzXG5cdFx0XHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuXHRcdH1cblxuXHRcdC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuXHRcdGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcblx0XHRcdHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuXHR9XG5cblx0cmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpzdHJpbmd8dW5kZWZpbmVkIHtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblx0Y29uc3QgdXJpVG9rZW5zOkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHRpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCJAXCIpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly9ub3JtYWxpemUgSVAgaG9zdHMsIGFkZCBicmFja2V0cyBhbmQgZXNjYXBlIHpvbmUgc2VwYXJhdG9yIGZvciBJUHY2XG5cdFx0dXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIChfLCAkMSwgJDIpID0+IFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiKSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKTtcblx0fVxuXG5cdHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBSRFMxID0gL15cXC5cXC4/XFwvLztcbmNvbnN0IFJEUzIgPSAvXlxcL1xcLihcXC98JCkvO1xuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG5jb25zdCBSRFM0ID0gL15cXC5cXC4/JC87XG5jb25zdCBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQ6c3RyaW5nKTpzdHJpbmcge1xuXHRjb25zdCBvdXRwdXQ6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcblx0XHRpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgXCIvXCIpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG5cdFx0XHRvdXRwdXQucG9wKCk7XG5cdFx0fSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuXHRcdFx0aW5wdXQgPSBcIlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuXHRcdFx0aWYgKGltKSB7XG5cdFx0XHRcdGNvbnN0IHMgPSBpbVswXTtcblx0XHRcdFx0aW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aCk7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9KTpzdHJpbmcge1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cdGNvbnN0IHVyaVRva2VuczpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0Ly9maW5kIHNjaGVtZSBoYW5kbGVyXG5cdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcblxuXHQvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cblx0aWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuXG5cdGlmIChjb21wb25lbnRzLmhvc3QpIHtcblx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGFuIElQdjYgYWRkcmVzc1xuXHRcdGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHtcblx0XHRcdC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblx0XHR9XG5cblx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcblx0XHRlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuXHRcdFx0Ly9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBvbmVudHMuaG9zdCA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vbm9ybWFsaXplIGVuY29kaW5nXG5cdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG5cblx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUpO1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcblx0fVxuXG5cdGNvbnN0IGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cdGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuXHRcdFx0dXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcblx0XHR9XG5cblx0XHR1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuXG5cdFx0aWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuXHRcdFx0dXJpVG9rZW5zLnB1c2goXCIvXCIpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdGxldCBzID0gY29tcG9uZW50cy5wYXRoO1xuXG5cdFx0aWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuXHRcdFx0cyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuXHRcdH1cblxuXHRcdGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgIC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcblx0XHR9XG5cblx0XHR1cmlUb2tlbnMucHVzaChzKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIj9cIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCIjXCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuXHR9XG5cblx0cmV0dXJuIHVyaVRva2Vucy5qb2luKFwiXCIpOyAgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2U6VVJJQ29tcG9uZW50cywgcmVsYXRpdmU6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zID0ge30sIHNraXBOb3JtYWxpemF0aW9uPzpib29sZWFuKTpVUklDb21wb25lbnRzIHtcblx0Y29uc3QgdGFyZ2V0OlVSSUNvbXBvbmVudHMgPSB7fTtcblxuXHRpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG5cdFx0YmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7ICAvL25vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcblx0XHRyZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAgLy9ub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuXHR9XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcblx0XHR0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuXHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcblx0XHR0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcblx0XHR0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG5cdFx0dGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuXHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcblx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0fSBlbHNlIHtcblx0XHRpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG5cdFx0XHR0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcblx0XHRcdHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcblx0XHRcdHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcblx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcblx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXJlbGF0aXZlLnBhdGgpIHtcblx0XHRcdFx0dGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG5cdFx0XHRcdGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuXHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHRcdH1cblx0XHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuXHRcdFx0dGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mbztcblx0XHRcdHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0O1xuXHRcdFx0dGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnQ7XG5cdFx0fVxuXHRcdHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcblx0fVxuXG5cdHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJOnN0cmluZywgcmVsYXRpdmVVUkk6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZSA6ICdudWxsJyB9LCBvcHRpb25zKTtcblx0cmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKSwgc2NoZW1lbGVzc09wdGlvbnMpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTpVUklDb21wb25lbnRzLCBvcHRpb25zPzpVUklPcHRpb25zKTpVUklDb21wb25lbnRzO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6YW55LCBvcHRpb25zPzpVUklPcHRpb25zKTphbnkge1xuXHRpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB1cmk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWwodXJpQTpzdHJpbmcsIHVyaUI6c3RyaW5nLCBvcHRpb25zPzogVVJJT3B0aW9ucyk6Ym9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOlVSSUNvbXBvbmVudHMsIHVyaUI6VVJJQ29tcG9uZW50cywgb3B0aW9ucz86VVJJT3B0aW9ucyk6Ym9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOmFueSwgdXJpQjphbnksIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmJvb2xlYW4ge1xuXHRpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmlBID0gc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaUEsIG9wdGlvbnMpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG5cdH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpQiA9IHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmlCLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB1cmlBID09PSB1cmlCO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHI6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFKSwgcGN0RW5jQ2hhcik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyOnN0cmluZywgb3B0aW9ucz86VVJJT3B0aW9ucyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuUENUX0VOQ09ERUQgOiBJUklfUFJPVE9DT0wuUENUX0VOQ09ERUQpLCBwY3REZWNDaGFycyk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbmNvbnN0IGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0Y29uc3QgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0bGV0IHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0Y29uc3QgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdGNvbnN0IGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cdGxldCBjb3VudGVyID0gMDtcblx0Y29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdGNvbnN0IGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG5jb25zdCB1Y3MyZW5jb2RlID0gYXJyYXkgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uYXJyYXkpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuY29uc3QgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0bGV0IGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0bGV0IGkgPSAwO1xuXHRsZXQgbiA9IGluaXRpYWxOO1xuXHRsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yIChsZXQgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0bGV0IG9sZGkgPSBpO1xuXHRcdGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdGNvbnN0IHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRjb25zdCBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdGxldCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGRlbHRhID0gMDtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0bGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0bGV0IG0gPSBtYXhJbnQ7XG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRsZXQgcSA9IGRlbHRhO1xuXHRcdFx0XHRmb3IgKGxldCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbmNvbnN0IHRvVW5pY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG5jb25zdCB0b0FTQ0lJID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuY29uc3QgcHVueWNvZGUgPSB7XG5cdC8qKlxuXHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG5cdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHB1bnljb2RlO1xuIiwgImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IGJ1aWxkRXhwcyB9IGZyb20gXCIuL3JlZ2V4cHMtdXJpXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyh0cnVlKTtcbiIsICJpbXBvcnQgeyBVUklSZWdFeHBzIH0gZnJvbSBcIi4vdXJpXCI7XG5pbXBvcnQgeyBtZXJnZSwgc3ViZXhwIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJOmJvb2xlYW4pOlVSSVJlZ0V4cHMge1xuXHRjb25zdFxuXHRcdEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG5cdFx0Q1IkID0gXCJbXFxcXHgwRF1cIixcblx0XHRESUdJVCQkID0gXCJbMC05XVwiLFxuXHRcdERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcblx0XHRIRVhESUckJCA9IG1lcmdlKERJR0lUJCQsIFwiW0EtRmEtZl1cIiksICAvL2Nhc2UtaW5zZW5zaXRpdmVcblx0XHRMRiQkID0gXCJbXFxcXHgwQV1cIixcblx0XHRTUCQkID0gXCJbXFxcXHgyMF1cIixcblx0XHRQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksICAvL2V4cGFuZGVkXG5cdFx0R0VOX0RFTElNUyQkID0gXCJbXFxcXDpcXFxcL1xcXFw/XFxcXCNcXFxcW1xcXFxdXFxcXEBdXCIsXG5cdFx0U1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcblx0XHRSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuXHRcdFVDU0NIQVIkJCA9IGlzSVJJID8gXCJbXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXVwiIDogXCJbXVwiLCAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG5cdFx0SVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIiwgIC8vc3Vic2V0XG5cdFx0VU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG5cdFx0U0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcblx0XHRVU0VSSU5GTyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSkgKyBcIipcIiksXG5cdFx0REVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG5cdFx0REVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSwgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdFx0SVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG5cdFx0SDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG5cdFx0TFMzMiQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIgKyBIMTYkKSArIFwifFwiICsgSVBWNEFERFJFU1MkKSxcblx0XHRJUFY2QUREUkVTUzEkID0gc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTMiQgPSBzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NX1cIiArIExTMzIkKSwgLy8gICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzMkID0gc3ViZXhwKHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezR9XCIgKyBMUzMyJCksIC8vWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1M0JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwxfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInszfVwiICsgTFMzMiQpLCAvL1sgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1M1JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwyfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInsyfVwiICsgTFMzMiQpLCAvL1sgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1M2JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwzfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyAgICAgICAgSDE2JCArIFwiXFxcXDpcIiAgICAgICAgICArIExTMzIkKSwgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuXHRcdElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIExTMzIkKSwgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcblx0XHRJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBIMTYkICksIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcblx0XHRJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG5cdFx0SVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG5cdFx0Wk9ORUlEJCA9IHN1YmV4cChzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQpICsgXCIrXCIpLCAgLy9SRkMgNjg3NFxuXHRcdElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSwgIC8vUkZDIDY4NzRcblx0XHRJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSwgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdFx0SVBWRlVUVVJFJCA9IHN1YmV4cChcIlt2Vl1cIiArIEhFWERJRyQkICsgXCIrXFxcXC5cIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikgKyBcIitcIiksXG5cdFx0SVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksICAvL1JGQyA2ODc0XG5cdFx0UkVHX05BTUUkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSkgKyBcIipcIiksXG5cdFx0SE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcblx0XHRQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuXHRcdEFVVEhPUklUWSQgPSBzdWJleHAoc3ViZXhwKFVTRVJJTkZPJCArIFwiQFwiKSArIFwiP1wiICsgSE9TVCQgKyBzdWJleHAoXCJcXFxcOlwiICsgUE9SVCQpICsgXCI/XCIpLFxuXHRcdFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG5cdFx0U0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuXHRcdFNFR01FTlRfTlokID0gc3ViZXhwKFBDSEFSJCArIFwiK1wiKSxcblx0XHRTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcblx0XHRQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG5cdFx0UEFUSF9BQlNPTFVURSQgPSBzdWJleHAoXCJcXFxcL1wiICsgc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCkgKyBcIj9cIiksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfRU1QVFkkID0gXCIoPyFcIiArIFBDSEFSJCArIFwiKVwiLFxuXHRcdFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuXHRcdEZSQUdNRU5UJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8W1xcXFwvXFxcXD9dXCIpICsgXCIqXCIpLFxuXHRcdEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuXHRcdFJFTEFUSVZFX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG5cdFx0UkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuXHRcdFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG5cdFx0QUJTT0xVVEVfVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIpLFxuXG5cdFx0R0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdFJFTEFUSVZFX1JFRiQgPSBcIl4oKXswfVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0U0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRBVVRIT1JJVFlfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/JFwiXG5cdDtcblxuXHRyZXR1cm4ge1xuXHRcdE5PVF9TQ0hFTUUgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcblx0XHROT1RfVVNFUklORk8gOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfSE9TVCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUEFUSCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUEFUSF9OT1NDSEVNRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX1FVRVJZIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcblx0XHROT1RfRlJBR01FTlQgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuXHRcdEVTQ0FQRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0VU5SRVNFUlZFRCA6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG5cdFx0T1RIRVJfQ0hBUlMgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuXHRcdFBDVF9FTkNPREVEIDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcblx0XHRJUFY0QUREUkVTUyA6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcblx0XHRJUFY2QUREUkVTUyA6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBidWlsZEV4cHMoZmFsc2UpO1xuIiwgImV4cG9ydCBmdW5jdGlvbiBtZXJnZSguLi5zZXRzOkFycmF5PHN0cmluZz4pOnN0cmluZyB7XG5cdGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcblx0XHRzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG5cdFx0Y29uc3QgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG5cdFx0Zm9yIChsZXQgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG5cdFx0fVxuXHRcdHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG5cdFx0cmV0dXJuIHNldHMuam9pbignJyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHNldHNbMF07XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmV4cChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRyZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZU9mKG86YW55KTpzdHJpbmcge1xuXHRyZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IChvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShvYmo6YW55KTpBcnJheTxhbnk+IHtcblx0cmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IChvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6ICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopKSkgOiBbXTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogb2JqZWN0LCBzb3VyY2U6IGFueSk6IGFueSB7XG5cdGNvbnN0IG9iaiA9IHRhcmdldCBhcyBhbnk7XG5cdGlmIChzb3VyY2UpIHtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdG9ialtrZXldID0gc291cmNlW2tleV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmo7XG59IiwgImltcG9ydCAqIGFzIHVyaSBmcm9tIFwidXJpLWpzXCJcblxudHlwZSBVUkkgPSB0eXBlb2YgdXJpICYge2NvZGU6IHN0cmluZ31cbjsodXJpIGFzIFVSSSkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCdcblxuZXhwb3J0IGRlZmF1bHQgdXJpIGFzIFVSSVxuIiwgImV4cG9ydCB7XG4gIEZvcm1hdCxcbiAgRm9ybWF0RGVmaW5pdGlvbixcbiAgQXN5bmNGb3JtYXREZWZpbml0aW9uLFxuICBLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBNYWNyb0tleXdvcmREZWZpbml0aW9uLFxuICBGdW5jS2V5d29yZERlZmluaXRpb24sXG4gIFZvY2FidWxhcnksXG4gIFNjaGVtYSxcbiAgU2NoZW1hT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFzeW5jU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEVycm9yTm9QYXJhbXMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4vY29tcGlsZVwiXG5leHBvcnQgaW50ZXJmYWNlIFBsdWdpbjxPcHRzPiB7XG4gIChhanY6IEFqdiwgb3B0aW9ucz86IE9wdHMpOiBBanZcbiAgW3Byb3A6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQge0tleXdvcmRDeHR9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGVcIlxuZXhwb3J0IHtEZWZpbmVkRXJyb3J9IGZyb20gXCIuL3ZvY2FidWxhcmllcy9lcnJvcnNcIlxuZXhwb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5leHBvcnQge0pTT05TY2hlbWFUeXBlfSBmcm9tIFwiLi90eXBlcy9qc29uLXNjaGVtYVwiXG5leHBvcnQge0pURFNjaGVtYVR5cGUsIFNvbWVKVERTY2hlbWFUeXBlLCBKVEREYXRhVHlwZX0gZnJvbSBcIi4vdHlwZXMvanRkLXNjaGVtYVwiXG5leHBvcnQge18sIHN0ciwgc3RyaW5naWZ5LCBuaWwsIE5hbWUsIENvZGUsIENvZGVHZW4sIENvZGVHZW5PcHRpb25zfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuXG5pbXBvcnQgdHlwZSB7XG4gIFNjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIFNjaGVtYU9iamVjdCxcbiAgQXN5bmNTY2hlbWEsXG4gIFZvY2FidWxhcnksXG4gIEtleXdvcmREZWZpbml0aW9uLFxuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBGb3JtYXQsXG4gIEFkZGVkRm9ybWF0LFxuICBSZWdFeHBFbmdpbmUsXG4gIFVyaVJlc29sdmVyLFxufSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7SlNPTlNjaGVtYVR5cGV9IGZyb20gXCIuL3R5cGVzL2pzb24tc2NoZW1hXCJcbmltcG9ydCB0eXBlIHtKVERTY2hlbWFUeXBlLCBTb21lSlREU2NoZW1hVHlwZSwgSlRERGF0YVR5cGV9IGZyb20gXCIuL3R5cGVzL2p0ZC1zY2hlbWFcIlxuaW1wb3J0IFZhbGlkYXRpb25FcnJvciBmcm9tIFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIlxuaW1wb3J0IE1pc3NpbmdSZWZFcnJvciBmcm9tIFwiLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge2dldFJ1bGVzLCBWYWxpZGF0aW9uUnVsZXMsIFJ1bGUsIFJ1bGVHcm91cCwgSlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuaW1wb3J0IHtTY2hlbWFFbnYsIGNvbXBpbGVTY2hlbWEsIHJlc29sdmVTY2hlbWF9IGZyb20gXCIuL2NvbXBpbGVcIlxuaW1wb3J0IHtDb2RlLCBWYWx1ZVNjb3BlfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHtub3JtYWxpemVJZCwgZ2V0U2NoZW1hUmVmc30gZnJvbSBcIi4vY29tcGlsZS9yZXNvbHZlXCJcbmltcG9ydCB7Z2V0SlNPTlR5cGVzfSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCJcbmltcG9ydCB7ZWFjaEl0ZW19IGZyb20gXCIuL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgKiBhcyAkZGF0YVJlZlNjaGVtYSBmcm9tIFwiLi9yZWZzL2RhdGEuanNvblwiXG5cbmltcG9ydCBEZWZhdWx0VXJpUmVzb2x2ZXIgZnJvbSBcIi4vcnVudGltZS91cmlcIlxuXG5jb25zdCBkZWZhdWx0UmVnRXhwOiBSZWdFeHBFbmdpbmUgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKVxuZGVmYXVsdFJlZ0V4cC5jb2RlID0gXCJuZXcgUmVnRXhwXCJcblxuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUzogKGtleW9mIE9wdGlvbnMpW10gPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXVxuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gIFwidmFsaWRhdGVcIixcbiAgXCJzZXJpYWxpemVcIixcbiAgXCJwYXJzZVwiLFxuICBcIndyYXBwZXJcIixcbiAgXCJyb290XCIsXG4gIFwic2NoZW1hXCIsXG4gIFwia2V5d29yZFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJmb3JtYXRzXCIsXG4gIFwidmFsaWRhdGUkZGF0YVwiLFxuICBcImZ1bmNcIixcbiAgXCJvYmpcIixcbiAgXCJFcnJvclwiLFxuXSlcblxuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IEN1cnJlbnRPcHRpb25zICYgRGVwcmVjYXRlZE9wdGlvbnNcblxuZXhwb3J0IGludGVyZmFjZSBDdXJyZW50T3B0aW9ucyB7XG4gIC8vIHN0cmljdCBtb2RlIG9wdGlvbnMgKE5FVylcbiAgc3RyaWN0PzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0U2NoZW1hPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0TnVtYmVycz86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdFR5cGVzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0VHVwbGVzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0UmVxdWlyZWQ/OiBib29sZWFuIHwgXCJsb2dcIlxuICBhbGxvd01hdGNoaW5nUHJvcGVydGllcz86IGJvb2xlYW4gLy8gZGlzYWJsZXMgYSBzdHJpY3QgbW9kZSByZXN0cmljdGlvblxuICBhbGxvd1VuaW9uVHlwZXM/OiBib29sZWFuXG4gIHZhbGlkYXRlRm9ybWF0cz86IGJvb2xlYW5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgcmVwb3J0aW5nIG9wdGlvbnM6XG4gICRkYXRhPzogYm9vbGVhblxuICBhbGxFcnJvcnM/OiBib29sZWFuXG4gIHZlcmJvc2U/OiBib29sZWFuXG4gIGRpc2NyaW1pbmF0b3I/OiBib29sZWFuXG4gIHVuaWNvZGVSZWdFeHA/OiBib29sZWFuXG4gIHRpbWVzdGFtcD86IFwic3RyaW5nXCIgfCBcImRhdGVcIiAvLyBKVEQgb25seVxuICBwYXJzZURhdGU/OiBib29sZWFuIC8vIEpURCBvbmx5XG4gIGFsbG93RGF0ZT86IGJvb2xlYW4gLy8gSlREIG9ubHlcbiAgJGNvbW1lbnQ/OlxuICAgIHwgdHJ1ZVxuICAgIHwgKChjb21tZW50OiBzdHJpbmcsIHNjaGVtYVBhdGg/OiBzdHJpbmcsIHJvb3RTY2hlbWE/OiBBbnlTY2hlbWFPYmplY3QpID0+IHVua25vd24pXG4gIGZvcm1hdHM/OiB7W05hbWUgaW4gc3RyaW5nXT86IEZvcm1hdH1cbiAga2V5d29yZHM/OiBWb2NhYnVsYXJ5XG4gIHNjaGVtYXM/OiBBbnlTY2hlbWFbXSB8IHtbS2V5IGluIHN0cmluZ10/OiBBbnlTY2hlbWF9XG4gIGxvZ2dlcj86IExvZ2dlciB8IGZhbHNlXG4gIGxvYWRTY2hlbWE/OiAodXJpOiBzdHJpbmcpID0+IFByb21pc2U8QW55U2NoZW1hT2JqZWN0PlxuICAvLyBvcHRpb25zIHRvIG1vZGlmeSB2YWxpZGF0ZWQgZGF0YTpcbiAgcmVtb3ZlQWRkaXRpb25hbD86IGJvb2xlYW4gfCBcImFsbFwiIHwgXCJmYWlsaW5nXCJcbiAgdXNlRGVmYXVsdHM/OiBib29sZWFuIHwgXCJlbXB0eVwiXG4gIGNvZXJjZVR5cGVzPzogYm9vbGVhbiB8IFwiYXJyYXlcIlxuICAvLyBhZHZhbmNlZCBvcHRpb25zOlxuICBuZXh0PzogYm9vbGVhbiAvLyBORVdcbiAgdW5ldmFsdWF0ZWQ/OiBib29sZWFuIC8vIE5FV1xuICBkeW5hbWljUmVmPzogYm9vbGVhbiAvLyBORVdcbiAgc2NoZW1hSWQ/OiBcImlkXCIgfCBcIiRpZFwiXG4gIGp0ZD86IGJvb2xlYW4gLy8gTkVXXG4gIG1ldGE/OiBTY2hlbWFPYmplY3QgfCBib29sZWFuXG4gIGRlZmF1bHRNZXRhPzogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0XG4gIHZhbGlkYXRlU2NoZW1hPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgYWRkVXNlZFNjaGVtYT86IGJvb2xlYW5cbiAgaW5saW5lUmVmcz86IGJvb2xlYW4gfCBudW1iZXJcbiAgcGFzc0NvbnRleHQ/OiBib29sZWFuXG4gIGxvb3BSZXF1aXJlZD86IG51bWJlclxuICBsb29wRW51bT86IG51bWJlciAvLyBORVdcbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbiAgbXVsdGlwbGVPZlByZWNpc2lvbj86IG51bWJlclxuICBpbnQzMnJhbmdlPzogYm9vbGVhbiAvLyBKVEQgb25seVxuICBtZXNzYWdlcz86IGJvb2xlYW5cbiAgY29kZT86IENvZGVPcHRpb25zIC8vIE5FV1xuICB1cmlSZXNvbHZlcj86IFVyaVJlc29sdmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZU9wdGlvbnMge1xuICBlczU/OiBib29sZWFuXG4gIGVzbT86IGJvb2xlYW5cbiAgbGluZXM/OiBib29sZWFuXG4gIG9wdGltaXplPzogYm9vbGVhbiB8IG51bWJlclxuICBmb3JtYXRzPzogQ29kZSAvLyBjb2RlIHRvIHJlcXVpcmUgKG9yIGNvbnN0cnVjdCkgbWFwIG9mIGF2YWlsYWJsZSBmb3JtYXRzIC0gZm9yIHN0YW5kYWxvbmUgY29kZVxuICBzb3VyY2U/OiBib29sZWFuXG4gIHByb2Nlc3M/OiAoY29kZTogc3RyaW5nLCBzY2hlbWE/OiBTY2hlbWFFbnYpID0+IHN0cmluZ1xuICByZWdFeHA/OiBSZWdFeHBFbmdpbmVcbn1cblxuaW50ZXJmYWNlIEluc3RhbmNlQ29kZU9wdGlvbnMgZXh0ZW5kcyBDb2RlT3B0aW9ucyB7XG4gIHJlZ0V4cDogUmVnRXhwRW5naW5lXG4gIG9wdGltaXplOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIERlcHJlY2F0ZWRPcHRpb25zIHtcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGlnbm9yZUtleXdvcmRzV2l0aFJlZj86IGJvb2xlYW5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGpzUHJvcGVydHlTeW50YXg/OiBib29sZWFuIC8vIGFkZGVkIGluc3RlYWQgb2YganNvblBvaW50ZXJzXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICB1bmljb2RlPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgUmVtb3ZlZE9wdGlvbnMge1xuICBmb3JtYXQ/OiBib29sZWFuXG4gIGVycm9yRGF0YVBhdGg/OiBcIm9iamVjdFwiIHwgXCJwcm9wZXJ0eVwiXG4gIG51bGxhYmxlPzogYm9vbGVhbiAvLyBcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdFxuICBqc29uUG9pbnRlcnM/OiBib29sZWFuXG4gIGV4dGVuZFJlZnM/OiB0cnVlIHwgXCJpZ25vcmVcIiB8IFwiZmFpbFwiXG4gIG1pc3NpbmdSZWZzPzogdHJ1ZSB8IFwiaWdub3JlXCIgfCBcImZhaWxcIlxuICBwcm9jZXNzQ29kZT86IChjb2RlOiBzdHJpbmcsIHNjaGVtYT86IFNjaGVtYUVudikgPT4gc3RyaW5nXG4gIHNvdXJjZUNvZGU/OiBib29sZWFuXG4gIHN0cmljdERlZmF1bHRzPzogYm9vbGVhblxuICBzdHJpY3RLZXl3b3Jkcz86IGJvb2xlYW5cbiAgdW5pcXVlSXRlbXM/OiBib29sZWFuXG4gIHVua25vd25Gb3JtYXRzPzogdHJ1ZSB8IHN0cmluZ1tdIHwgXCJpZ25vcmVcIlxuICBjYWNoZT86IGFueVxuICBzZXJpYWxpemU/OiAoc2NoZW1hOiBBbnlTY2hlbWEpID0+IHVua25vd25cbiAgYWp2RXJyb3JzPzogYm9vbGVhblxufVxuXG50eXBlIE9wdGlvbnNJbmZvPFQgZXh0ZW5kcyBSZW1vdmVkT3B0aW9ucyB8IERlcHJlY2F0ZWRPcHRpb25zPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmNvbnN0IHJlbW92ZWRPcHRpb25zOiBPcHRpb25zSW5mbzxSZW1vdmVkT3B0aW9ucz4gPSB7XG4gIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufVxuXG5jb25zdCBkZXByZWNhdGVkT3B0aW9uczogT3B0aW9uc0luZm88RGVwcmVjYXRlZE9wdGlvbnM+ID0ge1xuICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn1cblxudHlwZSBSZXF1aXJlZEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgW0sgaW5cbiAgICB8IFwic3RyaWN0U2NoZW1hXCJcbiAgICB8IFwic3RyaWN0TnVtYmVyc1wiXG4gICAgfCBcInN0cmljdFR5cGVzXCJcbiAgICB8IFwic3RyaWN0VHVwbGVzXCJcbiAgICB8IFwic3RyaWN0UmVxdWlyZWRcIlxuICAgIHwgXCJpbmxpbmVSZWZzXCJcbiAgICB8IFwibG9vcFJlcXVpcmVkXCJcbiAgICB8IFwibG9vcEVudW1cIlxuICAgIHwgXCJtZXRhXCJcbiAgICB8IFwibWVzc2FnZXNcIlxuICAgIHwgXCJzY2hlbWFJZFwiXG4gICAgfCBcImFkZFVzZWRTY2hlbWFcIlxuICAgIHwgXCJ2YWxpZGF0ZVNjaGVtYVwiXG4gICAgfCBcInZhbGlkYXRlRm9ybWF0c1wiXG4gICAgfCBcImludDMycmFuZ2VcIlxuICAgIHwgXCJ1bmljb2RlUmVnRXhwXCJcbiAgICB8IFwidXJpUmVzb2x2ZXJcIl06IE5vbk51bGxhYmxlPE9wdGlvbnNbS10+XG59ICYge2NvZGU6IEluc3RhbmNlQ29kZU9wdGlvbnN9XG5cbmV4cG9ydCB0eXBlIEluc3RhbmNlT3B0aW9ucyA9IE9wdGlvbnMgJiBSZXF1aXJlZEluc3RhbmNlT3B0aW9uc1xuXG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMFxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG86IE9wdGlvbnMpOiBSZXF1aXJlZEluc3RhbmNlT3B0aW9ucyB7XG4gIGNvbnN0IHMgPSBvLnN0cmljdFxuICBjb25zdCBfb3B0eiA9IG8uY29kZT8ub3B0aW1pemVcbiAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDBcbiAgY29uc3QgcmVnRXhwID0gby5jb2RlPy5yZWdFeHAgPz8gZGVmYXVsdFJlZ0V4cFxuICBjb25zdCB1cmlSZXNvbHZlciA9IG8udXJpUmVzb2x2ZXIgPz8gRGVmYXVsdFVyaVJlc29sdmVyXG4gIHJldHVybiB7XG4gICAgc3RyaWN0U2NoZW1hOiBvLnN0cmljdFNjaGVtYSA/PyBzID8/IHRydWUsXG4gICAgc3RyaWN0TnVtYmVyczogby5zdHJpY3ROdW1iZXJzID8/IHMgPz8gdHJ1ZSxcbiAgICBzdHJpY3RUeXBlczogby5zdHJpY3RUeXBlcyA/PyBzID8/IFwibG9nXCIsXG4gICAgc3RyaWN0VHVwbGVzOiBvLnN0cmljdFR1cGxlcyA/PyBzID8/IFwibG9nXCIsXG4gICAgc3RyaWN0UmVxdWlyZWQ6IG8uc3RyaWN0UmVxdWlyZWQgPz8gcyA/PyBmYWxzZSxcbiAgICBjb2RlOiBvLmNvZGUgPyB7Li4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwfSA6IHtvcHRpbWl6ZSwgcmVnRXhwfSxcbiAgICBsb29wUmVxdWlyZWQ6IG8ubG9vcFJlcXVpcmVkID8/IE1BWF9FWFBSRVNTSU9OLFxuICAgIGxvb3BFbnVtOiBvLmxvb3BFbnVtID8/IE1BWF9FWFBSRVNTSU9OLFxuICAgIG1ldGE6IG8ubWV0YSA/PyB0cnVlLFxuICAgIG1lc3NhZ2VzOiBvLm1lc3NhZ2VzID8/IHRydWUsXG4gICAgaW5saW5lUmVmczogby5pbmxpbmVSZWZzID8/IHRydWUsXG4gICAgc2NoZW1hSWQ6IG8uc2NoZW1hSWQgPz8gXCIkaWRcIixcbiAgICBhZGRVc2VkU2NoZW1hOiBvLmFkZFVzZWRTY2hlbWEgPz8gdHJ1ZSxcbiAgICB2YWxpZGF0ZVNjaGVtYTogby52YWxpZGF0ZVNjaGVtYSA/PyB0cnVlLFxuICAgIHZhbGlkYXRlRm9ybWF0czogby52YWxpZGF0ZUZvcm1hdHMgPz8gdHJ1ZSxcbiAgICB1bmljb2RlUmVnRXhwOiBvLnVuaWNvZGVSZWdFeHAgPz8gdHJ1ZSxcbiAgICBpbnQzMnJhbmdlOiBvLmludDMycmFuZ2UgPz8gdHJ1ZSxcbiAgICB1cmlSZXNvbHZlcjogdXJpUmVzb2x2ZXIsXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICBsb2coLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxuICB3YXJuKC4uLmFyZ3M6IHVua25vd25bXSk6IHVua25vd25cbiAgZXJyb3IoLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBanYge1xuICBvcHRzOiBJbnN0YW5jZU9wdGlvbnNcbiAgZXJyb3JzPzogRXJyb3JPYmplY3RbXSB8IG51bGwgLy8gZXJyb3JzIGZyb20gdGhlIGxhc3QgdmFsaWRhdGlvblxuICBsb2dnZXI6IExvZ2dlclxuICAvLyBzaGFyZWQgZXh0ZXJuYWwgc2NvcGUgdmFsdWVzIGZvciBjb21waWxlZCBmdW5jdGlvbnNcbiAgcmVhZG9ubHkgc2NvcGU6IFZhbHVlU2NvcGVcbiAgcmVhZG9ubHkgc2NoZW1hczoge1tLZXkgaW4gc3RyaW5nXT86IFNjaGVtYUVudn0gPSB7fVxuICByZWFkb25seSByZWZzOiB7W1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgc3RyaW5nfSA9IHt9XG4gIHJlYWRvbmx5IGZvcm1hdHM6IHtbTmFtZSBpbiBzdHJpbmddPzogQWRkZWRGb3JtYXR9ID0ge31cbiAgcmVhZG9ubHkgUlVMRVM6IFZhbGlkYXRpb25SdWxlc1xuICByZWFkb25seSBfY29tcGlsYXRpb25zOiBTZXQ8U2NoZW1hRW52PiA9IG5ldyBTZXQoKVxuICBwcml2YXRlIHJlYWRvbmx5IF9sb2FkaW5nOiB7W1JlZiBpbiBzdHJpbmddPzogUHJvbWlzZTxBbnlTY2hlbWFPYmplY3Q+fSA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NhY2hlOiBNYXA8QW55U2NoZW1hLCBTY2hlbWFFbnY+ID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgcmVhZG9ubHkgX21ldGFPcHRzOiBJbnN0YW5jZU9wdGlvbnNcblxuICBzdGF0aWMgVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yXG4gIHN0YXRpYyBNaXNzaW5nUmVmRXJyb3IgPSBNaXNzaW5nUmVmRXJyb3JcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICBvcHRzID0gdGhpcy5vcHRzID0gey4uLm9wdHMsIC4uLnJlcXVpcmVkT3B0aW9ucyhvcHRzKX1cbiAgICBjb25zdCB7ZXM1LCBsaW5lc30gPSB0aGlzLm9wdHMuY29kZVxuXG4gICAgdGhpcy5zY29wZSA9IG5ldyBWYWx1ZVNjb3BlKHtzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXN9KVxuICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKVxuICAgIGNvbnN0IGZvcm1hdE9wdCA9IG9wdHMudmFsaWRhdGVGb3JtYXRzXG4gICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZVxuXG4gICAgdGhpcy5SVUxFUyA9IGdldFJ1bGVzKClcbiAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpXG4gICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIilcbiAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcylcblxuICAgIGlmIChvcHRzLmZvcm1hdHMpIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcylcbiAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKVxuICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKClcbiAgICBpZiAob3B0cy5rZXl3b3JkcykgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3JkcylcbiAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKSB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKVxuICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcylcbiAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdFxuICB9XG5cbiAgX2FkZFZvY2FidWxhcmllcygpOiB2b2lkIHtcbiAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIilcbiAgfVxuXG4gIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpOiB2b2lkIHtcbiAgICBjb25zdCB7JGRhdGEsIG1ldGEsIHNjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGxldCBfZGF0YVJlZlNjaGVtYTogU2NoZW1hT2JqZWN0ID0gJGRhdGFSZWZTY2hlbWFcbiAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7Li4uJGRhdGFSZWZTY2hlbWF9XG4gICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZFxuICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZFxuICAgIH1cbiAgICBpZiAobWV0YSAmJiAkZGF0YSkgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKVxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB7bWV0YSwgc2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZClcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGRhdGEgdXNpbmcgc2NoZW1hXG4gIC8vIEFueVNjaGVtYSB3aWxsIGJlIGNvbXBpbGVkIGFuZCBjYWNoZWQgdXNpbmcgc2NoZW1hIGl0c2VsZiBhcyBhIGtleSBmb3IgTWFwXG4gIHZhbGlkYXRlKHNjaGVtYTogU2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogYm9vbGVhblxuICB2YWxpZGF0ZShzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGJvb2xlYW4gfCBQcm9taXNlPHVua25vd24+XG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogU2NoZW1hIHwgSlNPTlNjaGVtYVR5cGU8VD4gfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBkYXRhIGlzIFRcbiAgLy8gU2VwYXJhdGVkIGZvciB0eXBlIGluZmVyZW5jZSB0byB3b3JrXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogSlREU2NoZW1hVHlwZTxUPiwgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVFxuICAvLyBUaGlzIG92ZXJsb2FkIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHR5cGVzY3JpcHQgaW5mZXJlbmNlLCB0aGUgZmlyc3RcbiAgLy8gYXJndW1lbnQgcHJldmVudHMgbWFudWFsIHR5cGUgYW5ub3RhdGlvbiBmcm9tIG1hdGNoaW5nIHRoaXMgb3ZlcmxvYWRcbiAgdmFsaWRhdGU8TiBleHRlbmRzIG5ldmVyLCBUIGV4dGVuZHMgU29tZUpURFNjaGVtYVR5cGU+KFxuICAgIHNjaGVtYTogVCxcbiAgICBkYXRhOiB1bmtub3duXG4gICk6IGRhdGEgaXMgSlRERGF0YVR5cGU8VD5cbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBBc3luY1NjaGVtYSwgZGF0YTogdW5rbm93biB8IFQpOiBQcm9taXNlPFQ+XG4gIHZhbGlkYXRlPFQ+KHNjaGVtYUtleVJlZjogQW55U2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogZGF0YSBpcyBUIHwgUHJvbWlzZTxUPlxuICB2YWxpZGF0ZTxUPihcbiAgICBzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIGRhdGE6IHVua25vd24gfCBUIC8vIHRvIGJlIHZhbGlkYXRlZFxuICApOiBib29sZWFuIHwgUHJvbWlzZTxUPiB7XG4gICAgbGV0IHY6IEFueVZhbGlkYXRlRnVuY3Rpb24gfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2ID0gdGhpcy5nZXRTY2hlbWE8VD4oc2NoZW1hS2V5UmVmKVxuICAgICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApXG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSB0aGlzLmNvbXBpbGU8VD4oc2NoZW1hS2V5UmVmKVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKVxuICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpIHRoaXMuZXJyb3JzID0gdi5lcnJvcnNcbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIC8vIENyZWF0ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hXG4gIC8vIF9tZXRhOiB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHkgdG8gY29tcGlsZSBtZXRhIHNjaGVtYXMgb2YgdXNlci1kZWZpbmVkIGtleXdvcmRzLlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IFNjaGVtYSB8IEpTT05TY2hlbWFUeXBlPFQ+LCBfbWV0YT86IGJvb2xlYW4pOiBWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFZhbGlkYXRlRnVuY3Rpb248VD5cbiAgLy8gVGhpcyBvdmVybG9hZCBpcyBvbmx5IGludGVuZGVkIGZvciB0eXBlc2NyaXB0IGluZmVyZW5jZSwgdGhlIGZpcnN0XG4gIC8vIGFyZ3VtZW50IHByZXZlbnRzIG1hbnVhbCB0eXBlIGFubm90YXRpb24gZnJvbSBtYXRjaGluZyB0aGlzIG92ZXJsb2FkXG4gIGNvbXBpbGU8TiBleHRlbmRzIG5ldmVyLCBUIGV4dGVuZHMgU29tZUpURFNjaGVtYVR5cGU+KFxuICAgIHNjaGVtYTogVCxcbiAgICBfbWV0YT86IGJvb2xlYW5cbiAgKTogVmFsaWRhdGVGdW5jdGlvbjxKVEREYXRhVHlwZTxUPj5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBc3luY1NjaGVtYSwgX21ldGE/OiBib29sZWFuKTogQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQW55U2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQW55U2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHtcbiAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSlcbiAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpIGFzIEFueVZhbGlkYXRlRnVuY3Rpb248VD5cbiAgfVxuXG4gIC8vIENyZWF0ZXMgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYSB3aXRoIGFzeW5jaHJvbm91cyBsb2FkaW5nIG9mIG1pc3Npbmcgc2NoZW1hcy5cbiAgLy8gYGxvYWRTY2hlbWFgIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgc2NoZW1hIHVyaSBhbmQgcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2NoZW1hLlxuICAvLyBUT0RPIGFsbG93IHBhc3Npbmcgc2NoZW1hIFVSSVxuICAvLyBtZXRhIC0gb3B0aW9uYWwgdHJ1ZSB0byBjb21waWxlIG1ldGEtc2NoZW1hXG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oXG4gICAgc2NoZW1hOiBTY2hlbWFPYmplY3QgfCBKU09OU2NoZW1hVHlwZTxUPixcbiAgICBfbWV0YT86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICAvLyBTZXBhcmF0ZWQgZm9yIHR5cGUgaW5mZXJlbmNlIHRvIHdvcmtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFByb21pc2U8VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihzY2hlbWE6IEFzeW5jU2NoZW1hLCBtZXRhPzogYm9vbGVhbik6IFByb21pc2U8QXN5bmNWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIG1ldGE/OiBib29sZWFuXG4gICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBtZXRhPzogYm9vbGVhblxuICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb248VD4+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5sb2FkU2NoZW1hICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpXG4gICAgfVxuICAgIGNvbnN0IHtsb2FkU2NoZW1hfSA9IHRoaXMub3B0c1xuICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpXG5cbiAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoXG4gICAgICB0aGlzOiBBanYsXG4gICAgICBfc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAgICBfbWV0YT86IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb24+IHtcbiAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKVxuICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKVxuICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKHRoaXM6IEFqdiwgJHJlZj86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHskcmVmfSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb24+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE1pc3NpbmdSZWZFcnJvcikpIHRocm93IGVcbiAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKVxuICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSlcbiAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQodGhpczogQWp2LCB7bWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmfTogTWlzc2luZ1JlZkVycm9yKTogdm9pZCB7XG4gICAgICBpZiAodGhpcy5yZWZzW3JlZl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZilcbiAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKVxuICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSkgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkU2NoZW1hKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBQcm9taXNlPEFueVNjaGVtYU9iamVjdD4ge1xuICAgICAgY29uc3QgcCA9IHRoaXMuX2xvYWRpbmdbcmVmXVxuICAgICAgaWYgKHApIHJldHVybiBwXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuX2xvYWRpbmdbcmVmXSA9IGxvYWRTY2hlbWEocmVmKSlcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgYWRkU2NoZW1hKFxuICAgIHNjaGVtYTogQW55U2NoZW1hIHwgQW55U2NoZW1hW10sIC8vIElmIGFycmF5IGlzIHBhc3NlZCwgYGtleWAgd2lsbCBiZSBpZ25vcmVkXG4gICAga2V5Pzogc3RyaW5nLCAvLyBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgIF9tZXRhPzogYm9vbGVhbiwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICk6IEFqdiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2NoZW1hKSB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGxldCBpZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXVxuICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgJHtzY2hlbWFJZH0gbXVzdCBiZSBzdHJpbmdgKVxuICAgICAgfVxuICAgIH1cbiAgICBrZXkgPSBub3JtYWxpemVJZChrZXkgfHwgaWQpXG4gICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KVxuICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgYWRkTWV0YVNjaGVtYShcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBrZXk/OiBzdHJpbmcsIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICApOiBBanYge1xuICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hOiBBbnlTY2hlbWEsIHRocm93T3JMb2dFcnJvcj86IGJvb2xlYW4pOiBib29sZWFuIHwgUHJvbWlzZTx1bmtub3duPiB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB0cnVlXG4gICAgbGV0ICRzY2hlbWE6IHN0cmluZyB8IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYVxuICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpXG4gICAgfVxuICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKClcbiAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpXG4gICAgICB0aGlzLmVycm9ycyA9IG51bGxcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpXG4gICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpXG4gICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKSB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkXG4gIH1cblxuICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgZ2V0U2NoZW1hPFQgPSB1bmtub3duPihrZXlSZWY6IHN0cmluZyk6IEFueVZhbGlkYXRlRnVuY3Rpb248VD4gfCB1bmRlZmluZWQge1xuICAgIGxldCBzY2hcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKSBrZXlSZWYgPSBzY2hcbiAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICAgIGNvbnN0IHJvb3QgPSBuZXcgU2NoZW1hRW52KHtzY2hlbWE6IHt9LCBzY2hlbWFJZH0pXG4gICAgICBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKVxuICAgICAgaWYgKCFzY2gpIHJldHVyblxuICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2hcbiAgICB9XG4gICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKSBhcyBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHwgdW5kZWZpbmVkXG4gIH1cblxuICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmPzogQW55U2NoZW1hIHwgc3RyaW5nIHwgUmVnRXhwKTogQWp2IHtcbiAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKVxuICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcylcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpXG4gICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKVxuICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl1cbiAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWZcbiAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KVxuICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdXG4gICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIilcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9uczogVm9jYWJ1bGFyeSk6IEFqdiB7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpIHRoaXMuYWRkS2V5d29yZChkZWYpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGFkZEtleXdvcmQoXG4gICAga3dkT3JEZWY6IHN0cmluZyB8IEtleXdvcmREZWZpbml0aW9uLFxuICAgIGRlZj86IEtleXdvcmREZWZpbml0aW9uIC8vIGRlcHJlY2F0ZWRcbiAgKTogQWp2IHtcbiAgICBsZXQga2V5d29yZDogc3RyaW5nIHwgc3RyaW5nW11cbiAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGtleXdvcmQgPSBrd2RPckRlZlxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIilcbiAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVmID0ga3dkT3JEZWZcbiAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIilcbiAgICB9XG5cbiAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpXG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIGVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpXG4gICAgY29uc3QgZGVmaW5pdGlvbjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAgICAgIC4uLmRlZixcbiAgICAgIHR5cGU6IGdldEpTT05UeXBlcyhkZWYudHlwZSksXG4gICAgICBzY2hlbWFUeXBlOiBnZXRKU09OVHlwZXMoZGVmLnNjaGVtYVR5cGUpLFxuICAgIH1cbiAgICBlYWNoSXRlbShcbiAgICAgIGtleXdvcmQsXG4gICAgICBkZWZpbml0aW9uLnR5cGUubGVuZ3RoID09PSAwXG4gICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKVxuICAgIClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0S2V5d29yZChrZXl3b3JkOiBzdHJpbmcpOiBBZGRlZEtleXdvcmREZWZpbml0aW9uIHwgYm9vbGVhbiB7XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdXG4gICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGVcbiAgfVxuXG4gIC8vIFJlbW92ZSBrZXl3b3JkXG4gIHJlbW92ZUtleXdvcmQoa2V5d29yZDogc3RyaW5nKTogQWp2IHtcbiAgICAvLyBUT0RPIHJldHVybiB0eXBlIHNob3VsZCBiZSBBanZcbiAgICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXVxuICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF1cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSB7XG4gICAgICBjb25zdCBpID0gZ3JvdXAucnVsZXMuZmluZEluZGV4KChydWxlKSA9PiBydWxlLmtleXdvcmQgPT09IGtleXdvcmQpXG4gICAgICBpZiAoaSA+PSAwKSBncm91cC5ydWxlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEFkZCBmb3JtYXRcbiAgYWRkRm9ybWF0KG5hbWU6IHN0cmluZywgZm9ybWF0OiBGb3JtYXQpOiBBanYge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwic3RyaW5nXCIpIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KVxuICAgIHRoaXMuZm9ybWF0c1tuYW1lXSA9IGZvcm1hdFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlcnJvcnNUZXh0KFxuICAgIGVycm9yczogRXJyb3JPYmplY3RbXSB8IG51bGwgfCB1bmRlZmluZWQgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7c2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCJ9OiBFcnJvcnNUZXh0T3B0aW9ucyA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAoIWVycm9ycyB8fCBlcnJvcnMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBlcnJvcnNcIlxuICAgIHJldHVybiBlcnJvcnNcbiAgICAgIC5tYXAoKGUpID0+IGAke2RhdGFWYXJ9JHtlLmluc3RhbmNlUGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIC5yZWR1Y2UoKHRleHQsIG1zZykgPT4gdGV4dCArIHNlcGFyYXRvciArIG1zZylcbiAgfVxuXG4gICRkYXRhTWV0YVNjaGVtYShtZXRhU2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsIGtleXdvcmRzSnNvblBvaW50ZXJzOiBzdHJpbmdbXSk6IEFueVNjaGVtYU9iamVjdCB7XG4gICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbFxuICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKVxuICAgIGZvciAoY29uc3QganNvblBvaW50ZXIgb2Yga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpLnNsaWNlKDEpIC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hXG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cykga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddIGFzIEFueVNjaGVtYU9iamVjdFxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIikgY29udGludWVcbiAgICAgICAgY29uc3QgeyRkYXRhfSA9IHJ1bGUuZGVmaW5pdGlvblxuICAgICAgICBjb25zdCBzY2hlbWEgPSBrZXl3b3Jkc1trZXldIGFzIEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKSBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YVNjaGVtYVxuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzOiB7W1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgc3RyaW5nfSwgcmVnZXg/OiBSZWdFeHApOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl1cbiAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKVxuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hZGRTY2hlbWEoXG4gICAgc2NoZW1hOiBBbnlTY2hlbWEsXG4gICAgbWV0YT86IGJvb2xlYW4sXG4gICAgYmFzZUlkPzogc3RyaW5nLFxuICAgIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLFxuICAgIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hXG4gICk6IFNjaGVtYUVudiB7XG4gICAgbGV0IGlkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdHMuanRkKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIilcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIpIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpXG4gICAgfVxuICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKVxuICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZCkgcmV0dXJuIHNjaFxuXG4gICAgYmFzZUlkID0gbm9ybWFsaXplSWQoaWQgfHwgYmFzZUlkKVxuICAgIGNvbnN0IGxvY2FsUmVmcyA9IGdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEsIGJhc2VJZClcbiAgICBzY2ggPSBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmc30pXG4gICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaClcbiAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICBpZiAoYmFzZUlkKSB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpXG4gICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaFxuICAgIH1cbiAgICBpZiAodmFsaWRhdGVTY2hlbWEpIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKVxuICAgIHJldHVybiBzY2hcbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrVW5pcXVlKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NvbXBpbGVTY2hlbWFFbnYoc2NoOiBTY2hlbWFFbnYpOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uIHtcbiAgICBpZiAoc2NoLm1ldGEpIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaClcbiAgICBlbHNlIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXNjaC52YWxpZGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICB9XG5cbiAgcHJpdmF0ZSBfY29tcGlsZU1ldGFTY2hlbWEoc2NoOiBTY2hlbWFFbnYpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0c1xuICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JzVGV4dE9wdGlvbnMge1xuICBzZXBhcmF0b3I/OiBzdHJpbmdcbiAgZGF0YVZhcj86IHN0cmluZ1xufVxuXG5mdW5jdGlvbiBjaGVja09wdGlvbnMoXG4gIHRoaXM6IEFqdixcbiAgY2hlY2tPcHRzOiBPcHRpb25zSW5mbzxSZW1vdmVkT3B0aW9ucyB8IERlcHJlY2F0ZWRPcHRpb25zPixcbiAgb3B0aW9uczogT3B0aW9ucyAmIFJlbW92ZWRPcHRpb25zLFxuICBtc2c6IHN0cmluZyxcbiAgbG9nOiBcIndhcm5cIiB8IFwiZXJyb3JcIiA9IFwiZXJyb3JcIlxuKTogdm9pZCB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgIGNvbnN0IG9wdCA9IGtleSBhcyBrZXlvZiB0eXBlb2YgY2hlY2tPcHRzXG4gICAgaWYgKG9wdCBpbiBvcHRpb25zKSB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY2hFbnYodGhpczogQWp2LCBrZXlSZWY6IHN0cmluZyk6IFNjaGVtYUVudiB8IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGtleVJlZiA9IG5vcm1hbGl6ZUlkKGtleVJlZikgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gIHJldHVybiB0aGlzLnNjaGVtYXNba2V5UmVmXSB8fCB0aGlzLnJlZnNba2V5UmVmXVxufVxuXG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcyh0aGlzOiBBanYpOiB2b2lkIHtcbiAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hc1xuICBpZiAoIW9wdHNTY2hlbWFzKSByZXR1cm5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKSB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcylcbiAgZWxzZSBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcykgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSBhcyBBbnlTY2hlbWEsIGtleSlcbn1cblxuZnVuY3Rpb24gYWRkSW5pdGlhbEZvcm1hdHModGhpczogQWp2KTogdm9pZCB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMub3B0cy5mb3JtYXRzW25hbWVdXG4gICAgaWYgKGZvcm1hdCkgdGhpcy5hZGRGb3JtYXQobmFtZSwgZm9ybWF0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhcbiAgdGhpczogQWp2LFxuICBkZWZzOiBWb2NhYnVsYXJ5IHwge1tLIGluIHN0cmluZ10/OiBLZXl3b3JkRGVmaW5pdGlvbn1cbik6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgIHRoaXMuYWRkVm9jYWJ1bGFyeShkZWZzKVxuICAgIHJldHVyblxuICB9XG4gIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIilcbiAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdIGFzIEtleXdvcmREZWZpbml0aW9uXG4gICAgaWYgKCFkZWYua2V5d29yZCkgZGVmLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgdGhpcy5hZGRLZXl3b3JkKGRlZilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucyh0aGlzOiBBanYpOiBJbnN0YW5jZU9wdGlvbnMge1xuICBjb25zdCBtZXRhT3B0cyA9IHsuLi50aGlzLm9wdHN9XG4gIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpIGRlbGV0ZSBtZXRhT3B0c1tvcHRdXG4gIHJldHVybiBtZXRhT3B0c1xufVxuXG5jb25zdCBub0xvZ3MgPSB7bG9nKCkge30sIHdhcm4oKSB7fSwgZXJyb3IoKSB7fX1cblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcj86IFBhcnRpYWw8TG9nZ2VyPiB8IGZhbHNlKTogTG9nZ2VyIHtcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHJldHVybiBub0xvZ3NcbiAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY29uc29sZVxuICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpIHJldHVybiBsb2dnZXIgYXMgTG9nZ2VyXG4gIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIilcbn1cblxuY29uc3QgS0VZV09SRF9OQU1FID0gL15bYS16XyRdW2EtejAtOV8kOi1dKiQvaVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmQodGhpczogQWp2LCBrZXl3b3JkOiBzdHJpbmcgfCBzdHJpbmdbXSwgZGVmPzogS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge1JVTEVTfSA9IHRoaXNcbiAgZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKSB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApXG4gICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKSB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKVxuICB9KVxuICBpZiAoIWRlZikgcmV0dXJuXG4gIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVsZShcbiAgdGhpczogQWp2LFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gIGRlZmluaXRpb24/OiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBkYXRhVHlwZT86IEpTT05UeXBlXG4pOiB2b2lkIHtcbiAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24/LnBvc3RcbiAgaWYgKGRhdGFUeXBlICYmIHBvc3QpIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKVxuICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7dHlwZTogdH0pID0+IHQgPT09IGRhdGFUeXBlKVxuICBpZiAoIXJ1bGVHcm91cCkge1xuICAgIHJ1bGVHcm91cCA9IHt0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdfVxuICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKVxuICB9XG4gIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZVxuICBpZiAoIWRlZmluaXRpb24pIHJldHVyblxuXG4gIGNvbnN0IHJ1bGU6IFJ1bGUgPSB7XG4gICAga2V5d29yZCxcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgdHlwZTogZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24udHlwZSksXG4gICAgICBzY2hlbWFUeXBlOiBnZXRKU09OVHlwZXMoZGVmaW5pdGlvbi5zY2hlbWFUeXBlKSxcbiAgICB9LFxuICB9XG4gIGlmIChkZWZpbml0aW9uLmJlZm9yZSkgYWRkQmVmb3JlUnVsZS5jYWxsKHRoaXMsIHJ1bGVHcm91cCwgcnVsZSwgZGVmaW5pdGlvbi5iZWZvcmUpXG4gIGVsc2UgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSlcbiAgUlVMRVMuYWxsW2tleXdvcmRdID0gcnVsZVxuICBkZWZpbml0aW9uLmltcGxlbWVudHM/LmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpXG59XG5cbmZ1bmN0aW9uIGFkZEJlZm9yZVJ1bGUodGhpczogQWp2LCBydWxlR3JvdXA6IFJ1bGVHcm91cCwgcnVsZTogUnVsZSwgYmVmb3JlOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpXG4gIGlmIChpID49IDApIHtcbiAgICBydWxlR3JvdXAucnVsZXMuc3BsaWNlKGksIDAsIHJ1bGUpXG4gIH0gZWxzZSB7XG4gICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSlcbiAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApXG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5d29yZE1ldGFzY2hlbWEodGhpczogQWp2LCBkZWY6IEtleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGxldCB7bWV0YVNjaGVtYX0gPSBkZWZcbiAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKSBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpXG4gIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKVxufVxuXG5jb25zdCAkZGF0YVJlZiA9IHtcbiAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn1cblxuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYTogQW55U2NoZW1hKTogQW55U2NoZW1hT2JqZWN0IHtcbiAgcmV0dXJuIHthbnlPZjogW3NjaGVtYSwgJGRhdGFSZWZdfVxufVxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImlkXCIsXG4gIGNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQgTWlzc2luZ1JlZkVycm9yIGZyb20gXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge2NhbGxWYWxpZGF0ZUNvZGV9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7XywgbmlsLCBzdHJpbmdpZnksIENvZGUsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHtTY2hlbWFFbnYsIHJlc29sdmVSZWZ9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcbmltcG9ydCB7bWVyZ2VFdmFsdWF0ZWR9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCIkcmVmXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KTogdm9pZCB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hOiAkcmVmLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7YmFzZUlkLCBzY2hlbWFFbnY6IGVudiwgdmFsaWRhdGVOYW1lLCBvcHRzLCBzZWxmfSA9IGl0XG4gICAgY29uc3Qge3Jvb3R9ID0gZW52XG4gICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpIHJldHVybiBjYWxsUm9vdFJlZigpXG4gICAgY29uc3Qgc2NoT3JFbnYgPSByZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKVxuICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgTWlzc2luZ1JlZkVycm9yKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgJHJlZilcbiAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBTY2hlbWFFbnYpIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpXG4gICAgcmV0dXJuIGlubGluZVJlZlNjaGVtYShzY2hPckVudilcblxuICAgIGZ1bmN0aW9uIGNhbGxSb290UmVmKCk6IHZvaWQge1xuICAgICAgaWYgKGVudiA9PT0gcm9vdCkgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYylcbiAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHtyZWY6IHJvb3R9KVxuICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCBfYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaDogU2NoZW1hRW52KTogdm9pZCB7XG4gICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpXG4gICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2g6IEFueVNjaGVtYSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFxuICAgICAgICBcInNjaGVtYVwiLFxuICAgICAgICBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8ge3JlZjogc2NoLCBjb2RlOiBzdHJpbmdpZnkoc2NoKX0gOiB7cmVmOiBzY2h9XG4gICAgICApXG4gICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IG5pbCxcbiAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0OiBLZXl3b3JkQ3h0LCBzY2g6IFNjaGVtYUVudik6IENvZGUge1xuICBjb25zdCB7Z2VufSA9IGN4dFxuICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHtyZWY6IHNjaC52YWxpZGF0ZX0pXG4gICAgOiBfYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHtyZWY6IHNjaH0pfS52YWxpZGF0ZWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxSZWYoY3h0OiBLZXl3b3JkQ3h0LCB2OiBDb2RlLCBzY2g/OiBTY2hlbWFFbnYsICRhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgaXR9ID0gY3h0XG4gIGNvbnN0IHthbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzfSA9IGl0XG4gIGNvbnN0IHBhc3NDeHQgPSBvcHRzLnBhc3NDb250ZXh0ID8gTi50aGlzIDogbmlsXG4gIGlmICgkYXN5bmMpIGNhbGxBc3luY1JlZigpXG4gIGVsc2UgY2FsbFN5bmNSZWYoKVxuXG4gIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpOiB2b2lkIHtcbiAgICBpZiAoIWVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICBnZW4udHJ5KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnZW4uY29kZShfYGF3YWl0ICR7Y2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpfWApXG4gICAgICAgIGFkZEV2YWx1YXRlZEZyb20odikgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgZ2VuLmlmKF9gISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0pYCwgKCkgPT4gZ2VuLnRocm93KGUpKVxuICAgICAgICBhZGRFcnJvcnNGcm9tKGUpXG4gICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgIH1cbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKTogdm9pZCB7XG4gICAgY3h0LnJlc3VsdChcbiAgICAgIGNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KSxcbiAgICAgICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksXG4gICAgICAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2U6IENvZGUpOiB2b2lkIHtcbiAgICBjb25zdCBlcnJzID0gX2Ake3NvdXJjZX0uZXJyb3JzYFxuICAgIGdlbi5hc3NpZ24oTi52RXJyb3JzLCBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke04udkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCkgLy8gVE9ETyB0YWdnZWRcbiAgICBnZW4uYXNzaWduKE4uZXJyb3JzLCBfYCR7Ti52RXJyb3JzfS5sZW5ndGhgKVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2U6IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IHNjaD8udmFsaWRhdGU/LmV2YWx1YXRlZFxuICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIF9gJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApXG4gICAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIE5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgX2Ake3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYClcbiAgICAgICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIGl0ZW1zLCBpdC5pdGVtcywgTmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgaWRLZXl3b3JkIGZyb20gXCIuL2lkXCJcbmltcG9ydCByZWZLZXl3b3JkIGZyb20gXCIuL3JlZlwiXG5cbmNvbnN0IGNvcmU6IFZvY2FidWxhcnkgPSBbXG4gIFwiJHNjaGVtYVwiLFxuICBcIiRpZFwiLFxuICBcIiRkZWZzXCIsXG4gIFwiJHZvY2FidWxhcnlcIixcbiAge2tleXdvcmQ6IFwiJGNvbW1lbnRcIn0sXG4gIFwiZGVmaW5pdGlvbnNcIixcbiAgaWRLZXl3b3JkLFxuICByZWZLZXl3b3JkLFxuXVxuXG5leHBvcnQgZGVmYXVsdCBjb3JlXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9ycywgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IG9wcyA9IG9wZXJhdG9yc1xuXG50eXBlIEt3ZCA9IFwibWF4aW11bVwiIHwgXCJtaW5pbXVtXCIgfCBcImV4Y2x1c2l2ZU1heGltdW1cIiB8IFwiZXhjbHVzaXZlTWluaW11bVwiXG5cbnR5cGUgQ29tcGFyaXNvbiA9IFwiPD1cIiB8IFwiPj1cIiB8IFwiPFwiIHwgXCI+XCJcblxuY29uc3QgS1dEczoge1tLIGluIEt3ZF06IHtva1N0cjogQ29tcGFyaXNvbjsgb2s6IENvZGU7IGZhaWw6IENvZGV9fSA9IHtcbiAgbWF4aW11bToge29rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1R9LFxuICBtaW5pbXVtOiB7b2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVH0sXG4gIGV4Y2x1c2l2ZU1heGltdW06IHtva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEV9LFxuICBleGNsdXNpdmVNaW5pbXVtOiB7b2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFfSxcbn1cblxuZXhwb3J0IHR5cGUgTGltaXROdW1iZXJFcnJvciA9IEVycm9yT2JqZWN0PFxuICBLd2QsXG4gIHtsaW1pdDogbnVtYmVyOyBjb21wYXJpc29uOiBDb21wYXJpc29ufSxcbiAgbnVtYmVyIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBiZSAke0tXRHNba2V5d29yZCBhcyBLd2RdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgcGFyYW1zOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PlxuICAgIF9ge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gIHR5cGU6IFwibnVtYmVyXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZX0gPSBjeHRcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtkYXRhfSAke0tXRHNba2V5d29yZCBhcyBLd2RdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB0eXBlIE11bHRpcGxlT2ZFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm11bHRpcGxlT2ZcIixcbiAge211bHRpcGxlT2Y6IG51bWJlcn0sXG4gIG51bWJlciB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gIHR5cGU6IFwibnVtYmVyXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvblxuICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIilcbiAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgPyBfYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgOiBfYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWBcbiAgICBjeHQuZmFpbCRkYXRhKF9gKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICBsZXQgbGVuZ3RoID0gMFxuICBsZXQgcG9zID0gMFxuICBsZXQgdmFsdWU6IG51bWJlclxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKytcbiAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKVxuICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApIHBvcysrIC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aFxufVxuXG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0J1xuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHVjczJsZW5ndGggZnJvbSBcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICB0eXBlOiBcInN0cmluZ1wiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGNvbnN0IGxlbiA9XG4gICAgICBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gX2Ake2RhdGF9Lmxlbmd0aGAgOiBfYCR7dXNlRnVuYyhjeHQuZ2VuLCB1Y3MybGVuZ3RoKX0oJHtkYXRhfSlgXG4gICAgY3h0LmZhaWwkZGF0YShfYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHt1c2VQYXR0ZXJufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB0eXBlIFBhdHRlcm5FcnJvciA9IEVycm9yT2JqZWN0PFwicGF0dGVyblwiLCB7cGF0dGVybjogc3RyaW5nfSwgc3RyaW5nIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgbWF0Y2ggcGF0dGVybiBcIiR7c2NoZW1hQ29kZX1cImAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7ZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCJcbiAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/IF9gKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6IHVzZVBhdHRlcm4oY3h0LCBzY2hlbWEpXG4gICAgY3h0LmZhaWwkZGF0YShfYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiXG4gICAgcmV0dXJuIHN0cmBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IHByb3BlcnRpZXNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGV9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGN4dC5mYWlsJGRhdGEoX2BPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7XG4gIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AsXG4gIGNoZWNrTWlzc2luZ1Byb3AsXG4gIHJlcG9ydE1pc3NpbmdQcm9wLFxuICBwcm9wZXJ0eUluRGF0YSxcbiAgbm9Qcm9wZXJ0eUluRGF0YSxcbn0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5pbCwgbm90LCBOYW1lLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgUmVxdWlyZWRFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcInJlcXVpcmVkXCIsXG4gIHttaXNzaW5nUHJvcGVydHk6IHN0cmluZ30sXG4gIHN0cmluZ1tdIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge21pc3NpbmdQcm9wZXJ0eX19KSA9PiBzdHJgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge21pc3NpbmdQcm9wZXJ0eX19KSA9PiBfYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0c30gPSBpdFxuICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWRcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSBhbGxFcnJvcnNNb2RlKClcbiAgICBlbHNlIGV4aXRPbkVycm9yTW9kZSgpXG5cbiAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXNcbiAgICAgIGNvbnN0IHtkZWZpbmVkUHJvcGVydGllc30gPSBjeHQuaXRcbiAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRLZXkgb2Ygc2NoZW1hKSB7XG4gICAgICAgIGlmIChwcm9wcz8uW3JlcXVpcmVkS2V5XSA9PT0gdW5kZWZpbmVkICYmICFkZWZpbmVkUHJvcGVydGllcy5oYXMocmVxdWlyZWRLZXkpKSB7XG4gICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoXG4gICAgICAgICAgY29uc3QgbXNnID0gYHJlcXVpcmVkIHByb3BlcnR5IFwiJHtyZXF1aXJlZEtleX1cIiBpcyBub3QgZGVmaW5lZCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0UmVxdWlyZWQpYFxuICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpOiB2b2lkIHtcbiAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKG5pbCwgbG9vcEFsbFJlcXVpcmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCk6IHZvaWQge1xuICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpXG4gICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKVxuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpXG4gICAgICAgIGN4dC5vayh2YWxpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihjaGVja01pc3NpbmdQcm9wKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSlcbiAgICAgICAgcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKVxuICAgICAgICBnZW4uZWxzZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCk6IHZvaWQge1xuICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlIGFzIENvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogcHJvcH0pXG4gICAgICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZzogTmFtZSwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogbWlzc2luZ30pXG4gICAgICBnZW4uZm9yT2YoXG4gICAgICAgIG1pc3NpbmcsXG4gICAgICAgIHNjaGVtYUNvZGUgYXMgQ29kZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSlcbiAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5icmVhaygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgbmlsXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBvcGVyYXRvcnN9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZSh7a2V5d29yZCwgc2NoZW1hQ29kZX0pIHtcbiAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heEl0ZW1zXCIsIFwibWluSXRlbXNcIl0sXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlfSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY3h0LmZhaWwkZGF0YShfYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICIvLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuaW1wb3J0ICogYXMgZXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbFwiXG5cbnR5cGUgRXF1YWwgPSB0eXBlb2YgZXF1YWwgJiB7Y29kZTogc3RyaW5nfVxuOyhlcXVhbCBhcyBFcXVhbCkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0J1xuXG5leHBvcnQgZGVmYXVsdCBlcXVhbCBhcyBFcXVhbFxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Y2hlY2tEYXRhVHlwZXMsIGdldFNjaGVtYVR5cGVzLCBEYXRhVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIlxuaW1wb3J0IHtfLCBzdHIsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIFVuaXF1ZUl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJ1bmlxdWVJdGVtc1wiLFxuICB7aTogbnVtYmVyOyBqOiBudW1iZXJ9LFxuICBib29sZWFuIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2ksIGp9fSkgPT5cbiAgICBzdHJgbXVzdCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICR7an0gYW5kICR7aX0gYXJlIGlkZW50aWNhbClgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7aSwgan19KSA9PiBfYHtpOiAke2l9LCBqOiAke2p9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyBnZXRTY2hlbWFUeXBlcyhwYXJlbnRTY2hlbWEuaXRlbXMpIDogW11cbiAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgX2Ake3NjaGVtYUNvZGV9ID09PSBmYWxzZWApXG4gICAgY3h0Lm9rKHZhbGlkKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKVxuICAgICAgY3h0LnNldFBhcmFtcyh7aSwgan0pXG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgZ2VuLmlmKF9gJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BOKGk6IE5hbWUsIGo6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIilcbiAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZylcbiAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsIF9ge31gKVxuICAgICAgZ2VuLmZvcihfYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICBnZW4ubGV0KGl0ZW0sIF9gJHtkYXRhfVske2l9XWApXG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsIF9gY29udGludWVgKVxuICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpIGdlbi5pZihfYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCBfYCR7aXRlbX0gKz0gXCJfXCJgKVxuICAgICAgICBnZW5cbiAgICAgICAgICAuaWYoX2B0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCBfYCR7aW5kaWNlc31bJHtpdGVtfV1gKVxuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY29kZShfYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcE4yKGk6IE5hbWUsIGo6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGVxbCA9IHVzZUZ1bmMoZ2VuLCBlcXVhbClcbiAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKVxuICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoX2A7JHtpfS0tO2AsICgpID0+XG4gICAgICAgIGdlbi5mb3IoX2Ake2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+XG4gICAgICAgICAgZ2VuLmlmKF9gJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcilcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge199IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIENvbnN0RXJyb3IgPSBFcnJvck9iamVjdDxcImNvbnN0XCIsIHthbGxvd2VkVmFsdWU6IGFueX0+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWF9ID0gY3h0XG4gICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgY3h0LmZhaWwkZGF0YShfYCEke3VzZUZ1bmMoZ2VuLCBlcXVhbCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYClcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0LmZhaWwoX2Ake3NjaGVtYX0gIT09ICR7ZGF0YX1gKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBvciwgTmFtZSwgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgRW51bUVycm9yID0gRXJyb3JPYmplY3Q8XCJlbnVtXCIsIHthbGxvd2VkVmFsdWVzOiBhbnlbXX0sIGFueVtdIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImVudW1cIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIilcbiAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtXG4gICAgbGV0IGVxbDogTmFtZSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IGdldEVxbCA9ICgpOiBOYW1lID0+IChlcWwgPz89IHVzZUZ1bmMoZ2VuLCBlcXVhbCkpXG5cbiAgICBsZXQgdmFsaWQ6IENvZGVcbiAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCBsb29wRW51bSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKVxuICAgICAgdmFsaWQgPSBvciguLi5zY2hlbWEubWFwKChfeDogdW5rbm93biwgaTogbnVtYmVyKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKVxuICAgIH1cbiAgICBjeHQucGFzcyh2YWxpZClcblxuICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCk6IHZvaWQge1xuICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUgYXMgQ29kZSwgKHYpID0+XG4gICAgICAgIGdlbi5pZihfYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVhbENvZGUodlNjaGVtYTogTmFtZSwgaTogbnVtYmVyKTogQ29kZSB7XG4gICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV1cbiAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICA/IF9gJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgIDogX2Ake2RhdGF9ID09PSAke3NjaH1gXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JPYmplY3QsIFZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgbGltaXROdW1iZXIsIHtMaW1pdE51bWJlckVycm9yfSBmcm9tIFwiLi9saW1pdE51bWJlclwiXG5pbXBvcnQgbXVsdGlwbGVPZiwge011bHRpcGxlT2ZFcnJvcn0gZnJvbSBcIi4vbXVsdGlwbGVPZlwiXG5pbXBvcnQgbGltaXRMZW5ndGggZnJvbSBcIi4vbGltaXRMZW5ndGhcIlxuaW1wb3J0IHBhdHRlcm4sIHtQYXR0ZXJuRXJyb3J9IGZyb20gXCIuL3BhdHRlcm5cIlxuaW1wb3J0IGxpbWl0UHJvcGVydGllcyBmcm9tIFwiLi9saW1pdFByb3BlcnRpZXNcIlxuaW1wb3J0IHJlcXVpcmVkLCB7UmVxdWlyZWRFcnJvcn0gZnJvbSBcIi4vcmVxdWlyZWRcIlxuaW1wb3J0IGxpbWl0SXRlbXMgZnJvbSBcIi4vbGltaXRJdGVtc1wiXG5pbXBvcnQgdW5pcXVlSXRlbXMsIHtVbmlxdWVJdGVtc0Vycm9yfSBmcm9tIFwiLi91bmlxdWVJdGVtc1wiXG5pbXBvcnQgY29uc3RLZXl3b3JkLCB7Q29uc3RFcnJvcn0gZnJvbSBcIi4vY29uc3RcIlxuaW1wb3J0IGVudW1LZXl3b3JkLCB7RW51bUVycm9yfSBmcm9tIFwiLi9lbnVtXCJcblxuY29uc3QgdmFsaWRhdGlvbjogVm9jYWJ1bGFyeSA9IFtcbiAgLy8gbnVtYmVyXG4gIGxpbWl0TnVtYmVyLFxuICBtdWx0aXBsZU9mLFxuICAvLyBzdHJpbmdcbiAgbGltaXRMZW5ndGgsXG4gIHBhdHRlcm4sXG4gIC8vIG9iamVjdFxuICBsaW1pdFByb3BlcnRpZXMsXG4gIHJlcXVpcmVkLFxuICAvLyBhcnJheVxuICBsaW1pdEl0ZW1zLFxuICB1bmlxdWVJdGVtcyxcbiAgLy8gYW55XG4gIHtrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl19LFxuICB7a2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIn0sXG4gIGNvbnN0S2V5d29yZCxcbiAgZW51bUtleXdvcmQsXG5dXG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRpb25cblxudHlwZSBMaW1pdEVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwibWF4SXRlbXNcIiB8IFwibWluSXRlbXNcIiB8IFwibWluUHJvcGVydGllc1wiIHwgXCJtYXhQcm9wZXJ0aWVzXCIgfCBcIm1pbkxlbmd0aFwiIHwgXCJtYXhMZW5ndGhcIixcbiAge2xpbWl0OiBudW1iZXJ9LFxuICBudW1iZXIgfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuZXhwb3J0IHR5cGUgVmFsaWRhdGlvbktleXdvcmRFcnJvciA9XG4gIHwgTGltaXRFcnJvclxuICB8IExpbWl0TnVtYmVyRXJyb3JcbiAgfCBNdWx0aXBsZU9mRXJyb3JcbiAgfCBQYXR0ZXJuRXJyb3JcbiAgfCBSZXF1aXJlZEVycm9yXG4gIHwgVW5pcXVlSXRlbXNFcnJvclxuICB8IENvbnN0RXJyb3JcbiAgfCBFbnVtRXJyb3JcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgbm90LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIEFkZGl0aW9uYWxJdGVtc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJhZGRpdGlvbmFsSXRlbXNcIiwge2xpbWl0OiBudW1iZXJ9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2xlbn19KSA9PiBzdHJgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2xlbn19KSA9PiBfYHtsaW1pdDogJHtsZW59fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiIGFzIGNvbnN0LFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7cGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7aXRlbXN9ID0gcGFyZW50U2NoZW1hXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0OiBLZXl3b3JkQ3h0LCBpdGVtczogQW55U2NoZW1hW10pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgaXQuaXRlbXMgPSB0cnVlXG4gIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICBjeHQuc2V0UGFyYW1zKHtsZW46IGl0ZW1zLmxlbmd0aH0pXG4gICAgY3h0LnBhc3MoX2Ake2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgX2Ake2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCkgLy8gVE9ETyB2YXJcbiAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZDogTmFtZSk6IHZvaWQge1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiBUeXBlLk51bX0sIHZhbGlkKVxuICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYSwgQW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7X30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBtZXJnZUV2YWx1YXRlZCwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7dmFsaWRhdGVBcnJheX0gZnJvbSBcIi4uL2NvZGVcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge3NjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpXG4gICAgaXQuaXRlbXMgPSB0cnVlXG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjeHQub2sodmFsaWRhdGVBcnJheShjeHQpKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShcbiAgY3h0OiBLZXl3b3JkQ3h0LFxuICBleHRyYUl0ZW1zOiBzdHJpbmcsXG4gIHNjaEFycjogQW55U2NoZW1hW10gPSBjeHQuc2NoZW1hXG4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpXG4gIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpXG4gIH1cbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgc2NoQXJyLmZvckVhY2goKHNjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHJldHVyblxuICAgIGdlbi5pZihfYCR7bGVufSA+ICR7aX1gLCAoKSA9PlxuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoOiBBbnlTY2hlbWFPYmplY3QpOiB2b2lkIHtcbiAgICBjb25zdCB7b3B0cywgZXJyU2NoZW1hUGF0aH0gPSBpdFxuICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoXG4gICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSlcbiAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYFxuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHt2YWxpZGF0ZVR1cGxlfSBmcm9tIFwiLi9pdGVtc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBjb2RlOiAoY3h0KSA9PiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJpdGVtc1wiKSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge3ZhbGlkYXRlQXJyYXl9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7dmFsaWRhdGVBZGRpdGlvbmFsSXRlbXN9IGZyb20gXCIuL2FkZGl0aW9uYWxJdGVtc1wiXG5cbmV4cG9ydCB0eXBlIEl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcIml0ZW1zXCIsIHtsaW1pdDogbnVtYmVyfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtsZW59fSkgPT4gc3RyYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtsZW59fSkgPT4gX2B7bGltaXQ6ICR7bGVufX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7c2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtwcmVmaXhJdGVtc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpdC5pdGVtcyA9IHRydWVcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGlmIChwcmVmaXhJdGVtcykgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBwcmVmaXhJdGVtcylcbiAgICBlbHNlIGN4dC5vayh2YWxpZGF0ZUFycmF5KGN4dCkpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIENvbnRhaW5zRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJjb250YWluc1wiLFxuICB7bWluQ29udGFpbnM6IG51bWJlcjsgbWF4Q29udGFpbnM/OiBudW1iZXJ9LFxuICBBbnlTY2hlbWFcbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bWluLCBtYXh9fSkgPT5cbiAgICBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgPyBzdHJgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgOiBzdHJgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge21pbiwgbWF4fX0pID0+XG4gICAgbWF4ID09PSB1bmRlZmluZWQgPyBfYHttaW5Db250YWluczogJHttaW59fWAgOiBfYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgbGV0IG1pbjogbnVtYmVyXG4gICAgbGV0IG1heDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgY29uc3Qge21pbkNvbnRhaW5zLCBtYXhDb250YWluc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zXG4gICAgICBtYXggPSBtYXhDb250YWluc1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW4gPSAxXG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICBjeHQuc2V0UGFyYW1zKHttaW4sIG1heH0pXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwibWluQ29udGFpbnNcIiA+IFwibWF4Q29udGFpbnNcIiBpcyBhbHdheXMgaW52YWxpZGApXG4gICAgICBjeHQuZmFpbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICBsZXQgY29uZCA9IF9gJHtsZW59ID49ICR7bWlufWBcbiAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkgY29uZCA9IF9gJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YFxuICAgICAgY3h0LnBhc3MoY29uZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGl0Lml0ZW1zID0gdHJ1ZVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKVxuICAgIH0gZWxzZSBpZiAobWluID09PSAwKSB7XG4gICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKVxuICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSBnZW4uaWYoX2Ake2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSlcbiAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKVxuICAgIH1cbiAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSlcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG4gICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKVxuICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkOiBOYW1lLCBibG9jazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIF92YWxpZFxuICAgICAgICApXG4gICAgICAgIGJsb2NrKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQ6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGdlbi5jb2RlKF9gJHtjb3VudH0rK2ApXG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2VuLmlmKF9gJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihfYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpXG4gICAgICAgIGlmIChtaW4gPT09IDEpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICAgIGVsc2UgZ2VuLmlmKF9gJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIFNjaGVtYU1hcCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtjaGVja1JlcG9ydE1pc3NpbmdQcm9wLCBjaGVja01pc3NpbmdQcm9wLCByZXBvcnRNaXNzaW5nUHJvcCwgcHJvcGVydHlJbkRhdGF9IGZyb20gXCIuLi9jb2RlXCJcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlEZXBlbmRlbmNpZXMgPSB7W0sgaW4gc3RyaW5nXT86IHN0cmluZ1tdfVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGVuZGVuY2llc0Vycm9yUGFyYW1zIHtcbiAgcHJvcGVydHk6IHN0cmluZ1xuICBtaXNzaW5nUHJvcGVydHk6IHN0cmluZ1xuICBkZXBzQ291bnQ6IG51bWJlclxuICBkZXBzOiBzdHJpbmcgLy8gVE9ETyBjaGFuZ2UgdG8gc3RyaW5nW11cbn1cblxudHlwZSBTY2hlbWFEZXBlbmRlbmNpZXMgPSBTY2hlbWFNYXBcblxuZXhwb3J0IHR5cGUgRGVwZW5kZW5jaWVzRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJkZXBlbmRlbmNpZXNcIixcbiAgRGVwZW5kZW5jaWVzRXJyb3JQYXJhbXMsXG4gIHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW10gfCBBbnlTY2hlbWF9XG4+XG5cbmV4cG9ydCBjb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzfX0pID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIlxuICAgIHJldHVybiBzdHJgbXVzdCBoYXZlICR7cHJvcGVydHlfaWVzfSAke2RlcHN9IHdoZW4gcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgcHJlc2VudGBcbiAgfSxcbiAgcGFyYW1zOiAoe3BhcmFtczoge3Byb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eX19KSA9PlxuICAgIF9ge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dClcbiAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKVxuICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpXG4gIH0sXG59XG5cbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHtzY2hlbWF9OiBLZXl3b3JkQ3h0KTogW1Byb3BlcnR5RGVwZW5kZW5jaWVzLCBTY2hlbWFEZXBlbmRlbmNpZXNdIHtcbiAgY29uc3QgcHJvcGVydHlEZXBzOiBQcm9wZXJ0eURlcGVuZGVuY2llcyA9IHt9XG4gIGNvbnN0IHNjaGVtYURlcHM6IFNjaGVtYURlcGVuZGVuY2llcyA9IHt9XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIGNvbnRpbnVlXG4gICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwc1xuICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldXG4gIH1cbiAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhcbiAgY3h0OiBLZXl3b3JkQ3h0LFxuICBwcm9wZXJ0eURlcHM6IHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW119ID0gY3h0LnNjaGVtYVxuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGl0fSA9IGN4dFxuICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApIHJldHVyblxuICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIilcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF0gYXMgc3RyaW5nW11cbiAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgY29uc3QgaGFzUHJvcGVydHkgPSBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcylcbiAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgIH0pXG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwUHJvcCBvZiBkZXBzKSB7XG4gICAgICAgICAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIGRlcFByb3ApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5pZihfYCR7aGFzUHJvcGVydHl9ICYmICgke2NoZWNrTWlzc2luZ1Byb3AoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYClcbiAgICAgIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZylcbiAgICAgIGdlbi5lbHNlKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQ6IEtleXdvcmRDeHQsIHNjaGVtYURlcHM6IFNjaGVtYU1hcCA9IGN4dC5zY2hlbWEpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hRGVwc1twcm9wXSBhcyBBbnlTY2hlbWEpKSBjb250aW51ZVxuICAgIGdlbi5pZihcbiAgICAgIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcH0sIHZhbGlkKVxuICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKVxuICAgICAgfSxcbiAgICAgICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIG5vdH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlOYW1lc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJwcm9wZXJ0eU5hbWVzXCIsIHtwcm9wZXJ0eU5hbWU6IHN0cmluZ30sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG5cbiAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgY3h0LnNldFBhcmFtcyh7cHJvcGVydHlOYW1lOiBrZXl9KVxuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgY3h0LmVycm9yKHRydWUpXG4gICAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uYnJlYWsoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7YWxsU2NoZW1hUHJvcGVydGllcywgdXNlUGF0dGVybiwgaXNPd25Qcm9wZXJ0eX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBuaWwsIG9yLCBub3QsIENvZGUsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHR5cGUge1N1YnNjaGVtYUFyZ3N9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBzY2hlbWFSZWZPclZhbCwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIEFkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICB7YWRkaXRpb25hbFByb3BlcnR5OiBzdHJpbmd9LFxuICBBbnlTY2hlbWFcbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge2FkZGl0aW9uYWxQcm9wZXJ0eTogJHtwYXJhbXMuYWRkaXRpb25hbFByb3BlcnR5fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiAmIEFkZGVkS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgdHlwZTogW1wib2JqZWN0XCJdLFxuICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0fSA9IGN4dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZXJyc0NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICBjb25zdCB7YWxsRXJyb3JzLCBvcHRzfSA9IGl0XG4gICAgaXQucHJvcHMgPSB0cnVlXG4gICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY29uc3QgcHJvcHMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKVxuICAgIGNvbnN0IHBhdFByb3BzID0gYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpXG4gICAgY3h0Lm9rKF9gJHtlcnJzQ291bnR9ID09PSAke04uZXJyb3JzfWApXG5cbiAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXk6IE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aCkgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpXG4gICAgICAgIGVsc2UgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXk6IE5hbWUpOiBDb2RlIHtcbiAgICAgIGxldCBkZWZpbmVkUHJvcDogQ29kZVxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gc2NoZW1hUmVmT3JWYWwoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIilcbiAgICAgICAgZGVmaW5lZFByb3AgPSBpc093blByb3BlcnR5KGdlbiwgcHJvcHNTY2hlbWEgYXMgQ29kZSwga2V5KVxuICAgICAgfSBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5lZFByb3AgPSBvciguLi5wcm9wcy5tYXAoKHApID0+IF9gJHtrZXl9ID09PSAke3B9YCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG5pbFxuICAgICAgfVxuICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG9yKGRlZmluZWRQcm9wLCAuLi5wYXRQcm9wcy5tYXAoKHApID0+IF9gJHt1c2VQYXR0ZXJuKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdChkZWZpbmVkUHJvcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVBZGRpdGlvbmFsKGtleTogTmFtZSk6IHZvaWQge1xuICAgICAgZ2VuLmNvZGUoX2BkZWxldGUgJHtkYXRhfVske2tleX1dYClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleTogTmFtZSk6IHZvaWQge1xuICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7YWRkaXRpb25hbFByb3BlcnR5OiBrZXl9KVxuICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmJyZWFrKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LnJlc2V0KClcbiAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpXG4gICAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXk6IE5hbWUsIHZhbGlkOiBOYW1lLCBlcnJvcnM/OiBmYWxzZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc3Vic2NoZW1hOiBTdWJzY2hlbWFBcmdzID0ge1xuICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5TdHIsXG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtwcm9wZXJ0eUluRGF0YSwgYWxsU2NoZW1hUHJvcGVydGllc30gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgdG9IYXNoLCBtZXJnZUV2YWx1YXRlZH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgYXBEZWYgZnJvbSBcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwRGVmLmNvZGUobmV3IEtleXdvcmRDeHQoaXQsIGFwRGVmLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKVxuICAgIH1cbiAgICBjb25zdCBhbGxQcm9wcyA9IGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHRvSGFzaChhbGxQcm9wcyksIGl0LnByb3BzKVxuICAgIH1cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSkpXG4gICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW4uaWYocHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKVxuICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApXG4gICAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSlcbiAgICAgICAgZ2VuLmVuZElmKClcbiAgICAgIH1cbiAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3A6IHN0cmluZyk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHthbGxTY2hlbWFQcm9wZXJ0aWVzLCB1c2VQYXR0ZXJufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIG5vdCwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtldmFsdWF0ZWRQcm9wc1RvTmFtZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge0FueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHN9ID0gaXRcbiAgICBjb25zdCBwYXR0ZXJucyA9IGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKVxuICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+XG4gICAgICBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdIGFzIEFueVNjaGVtYSlcbiAgICApXG5cbiAgICBpZiAoXG4gICAgICBwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPVxuICAgICAgb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXNcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIE5hbWUpKSB7XG4gICAgICBpdC5wcm9wcyA9IGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgaXQucHJvcHMpXG4gICAgfVxuICAgIGNvbnN0IHtwcm9wc30gPSBpdFxuICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdClcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KVxuICAgICAgICAgIGdlbi5pZih2YWxpZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgIGdlbi5pZihfYCR7dXNlUGF0dGVybihjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KVxuICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLlN0cixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihfYCR7cHJvcHN9WyR7a2V5fV1gLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yTm9QYXJhbXMsIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgTm90S2V5d29yZEVycm9yID0gRXJyb3JOb1BhcmFtczxcIm5vdFwiLCBBbnlTY2hlbWE+XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm5vdFwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgY3h0LmZhaWwoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgY3h0LnN1YnNjaGVtYShcbiAgICAgIHtcbiAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB2YWxpZFxuICAgIClcblxuICAgIGN4dC5mYWlsUmVzdWx0KFxuICAgICAgdmFsaWQsXG4gICAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcigpXG4gICAgKVxuICB9LFxuICBlcnJvcjoge21lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIn0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yTm9QYXJhbXMsIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7dmFsaWRhdGVVbmlvbn0gZnJvbSBcIi4uL2NvZGVcIlxuXG5leHBvcnQgdHlwZSBBbnlPZkVycm9yID0gRXJyb3JOb1BhcmFtczxcImFueU9mXCIsIEFueVNjaGVtYVtdPlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhbnlPZlwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBjb2RlOiB2YWxpZGF0ZVVuaW9uLFxuICBlcnJvcjoge21lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwifSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtTY2hlbWFDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcblxuZXhwb3J0IHR5cGUgT25lT2ZFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm9uZU9mXCIsXG4gIHtwYXNzaW5nU2NoZW1hczogW251bWJlciwgbnVtYmVyXSB8IG51bGx9LFxuICBBbnlTY2hlbWFbXVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgaWYgKGl0Lm9wdHMuZGlzY3JpbWluYXRvciAmJiBwYXJlbnRTY2hlbWEuZGlzY3JpbWluYXRvcikgcmV0dXJuXG4gICAgY29uc3Qgc2NoQXJyOiBBbnlTY2hlbWFbXSA9IHNjaGVtYVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICAgIGNvbnN0IHBhc3NpbmcgPSBnZW4ubGV0KFwicGFzc2luZ1wiLCBudWxsKVxuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcbiAgICBjeHQuc2V0UGFyYW1zKHtwYXNzaW5nfSlcbiAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuXG4gICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpXG5cbiAgICBjeHQucmVzdWx0KFxuICAgICAgdmFsaWQsXG4gICAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcih0cnVlKVxuICAgIClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoKTogdm9pZCB7XG4gICAgICBzY2hBcnIuZm9yRWFjaCgoc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgc2NoQ3h0OiBTY2hlbWFDeHQgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKSB7XG4gICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NoVmFsaWRcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBnZW5cbiAgICAgICAgICAgIC5pZihfYCR7c2NoVmFsaWR9ICYmICR7dmFsaWR9YClcbiAgICAgICAgICAgIC5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgICAgICAgLmFzc2lnbihwYXNzaW5nLCBfYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAuZWxzZSgpXG4gICAgICAgIH1cblxuICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSlcbiAgICAgICAgICBpZiAoc2NoQ3h0KSBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBOYW1lKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgaXR9ID0gY3h0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIHNjaGVtYS5mb3JFYWNoKChzY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHJldHVyblxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpfSwgdmFsaWQpXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KVxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBub3QsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgSWZLZXl3b3JkRXJyb3IgPSBFcnJvck9iamVjdDxcImlmXCIsIHtmYWlsaW5nS2V5d29yZDogc3RyaW5nfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXN9KSA9PiBzdHJgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImlmXCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJylcbiAgICB9XG4gICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpXG4gICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpXG4gICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKSByZXR1cm5cblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuICAgIHZhbGlkYXRlSWYoKVxuICAgIGN4dC5yZXNldCgpXG5cbiAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKVxuICAgICAgY3h0LnNldFBhcmFtcyh7aWZDbGF1c2V9KVxuICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKVxuICAgIH0gZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5pZihub3Qoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpXG4gICAgfVxuXG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSlcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBzY2hWYWxpZFxuICAgICAgKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkOiBzdHJpbmcsIGlmQ2xhdXNlPzogTmFtZSk6ICgpID0+IHZvaWQge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZH0sIHNjaFZhbGlkKVxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZClcbiAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZClcbiAgICAgICAgaWYgKGlmQ2xhdXNlKSBnZW4uYXNzaWduKGlmQ2xhdXNlLCBfYCR7a2V5d29yZH1gKVxuICAgICAgICBlbHNlIGN4dC5zZXRQYXJhbXMoe2lmQ2xhdXNlOiBrZXl3b3JkfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmZ1bmN0aW9uIGhhc1NjaGVtYShpdDogU2NoZW1hT2JqQ3h0LCBrZXl3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gIHJldHVybiBzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2NoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgY29kZSh7a2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdH06IEtleXdvcmRDeHQpIHtcbiAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JOb1BhcmFtcywgVm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBhZGRpdGlvbmFsSXRlbXMsIHtBZGRpdGlvbmFsSXRlbXNFcnJvcn0gZnJvbSBcIi4vYWRkaXRpb25hbEl0ZW1zXCJcbmltcG9ydCBwcmVmaXhJdGVtcyBmcm9tIFwiLi9wcmVmaXhJdGVtc1wiXG5pbXBvcnQgaXRlbXMgZnJvbSBcIi4vaXRlbXNcIlxuaW1wb3J0IGl0ZW1zMjAyMCwge0l0ZW1zRXJyb3J9IGZyb20gXCIuL2l0ZW1zMjAyMFwiXG5pbXBvcnQgY29udGFpbnMsIHtDb250YWluc0Vycm9yfSBmcm9tIFwiLi9jb250YWluc1wiXG5pbXBvcnQgZGVwZW5kZW5jaWVzLCB7RGVwZW5kZW5jaWVzRXJyb3J9IGZyb20gXCIuL2RlcGVuZGVuY2llc1wiXG5pbXBvcnQgcHJvcGVydHlOYW1lcywge1Byb3BlcnR5TmFtZXNFcnJvcn0gZnJvbSBcIi4vcHJvcGVydHlOYW1lc1wiXG5pbXBvcnQgYWRkaXRpb25hbFByb3BlcnRpZXMsIHtBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yfSBmcm9tIFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiXG5pbXBvcnQgcHJvcGVydGllcyBmcm9tIFwiLi9wcm9wZXJ0aWVzXCJcbmltcG9ydCBwYXR0ZXJuUHJvcGVydGllcyBmcm9tIFwiLi9wYXR0ZXJuUHJvcGVydGllc1wiXG5pbXBvcnQgbm90S2V5d29yZCwge05vdEtleXdvcmRFcnJvcn0gZnJvbSBcIi4vbm90XCJcbmltcG9ydCBhbnlPZiwge0FueU9mRXJyb3J9IGZyb20gXCIuL2FueU9mXCJcbmltcG9ydCBvbmVPZiwge09uZU9mRXJyb3J9IGZyb20gXCIuL29uZU9mXCJcbmltcG9ydCBhbGxPZiBmcm9tIFwiLi9hbGxPZlwiXG5pbXBvcnQgaWZLZXl3b3JkLCB7SWZLZXl3b3JkRXJyb3J9IGZyb20gXCIuL2lmXCJcbmltcG9ydCB0aGVuRWxzZSBmcm9tIFwiLi90aGVuRWxzZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpOiBWb2NhYnVsYXJ5IHtcbiAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAvLyBhbnlcbiAgICBub3RLZXl3b3JkLFxuICAgIGFueU9mLFxuICAgIG9uZU9mLFxuICAgIGFsbE9mLFxuICAgIGlmS2V5d29yZCxcbiAgICB0aGVuRWxzZSxcbiAgICAvLyBvYmplY3RcbiAgICBwcm9wZXJ0eU5hbWVzLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzLFxuICBdXG4gIC8vIGFycmF5XG4gIGlmIChkcmFmdDIwMjApIGFwcGxpY2F0b3IucHVzaChwcmVmaXhJdGVtcywgaXRlbXMyMDIwKVxuICBlbHNlIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXMsIGl0ZW1zKVxuICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnMpXG4gIHJldHVybiBhcHBsaWNhdG9yXG59XG5cbmV4cG9ydCB0eXBlIEFwcGxpY2F0b3JLZXl3b3JkRXJyb3IgPVxuICB8IEVycm9yTm9QYXJhbXM8XCJmYWxzZSBzY2hlbWFcIj5cbiAgfCBBZGRpdGlvbmFsSXRlbXNFcnJvclxuICB8IEl0ZW1zRXJyb3JcbiAgfCBDb250YWluc0Vycm9yXG4gIHwgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvclxuICB8IERlcGVuZGVuY2llc0Vycm9yXG4gIHwgSWZLZXl3b3JkRXJyb3JcbiAgfCBBbnlPZkVycm9yXG4gIHwgT25lT2ZFcnJvclxuICB8IE5vdEtleXdvcmRFcnJvclxuICB8IFByb3BlcnR5TmFtZXNFcnJvclxuIiwgImltcG9ydCB0eXBlIHtcbiAgQWRkZWRGb3JtYXQsXG4gIEZvcm1hdFZhbGlkYXRvcixcbiAgQXN5bmNGb3JtYXRWYWxpZGF0b3IsXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5pbCwgb3IsIENvZGUsIGdldFByb3BlcnR5LCByZWdleHBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxudHlwZSBGb3JtYXRWYWxpZGF0ZSA9XG4gIHwgRm9ybWF0VmFsaWRhdG9yPHN0cmluZz5cbiAgfCBGb3JtYXRWYWxpZGF0b3I8bnVtYmVyPlxuICB8IEFzeW5jRm9ybWF0VmFsaWRhdG9yPHN0cmluZz5cbiAgfCBBc3luY0Zvcm1hdFZhbGlkYXRvcjxudW1iZXI+XG4gIHwgUmVnRXhwXG4gIHwgc3RyaW5nXG4gIHwgdHJ1ZVxuXG5leHBvcnQgdHlwZSBGb3JtYXRFcnJvciA9IEVycm9yT2JqZWN0PFwiZm9ybWF0XCIsIHtmb3JtYXQ6IHN0cmluZ30sIHN0cmluZyB8IHskZGF0YTogc3RyaW5nfT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IG1hdGNoIGZvcm1hdCBcIiR7c2NoZW1hQ29kZX1cImAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQsIHJ1bGVUeXBlPzogc3RyaW5nKSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZn0gPSBpdFxuICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpIHJldHVyblxuXG4gICAgaWYgKCRkYXRhKSB2YWxpZGF0ZSREYXRhRm9ybWF0KClcbiAgICBlbHNlIHZhbGlkYXRlRm9ybWF0KClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKTogdm9pZCB7XG4gICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsIF9gJHtmbXRzfVske3NjaGVtYUNvZGV9XWApXG4gICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKVxuICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKVxuICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgZ2VuLmlmKFxuICAgICAgICBfYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsXG4gICAgICAgICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIF9gJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBfYCR7ZkRlZn0udmFsaWRhdGVgKSxcbiAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgX2BcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZilcbiAgICAgIClcbiAgICAgIGN4dC5mYWlsJGRhdGEob3IodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKVxuXG4gICAgICBmdW5jdGlvbiB1bmtub3duRm10KCk6IENvZGUge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSByZXR1cm4gbmlsXG4gICAgICAgIHJldHVybiBfYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWBcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpOiBDb2RlIHtcbiAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICA/IF9gKCR7ZkRlZn0uYXN5bmMgPyBhd2FpdCAke2Zvcm1hdH0oJHtkYXRhfSkgOiAke2Zvcm1hdH0oJHtkYXRhfSkpYFxuICAgICAgICAgIDogX2Ake2Zvcm1hdH0oJHtkYXRhfSlgXG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IF9gKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWBcbiAgICAgICAgcmV0dXJuIF9gJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZvcm1hdERlZjogQWRkZWRGb3JtYXQgfCB1bmRlZmluZWQgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXVxuICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgdW5rbm93bkZvcm1hdCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZilcbiAgICAgIGlmIChmbXRUeXBlID09PSBydWxlVHlwZSkgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSlcblxuICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpXG5cbiAgICAgICAgZnVuY3Rpb24gdW5rbm93bk1zZygpOiBzdHJpbmcge1xuICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYSBhcyBzdHJpbmd9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmOiBBZGRlZEZvcm1hdCk6IFtzdHJpbmcsIEZvcm1hdFZhbGlkYXRlLCBDb2RlXSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPVxuICAgICAgICAgIGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgPyByZWdleHBDb2RlKGZtdERlZilcbiAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgID8gX2Ake29wdHMuY29kZS5mb3JtYXRzfSR7Z2V0UHJvcGVydHkoc2NoZW1hKX1gXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge2tleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZX0pXG4gICAgICAgIGlmICh0eXBlb2YgZm10RGVmID09IFwib2JqZWN0XCIgJiYgIShmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsIF9gJHtmbXR9LnZhbGlkYXRlYF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCk6IENvZGUge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKVxuICAgICAgICAgIHJldHVybiBfYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyBfYCR7Zm10UmVmfSgke2RhdGF9KWAgOiBfYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYFxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgZm9ybWF0S2V5d29yZCBmcm9tIFwiLi9mb3JtYXRcIlxuXG5jb25zdCBmb3JtYXQ6IFZvY2FidWxhcnkgPSBbZm9ybWF0S2V5d29yZF1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0XG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi90eXBlc1wiXG5cbmV4cG9ydCBjb25zdCBtZXRhZGF0YVZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSBbXG4gIFwidGl0bGVcIixcbiAgXCJkZXNjcmlwdGlvblwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJkZXByZWNhdGVkXCIsXG4gIFwicmVhZE9ubHlcIixcbiAgXCJ3cml0ZU9ubHlcIixcbiAgXCJleGFtcGxlc1wiLFxuXVxuXG5leHBvcnQgY29uc3QgY29udGVudFZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSBbXG4gIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICBcImNvbnRlbnRTY2hlbWFcIixcbl1cbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCBjb3JlVm9jYWJ1bGFyeSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCB2YWxpZGF0aW9uVm9jYWJ1bGFyeSBmcm9tIFwiLi92YWxpZGF0aW9uXCJcbmltcG9ydCBnZXRBcHBsaWNhdG9yVm9jYWJ1bGFyeSBmcm9tIFwiLi9hcHBsaWNhdG9yXCJcbmltcG9ydCBmb3JtYXRWb2NhYnVsYXJ5IGZyb20gXCIuL2Zvcm1hdFwiXG5pbXBvcnQge21ldGFkYXRhVm9jYWJ1bGFyeSwgY29udGVudFZvY2FidWxhcnl9IGZyb20gXCIuL21ldGFkYXRhXCJcblxuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzOiBWb2NhYnVsYXJ5W10gPSBbXG4gIGNvcmVWb2NhYnVsYXJ5LFxuICB2YWxpZGF0aW9uVm9jYWJ1bGFyeSxcbiAgZ2V0QXBwbGljYXRvclZvY2FidWxhcnkoKSxcbiAgZm9ybWF0Vm9jYWJ1bGFyeSxcbiAgbWV0YWRhdGFWb2NhYnVsYXJ5LFxuICBjb250ZW50Vm9jYWJ1bGFyeSxcbl1cblxuZXhwb3J0IGRlZmF1bHQgZHJhZnQ3Vm9jYWJ1bGFyaWVzXG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuXG5leHBvcnQgZW51bSBEaXNjckVycm9yIHtcbiAgVGFnID0gXCJ0YWdcIixcbiAgTWFwcGluZyA9IFwibWFwcGluZ1wiLFxufVxuXG5leHBvcnQgdHlwZSBEaXNjckVycm9yT2JqPEUgZXh0ZW5kcyBEaXNjckVycm9yPiA9IEVycm9yT2JqZWN0PFxuICBcImRpc2NyaW1pbmF0b3JcIixcbiAge2Vycm9yOiBFOyB0YWc6IHN0cmluZzsgdGFnVmFsdWU6IHVua25vd259LFxuICBzdHJpbmdcbj5cbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBBbnlTY2hlbWFPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBnZXRQcm9wZXJ0eSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge0Rpc2NyRXJyb3IsIERpc2NyRXJyb3JPYmp9IGZyb20gXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCJcbmltcG9ydCB7cmVzb2x2ZVJlZiwgU2NoZW1hRW52fSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5pbXBvcnQge3NjaGVtYUhhc1J1bGVzQnV0UmVmfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgRGlzY3JpbWluYXRvckVycm9yID0gRGlzY3JFcnJvck9iajxEaXNjckVycm9yLlRhZz4gfCBEaXNjckVycm9yT2JqPERpc2NyRXJyb3IuTWFwcGluZz5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7ZGlzY3JFcnJvciwgdGFnTmFtZX19KSA9PlxuICAgIGRpc2NyRXJyb3IgPT09IERpc2NyRXJyb3IuVGFnXG4gICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtkaXNjckVycm9yLCB0YWcsIHRhZ05hbWV9fSkgPT5cbiAgICBfYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImRpc2NyaW1pbmF0b3JcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvbmVPZn0gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIilcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWVcbiAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpXG4gICAgaWYgKHNjaGVtYS5tYXBwaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIilcbiAgICBpZiAoIW9uZU9mKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpXG4gICAgY29uc3QgdGFnID0gZ2VuLmNvbnN0KFwidGFnXCIsIF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkodGFnTmFtZSl9YClcbiAgICBnZW4uaWYoXG4gICAgICBfYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsXG4gICAgICAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcihmYWxzZSwge2Rpc2NyRXJyb3I6IERpc2NyRXJyb3IuVGFnLCB0YWcsIHRhZ05hbWV9KVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcHBpbmcoKTogdm9pZCB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZygpXG4gICAgICBnZW4uaWYoZmFsc2UpXG4gICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgZ2VuLmVsc2VJZihfYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKVxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpXG4gICAgICB9XG4gICAgICBnZW4uZWxzZSgpXG4gICAgICBjeHQuZXJyb3IoZmFsc2UsIHtkaXNjckVycm9yOiBEaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZX0pXG4gICAgICBnZW4uZW5kSWYoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3A/OiBudW1iZXIpOiBOYW1lIHtcbiAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe2tleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcH0sIF92YWxpZClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIE5hbWUpXG4gICAgICByZXR1cm4gX3ZhbGlkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpOiB7W1QgaW4gc3RyaW5nXT86IG51bWJlcn0ge1xuICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nOiB7W1QgaW4gc3RyaW5nXT86IG51bWJlcn0gPSB7fVxuICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpXG4gICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzY2ggPSBvbmVPZltpXVxuICAgICAgICBpZiAoc2NoPy4kcmVmICYmICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2gsIGl0LnNlbGYuUlVMRVMpKSB7XG4gICAgICAgICAgc2NoID0gcmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHNjaD8uJHJlZilcbiAgICAgICAgICBpZiAoc2NoIGluc3RhbmNlb2YgU2NoZW1hRW52KSBzY2ggPSBzY2guc2NoZW1hXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcFNjaCA9IHNjaD8ucHJvcGVydGllcz8uW3RhZ05hbWVdXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRhZ1JlcXVpcmVkID0gdGFnUmVxdWlyZWQgJiYgKHRvcFJlcXVpcmVkIHx8IGhhc1JlcXVpcmVkKHNjaCkpXG4gICAgICAgIGFkZE1hcHBpbmdzKHByb3BTY2gsIGkpXG4gICAgICB9XG4gICAgICBpZiAoIXRhZ1JlcXVpcmVkKSB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgcmVxdWlyZWRgKVxuICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZ1xuXG4gICAgICBmdW5jdGlvbiBoYXNSZXF1aXJlZCh7cmVxdWlyZWR9OiBBbnlTY2hlbWFPYmplY3QpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaDogQW55U2NoZW1hT2JqZWN0LCBpOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgIGFkZE1hcHBpbmcoc2NoLmNvbnN0LCBpKVxuICAgICAgICB9IGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBvZiBzY2guZW51bSkge1xuICAgICAgICAgICAgYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWU6IHVua25vd24sIGk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUgc3RyaW5nc2ApXG4gICAgICAgIH1cbiAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgIntcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwiJGlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJDb3JlIHNjaGVtYSBtZXRhLXNjaGVtYVwiLFxuICBcImRlZmluaXRpb25zXCI6IHtcbiAgICBcInNjaGVtYUFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiOiB7XG4gICAgICBcImFsbE9mXCI6IFt7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sIHtcImRlZmF1bHRcIjogMH1dXG4gICAgfSxcbiAgICBcInNpbXBsZVR5cGVzXCI6IHtcbiAgICAgIFwiZW51bVwiOiBbXCJhcnJheVwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcIm9iamVjdFwiLCBcInN0cmluZ1wiXVxuICAgIH0sXG4gICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IFtdXG4gICAgfVxuICB9LFxuICBcInR5cGVcIjogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgfSxcbiAgICBcIiRyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkY29tbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJ0aXRsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgXCJyZWFkT25seVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZXhhbXBsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtdWx0aXBsZU9mXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtYXhMZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluTGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsSXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJpdGVtc1wiOiB7XG4gICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIFwibWF4SXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluSXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJ1bmlxdWVJdGVtc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiY29udGFpbnNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pblByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJyZXF1aXJlZFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCJmb3JtYXRcIjogXCJyZWdleFwifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9XVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiY29uc3RcIjogdHJ1ZSxcbiAgICBcImVudW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImlmXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwidGhlblwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImVsc2VcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJhbGxPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcImFueU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwib25lT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJub3RcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgfSxcbiAgXCJkZWZhdWx0XCI6IHRydWVcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgQWp2Q29yZSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCBkcmFmdDdWb2NhYnVsYXJpZXMgZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiXG5pbXBvcnQgZGlzY3JpbWluYXRvciBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvclwiXG5pbXBvcnQgKiBhcyBkcmFmdDdNZXRhU2NoZW1hIGZyb20gXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiXG5cbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl1cblxuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hXCJcblxuY2xhc3MgQWp2IGV4dGVuZHMgQWp2Q29yZSB7XG4gIF9hZGRWb2NhYnVsYXJpZXMoKTogdm9pZCB7XG4gICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpXG4gICAgZHJhZnQ3Vm9jYWJ1bGFyaWVzLmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSlcbiAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yKVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk6IHZvaWQge1xuICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpXG4gICAgaWYgKCF0aGlzLm9wdHMubWV0YSkgcmV0dXJuXG4gICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYVxuICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpXG4gICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRFxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pXG5cbmV4cG9ydCBkZWZhdWx0IEFqdlxuXG5leHBvcnQge1xuICBGb3JtYXQsXG4gIEZvcm1hdERlZmluaXRpb24sXG4gIEFzeW5jRm9ybWF0RGVmaW5pdGlvbixcbiAgS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxuICBWb2NhYnVsYXJ5LFxuICBTY2hlbWEsXG4gIFNjaGVtYU9iamVjdCxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBBc3luY1NjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIFNjaGVtYVZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBFcnJvck5vUGFyYW1zLFxufSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCB7UGx1Z2luLCBPcHRpb25zLCBDb2RlT3B0aW9ucywgSW5zdGFuY2VPcHRpb25zLCBMb2dnZXIsIEVycm9yc1RleHRPcHRpb25zfSBmcm9tIFwiLi9jb3JlXCJcbmV4cG9ydCB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuL2NvbXBpbGVcIlxuZXhwb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlXCJcbmV4cG9ydCB7RGVmaW5lZEVycm9yfSBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZXJyb3JzXCJcbmV4cG9ydCB7SlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuZXhwb3J0IHtKU09OU2NoZW1hVHlwZX0gZnJvbSBcIi4vdHlwZXMvanNvbi1zY2hlbWFcIlxuZXhwb3J0IHtfLCBzdHIsIHN0cmluZ2lmeSwgbmlsLCBOYW1lLCBDb2RlLCBDb2RlR2VuLCBDb2RlR2VuT3B0aW9uc30gZnJvbSBcIi4vY29tcGlsZS9jb2RlZ2VuXCJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWYWxpZGF0aW9uRXJyb3J9IGZyb20gXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiXG5leHBvcnQge2RlZmF1bHQgYXMgTWlzc2luZ1JlZkVycm9yfSBmcm9tIFwiLi9jb21waWxlL3JlZl9lcnJvclwiXG4iLCBudWxsLCBudWxsLCBudWxsLCAiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94XG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAyMyBIYXlkbiBQYXRlcnNvbiAoc2luY2xhaXIpIDxoYXlkbi5kZXZlbG9wZXJAZ21haWwuY29tPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGUgPSBleHBvcnRzLlN0YW5kYXJkVHlwZSA9IGV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IGV4cG9ydHMuU3RhbmRhcmRUeXBlQnVpbGRlciA9IGV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gZXhwb3J0cy5VbmlvblJlc29sdmVyID0gZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gZXhwb3J0cy5LZXlSZXNvbHZlciA9IGV4cG9ydHMuT2JqZWN0TWFwID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBleHBvcnRzLlR5cGVDbG9uZSA9IGV4cG9ydHMuVHlwZUV4dGVuZHMgPSBleHBvcnRzLlR5cGVFeHRlbmRzUmVzdWx0ID0gZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gZXhwb3J0cy5UeXBlR3VhcmQgPSBleHBvcnRzLlR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgPSBleHBvcnRzLkZvcm1hdFJlZ2lzdHJ5ID0gZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA9IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbkV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9IGV4cG9ydHMuS2luZCA9IGV4cG9ydHMuSGludCA9IGV4cG9ydHMuTW9kaWZpZXIgPSB2b2lkIDA7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3ltYm9sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuTW9kaWZpZXIgPSBTeW1ib2wuZm9yKCdUeXBlQm94Lk1vZGlmaWVyJyk7XG5leHBvcnRzLkhpbnQgPSBTeW1ib2wuZm9yKCdUeXBlQm94LkhpbnQnKTtcbmV4cG9ydHMuS2luZCA9IFN5bWJvbC5mb3IoJ1R5cGVCb3guS2luZCcpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhdHRlcm5zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9ICcodHJ1ZXxmYWxzZSknO1xuZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gJygwfFsxLTldWzAtOV0qKSc7XG5leHBvcnRzLlBhdHRlcm5TdHJpbmcgPSAnKC4qKSc7XG5leHBvcnRzLlBhdHRlcm5Cb29sZWFuRXhhY3QgPSBgXiR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn0kYDtcbmV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVybk51bWJlcn0kYDtcbmV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVyblN0cmluZ30kYDtcbi8qKiBBIHJlZ2lzdHJ5IGZvciB1c2VyIGRlZmluZWQgdHlwZXMgKi9cbnZhciBUeXBlUmVnaXN0cnk7XG4oZnVuY3Rpb24gKFR5cGVSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkVudHJpZXMgPSBFbnRyaWVzO1xuICAgIC8qKiBDbGVhcnMgYWxsIHVzZXIgZGVmaW5lZCB0eXBlcyAqL1xuICAgIGZ1bmN0aW9uIENsZWFyKCkge1xuICAgICAgICByZXR1cm4gbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5DbGVhciA9IENsZWFyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWdpc3RyeSBjb250YWlucyB0aGlzIGtpbmQgKi9cbiAgICBmdW5jdGlvbiBIYXMoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBTZXQoa2luZCwgZnVuYykge1xuICAgICAgICBtYXAuc2V0KGtpbmQsIGZ1bmMpO1xuICAgIH1cbiAgICBUeXBlUmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBHZXQoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmdldChraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkdldCA9IEdldDtcbn0pKFR5cGVSZWdpc3RyeSB8fCAoZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBUeXBlUmVnaXN0cnkgPSB7fSkpO1xuLyoqIEEgcmVnaXN0cnkgZm9yIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0cyAqL1xudmFyIEZvcm1hdFJlZ2lzdHJ5O1xuKGZ1bmN0aW9uIChGb3JtYXRSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuRW50cmllcyA9IEVudHJpZXM7XG4gICAgLyoqIENsZWFycyBhbGwgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXRzICovXG4gICAgZnVuY3Rpb24gQ2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBtYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuQ2xlYXIgPSBDbGVhcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCBleGlzdHMgKi9cbiAgICBmdW5jdGlvbiBIYXMoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBtYXAuaGFzKGZvcm1hdCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBTZXQoZm9ybWF0LCBmdW5jKSB7XG4gICAgICAgIG1hcC5zZXQoZm9ybWF0LCBmdW5jKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCAqL1xuICAgIGZ1bmN0aW9uIEdldChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoZm9ybWF0KTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuR2V0ID0gR2V0O1xufSkoRm9ybWF0UmVnaXN0cnkgfHwgKGV4cG9ydHMuRm9ybWF0UmVnaXN0cnkgPSBGb3JtYXRSZWdpc3RyeSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUd1YXJkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1R5cGVHdWFyZDogVW5rbm93biB0eXBlJyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciA9IFR5cGVHdWFyZFVua25vd25UeXBlRXJyb3I7XG4vKiogUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHRlc3QgaWYgSmF2YVNjcmlwdCB2YWx1ZXMgYXJlIFR5cGVCb3ggdHlwZXMgKi9cbnZhciBUeXBlR3VhcmQ7XG4oZnVuY3Rpb24gKFR5cGVHdWFyZCkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA+PSA3ICYmIGNvZGUgPD0gMTMpIHx8IGNvZGUgPT09IDI3IHx8IGNvZGUgPT09IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBZGRpdGlvbmFsUHJvcGVydGllcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXNPcHRpb25hbEJvb2xlYW4odmFsdWUpIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0JpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGdsb2JhbFRoaXMuTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEJpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc0JpZ0ludCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzQm9vbGVhbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSAmJiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSAmJiBJc1BhdHRlcm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEZvcm1hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkgJiYgSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU2NoZW1hKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEFueSAqL1xuICAgIGZ1bmN0aW9uIFRBbnkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQW55JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFueSA9IFRBbnk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0FycmF5JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW1zKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCb29sZWFuKHNjaGVtYS51bmlxdWVJdGVtcykpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFycmF5ID0gVEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQmlnSW50ICovXG4gICAgZnVuY3Rpb24gVEJpZ0ludChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdCaWdJbnQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnQmlnSW50JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCaWdJbnQgPSBUQmlnSW50O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQm9vbGVhbiAqL1xuICAgIGZ1bmN0aW9uIFRCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0Jvb2xlYW4nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCb29sZWFuID0gVEJvb2xlYW47XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRDb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIFRDb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRDb25zdHJ1Y3RvciA9IFRDb25zdHJ1Y3RvcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVERhdGUgKi9cbiAgICBmdW5jdGlvbiBURGF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0RhdGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRGF0ZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW1UaW1lc3RhbXApICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW1UaW1lc3RhbXApKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlREYXRlID0gVERhdGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRGdW5jdGlvbiAqL1xuICAgIGZ1bmN0aW9uIFRGdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRGdW5jdGlvbiA9IFRGdW5jdGlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVnZXIgKi9cbiAgICBmdW5jdGlvbiBUSW50ZWdlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVnZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2ludGVnZXInICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heGltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEludGVnZXIgPSBUSW50ZWdlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVyc2VjdCAqL1xuICAgIGZ1bmN0aW9uIFRJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcgJiZcbiAgICAgICAgICAgIElzQXJyYXkoc2NoZW1hLmFsbE9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEudHlwZSkgJiZcbiAgICAgICAgICAgIChJc09wdGlvbmFsQm9vbGVhbihzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBJc09wdGlvbmFsU2NoZW1hKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMpKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3R5cGUnIGluIHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5USW50ZXJzZWN0ID0gVEludGVyc2VjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEtpbmQgKi9cbiAgICBmdW5jdGlvbiBUS2luZChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0KHNjaGVtYSkgJiYgZXhwb3J0cy5LaW5kIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdzdHJpbmcnOyAvLyBUUyA0LjEuNTogYW55IHJlcXVpcmVkIGZvciBzeW1ib2wgaW5kZXhlclxuICAgIH1cbiAgICBUeXBlR3VhcmQuVEtpbmQgPSBUS2luZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWw8c3RyaW5nPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTGl0ZXJhbFN0cmluZyA9IFRMaXRlcmFsU3RyaW5nO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbDxudW1iZXI+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxOdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTGl0ZXJhbCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsTnVtYmVyID0gVExpdGVyYWxOdW1iZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRMaXRlcmFsPGJvb2xlYW4+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWxCb29sZWFuID0gVExpdGVyYWxCb29sZWFuO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbCAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpIHx8IFRMaXRlcmFsQm9vbGVhbihzY2hlbWEpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWwgPSBUTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5ldmVyICovXG4gICAgZnVuY3Rpb24gVE5ldmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ05ldmVyJyAmJiBJc09iamVjdChzY2hlbWEubm90KSAmJiBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROZXZlciA9IFROZXZlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5vdCAqL1xuICAgIGZ1bmN0aW9uIFROb3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90JyAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEubm90KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTm90ID0gVE5vdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE51bGwgKi9cbiAgICBmdW5jdGlvbiBUTnVsbChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOdWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTnVsbCA9IFROdWxsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTnVtYmVyICovXG4gICAgZnVuY3Rpb24gVE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROdW1iZXIgPSBUTnVtYmVyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUT2JqZWN0ICovXG4gICAgZnVuY3Rpb24gVE9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT2JqZWN0KHNjaGVtYS5wcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4UHJvcGVydGllcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAoIUlzQ29udHJvbENoYXJhY3RlckZyZWUoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPYmplY3QgPSBUT2JqZWN0O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUHJvbWlzZSAqL1xuICAgIGZ1bmN0aW9uIFRQcm9taXNlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnUHJvbWlzZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRQcm9taXNlID0gVFByb21pc2U7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWNvcmQgKi9cbiAgICBmdW5jdGlvbiBUUmVjb3JkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdSZWNvcmQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPYmplY3Qoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1BhdHRlcm4oa2V5c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVRTY2hlbWEoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2tleXNbMF1dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlY29yZCA9IFRSZWNvcmQ7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWYgKi9cbiAgICBmdW5jdGlvbiBUUmVmKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1JlZicgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzU3RyaW5nKHNjaGVtYS4kcmVmKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUmVmID0gVFJlZjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN0cmluZyAqL1xuICAgIGZ1bmN0aW9uIFRTdHJpbmcoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdTdHJpbmcnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heExlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxQYXR0ZXJuKHNjaGVtYS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEZvcm1hdChzY2hlbWEuZm9ybWF0KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU3RyaW5nID0gVFN0cmluZztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN5bWJvbCAqL1xuICAgIGZ1bmN0aW9uIFRTeW1ib2woc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnU3ltYm9sJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGVPZiA9PT0gJ1N5bWJvbCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFN5bWJvbCA9IFRTeW1ib2w7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRUZW1wbGF0ZUxpdGVyYWwgKi9cbiAgICBmdW5jdGlvbiBUVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RlbXBsYXRlTGl0ZXJhbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgSXNTdHJpbmcoc2NoZW1hLnBhdHRlcm4pICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVyblswXSA9PT0gJ14nICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVybltzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJyQnKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwgPSBUVGVtcGxhdGVMaXRlcmFsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVGhpcyAqL1xuICAgIGZ1bmN0aW9uIFRUaGlzKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RoaXMnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc1N0cmluZyhzY2hlbWEuJHJlZikpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFRoaXMgPSBUVGhpcztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFR1cGxlICovXG4gICAgZnVuY3Rpb24gVFR1cGxlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUdXBsZScgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWF4SXRlbXMpICYmXG4gICAgICAgICAgICBzY2hlbWEubWluSXRlbXMgPT09IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgJiYgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5taW5JdGVtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVHVwbGUgPSBUVHVwbGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmRlZmluZWQgKi9cbiAgICBmdW5jdGlvbiBUVW5kZWZpbmVkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdVbmRlZmluZWQnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmRlZmluZWQgPSBUVW5kZWZpbmVkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5pb248TGl0ZXJhbDxzdHJpbmcgfCBudW1iZXI+W10+ICovXG4gICAgZnVuY3Rpb24gVFVuaW9uTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRVbmlvbihzY2hlbWEpICYmIHNjaGVtYS5hbnlPZi5ldmVyeSgoc2NoZW1hKSA9PiBUTGl0ZXJhbFN0cmluZyhzY2hlbWEpIHx8IFRMaXRlcmFsTnVtYmVyKHNjaGVtYSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbCA9IFRVbmlvbkxpdGVyYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmlvbiAqL1xuICAgIGZ1bmN0aW9uIFRVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5hbnlPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uID0gVFVuaW9uO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVWludDhBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRVaW50OEFycmF5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VpbnQ4QXJyYXknICYmIHNjaGVtYS50eXBlID09PSAnb2JqZWN0JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnVWludDhBcnJheScgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluQnl0ZUxlbmd0aCkgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4Qnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVWludDhBcnJheSA9IFRVaW50OEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5rbm93biAqL1xuICAgIGZ1bmN0aW9uIFRVbmtub3duKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vua25vd24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmtub3duID0gVFVua25vd247XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIGEgcmF3IFRVbnNhZmUgKi9cbiAgICBmdW5jdGlvbiBUVW5zYWZlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vuc2FmZScpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuc2FmZSA9IFRVbnNhZmU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRWb2lkICovXG4gICAgZnVuY3Rpb24gVFZvaWQoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVm9pZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdWb2lkJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVm9pZCA9IFRWb2lkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzY2hlbWEgaGFzIHRoZSBSZWFkb25seU9wdGlvbmFsIG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVFJlYWRvbmx5T3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5T3B0aW9uYWwnO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlYWRvbmx5T3B0aW9uYWwgPSBUUmVhZG9ubHlPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgUmVhZG9ubHkgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUUmVhZG9ubHkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5JztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWFkb25seSA9IFRSZWFkb25seTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgT3B0aW9uYWwgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ09wdGlvbmFsJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPcHRpb25hbCA9IFRPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFRTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIChUQW55KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRCb29sZWFuKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQmlnSW50KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQ29uc3RydWN0b3Ioc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFREYXRlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBURnVuY3Rpb24oc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRJbnRlZ2VyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUSW50ZXJzZWN0KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTGl0ZXJhbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE5ldmVyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTm90KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTnVsbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE51bWJlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE9iamVjdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFByb21pc2Uoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWNvcmQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWYoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTdHJpbmcoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTeW1ib2woc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUaGlzKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVHVwbGUoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmRlZmluZWQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmlvbihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFVpbnQ4QXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmtub3duKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5zYWZlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVm9pZChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgKFRLaW5kKHNjaGVtYSkgJiYgVHlwZVJlZ2lzdHJ5LkhhcyhzY2hlbWFbZXhwb3J0cy5LaW5kXSkpKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU2NoZW1hID0gVFNjaGVtYTtcbn0pKFR5cGVHdWFyZCB8fCAoZXhwb3J0cy5UeXBlR3VhcmQgPSBUeXBlR3VhcmQgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZHNVbmRlZmluZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogRmFzdCB1bmRlZmluZWQgY2hlY2sgdXNlZCBmb3IgcHJvcGVydGllcyBvZiB0eXBlIHVuZGVmaW5lZCAqL1xudmFyIEV4dGVuZHNVbmRlZmluZWQ7XG4oZnVuY3Rpb24gKEV4dGVuZHNVbmRlZmluZWQpIHtcbiAgICBmdW5jdGlvbiBDaGVjayhzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gIUNoZWNrKHNjaGVtYS5ub3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3QuYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gQ2hlY2soc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiB1bmlvbi5hbnlPZi5zb21lKChzY2hlbWEpID0+IENoZWNrKHNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgRXh0ZW5kc1VuZGVmaW5lZC5DaGVjayA9IENoZWNrO1xufSkoRXh0ZW5kc1VuZGVmaW5lZCB8fCAoZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gRXh0ZW5kc1VuZGVmaW5lZCA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUV4dGVuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVHlwZUV4dGVuZHNSZXN1bHQ7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzUmVzdWx0KSB7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJVbmlvblwiXSA9IDBdID0gXCJVbmlvblwiO1xuICAgIFR5cGVFeHRlbmRzUmVzdWx0W1R5cGVFeHRlbmRzUmVzdWx0W1wiVHJ1ZVwiXSA9IDFdID0gXCJUcnVlXCI7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJGYWxzZVwiXSA9IDJdID0gXCJGYWxzZVwiO1xufSkoVHlwZUV4dGVuZHNSZXN1bHQgfHwgKGV4cG9ydHMuVHlwZUV4dGVuZHNSZXN1bHQgPSBUeXBlRXh0ZW5kc1Jlc3VsdCA9IHt9KSk7XG52YXIgVHlwZUV4dGVuZHM7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJbnRvQm9vbGVhblJlc3VsdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50b0Jvb2xlYW5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFueVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQW55UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFueShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpICYmIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVHlwZUd1YXJkLlRBbnkoc2NoZW1hKSB8fCBUeXBlR3VhcmQuVFVua25vd24oc2NoZW1hKSkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQXJyYXlSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQXJyYXkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkgJiYgSXNPYmplY3RBcnJheUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRBcnJheShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0Lml0ZW1zLCByaWdodC5pdGVtcykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpZ0ludFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQmlnSW50KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQmlnSW50KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb29sZWFuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiB0eXBlb2YgbGVmdC5jb25zdCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJvb2xlYW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UQ29uc3RydWN0b3IocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5wYXJhbWV0ZXJzLmxlbmd0aCA+IHJpZ2h0LnBhcmFtZXRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoIWxlZnQucGFyYW1ldGVycy5ldmVyeSgoc2NoZW1hLCBpbmRleCkgPT4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQocmlnaHQucGFyYW1ldGVyc1tpbmRleF0sIHNjaGVtYSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LnJldHVybnMsIHJpZ2h0LnJldHVybnMpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBEYXRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVERhdGUocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBGdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRGdW5jdGlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChsZWZ0LnBhcmFtZXRlcnMubGVuZ3RoID4gcmlnaHQucGFyYW1ldGVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmICghbGVmdC5wYXJhbWV0ZXJzLmV2ZXJ5KChzY2hlbWEsIGluZGV4KSA9PiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChyaWdodC5wYXJhbWV0ZXJzW2luZGV4XSwgc2NoZW1hKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQucmV0dXJucywgcmlnaHQucmV0dXJucykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEludGVnZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdW1iZXIobGVmdCkgfHwgVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlZ2VyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkgfHwgVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVyc2VjdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFsbE9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KGxlZnQsIHNjaGVtYSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuYWxsT2Yuc29tZSgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTGl0ZXJhbE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0xpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRMaXRlcmFsKHJpZ2h0KSAmJiByaWdodC5jb25zdCA9PT0gbGVmdC5jb25zdCA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOZXZlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gTmV2ZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5ldmVyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE5vdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW53cmFwTm90KHNjaGVtYSkge1xuICAgICAgICBsZXQgW2N1cnJlbnQsIGRlcHRoXSA9IFtzY2hlbWEsIDBdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFUeXBlR3VhcmQuVE5vdChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5vdDtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoICUgMiA9PT0gMCA/IGN1cnJlbnQgOiBleHBvcnRzLlR5cGUuVW5rbm93bigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOb3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBoYXMgbm8gY29uY2VwdCBvZiBuZWdhdGVkIHR5cGVzLCBhbmQgYXR0ZW1wdHMgdG8gY29ycmVjdGx5IGNoZWNrIHRoZSBuZWdhdGVkXG4gICAgICAgIC8vIHR5cGUgYXQgcnVudGltZSB3b3VsZCBwdXQgVHlwZUJveCBhdCBvZGRzIHdpdGggVHlwZVNjcmlwdHMgYWJpbGl0eSB0byBzdGF0aWNhbGx5IGluZmVyXG4gICAgICAgIC8vIHRoZSB0eXBlLiBJbnN0ZWFkIHdlIHVud3JhcCB0byBlaXRoZXIgdW5rbm93biBvciBUIGFuZCBjb250aW51ZSBldmFsdWF0aW5nLlxuICAgICAgICBpZiAoVHlwZUd1YXJkLlROb3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQoVW53cmFwTm90KGxlZnQpLCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5vdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVW53cmFwTm90KHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIE5vdGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE51bGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bGwobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdWxsKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOdW1iZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsTnVtYmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSB8fCBUeXBlR3VhcmQuVEludGVnZXIobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE51bWJlcihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBPYmplY3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPT09IGNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN0cmluZ0xpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdEFycmF5TGlrZShzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN5bWJvbExpa2Uoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICdkZXNjcmlwdGlvbicgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbikgJiYgc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2YubGVuZ3RoID09PSAyICYmICgoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMF0pICYmXG4gICAgICAgICAgICBUeXBlR3VhcmQuVFVuZGVmaW5lZChzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkpIHx8IChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkgJiZcbiAgICAgICAgICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzBdKSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3ROdW1iZXJMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Qm9vbGVhbkxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RCaWdJbnRMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RGF0ZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RVaW50OEFycmF5TGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RnVuY3Rpb25MaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvbWlzZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHRoZW4gPSBleHBvcnRzLlR5cGUuRnVuY3Rpb24oW2V4cG9ydHMuVHlwZS5BbnkoKV0sIGV4cG9ydHMuVHlwZS5BbnkoKSk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ3RoZW4nIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHNjaGVtYS5wcm9wZXJ0aWVzWyd0aGVuJ10sIHRoZW4pKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvcGVydHlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFByb3BlcnR5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChWaXNpdChsZWZ0LCByaWdodCkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPcHRpb25hbChsZWZ0KSAmJiAhVHlwZUd1YXJkLlRPcHRpb25hbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3RSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxOdW1iZXIobGVmdCkgJiYgSXNPYmplY3ROdW1iZXJMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQmlnSW50KGxlZnQpICYmIElzT2JqZWN0QmlnSW50TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpICYmIElzT2JqZWN0TnVtYmVyTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSAmJiBJc09iamVjdE51bWJlckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVWludDhBcnJheShsZWZ0KSAmJiBJc09iamVjdFVpbnQ4QXJyYXlMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpICYmIElzT2JqZWN0RGF0ZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVENvbnN0cnVjdG9yKGxlZnQpICYmIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSAmJiBJc09iamVjdEZ1bmN0aW9uTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpICYmIFR5cGVHdWFyZC5UU3RyaW5nKFJlY29yZEtleShsZWZ0KSkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZXhwcmVzc2luZyBhIFJlY29yZCB3aXRoIGxpdGVyYWwga2V5IHZhbHVlcywgdGhlIFJlY29yZCBpcyBjb252ZXJ0ZWQgaW50byBhIE9iamVjdCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgSGludCBhc3NpZ25lZCBhcyBgUmVjb3JkYC4gVGhpcyBpcyB1c2VkIHRvIGludmVydCB0aGUgZXh0ZW5kcyBsb2dpYy5cbiAgICAgICAgICAgIHJldHVybiByaWdodFtleHBvcnRzLkhpbnRdID09PSAnUmVjb3JkJyA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoUmVjb3JkS2V5KGxlZnQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChyaWdodCwgMCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhyaWdodC5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGxlZnQucHJvcGVydGllcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICAgICAgaWYgKFByb3BlcnR5KGxlZnQucHJvcGVydGllc1trZXldLCByaWdodC5wcm9wZXJ0aWVzW2tleV0pID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcm9taXNlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBQcm9taXNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpICYmIElzT2JqZWN0UHJvbWlzZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRQcm9taXNlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQuaXRlbSwgcmlnaHQuaXRlbSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlY29yZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gUmVjb3JkS2V5KHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuU3RyaW5nKCk7XG4gICAgICAgIHRocm93IEVycm9yKCdUeXBlRXh0ZW5kczogQ2Fubm90IGdldCByZWNvcmQga2V5Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZFZhbHVlKHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1tleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdF07XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2V4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0XTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVFeHRlbmRzOiBDYW5ub3QgZ2V0IHJlY29yZCB2YWx1ZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBLZXkgPSBSZWNvcmRLZXkocmlnaHQpO1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxTdHJpbmcobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LCBWYWx1ZSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVpbnQ4QXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFZhbHVlKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChsZWZ0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhsZWZ0LnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFByb3BlcnR5KFZhbHVlLCBsZWZ0LnByb3BlcnRpZXNba2V5XSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKGxlZnQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gVmlzaXQoVmFsdWUsIFJlY29yZFZhbHVlKHJpZ2h0KSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN0cmluZyhsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3ltYm9sXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTeW1ib2wobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTeW1ib2wocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRlbXBsYXRlTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vIFRlbXBsYXRlTGl0ZXJhbCB0eXBlcyBhcmUgcmVzb2x2ZWQgdG8gZWl0aGVyIHVuaW9ucyBmb3IgZmluaXRlIGV4cHJlc3Npb25zIG9yIHN0cmluZ1xuICAgICAgICAvLyBmb3IgaW5maW5pdGUgZXhwcmVzc2lvbnMuIEhlcmUgd2UgY2FsbCB0byBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciB0byByZXNvbHZlIGZvclxuICAgICAgICAvLyBlaXRoZXIgdHlwZSBhbmQgY29udGludWUgZXZhbHVhdGluZy5cbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUobGVmdCksIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIFRlbXBsYXRlTGl0ZXJhbGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFR1cGxlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBUdXBsZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5T2ZUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRBcnJheShyaWdodCkgJiYgbGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCByaWdodC5pdGVtcykgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSAmJiBJc09iamVjdEFycmF5TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpICYmIElzQXJyYXlPZlR1cGxlKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UVHVwbGUocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoKGxlZnQuaXRlbXMgPT09IHVuZGVmaW5lZCAmJiByaWdodC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB8fCAobGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSwgaW5kZXgpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQuaXRlbXNbaW5kZXhdKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVWludDhBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVWludDhBcnJheShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVaW50OEFycmF5KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmRlZmluZWRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuZGVmaW5lZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFZvaWQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5pb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVmlzaXQobGVmdCwgc2NoZW1hKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmFueU9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmtub3duXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGVSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBWb2lkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBWb2lkUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5kZWZpbmVkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFZvaWQocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChsZWZ0LCByaWdodCkge1xuICAgICAgICAvLyBSZXNvbHZhYmxlIFR5cGVzXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSB8fCBUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTm90KGxlZnQpIHx8IFR5cGVHdWFyZC5UTm90KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOb3QobGVmdCwgcmlnaHQpO1xuICAgICAgICAvLyBTdGFuZGFyZCBUeXBlc1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQW55KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCaWdJbnQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQ29uc3RydWN0b3IobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIERhdGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIExpdGVyYWwobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bGwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTnVsbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTeW1ib2wobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVHVwbGUobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRQcm9taXNlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVaW50OEFycmF5KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmRlZmluZWQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5kZWZpbmVkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRWb2lkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aHJvdyBFcnJvcihgVHlwZUV4dGVuZHM6IFVua25vd24gbGVmdCB0eXBlIG9wZXJhbmQgJyR7bGVmdFtleHBvcnRzLktpbmRdfSdgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRXh0ZW5kcyhsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBUeXBlRXh0ZW5kcy5FeHRlbmRzID0gRXh0ZW5kcztcbn0pKFR5cGVFeHRlbmRzIHx8IChleHBvcnRzLlR5cGVFeHRlbmRzID0gVHlwZUV4dGVuZHMgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVDbG9uZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBTcGVjaWFsaXplZCBDbG9uZSBmb3IgVHlwZXMgKi9cbnZhciBUeXBlQ2xvbmU7XG4oZnVuY3Rpb24gKFR5cGVDbG9uZSkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2YWx1ZSkgPT4gVmlzaXQodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFByb3BlcnRpZXMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtrZXldOiBWaXNpdCh2YWx1ZVtrZXldKSB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFN5bWJvbHMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IFZpc2l0KHZhbHVlW2tleV0pIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2xvbmVkUHJvcGVydGllcywgLi4uY2xvbmVkU3ltYm9scyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdCh2YWx1ZSkge1xuICAgICAgICBpZiAoSXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoSXNPYmplY3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIENsb25lcyBhIHR5cGUuICovXG4gICAgZnVuY3Rpb24gQ2xvbmUoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KHNjaGVtYSksIC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgVHlwZUNsb25lLkNsb25lID0gQ2xvbmU7XG59KShUeXBlQ2xvbmUgfHwgKGV4cG9ydHMuVHlwZUNsb25lID0gVHlwZUNsb25lID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbmRleGVkQWNjZXNzb3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgSW5kZXhlZEFjY2Vzc29yO1xuKGZ1bmN0aW9uIChJbmRleGVkQWNjZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBPcHRpb25hbFVud3JhcChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXAoKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBbZXhwb3J0cy5Nb2RpZmllcl06IF8sIC4uLmNsb25lIH0gPSBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0ludGVyc2VjdE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmV2ZXJ5KChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVW5pb25PcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zb21lKChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gSXNJbnRlcnNlY3RPcHRpb25hbChzY2hlbWEuYWxsT2YpO1xuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBleHBvcnRzLlR5cGUuT3B0aW9uYWwoZXhwb3J0cy5UeXBlLkludGVyc2VjdChPcHRpb25hbFVud3JhcChzY2hlbWEuYWxsT2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBJc1VuaW9uT3B0aW9uYWwoc2NoZW1hLmFueU9mKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gZXhwb3J0cy5UeXBlLk9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihPcHRpb25hbFVud3JhcChzY2hlbWEuYW55T2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlSW50ZXJzZWN0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlVW5pb24oc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWQgPSBWaXNpdChzY2hlbWEsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZFtleHBvcnRzLktpbmRdID09PSAnTmV2ZXInID8gYWNjIDogWy4uLmFjYywgaW5kZXhlZF07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHJlc29sdmVkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGtleSkpO1xuICAgICAgICByZXR1cm4gUmVzb2x2ZU9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihyZXNvbHZlZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzY2hlbWEucHJvcGVydGllc1trZXldO1xuICAgICAgICByZXR1cm4gcHJvcGVydHkgPT09IHVuZGVmaW5lZCA/IGV4cG9ydHMuVHlwZS5OZXZlcigpIDogZXhwb3J0cy5UeXBlLlVuaW9uKFtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgICAgaWYgKGl0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk5ldmVyKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpdGVtc1trZXldOyAvL1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24oc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIGtleSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1R1cGxlJylcbiAgICAgICAgICAgIHJldHVybiBUdXBsZShzY2hlbWEsIGtleSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVzb2x2ZShzY2hlbWEsIGtleXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGtleXMubWFwKChrZXkpID0+IFZpc2l0KHNjaGVtYSwga2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuVW5pb24ocmVzb2x2ZWQsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgSW5kZXhlZEFjY2Vzc29yLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoSW5kZXhlZEFjY2Vzc29yIHx8IChleHBvcnRzLkluZGV4ZWRBY2Nlc3NvciA9IEluZGV4ZWRBY2Nlc3NvciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0TWFwXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIE9iamVjdE1hcDtcbihmdW5jdGlvbiAoT2JqZWN0TWFwKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHNjaGVtYS5hbGxPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgY2FsbGJhY2spKSwgeyAuLi5zY2hlbWEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBjYWxsYmFjaykpLCB7IC4uLnNjaGVtYSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHVzZXJzIG5lZWQgdG8gbWFwIG9iamVjdHMgd2l0aCB1bnJlZ2lzdGVyZWQga2luZHMuIFVzaW5nIGEgVHlwZUd1YXJkIGhlcmUgd291bGRcbiAgICAgICAgLy8gcHJldmVudCBzdWIgc2NoZW1hIG1hcHBpbmcgYXMgdW5yZWdpc3RlcmVkIGtpbmRzIHdpbGwgbm90IHBhc3MgVFNjaGVtYSBjaGVja3MuIFRoaXMgaXMgbm90YWJsZSBpbiB0aGVcbiAgICAgICAgLy8gY2FzZSBvZiBUT2JqZWN0IHdoZXJlIHVucmVnaXN0ZXJlZCBwcm9wZXJ0eSBraW5kcyBjYXVzZSB0aGUgVE9iamVjdCBjaGVjayB0byBmYWlsLiBBcyBtYXBwaW5nIGlzIG9ubHlcbiAgICAgICAgLy8gdXNlZCBmb3IgY29tcG9zaXRpb24sIHdlIHVzZSBleHBsaWNpdCBjaGVja3MgaW5zdGVhZC5cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hcChzY2hlbWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgY2FsbGJhY2spLCAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIE9iamVjdE1hcC5NYXAgPSBNYXA7XG59KShPYmplY3RNYXAgfHwgKGV4cG9ydHMuT2JqZWN0TWFwID0gT2JqZWN0TWFwID0ge30pKTtcbnZhciBLZXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5UmVzb2x2ZXIpIHtcbiAgICBmdW5jdGlvbiBVbndyYXBQYXR0ZXJuKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5WzBdID09PSAnXicgJiYga2V5W2tleS5sZW5ndGggLSAxXSA9PT0gJyQnID8ga2V5LnNsaWNlKDEsIGtleS5sZW5ndGggLSAxKSA6IGtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IFsuLi5hY2MsIC4uLlZpc2l0KHNjaGVtYSwgb3B0aW9ucyldLCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXRzID0gc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBbLi4uc2V0cy5yZWR1Y2UoKHNldCwgb3V0ZXIpID0+IG91dGVyLm1hcCgoa2V5KSA9PiAoc2V0cy5ldmVyeSgoaW5uZXIpID0+IGlubmVyLmluY2x1ZGVzKGtleSkpID8gc2V0LmFkZChrZXkpIDogc2V0KSlbMF0sIG5ldyBTZXQoKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmNsdWRlUGF0dGVybnMgPyBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgOiBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmQoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKiogUmVzb2x2ZXMgYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIHNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVLZXlzKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoVmlzaXQoc2NoZW1hLCBvcHRpb25zKSldO1xuICAgIH1cbiAgICBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyA9IFJlc29sdmVLZXlzO1xuICAgIC8qKiBSZXNvbHZlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIG1hdGNoaW5nIGFsbCBrZXlzIGluIHRoaXMgc2NoZW1hICovXG4gICAgZnVuY3Rpb24gUmVzb2x2ZVBhdHRlcm4oc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBSZXNvbHZlS2V5cyhzY2hlbWEsIHsgaW5jbHVkZVBhdHRlcm5zOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0ga2V5cy5tYXAoKGtleSkgPT4gYCgke1Vud3JhcFBhdHRlcm4oa2V5KX0pYCk7XG4gICAgICAgIHJldHVybiBgXigke3BhdHRlcm4uam9pbignfCcpfSkkYDtcbiAgICB9XG4gICAgS2V5UmVzb2x2ZXIuUmVzb2x2ZVBhdHRlcm4gPSBSZXNvbHZlUGF0dGVybjtcbn0pKEtleVJlc29sdmVyIHx8IChleHBvcnRzLktleVJlc29sdmVyID0gS2V5UmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtleUFycmF5UmVzb2x2ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgS2V5QXJyYXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5QXJyYXlSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBzdHJpbmdbXSBrZXlzIGZyb20gdGhlIGdpdmVuIHNjaGVtYSBvciBhcnJheSB0eXBlLiAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUoc2NoZW1hKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gW3NjaGVtYS5jb25zdF07XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3Qoc2NoZW1hLnBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0tleUFycmF5UmVzb2x2ZXI6IENhbm5vdCByZXNvbHZlIGtleXMgZnJvbSBpbmZpbml0ZSB0ZW1wbGF0ZSBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvci5HZW5lcmF0ZShleHByZXNzaW9uKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoS2V5QXJyYXlSZXNvbHZlciB8fCAoZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gS2V5QXJyYXlSZXNvbHZlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVW5pb25SZXNvbHZlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBVbmlvblJlc29sdmVyO1xuKGZ1bmN0aW9uIChVbmlvblJlc29sdmVyKSB7XG4gICAgZnVuY3Rpb24qIFVuaW9uKHVuaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHVuaW9uLmFueU9mKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVW5pb24oc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJlc29sdmVkIHVuaW9uIHdpdGggaW50ZXJpb3IgdW5pb25zIGZsYXR0ZW5lZCAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUodW5pb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5VbmlvbihbLi4uVW5pb24odW5pb24pXSwgeyAuLi51bmlvbiB9KTtcbiAgICB9XG4gICAgVW5pb25SZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFVuaW9uUmVzb2x2ZXIgfHwgKGV4cG9ydHMuVW5pb25SZXNvbHZlciA9IFVuaW9uUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVGVtcGxhdGVMaXRlcmFsUGF0dGVybjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGF0dGVybikge1xuICAgIGZ1bmN0aW9uIEVzY2FwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBhY2MpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEucGF0dGVybi5zbGljZSgxLCBzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGFjYykpLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgIHJldHVybiBgKCR7dG9rZW5zfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEludGVnZXIoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FjY30ke2V4cG9ydHMuUGF0dGVybk51bWJlcn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQmlnSW50KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuU3RyaW5nfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtFc2NhcGUoc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5Cb29sZWFufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlROZXZlcihzY2hlbWEpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGVMaXRlcmFsUGF0dGVybjogVGVtcGxhdGVMaXRlcmFsIGNhbm5vdCBvcGVyYXRlIG9uIHR5cGVzIG9mIFROZXZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm46IFVuZXhwZWN0ZWQgS2luZCAnJHtzY2hlbWFbZXhwb3J0cy5LaW5kXX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ3JlYXRlKGtpbmRzKSB7XG4gICAgICAgIHJldHVybiBgXiR7a2luZHMubWFwKChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgJycpKS5qb2luKCcnKX1cXCRgO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSA9IENyZWF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gfHwgKGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGF0dGVybiA9IFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyO1xuKGZ1bmN0aW9uIChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYSBUVW5pb24gKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2VFeGFjdCh0ZW1wbGF0ZS5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLm1hcCgodmFsdWUpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24obGl0ZXJhbHMpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhcnNlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yO1xudmFyIFRlbXBsYXRlTGl0ZXJhbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCBjaGFyKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuW2luZGV4XSA9PT0gY2hhciAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoaW5kZXggLSAxKSAhPT0gOTI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBJc05vbkVzY2FwZWQocGF0dGVybiwgaW5kZXgsICcoJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnKScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnfCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0dyb3VwKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCEoSXNPcGVuUGFyZW4ocGF0dGVybiwgMCkgJiYgSXNDbG9zZVBhcmVuKHBhdHRlcm4sIHBhdHRlcm4ubGVuZ3RoIC0gMSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDAgJiYgaW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluR3JvdXAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkgJiYgY291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VBbmQocGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBbY291bnQsIHN0YXJ0XSA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoSXNDbG9zZVBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKElzU2VwYXJhdG9yKHBhdHRlcm4sIGluZGV4KSAmJiBjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29yJywgZXhwcjogZXhwcmVzc2lvbnMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQW5kKHBhdHRlcm4pIHtcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIUlzT3BlblBhcmVuKHZhbHVlLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yKGBUZW1wbGF0ZUxpdGVyYWxQYXJzZXI6IEluZGV4IG11c3QgcG9pbnQgdG8gb3BlbiBwYXJlbnNgKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCB2YWx1ZS5sZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcihgVGVtcGxhdGVMaXRlcmFsUGFyc2VyOiBVbmNsb3NlZCBncm91cCBwYXJlbnMgaW4gZXhwcmVzc2lvbmApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCBwYXR0ZXJuLmxlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5kZXgsIHBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBHcm91cChwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZShwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FuZCcsIGV4cHI6IGV4cHJlc3Npb25zIH07XG4gICAgfVxuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCByZXR1cm5zIGFuIGV4cHJlc3Npb24gdHJlZSAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKElzR3JvdXAocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gUGFyc2UoSW5Hcm91cChwYXR0ZXJuKSk7XG4gICAgICAgIGlmIChJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBPcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKElzUHJlY2VkZW5jZUFuZChwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBBbmQocGF0dGVybik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjb25zdCcsIGNvbnN0OiBwYXR0ZXJuIH07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCBzdHJpcHMgZm9yd2FyZCBhbmQgdHJhaWxpbmcgXiBhbmQgJCAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlRXhhY3QocGF0dGVybikge1xuICAgICAgICByZXR1cm4gUGFyc2UocGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3QgPSBQYXJzZUV4YWN0O1xufSkoVGVtcGxhdGVMaXRlcmFsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsRmluaXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZTtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRmluaXRlKSB7XG4gICAgZnVuY3Rpb24gSXNOdW1iZXIoZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uLnR5cGUgPT09ICdvcicgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwci5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0uY29uc3QgPT09ICcwJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS5jb25zdCA9PT0gJ1sxLTldWzAtOV0qJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQm9vbGVhbihleHByZXNzaW9uKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzBdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS5jb25zdCA9PT0gJ3RydWUnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMV0udHlwZSA9PT0gJ2NvbnN0JyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLmNvbnN0ID09PSAnZmFsc2UnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnICYmIGV4cHJlc3Npb24uY29uc3QgPT09ICcuKic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoZWNrKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKElzQm9vbGVhbihleHByZXNzaW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoSXNOdW1iZXIoZXhwcmVzc2lvbikgfHwgSXNTdHJpbmcoZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdhbmQnKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IEVycm9yKGBUZW1wbGF0ZUxpdGVyYWxGaW5pdGU6IFVua25vd24gZXhwcmVzc2lvbiB0eXBlYCk7XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayA9IENoZWNrO1xufSkoVGVtcGxhdGVMaXRlcmFsRmluaXRlIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24qIFJlZHVjZShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIGJ1ZmZlclswXTtcbiAgICAgICAgZm9yIChjb25zdCBsZWZ0IG9mIGJ1ZmZlclswXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByaWdodCBvZiBSZWR1Y2UoYnVmZmVyLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGAke2xlZnR9JHtyaWdodH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBBbmQoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geWllbGQqIFJlZHVjZShleHByZXNzaW9uLmV4cHIubWFwKChleHByKSA9PiBbLi4uR2VuZXJhdGUoZXhwcildKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBPcihleHByZXNzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXhwciBvZiBleHByZXNzaW9uLmV4cHIpXG4gICAgICAgICAgICB5aWVsZCogR2VuZXJhdGUoZXhwcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBDb25zdChleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBleHByZXNzaW9uLmNvbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiogR2VuZXJhdGUoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnYW5kJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQW5kKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBPcihleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQ29uc3QoZXhwcmVzc2lvbik7XG4gICAgICAgIHRocm93IEVycm9yKCdUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3I6IFVua25vd24gZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUgPSBHZW5lcmF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24qIFBhcnNlVW5pb24odGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3QgdHJpbSA9IHRlbXBsYXRlLnRyaW0oKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBleHBvcnRzLlR5cGUuQm9vbGVhbigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLkJpZ0ludCgpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IHRyaW0uc3BsaXQoJ3wnKS5tYXAoKGxpdGVyYWwpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKGxpdGVyYWwudHJpbSgpKSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBsaXRlcmFscy5sZW5ndGggPT09IDAgPyBleHBvcnRzLlR5cGUuTmV2ZXIoKSA6IGxpdGVyYWxzLmxlbmd0aCA9PT0gMSA/IGxpdGVyYWxzWzBdIDogZXhwb3J0cy5UeXBlLlVuaW9uKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFBhcnNlVGVybWluYWwodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlWzFdICE9PSAneycpIHtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBleHBvcnRzLlR5cGUuTGl0ZXJhbCgnJCcpO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIFtMLCAuLi5SXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHRlbXBsYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0gPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBQYXJzZVVuaW9uKHRlbXBsYXRlLnNsaWNlKDIsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VMaXRlcmFsKHRlbXBsYXRlLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbLi4uTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogUGFyc2VMaXRlcmFsKHRlbXBsYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVtpXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTCA9IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VUZXJtaW5hbCh0ZW1wbGF0ZS5zbGljZShpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXJzZSh0ZW1wbGF0ZV9kc2wpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5QYXJzZUxpdGVyYWwodGVtcGxhdGVfZHNsKV07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xufSkoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZU9yZGluYWw6IFVzZWQgZm9yIGF1dG8gJGlkIGdlbmVyYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5sZXQgVHlwZU9yZGluYWwgPSAwO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUJ1aWxkZXIge1xuICAgIC8qKiBgW1V0aWxpdHldYCBDcmVhdGVzIGEgc2NoZW1hIHdpdGhvdXQgYHN0YXRpY2AgYW5kIGBwYXJhbXNgIHR5cGVzICovXG4gICAgQ3JlYXRlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIE9taXRzIGNvbXBvc2l0aW5nIHN5bWJvbHMgZnJvbSB0aGlzIHNjaGVtYSAqL1xuICAgIFN0cmljdChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlQnVpbGRlciA9IFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YW5kYXJkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBTdGFuZGFyZFR5cGVCdWlsZGVyIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1vZGlmaWVyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIE9wdGlvbmFsIHByb3BlcnR5ICovXG4gICAgT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB7IFtleHBvcnRzLk1vZGlmaWVyXTogJ09wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5T3B0aW9uYWwgcHJvcGVydHkgKi9cbiAgICBSZWFkb25seU9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seU9wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5IG9iamVjdCBvciBwcm9wZXJ0eSAqL1xuICAgIFJlYWRvbmx5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seScsIC4uLnNjaGVtYSB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUeXBlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBBbnkgdHlwZSAqL1xuICAgIEFueShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBbnknIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gQXJyYXkgdHlwZSAqL1xuICAgIEFycmF5KGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBcnJheScsIHR5cGU6ICdhcnJheScsIGl0ZW1zOiBUeXBlQ2xvbmUuQ2xvbmUoaXRlbXMsIHt9KSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgQm9vbGVhbiB0eXBlICovXG4gICAgQm9vbGVhbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdCb29sZWFuJywgdHlwZTogJ2Jvb2xlYW4nIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBDb21wb3NpdGUgb2JqZWN0IHR5cGUuICovXG4gICAgQ29tcG9zaXRlKG9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gZXhwb3J0cy5UeXBlLkludGVyc2VjdChvYmplY3RzLCB7fSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyhpbnRlcnNlY3QsIHsgaW5jbHVkZVBhdHRlcm5zOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gKHsgLi4uYWNjLCBba2V5XTogZXhwb3J0cy5UeXBlLkluZGV4KGludGVyc2VjdCwgW2tleV0pIH0pLCB7fSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuT2JqZWN0KHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBFbnVtIHR5cGUgKi9cbiAgICBFbnVtKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhpdGVtKS5maWx0ZXIoKGtleSkgPT4gaXNOYU4oa2V5KSkubWFwKChrZXkpID0+IGl0ZW1ba2V5XSk7XG4gICAgICAgIGNvbnN0IGFueU9mID0gdmFsdWVzLm1hcCgodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8geyBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgY29uc3Q6IHZhbHVlIH0gOiB7IFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIHR5cGU6ICdudW1iZXInLCBjb25zdDogdmFsdWUgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VuaW9uJywgYW55T2YgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQSBjb25kaXRpb25hbCB0eXBlIGV4cHJlc3Npb24gdGhhdCB3aWxsIHJldHVybiB0aGUgdHJ1ZSB0eXBlIGlmIHRoZSBsZWZ0IHR5cGUgZXh0ZW5kcyB0aGUgcmlnaHQgKi9cbiAgICBFeHRlbmRzKGxlZnQsIHJpZ2h0LCB0cnVlVHlwZSwgZmFsc2VUeXBlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3dpdGNoIChUeXBlRXh0ZW5kcy5FeHRlbmRzKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgY2FzZSBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihbVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKSwgVHlwZUNsb25lLkNsb25lKGZhbHNlVHlwZSwgb3B0aW9ucyldKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShmYWxzZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXhjbHVkZXMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgbm90IGFzc2lnbmFibGUgdG8gdGhlIHJpZ2h0ICovXG4gICAgRXhjbHVkZShsZWZ0LCByaWdodCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4Y2x1ZGUoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShsZWZ0KSwgcmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXhjbHVkZShsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKSB7XG4gICAgICAgICAgICBjb25zdCBuYXJyb3dlZCA9IGxlZnQuYW55T2YuZmlsdGVyKChpbm5lcikgPT4gVHlwZUV4dGVuZHMuRXh0ZW5kcyhpbm5lciwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKG5hcnJvd2VkLmxlbmd0aCA9PT0gMSA/IFR5cGVDbG9uZS5DbG9uZShuYXJyb3dlZFswXSwgb3B0aW9ucykgOiB0aGlzLlVuaW9uKG5hcnJvd2VkLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFR5cGVFeHRlbmRzLkV4dGVuZHMobGVmdCwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IHRoaXMuTmV2ZXIob3B0aW9ucykgOiBUeXBlQ2xvbmUuQ2xvbmUobGVmdCwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXh0cmFjdHMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgYXNzaWduYWJsZSB0byB0aGUgcmlnaHQgKi9cbiAgICBFeHRyYWN0KGxlZnQsIHJpZ2h0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXh0cmFjdChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKGxlZnQpLCByaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeHRyYWN0KGxlZnQsIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUocmlnaHQpLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hcnJvd2VkID0gbGVmdC5hbnlPZi5maWx0ZXIoKGlubmVyKSA9PiBUeXBlRXh0ZW5kcy5FeHRlbmRzKGlubmVyLCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAobmFycm93ZWQubGVuZ3RoID09PSAxID8gVHlwZUNsb25lLkNsb25lKG5hcnJvd2VkWzBdLCBvcHRpb25zKSA6IHRoaXMuVW5pb24obmFycm93ZWQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoVHlwZUV4dGVuZHMuRXh0ZW5kcyhsZWZ0LCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUNsb25lLkNsb25lKGxlZnQsIG9wdGlvbnMpIDogdGhpcy5OZXZlcihvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBSZXR1cm5zIGluZGV4ZWQgcHJvcGVydHkgdHlwZXMgZm9yIHRoZSBnaXZlbiBrZXlzICovXG4gICAgSW5kZXgoc2NoZW1hLCB1bnJlc29sdmVkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShzY2hlbWEuaXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gaXRlbXMubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihjbG9uZWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleUFycmF5UmVzb2x2ZXIuUmVzb2x2ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIEluZGV4ZWRBY2Nlc3Nvci5SZXNvbHZlKGNsb25lLCBrZXlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gSW50ZWdlciB0eXBlICovXG4gICAgSW50ZWdlcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdJbnRlZ2VyJywgdHlwZTogJ2ludGVnZXInIH0pO1xuICAgIH1cbiAgICBJbnRlcnNlY3QoYWxsT2YsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShhbGxPZlswXSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBhbGxPZi5ldmVyeSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gYWxsT2YubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcyA9IFR5cGVHdWFyZC5UU2NoZW1hKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSA/IHsgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiBUeXBlQ2xvbmUuQ2xvbmUob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMsIHt9KSB9IDoge307XG4gICAgICAgIGlmIChvcHRpb25zLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UgfHwgVHlwZUd1YXJkLlRTY2hlbWEob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMpIHx8IG9iamVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCB0eXBlOiAnb2JqZWN0JywgYWxsT2Y6IGNsb25lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCBhbGxPZjogY2xvbmVkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIEtleU9mIHR5cGUgKi9cbiAgICBLZXlPZihzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylbMF07XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0cmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTdGFuZGFyZFR5cGVCdWlsZGVyOiBVbmFibGUgdG8gcmVzb2x2ZSBrZXkgdHlwZSBmcm9tIFJlY29yZCBrZXkgcGF0dGVybicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBpdGVtcy5tYXAoKF8sIGluZGV4KSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbChpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24obGl0ZXJhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleVJlc29sdmVyLlJlc29sdmVLZXlzKHNjaGVtYSwgeyBpbmNsdWRlUGF0dGVybnM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk5ldmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLkxpdGVyYWwoa2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihsaXRlcmFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTGl0ZXJhbCB0eXBlICovXG4gICAgTGl0ZXJhbCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIGNvbnN0OiB2YWx1ZSwgdHlwZTogdHlwZW9mIHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOZXZlciB0eXBlICovXG4gICAgTmV2ZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTmV2ZXInLCBub3Q6IHt9IH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOb3QgdHlwZSAqL1xuICAgIE5vdChub3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdOb3QnLCBub3QgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIE51bGwgdHlwZSAqL1xuICAgIE51bGwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVsbCcsIHR5cGU6ICdudWxsJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTnVtYmVyIHR5cGUgKi9cbiAgICBOdW1iZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVtYmVyJywgdHlwZTogJ251bWJlcicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBPYmplY3QgdHlwZSAqL1xuICAgIE9iamVjdChwcm9wZXJ0aWVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlLZXlzID0gZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxLZXlzID0gcHJvcGVydHlLZXlzLmZpbHRlcigoa2V5KSA9PiBUeXBlR3VhcmQuVE9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkgfHwgVHlwZUd1YXJkLlRSZWFkb25seU9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICBjb25zdCByZXF1aXJlZEtleXMgPSBwcm9wZXJ0eUtleXMuZmlsdGVyKChuYW1lKSA9PiAhb3B0aW9uYWxLZXlzLmluY2x1ZGVzKG5hbWUpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMgPSBUeXBlR3VhcmQuVFNjaGVtYShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA/IHsgYWRkaXRpb25hbFByb3BlcnRpZXM6IFR5cGVDbG9uZS5DbG9uZShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCB7fSkgfSA6IHt9O1xuICAgICAgICBjb25zdCBjbG9uZWRQcm9wZXJ0aWVzID0gcHJvcGVydHlLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShwcm9wZXJ0aWVzW2tleV0sIHt9KSB9KSwge30pO1xuICAgICAgICBpZiAocmVxdWlyZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBbZXhwb3J0cy5LaW5kXTogJ09iamVjdCcsIHR5cGU6ICdvYmplY3QnLCBwcm9wZXJ0aWVzOiBjbG9uZWRQcm9wZXJ0aWVzLCByZXF1aXJlZDogcmVxdWlyZWRLZXlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgLi4uY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnT2JqZWN0JywgdHlwZTogJ29iamVjdCcsIHByb3BlcnRpZXM6IGNsb25lZFByb3BlcnRpZXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT21pdChzY2hlbWEsIHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlKHVucmVzb2x2ZWQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLnJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkLmZpbHRlcigoa2V5KSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIG1hcHBlZCB0eXBlIHdoZXJlIGFsbCBwcm9wZXJ0aWVzIGFyZSBPcHRpb25hbCAqL1xuICAgIFBhcnRpYWwoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHkoc2NoZW1hKSB7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHlPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdSZWFkb25seU9wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHlPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ09wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3RNYXAuTWFwKFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goa2V5ID0+IEFwcGx5KHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBQaWNrKHNjaGVtYSwgdW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUodW5yZXNvbHZlZCk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEucmVxdWlyZWQgPSBzY2hlbWEucmVxdWlyZWQuZmlsdGVyKChrZXkpID0+IGtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZShzY2hlbWEpO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVjb3JkIHR5cGUgKi9cbiAgICBSZWNvcmQoa2V5LCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0KGtleS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayhleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgID8gKHRoaXMuT2JqZWN0KFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW2tleS5wYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRVbmlvbihrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IFVuaW9uUmVzb2x2ZXIuUmVzb2x2ZShrZXkpO1xuICAgICAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb25MaXRlcmFsKHVuaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB1bmlvbi5hbnlPZi5yZWR1Y2UoKGFjYywgbGl0ZXJhbCkgPT4gKHsgLi4uYWNjLCBbbGl0ZXJhbC5jb25zdF06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk9iamVjdChwcm9wZXJ0aWVzLCB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLkhpbnRdOiAnUmVjb3JkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVHlwZUJ1aWxkZXI6IFJlY29yZCBrZXkgb2YgdHlwZSB1bmlvbiBjb250YWlucyBub24tbGl0ZXJhbCB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChrZXkpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleS5jb25zdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGtleS5jb25zdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5PYmplY3QoeyBba2V5LmNvbnN0XTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUeXBlQnVpbGRlcjogUmVjb3JkIGtleSBvZiB0eXBlIGxpdGVyYWwgaXMgbm90IG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihrZXkpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtwYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGtleS5wYXR0ZXJuID09PSB1bmRlZmluZWQgPyBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA6IGtleS5wYXR0ZXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW3BhdHRlcm5dOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTdGFuZGFyZFR5cGVCdWlsZGVyOiBSZWNvcmQga2V5IGlzIGFuIGludmFsaWQgdHlwZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlY3Vyc2l2ZSB0eXBlICovXG4gICAgUmVjdXJzaXZlKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvcHRpb25zLiRpZCA9IGBUJHtUeXBlT3JkaW5hbCsrfWA7XG4gICAgICAgIGNvbnN0IHRoaXNUeXBlID0gY2FsbGJhY2soeyBbZXhwb3J0cy5LaW5kXTogJ1RoaXMnLCAkcmVmOiBgJHtvcHRpb25zLiRpZH1gIH0pO1xuICAgICAgICB0aGlzVHlwZS4kaWQgPSBvcHRpb25zLiRpZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuSGludF06ICdSZWN1cnNpdmUnLCAuLi50aGlzVHlwZSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVmIHR5cGUuIFRoZSByZWZlcmVuY2VkIHR5cGUgbXVzdCBjb250YWluIGEgJGlkICovXG4gICAgUmVmKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChzY2hlbWEuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU3RhbmRhcmRUeXBlQnVpbGRlci5SZWY6IFRhcmdldCB0eXBlIG11c3Qgc3BlY2lmeSBhbiAkaWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWYnLCAkcmVmOiBzY2hlbWEuJGlkIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBtYXBwZWQgdHlwZSB3aGVyZSBhbGwgcHJvcGVydGllcyBhcmUgUmVxdWlyZWQgKi9cbiAgICBSZXF1aXJlZChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBBcHBseShzY2hlbWEpIHtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgc3dpdGNoIChzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdSZWFkb25seU9wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykuZm9yRWFjaChrZXkgPT4gQXBwbHkoc2NoZW1hLnByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgUmV0dXJucyBhIHNjaGVtYSBhcnJheSB3aGljaCBhbGxvd3MgdHlwZXMgdG8gY29tcG9zZSB3aXRoIHRoZSBKYXZhU2NyaXB0IHNwcmVhZCBvcGVyYXRvciAqL1xuICAgIFJlc3Qoc2NoZW1hKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFN0cmluZyB0eXBlICovXG4gICAgU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHR5cGUgKi9cbiAgICBUZW1wbGF0ZUxpdGVyYWwodW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gKHR5cGVvZiB1bnJlc29sdmVkID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8gVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyLlBhcnNlKHVucmVzb2x2ZWQpKVxuICAgICAgICAgICAgOiBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdUZW1wbGF0ZUxpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgcGF0dGVybiB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgVHVwbGUgdHlwZSAqL1xuICAgIFR1cGxlKGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgW2FkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zXSA9IFtmYWxzZSwgaXRlbXMubGVuZ3RoLCBpdGVtcy5sZW5ndGhdO1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gVHlwZUNsb25lLkNsb25lKGl0ZW0sIHt9KSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBzY2hlbWEgPSAoaXRlbXMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVHVwbGUnLCB0eXBlOiAnYXJyYXknLCBpdGVtczogY2xvbmVkSXRlbXMsIGFkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zIH0gOlxuICAgICAgICAgICAgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1R1cGxlJywgdHlwZTogJ2FycmF5JywgbWluSXRlbXMsIG1heEl0ZW1zIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICB9XG4gICAgVW5pb24odW5pb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwodW5pb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZSh1bmlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbnlPZiA9IHVuaW9uO1xuICAgICAgICAgICAgaWYgKGFueU9mLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5OZXZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKFR5cGVDbG9uZS5DbG9uZShhbnlPZlswXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkQW55T2YgPSBhbnlPZi5tYXAoKHNjaGVtYSkgPT4gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5pb24nLCBhbnlPZjogY2xvbmVkQW55T2YgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIFVua25vd24gdHlwZSAqL1xuICAgIFVua25vd24ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5rbm93bicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFVuc2FmZSB0eXBlIHRoYXQgaW5mZXJzIGZvciB0aGUgZ2VuZXJpYyBhcmd1bWVudCAqL1xuICAgIFVuc2FmZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06IG9wdGlvbnNbZXhwb3J0cy5LaW5kXSB8fCAnVW5zYWZlJyB9KTtcbiAgICB9XG59XG5leHBvcnRzLlN0YW5kYXJkVHlwZUJ1aWxkZXIgPSBTdGFuZGFyZFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZGVkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBFeHRlbmRlZFR5cGVCdWlsZGVyIGV4dGVuZHMgU3RhbmRhcmRUeXBlQnVpbGRlciB7XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgQmlnSW50IHR5cGUgKi9cbiAgICBCaWdJbnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQmlnSW50JywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdCaWdJbnQnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBDb25zdHJ1Y3RvclBhcmFtZXRlcnMgZnJvbSB0aGUgZ2l2ZW4gQ29uc3RydWN0b3IgdHlwZSAqL1xuICAgIENvbnN0cnVjdG9yUGFyYW1ldGVycyhzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5UdXBsZShbLi4uc2NoZW1hLnBhcmFtZXRlcnNdLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIENvbnN0cnVjdG9yIHR5cGUgKi9cbiAgICBDb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCByZXR1cm5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFJldHVybnMgPSBUeXBlQ2xvbmUuQ2xvbmUocmV0dXJucywge30pO1xuICAgICAgICBjb25zdCBjbG9uZWRQYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5tYXAoKHBhcmFtZXRlcikgPT4gVHlwZUNsb25lLkNsb25lKHBhcmFtZXRlciwge30pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdDb25zdHJ1Y3RvcicsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnQ29uc3RydWN0b3InLCBwYXJhbWV0ZXJzOiBjbG9uZWRQYXJhbWV0ZXJzLCByZXR1cm5zOiBjbG9uZWRSZXR1cm5zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBEYXRlIHR5cGUgKi9cbiAgICBEYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0RhdGUnLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0RhdGUnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBGdW5jdGlvbiB0eXBlICovXG4gICAgRnVuY3Rpb24ocGFyYW1ldGVycywgcmV0dXJucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXR1cm5zID0gVHlwZUNsb25lLkNsb25lKHJldHVybnMsIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IFR5cGVDbG9uZS5DbG9uZShwYXJhbWV0ZXIsIHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnRnVuY3Rpb24nLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0Z1bmN0aW9uJywgcGFyYW1ldGVyczogY2xvbmVkUGFyYW1ldGVycywgcmV0dXJuczogY2xvbmVkUmV0dXJucyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgSW5zdGFuY2VUeXBlIGZyb20gdGhlIGdpdmVuIENvbnN0cnVjdG9yICovXG4gICAgSW5zdGFuY2VUeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBQYXJhbWV0ZXJzIGZyb20gdGhlIGdpdmVuIEZ1bmN0aW9uIHR5cGUgKi9cbiAgICBQYXJhbWV0ZXJzKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlR1cGxlKHNjaGVtYS5wYXJhbWV0ZXJzLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFByb21pc2UgdHlwZSAqL1xuICAgIFByb21pc2UoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUHJvbWlzZScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnUHJvbWlzZScsIGl0ZW06IFR5cGVDbG9uZS5DbG9uZShpdGVtLCB7fSkgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0eXBlICovXG4gICAgUmVnRXgocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnLCBwYXR0ZXJuOiByZWdleC5zb3VyY2UgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgRXh0cmFjdHMgdGhlIFJldHVyblR5cGUgZnJvbSB0aGUgZ2l2ZW4gRnVuY3Rpb24gKi9cbiAgICBSZXR1cm5UeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBTeW1ib2wgdHlwZSAqL1xuICAgIFN5bWJvbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnU3ltYm9sJywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdTeW1ib2wnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBVbmRlZmluZWQgdHlwZSAqL1xuICAgIFVuZGVmaW5lZChvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdVbmRlZmluZWQnLCB0eXBlOiAnbnVsbCcsIHR5cGVPZjogJ1VuZGVmaW5lZCcgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFVpbnQ4QXJyYXkgdHlwZSAqL1xuICAgIFVpbnQ4QXJyYXkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVWludDhBcnJheScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnVWludDhBcnJheScgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFZvaWQgdHlwZSAqL1xuICAgIFZvaWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVm9pZCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnVm9pZCcgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlbmRlZFR5cGVCdWlsZGVyID0gRXh0ZW5kZWRUeXBlQnVpbGRlcjtcbi8qKiBKU09OIFNjaGVtYSBUeXBlQnVpbGRlciB3aXRoIFN0YXRpYyBSZXNvbHV0aW9uIGZvciBUeXBlU2NyaXB0ICovXG5leHBvcnRzLlN0YW5kYXJkVHlwZSA9IG5ldyBTdGFuZGFyZFR5cGVCdWlsZGVyKCk7XG4vKiogSlNPTiBTY2hlbWEgVHlwZUJ1aWxkZXIgd2l0aCBTdGF0aWMgUmVzb2x1dGlvbiBmb3IgVHlwZVNjcmlwdCAqL1xuZXhwb3J0cy5UeXBlID0gbmV3IEV4dGVuZGVkVHlwZUJ1aWxkZXIoKTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJ7XG4gICAgXCJuYW1lXCI6IFwiQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjFcIlxufVxuIiwgbnVsbCwgInZhciBnbG9iYWwgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcztcbnZhciBfX3NlbGZfXyA9IChmdW5jdGlvbiAoKSB7XG5mdW5jdGlvbiBGKCkge1xudGhpcy5mZXRjaCA9IGZhbHNlO1xudGhpcy5ET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uXG59XG5GLnByb3RvdHlwZSA9IGdsb2JhbDtcbnJldHVybiBuZXcgRigpO1xufSkoKTtcbihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKHt9KTtcbn0pKF9fc2VsZl9fKTtcbl9fc2VsZl9fLmZldGNoLnBvbnlmaWxsID0gdHJ1ZTtcbi8vIFJlbW92ZSBcInBvbHlmaWxsXCIgcHJvcGVydHkgYWRkZWQgYnkgd2hhdHdnLWZldGNoXG5kZWxldGUgX19zZWxmX18uZmV0Y2gucG9seWZpbGw7XG4vLyBDaG9vc2UgYmV0d2VlbiBuYXRpdmUgaW1wbGVtZW50YXRpb24gKGdsb2JhbCkgb3IgY3VzdG9tIGltcGxlbWVudGF0aW9uIChfX3NlbGZfXylcbi8vIHZhciBjdHggPSBnbG9iYWwuZmV0Y2ggPyBnbG9iYWwgOiBfX3NlbGZfXztcbnZhciBjdHggPSBfX3NlbGZfXzsgLy8gdGhpcyBsaW5lIGRpc2FibGUgc2VydmljZSB3b3JrZXIgc3VwcG9ydCB0ZW1wb3JhcmlseVxuZXhwb3J0cyA9IGN0eC5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuZGVmYXVsdCA9IGN0eC5mZXRjaCAvLyBGb3IgVHlwZVNjcmlwdCBjb25zdW1lcnMgd2l0aG91dCBlc01vZHVsZUludGVyb3AuXG5leHBvcnRzLmZldGNoID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IHtmZXRjaH0gZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLkhlYWRlcnMgPSBjdHguSGVhZGVyc1xuZXhwb3J0cy5SZXF1ZXN0ID0gY3R4LlJlcXVlc3RcbmV4cG9ydHMuUmVzcG9uc2UgPSBjdHguUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKHt9KTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQge1xyXG5cdEFwcCxcclxuXHRFZGl0b3IsXHJcblx0SGVhZGluZ0NhY2hlLFxyXG5cdE1hcmtkb3duVmlldyxcclxuXHRNb2RhbCxcclxuXHROb3RpY2UsXHJcblx0UGx1Z2luLFxyXG5cdFBsdWdpblNldHRpbmdUYWIsXHJcblx0U2V0dGluZyxcclxuXHRUQWJzdHJhY3RGaWxlLFxyXG5cdFRGaWxlLFxyXG59IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuaW1wb3J0IHsgcmVhZEZpbGUgfSBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcclxuXHJcbmltcG9ydCB7IHJlYWRGaWxlU3luYywgcmVhZGRpclN5bmMgfSBmcm9tIFwiZnNcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSBcImh0dHBcIjtcclxuaW1wb3J0IHsgc3RhdHVzQ29sb3IgfSBmcm9tIFwidXRpbHMvc3R5bGluZ1wiO1xyXG5pbXBvcnQge1xyXG5cdGFkZFdhcm5pbmcsXHJcblx0YWRkRXJyb3IsXHJcblx0cmVtb3ZlV2FybmluZyxcclxuXHRyZW1vdmVFcnJvcixcclxuXHRnZXRTZWN0aW9uLFxyXG5cdGluc2VydE1hcmtkb3duVW5kZXJIZWFkaW5nLFxyXG5cdGFkZEljb25Ub05hbWUsXHJcblx0cmVtb3ZlSWNvbkZyb21OYW1lLFxyXG59IGZyb20gXCJ1dGlscy9maWxlc1wiO1xyXG5pbXBvcnQge1xyXG5cdGFkZEVtYmVkLFxyXG5cdGNvbXBhcmVSZXF1aXJlbWVudHMsXHJcblx0dGVzdHNUYWJsZSxcclxuXHRyZXF1aXJlbWVudHNUYWJsZTIsXHJcblx0aW50ZXJmYWNlc1RhYmxlLFxyXG59IGZyb20gXCJ1dGlscy9yZXF1aXJlbWVudHNcIjtcclxuaW1wb3J0IHBsdWdpbkhhbmRsZXIgZnJvbSBcInV0aWxzL2dsb2JhbEhhbmRsZXJzXCI7XHJcbmltcG9ydCB7XHJcblx0YWRkQ29tcG9uZW50LFxyXG5cdGFkZFJlcXVpcmVtZW50LFxyXG5cdGFkZFRvU3lzdGVtRGlhZ3JhbSxcclxufSBmcm9tIFwidXRpbHMvdGVtcGxhdGVzXCI7XHJcbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxyXG5cclxubGV0IGF1dG9tYXRpY1Jlc29sdmUgPSBmYWxzZTtcclxuXHJcbmludGVyZmFjZSBNeVBsdWdpblNldHRpbmdzIHtcclxuXHRteVNldHRpbmc6IHN0cmluZztcclxuXHRzeXN0ZW1fZGVzaWduX3Jvb3RfZm9sZGVyOiBzdHJpbmc7XHJcblx0dGVzdF9kb2N1bWVudGF0aW9uX3Jvb3RfZm9sZGVyOiBzdHJpbmc7XHJcblx0aW50ZXJmYWNlc19yb290X2ZvbGRlcjogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xyXG5cdG15U2V0dGluZzogXCJkZWZhdWx0XCIsXHJcblx0c3lzdGVtX2Rlc2lnbl9yb290X2ZvbGRlcjogXCIxMS1TeXN0ZW1zX2Rlc2lnblwiLFxyXG5cdHRlc3RfZG9jdW1lbnRhdGlvbl9yb290X2ZvbGRlcjogXCIwNS1UZXN0X2RvY3VtZW50YXRpb25cIixcclxuXHRpbnRlcmZhY2VzX3Jvb3RfZm9sZGVyOiBcIjEyLUludGVyZmFjZXNcIixcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcblx0XHRjcmVhdGVTZXJ2ZXIoYXN5bmMgKHJlcSwgcmVzKSA9PiB7XHJcblx0XHRcdGNvbnN0IHJlcVVybCA9IHJlcS51cmw7XHJcblx0XHRcdGNvbnNvbGUubG9nKHJlcVVybCk7XHJcblxyXG5cdFx0XHRpZiAoIXJlcVVybCkge1xyXG5cdFx0XHRcdHJlcy5lbmQoXCJObyB1cmwgcHJvdmlkZWRcIik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkaXNhYmxlIGNvcnNcclxuXHRcdFx0cmVzLndyaXRlSGVhZCgyMDAsIHtcclxuXHRcdFx0XHRcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIixcclxuXHRcdFx0XHRcIkFjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHNcIjogXCJHRVQsIFBPU1QsIE9QVElPTlNcIixcclxuXHRcdFx0XHRcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIjpcclxuXHRcdFx0XHRcdFwiT3JpZ2luLCBYLVJlcXVlc3RlZC1XaXRoLCBDb250ZW50LVR5cGUsIEFjY2VwdFwiLFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChcclxuXHRcdFx0XHRcIm1vZGVscy9XYWRkbGVzX3dtLnN0bFwiXHJcblx0XHRcdCkgYXMgYW55O1xyXG5cdFx0XHRjb25zdCB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheShcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGZpbGUpXHJcblx0XHRcdCk7XHJcblx0XHRcdHJlcy5lbmQodWludDhWaWV3KTtcclxuXHRcdFx0Ly8gcmVhZCBhIGxvY2FsIGZpbGVcclxuXHRcdH0pLmxpc3Rlbig1NTY2KTtcclxuXHJcblx0XHRwbHVnaW5IYW5kbGVyLmluaXQodGhpcy5hcHApO1xyXG5cclxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2codGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zKTtcclxuXHRcdFx0cGx1Z2luSGFuZGxlci5zZXRQbHVnaW5zKHtcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRkYXRhdmlldzogdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zW1wiZGF0YXZpZXdcIl0uYXBpLFxyXG5cdFx0XHRcdC8vQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGZyb250bWF0dGVyOiB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnNbXCJtZXRhZGF0YS1tZW51XCJdLmFwaSxcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRza2Ffc2U6IHRoaXMuYXBwLnBsdWdpbnMucGx1Z2luc1tcInNrYS1zZS1vYnNpZGlhbi1wbHVnaW5cIl0sXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHQvLyBUaGlzIGNyZWF0ZXMgYW4gaWNvbiBpbiB0aGUgbGVmdCByaWJib24uXHJcblx0XHRjb25zdCByaWJib25JY29uRWwgPSB0aGlzLmFkZFJpYmJvbkljb24oXHJcblx0XHRcdFwiZGljZVwiLFxyXG5cdFx0XHRcIlNLQSBTRVwiLFxyXG5cdFx0XHQoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcblx0XHRcdFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBpY29uLlxyXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJUaGlzIGlzIGEgbm90aWNlIVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHRcdC8vIFBlcmZvcm0gYWRkaXRpb25hbCB0aGluZ3Mgd2l0aCB0aGUgcmliYm9uXHJcblx0XHRyaWJib25JY29uRWwuYWRkQ2xhc3MoXCJteS1wbHVnaW4tcmliYm9uLWNsYXNzXCIpO1xyXG5cclxuXHRcdC8vIFRoaXMgYWRkcyBhIHN0YXR1cyBiYXIgaXRlbSB0byB0aGUgYm90dG9tIG9mIHRoZSBhcHAuIERvZXMgbm90IHdvcmsgb24gbW9iaWxlIGFwcHMuXHJcblx0XHRjb25zdCBzdGF0dXNCYXJJdGVtRWwgPSB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKTtcclxuXHRcdHN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KFwiU3RhdHVzIEJhciBUZXh0XCIpO1xyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcImFkZC1yZXF1aXJlbWVudHNcIixcclxuXHRcdFx0bmFtZTogXCJBZGQgcmVxdWlyZW1lbnRcIixcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBjdXJyZW50RmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblxyXG5cdFx0XHRcdGlmICghY3VycmVudEZpbGUpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJBY3RpdmUgZmlsZSBpcyBub3QgYSBjb21wb25lbnRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBzeXN0ZW0gPVxyXG5cdFx0XHRcdFx0YXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGN1cnJlbnRGaWxlKT8uZnJvbnRtYXR0ZXJcclxuXHRcdFx0XHRcdFx0Py5JRDtcclxuXHJcblx0XHRcdFx0aWYgKCFzeXN0ZW0pIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJBY3RpdmUgZmlsZSBpcyBub3QgYSBjb21wb25lbnRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBuZXdSZXF1aXJlbWVudCA9IGF3YWl0IGFkZFJlcXVpcmVtZW50KHtcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlwiLFxyXG5cdFx0XHRcdFx0c291cmNlOiBcIlwiLFxyXG5cdFx0XHRcdFx0c3lzdGVtLFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHQvLyBvcGVuIHRoZSBuZXcgZmlsZVxyXG5cdFx0XHRcdGFwcC53b3Jrc3BhY2VcclxuXHRcdFx0XHRcdC5jcmVhdGVMZWFmQnlTcGxpdChhcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpKVxyXG5cdFx0XHRcdFx0Lm9wZW5GaWxlKG5ld1JlcXVpcmVtZW50KTtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcImFkZC1jb21wb25lbnRcIixcclxuXHRcdFx0bmFtZTogXCJBZGQgY29tcG9uZW50XCIsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0bmV3IENyZWF0ZUNvbXBvbmVudE1vZGFsKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzKS5vcGVuKCk7XHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXHJcblx0XHRcdFwic3RscmVuZGVyXCIsXHJcblx0XHRcdGFzeW5jIChzb3VyY2UsIGVsLCBjdHgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XHJcblx0XHRcdFx0ZnJhbWUuaWQgPSBcInN0bGZyYW1lXCI7XHJcblx0XHRcdFx0ZWwuYXBwZW5kQ2hpbGQoZnJhbWUpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoXHJcblx0XHRcdFx0XHRhcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpICtcclxuXHRcdFx0XHRcdFx0XCIvLm9ic2lkaWFuL3BsdWdpbnMvc2thX3NlL3RlbXBsYXRlcy9pbmRleC5odG1sXCJcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBkb2MgPSBmcmFtZS5jb250ZW50V2luZG93Py5kb2N1bWVudDtcclxuXHRcdFx0XHRkb2M/Lm9wZW4oKTtcclxuXHRcdFx0XHRkb2M/LndyaXRlKGNvbnRlbnQudG9TdHJpbmcoKSk7XHJcblx0XHRcdFx0ZG9jPy5jbG9zZSgpO1xyXG5cclxuXHRcdFx0XHRmcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG5cdFx0XHRcdGZyYW1lLnN0eWxlLm1pbkhlaWdodCA9IFwiNDAwcHhcIjtcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRjb25zdCBmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGxmcmFtZVwiKTtcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRmLmNvbnRlbnRXaW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0Zi5jb250ZW50V2luZG93Py5zdGFydFJlbmRlcihcIi9cIiArIHNvdXJjZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhZGRzIGFuIGVkaXRvciBjb21tYW5kIHRoYXQgY2FuIHBlcmZvcm0gc29tZSBvcGVyYXRpb24gb24gdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogXCJzYW1wbGUtZWRpdG9yLWNvbW1hbmRcIixcclxuXHRcdFx0bmFtZTogXCJTYW1wbGUgZWRpdG9yIGNvbW1hbmRcIixcclxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcclxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihcIlNhbXBsZSBFZGl0b3IgQ29tbWFuZFwiKTtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXHJcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgcGx1Z2luIGhvb2tzIHVwIGFueSBnbG9iYWwgRE9NIGV2ZW50cyAob24gcGFydHMgb2YgdGhlIGFwcCB0aGF0IGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgcGx1Z2luKVxyXG5cdFx0Ly8gVXNpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lciB3aGVuIHRoaXMgcGx1Z2luIGlzIGRpc2FibGVkLlxyXG5cdFx0Ly8gdGhpcy5yZWdpc3RlckRvbUV2ZW50KGRvY3VtZW50LCBcImNsaWNrXCIsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuXHRcdC8vIFx0Y29uc29sZS5sb2coXCJjbGlja1wiLCBldnQpO1xyXG5cdFx0Ly8gfSk7XHJcblxyXG5cdFx0Ly8gV2hlbiByZWdpc3RlcmluZyBpbnRlcnZhbHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBpbnRlcnZhbCB3aGVuIHRoZSBwbHVnaW4gaXMgZGlzYWJsZWQuXHJcblx0XHQvLyB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwoXHJcblx0XHQvLyBcdHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiBjb25zb2xlLmxvZyhcInNldEludGVydmFsXCIpLCA1ICogNjAgKiAxMDAwKVxyXG5cdFx0Ly8gKTtcclxuXHJcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW9wZW5cIiwgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0aGlzRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHRcdGlmICghdGhpc0ZpbGUpIHJldHVybjtcclxuXHJcblx0XHRcdGlmICh0aGlzRmlsZS5leHRlbnNpb24gPT09IFwiY2FudmFzXCIpXHJcblx0XHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT5cclxuXHRcdFx0XHRcdGhhbmRsZUNhbnZhcyh0aGlzRmlsZSwgdGhpcylcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHQvLyBzeXN0ZW0gZGVzaWduXHJcblx0XHRcdGVsc2UgaWYgKFxyXG5cdFx0XHRcdHRoaXNGaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiICYmXHJcblx0XHRcdFx0dGhpc0ZpbGUucGF0aC5pbmNsdWRlcyhcclxuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3lzdGVtX2Rlc2lnbl9yb290X2ZvbGRlclxyXG5cdFx0XHRcdCkgJiZcclxuXHRcdFx0XHQhdGhpc0ZpbGUucGF0aC5pbmNsdWRlcyhcIlJlcXVpcmVtZW50c1wiKVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcInN5c3RlbSBkZXNpZ25cIik7XHJcblx0XHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xyXG5cdFx0XHRcdFx0aGFuZGxlU3lzdGVtKHRoaXNGaWxlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHQvLyBpbnRlcmZhY2VzXHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0dGhpc0ZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgJiZcclxuXHRcdFx0XHR0aGlzRmlsZS5wYXRoLmluY2x1ZGVzKHRoaXMuc2V0dGluZ3MuaW50ZXJmYWNlc19yb290X2ZvbGRlcilcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJpbnRlcmZhY2VzXCIpO1xyXG5cdFx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcclxuXHRcdFx0XHRcdGhhbmRsZUludGVyZmFjZSh0aGlzRmlsZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0dGhpc0ZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgJiZcclxuXHRcdFx0XHR0aGlzRmlsZS5wYXRoLmluY2x1ZGVzKFwiUmVxdWlyZW1lbnRzXCIpICYmXHJcblx0XHRcdFx0dGhpc0ZpbGUuYmFzZW5hbWUgIT09IFwiUmVxdWlyZW1lbnRzXCJcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJoYW5kbGluZyByZXF1aXJlbWVudFwiKTtcclxuXHRcdFx0XHRoYW5kbGVSZXF1aXJlbWVudCh0aGlzRmlsZSwgdGhpcy5hcHApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW9wZW5cIiwgYXN5bmMgKGZpbGUpID0+IHtcclxuXHRcdFx0aWYgKCFmaWxlKSByZXR1cm47XHJcblx0XHRcdGlmIChmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiKSB7XHJcblx0XHRcdFx0Ly9AdHMtaWdub3JlXHJcblx0XHRcdFx0Y29uc3QgZHYgPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKS5kYXRhdmlldztcclxuXHRcdFx0XHRjb25zdCBwYWdlcyA9IFsuLi5kdi5wYWdlcygnXCJSZXF1aXJlbWVudHNcIicpXTtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhwYWdlcyk7XHJcblx0XHRcdFx0aWYgKCFwYWdlcykgcmV0dXJuO1xyXG5cdFx0XHRcdGNvbnN0IHBhZ2VDbGFzcyA9IE9iamVjdC5lbnRyaWVzKHBhZ2VzKS5maW5kKChbLCBwYWdlXSkgPT4ge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhZ2UuZmlsZS5wYXRoID09PSBmaWxlLnBhdGg7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChwYWdlQ2xhc3MgJiYgcGFnZUNsYXNzWzFdLkNsYXNzLmluY2x1ZGVzKFwiUmVxdWlyZW1lbnRcIikpIHtcclxuXHRcdFx0XHRcdGF3YWl0IGhhbmRsZVJlcXVpcmVtZW50KGZpbGUsIGFwcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCByZXNvbHZlZEZpbGVzOiAoKCkgPT4gUHJvbWlzZTx2b2lkPilbXSA9IFtdO1xyXG5cclxuXHRcdC8vIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oXCJyZXNvbHZlXCIsIGFzeW5jIChmaWxlKSA9PiB7XHJcblx0XHQvLyBcdGlmICghZmlsZSkgcmV0dXJuO1xyXG5cdFx0Ly8gXHRpZiAoYXV0b21hdGljUmVzb2x2ZSkge1xyXG5cdFx0Ly8gXHRcdGF1dG9tYXRpY1Jlc29sdmUgPSBmYWxzZTtcclxuXHRcdC8vIFx0XHRyZXR1cm47XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIFx0aWYgKGZpbGUucGF0aC5pbmNsdWRlcyhcIi5tZFwiKSkge1xyXG5cdFx0Ly8gXHRcdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoXCJSZXF1aXJlbWVudHNcIikpIHtcclxuXHRcdC8vIFx0XHRcdGNvbnN0IGZpbGVEYXRhID0gdGhpcy5hcHAudmF1bHRcclxuXHRcdC8vIFx0XHRcdFx0LmdldE1hcmtkb3duRmlsZXMoKVxyXG5cdFx0Ly8gXHRcdFx0XHQuZmluZCgoZikgPT4gZi5wYXRoID09PSBmaWxlLnBhdGgpO1xyXG5cclxuXHRcdC8vIFx0XHRcdGlmICghZmlsZURhdGEpIHJldHVybjtcclxuXHRcdC8vIFx0XHRcdGlmIChcclxuXHRcdC8vIFx0XHRcdFx0dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyXHJcblx0XHQvLyBcdFx0XHRcdFx0Py5TdGF0dXMgPT09IFwiQ29uZmxpY3RcIlxyXG5cdFx0Ly8gXHRcdFx0KVxyXG5cdFx0Ly8gXHRcdFx0XHRyZXR1cm47XHJcblx0XHQvLyBcdFx0XHRyZXNvbHZlZEZpbGVzLnB1c2goKCkgPT4gaGFuZGxlUmVxdWlyZW1lbnQoZmlsZURhdGEsIGFwcCkpO1xyXG5cdFx0Ly8gXHRcdH1cclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfSk7XHJcblxyXG5cdFx0dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbihcInJlc29sdmVkXCIsIGFzeW5jICgpID0+IHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0YXdhaXQgcmVzb2x2ZWRGaWxlc1tpXSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdG9udW5sb2FkKCkge31cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXHJcblx0XHRcdHt9LFxyXG5cdFx0XHRERUZBVUxUX1NFVFRJTkdTLFxyXG5cdFx0XHRhd2FpdCB0aGlzLmxvYWREYXRhKClcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2FudmFzKGNhbnZhc0ZpbGU6IFRGaWxlLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcblx0Y29uc3QgYXBwID0gcGx1Z2luSGFuZGxlci5hcHA7XHJcblxyXG5cdGNvbnN0IGNhbnZhc0ZpbGVSYXcgPSBhd2FpdCBhcHAudmF1bHQucmVhZChjYW52YXNGaWxlKTtcclxuXHRjb25zdCBjYW52YXNKc29uID0gSlNPTi5wYXJzZShjYW52YXNGaWxlUmF3KTtcclxuXHJcblx0aWYgKGNhbnZhc0ZpbGUuYmFzZW5hbWUgIT09IFwiU3lzdGVtIERpYWdyYW1cIikgcmV0dXJuO1xyXG5cclxuXHRjb25zdCBub2RlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJjYW52YXMtbm9kZVwiKTtcclxuXHJcblx0QXJyYXkuZnJvbShub2RlcykuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG5cdFx0cmVzb2x2ZUNvbXBvbmVudChub2RlKTtcclxuXHR9KTtcclxuXHJcblx0Y29uc3QgZWRnZXMgPSBjYW52YXNKc29uLmVkZ2VzO1xyXG5cclxuXHRlZGdlcy5mb3JFYWNoKFxyXG5cdFx0KFxyXG5cdFx0XHRlZGdlOiB7XHJcblx0XHRcdFx0bGFiZWw6IGFueTtcclxuXHRcdFx0fSxcclxuXHRcdFx0aWR4OiBudW1iZXJcclxuXHRcdCkgPT4ge1xyXG5cdFx0XHRpZiAoIWVkZ2UubGFiZWwpIHtcclxuXHRcdFx0XHRjYW52YXNKc29uLmVkZ2VzW2lkeF0ubGFiZWwgPSBcIlx1MjZBMFx1RkUwRlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0KTtcclxuXHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KGNhbnZhc0ZpbGUsIEpTT04uc3RyaW5naWZ5KGNhbnZhc0pzb24pKTtcclxuXHJcblx0Y29uc3QgdXNlZEVkZ2VzOiBhbnlbXSA9IFtdO1xyXG5cdGNvbnN0IG5ld0Nvbm5lY3Rpb25zOiB7XHJcblx0XHRba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcclxuXHR9ID0ge307XHJcblx0Y29uc3QgZWRnZXNFbHMgPSBBcnJheS5mcm9tKFxyXG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNhbnZhcy1wYXRoLWxhYmVsXCIpXHJcblx0KTtcclxuXHRlZGdlcy5mb3JFYWNoKChlZGdlOiBhbnksIGlkeDogbnVtYmVyKSA9PiByZXNvbHZlRWRnZShlZGdlLCBpZHgpKTtcclxuXHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KGNhbnZhc0ZpbGUsIEpTT04uc3RyaW5naWZ5KGNhbnZhc0pzb24pKTtcclxuXHJcblx0Y29uc3QgaW50ID0gYXdhaXQgcGx1Z2luSGFuZGxlclxyXG5cdFx0LmdldFBsdWdpbnMoKVxyXG5cdFx0LmRhdGF2aWV3LnBhZ2VzKGBcIiR7cGx1Z2luLnNldHRpbmdzLmludGVyZmFjZXNfcm9vdF9mb2xkZXJ9XCJgKTtcclxuXHRpbnQuZm9yRWFjaChhc3luYyAoaTogYW55KSA9PiB7XHJcblx0XHRhd2FpdCBwbHVnaW5IYW5kbGVyXHJcblx0XHRcdC5nZXRQbHVnaW5zKClcclxuXHRcdFx0LmZyb250bWF0dGVyLnBvc3RWYWx1ZXMoaS5maWxlLnBhdGgsIFtcclxuXHRcdFx0XHR7IG5hbWU6IFwiQ29ubmVjdGlvbnNcIiwgcGF5bG9hZDogeyB2YWx1ZTogXCJcIiB9IH0sXHJcblx0XHRcdF0pO1xyXG5cdH0pO1xyXG5cclxuXHQvLyB1cGRhdGUgdGhlIGNvbm5lY3Rpb25zIHByb3BlcnR5IG9mIGVhY2ggaW50ZXJmYWNlXHJcblx0T2JqZWN0LmVudHJpZXMobmV3Q29ubmVjdGlvbnMpLmZvckVhY2goYXN5bmMgKFtmaWxlLCBjb25uZWN0aW9uc10pID0+IHtcclxuXHRcdGNvbnN0IGZpbGVDYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldENhY2hlKGZpbGUpO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHRmaWxlQ2FjaGUgJiZcclxuXHRcdFx0ZmlsZUNhY2hlLmZyb250bWF0dGVyICYmXHJcblx0XHRcdGZpbGVDYWNoZS5mcm9udG1hdHRlci5Db25uZWN0aW9uc1xyXG5cdFx0KSB7XHJcblx0XHRcdGF3YWl0IHBsdWdpbkhhbmRsZXIuZ2V0UGx1Z2lucygpLmZyb250bWF0dGVyLnBvc3RWYWx1ZXMoZmlsZSwgW1xyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdG5hbWU6IFwiQ29ubmVjdGlvbnNcIixcclxuXHRcdFx0XHRcdHBheWxvYWQ6IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IGNvbm5lY3Rpb25zXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgoYzogc3RyaW5nKSA9PiBgXFxuIC0gJHtjLnRyaW0oKX1gKVxyXG5cdFx0XHRcdFx0XHRcdC5qb2luKFwiXCIpLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0YXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChub2RlOiBFbGVtZW50KSB7XHJcblx0XHRsZXQgaXNHcm91cCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhcImNhbnZhcy1ub2RlLWdyb3VwXCIpKSBpc0dyb3VwID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBhZGQgY2xhc3MgdG8gZ3JvdXAgdG8gbWFrZSBpdCBjbGlja2FibGVcclxuXHRcdG5vZGUuY2xhc3NMaXN0LmFkZChcImNhbnZhcy1ub2RlLXN1YnN5c3RlbVwiKTtcclxuXHRcdGNvbnN0IGdyb3VwQ29udGVudCA9IG5vZGUuY2hpbGROb2Rlc1swXT8uY2hpbGROb2Rlc1swXTtcclxuXHRcdGNvbnN0IGdyb3VwTGFiZWwgPSBub2RlLmNoaWxkTm9kZXNbMV07XHJcblxyXG5cdFx0Y29uc3Qgbm9kZU5hbWUgPSBpc0dyb3VwXHJcblx0XHRcdD8gZ3JvdXBMYWJlbD8udGV4dENvbnRlbnRcclxuXHRcdFx0OiBncm91cENvbnRlbnQ/LnRleHRDb250ZW50O1xyXG5cclxuXHRcdGlmICghbm9kZU5hbWUpIHJldHVybjtcclxuXHJcblx0XHRjb25zdCBub2RlRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KG5vZGVOYW1lLCBcIlwiKTtcclxuXHJcblx0XHRpZiAoIW5vZGVGaWxlKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZG9tLWV2ZW50LXJlZ2lzdGVyZWRcIikpIHJldHVybjtcclxuXHRcdHBsdWdpbi5yZWdpc3RlckRvbUV2ZW50KG5vZGUgYXMgSFRNTEVsZW1lbnQsIFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xyXG5cdFx0XHRpZiAobm9kZUZpbGUgJiYgbm9kZUZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcclxuXHRcdFx0XHRhcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChub2RlRmlsZS5wYXRoLCBcIlwiLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bm9kZS5jbGFzc0xpc3QuYWRkKFwiZG9tLWV2ZW50LXJlZ2lzdGVyZWRcIik7XHJcblxyXG5cdFx0bGV0IHVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzSnNvbi5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0Y2FudmFzSnNvbi5ub2Rlc1tpXS5sYWJlbCA9PT0gbm9kZU5hbWUgJiZcclxuXHRcdFx0XHRjYW52YXNKc29uLm5vZGVzW2ldLmZpbGUgIT09IG5vZGVGaWxlPy5wYXRoXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0Y2FudmFzSnNvbi5ub2Rlc1tpXS5maWxlID0gbm9kZUZpbGU/LnBhdGg7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHVwZGF0ZSAmJlxyXG5cdFx0XHQoYXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShjYW52YXNGaWxlLCBKU09OLnN0cmluZ2lmeShjYW52YXNKc29uKSkpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBoYW5kbGVycyBsb2dpY1xyXG5cdFx0aWYgKGlzR3JvdXApIHtcclxuXHRcdFx0cGx1Z2luLnJlZ2lzdGVyRG9tRXZlbnQoZ3JvdXBMYWJlbCBhcyBIVE1MRWxlbWVudCwgXCJmb2N1c291dFwiLCAoKSA9PlxyXG5cdFx0XHRcdHJlc29sdmVDb21wb25lbnQobm9kZSlcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBsdWdpbi5yZWdpc3RlckRvbUV2ZW50KFxyXG5cdFx0XHRcdGdyb3VwQ29udGVudCBhcyBIVE1MRWxlbWVudCxcclxuXHRcdFx0XHRcIm1vdXNlb3V0XCIsXHJcblx0XHRcdFx0KCkgPT4gcmVzb2x2ZUNvbXBvbmVudChub2RlKVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUVkZ2UoXHJcblx0XHRlZGdlSnNvbjoge1xyXG5cdFx0XHRsYWJlbDogYW55O1xyXG5cdFx0XHRjaGlsZE5vZGVzOiBhbnk7XHJcblx0XHRcdGZyb21Ob2RlOiBhbnk7XHJcblx0XHRcdHRvTm9kZTogYW55O1xyXG5cdFx0XHRpZDogc3RyaW5nO1xyXG5cdFx0fSxcclxuXHRcdGluZGV4OiBudW1iZXJcclxuXHQpIHtcclxuXHRcdGNvbnN0IGVkZ2UgPSBBcnJheS5mcm9tKGVkZ2VzRWxzKS5maW5kKChlZGdlKSA9PiB7XHJcblx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0ZWRnZUpzb24ubGFiZWwgPT09IGVkZ2UuY2hpbGROb2Rlc1swXT8udGV4dENvbnRlbnQgJiZcclxuXHRcdFx0XHQhdXNlZEVkZ2VzLmluY2x1ZGVzKGVkZ2UpXHJcblx0XHRcdCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWVkZ2UpIHJldHVybjtcclxuXHJcblx0XHQvLyBnZXQgdGhlIGVkZ2UgZnJvbSB0aGUgY2FudmFzIGZpbGVcclxuXHJcblx0XHRjb25zdCBlZGdlTmFtZSA9IGVkZ2UuY2hpbGROb2Rlc1swXT8udGV4dENvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKCFlZGdlTmFtZSB8fCBlZGdlTmFtZS5sZW5ndGggPD0gMykge1xyXG5cdFx0XHRjYW52YXNKc29uLmVkZ2VzW2luZGV4XS5sYWJlbCA9IFwiXHUyNkEwXHVGRTBGXCI7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYmVzdE1hdGNoID0gXCJcIjtcclxuXHJcblx0XHRPYmplY3QuZW50cmllcyhhcHAudmF1bHQuZmlsZU1hcCkuZm9yRWFjaCgoW3BhdGgsIGZpbGVdKSA9PiB7XHJcblx0XHRcdGlmIChwYXRoLmluY2x1ZGVzKFwiLm1kXCIpKSB7XHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0ZmlsZS5iYXNlbmFtZVxyXG5cdFx0XHRcdFx0XHQudG9Mb3dlckNhc2UoKVxyXG5cdFx0XHRcdFx0XHQuaW5jbHVkZXMoZWRnZU5hbWU/LnRvTG93ZXJDYXNlKCkpICYmXHJcblx0XHRcdFx0XHRmaWxlLmJhc2VuYW1lLmxlbmd0aCA+IGJlc3RNYXRjaC5sZW5ndGhcclxuXHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdGJlc3RNYXRjaCA9IGZpbGUuYmFzZW5hbWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBlZGdlRmlsZSA9IGVkZ2VOYW1lXHJcblx0XHRcdD8gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoYmVzdE1hdGNoLCBcIlwiKVxyXG5cdFx0XHQ6IG51bGw7XHJcblxyXG5cdFx0aWYgKCFlZGdlRmlsZSB8fCBlZGdlRmlsZS5leHRlbnNpb24gIT09IFwibWRcIikgcmV0dXJuO1xyXG5cclxuXHRcdGlmICghZWRnZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkb20tZXZlbnQtcmVnaXN0ZXJlZFwiKSkge1xyXG5cdFx0XHRwbHVnaW4ucmVnaXN0ZXJEb21FdmVudChlZGdlIGFzIEhUTUxFbGVtZW50LCBcImRibGNsaWNrXCIsICgpID0+IHtcclxuXHRcdFx0XHRhcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChlZGdlRmlsZS5wYXRoLCBcIlwiLCB0cnVlKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRlZGdlLmNsYXNzTGlzdC5hZGQoXCJkb20tZXZlbnQtcmVnaXN0ZXJlZFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZXQgdGhlIGZyb20gYW5kIHRvIG5vZGVzXHJcblx0XHRjb25zdCBmcm9tTm9kZSA9IGNhbnZhc0pzb24ubm9kZXMuZmluZCgobm9kZTogYW55KSA9PiB7XHJcblx0XHRcdHJldHVybiBub2RlLmlkID09PSBlZGdlSnNvbi5mcm9tTm9kZTtcclxuXHRcdH0pLmZpbGU7XHJcblx0XHRjb25zdCB0b05vZGUgPSBjYW52YXNKc29uLm5vZGVzLmZpbmQoKG5vZGU6IGFueSkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5pZCA9PT0gZWRnZUpzb24udG9Ob2RlO1xyXG5cdFx0fSkuZmlsZTtcclxuXHJcblx0XHQvLyBnZXQgdGhlIGZyb20gYW5kIHRvIGZpbGVzXHJcblx0XHRjb25zdCBmcm9tRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGZyb21Ob2RlLCBcIlwiKTtcclxuXHRcdGNvbnN0IHRvRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHRvTm9kZSwgXCJcIik7XHJcblxyXG5cdFx0Ly8gZ2V0IHRoZSBmcm9tIGFuZCB0byBjb25uZWN0aW9uc1xyXG5cdFx0Y29uc3QgZnJvbUNvbmVuY3Rpb24gPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZnJvbUZpbGUgYXMgYW55KVxyXG5cdFx0XHQ/LmZyb250bWF0dGVyPy5JRDtcclxuXHRcdGNvbnN0IHRvQ29ubmVjdGlvbiA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0b0ZpbGUgYXMgYW55KVxyXG5cdFx0XHQ/LmZyb250bWF0dGVyPy5JRDtcclxuXHJcblx0XHRpZiAoZWRnZUZpbGUpIHtcclxuXHRcdFx0Ly8gZ2V0IHRoZSBlZGdlJ3MgZmlsZSBjYWNoZVxyXG5cdFx0XHRjb25zdCBlZGdlRmlsZUNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGUoZWRnZUZpbGUucGF0aCk7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRlZGdlRmlsZUNhY2hlICYmXHJcblx0XHRcdFx0ZWRnZUZpbGVDYWNoZS5mcm9udG1hdHRlciAmJlxyXG5cdFx0XHRcdGVkZ2VGaWxlQ2FjaGUuZnJvbnRtYXR0ZXIuQ29ubmVjdGlvbnNcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0aWYgKCFuZXdDb25uZWN0aW9uc1tlZGdlRmlsZS5wYXRoXSkge1xyXG5cdFx0XHRcdFx0bmV3Q29ubmVjdGlvbnNbZWRnZUZpbGUucGF0aF0gPSBbXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bmV3Q29ubmVjdGlvbnNbZWRnZUZpbGUucGF0aF0ucHVzaChcclxuXHRcdFx0XHRcdGAke2Zyb21Db25lbmN0aW9ufSA8PT4gJHt0b0Nvbm5lY3Rpb259YFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjYW52YXNKc29uLmVkZ2VzW2luZGV4XS5sYWJlbCA9IGVkZ2VGaWxlLmJhc2VuYW1lO1xyXG5cdFx0dXNlZEVkZ2VzLnB1c2goZWRnZSk7XHJcblx0fVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTeXN0ZW0oZmlsZTogVEZpbGUpIHtcclxuXHRpZiAoIWZpbGUpIHJldHVybjtcclxuXHJcblx0Y29uc3QgeyBmcm9udG1hdHRlciB9ID0gcGx1Z2luSGFuZGxlci5nZXRQbHVnaW5zKCk7XHJcblx0Y29uc3Qgc3lzdGVtID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcj8uU3lzdGVtO1xyXG5cdGNvbnN0IGFsaWFzID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcj8uYWxpYXNlcztcclxuXHJcblx0YXdhaXQgZnJvbnRtYXR0ZXIucG9zdFZhbHVlcyhmaWxlLCBbXHJcblx0XHR7XHJcblx0XHRcdG5hbWU6IFwiSURcIixcclxuXHRcdFx0cGF5bG9hZDoge1xyXG5cdFx0XHRcdHZhbHVlOlxyXG5cdFx0XHRcdFx0c3lzdGVtICtcclxuXHRcdFx0XHRcdFwiLlwiICtcclxuXHRcdFx0XHRcdChhbGlhc1swXVxyXG5cdFx0XHRcdFx0XHQ/IGFsaWFzWzBdLnRvVXBwZXJDYXNlKCkudHJpbSgpXHJcblx0XHRcdFx0XHRcdDogZmlsZS5iYXNlbmFtZVxyXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teXFx3LixcXHNdL2csIFwiXCIpXHJcblx0XHRcdFx0XHRcdFx0XHQudG9VcHBlckNhc2UoKVxyXG5cdFx0XHRcdFx0XHRcdFx0LnRyaW0oKVxyXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoLyAvZywgXCJfXCIpKSxcclxuXHRcdFx0fSxcclxuXHRcdH0sXHJcblx0XSk7XHJcblxyXG5cdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVIZWFkaW5nQ29tcG9uZW50KHJfZmlsZTogVEZpbGUpIHtcclxuXHRcdGlmIChyX2ZpbGUgIT09IGZpbGUpIHJldHVybjtcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcInJlc29sdmluZyBoZWFkaW5nIGNvbXBvbmVudFwiLCBpbmRleCk7XHJcblxyXG5cdFx0c3dpdGNoIChpbmRleCkge1xyXG5cdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0Y29uc3QgcnRtayA9IGF3YWl0IHJlcXVpcmVtZW50c1RhYmxlMihmaWxlKTtcclxuXHRcdFx0XHRhd2FpdCBpbnNlcnRNYXJrZG93blVuZGVySGVhZGluZyhmaWxlLCBcIlJlcXVpcmVtZW50c1wiLCBydG1rKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdGNvbnN0IHR0bWsgPSBhd2FpdCB0ZXN0c1RhYmxlKGZpbGUpO1xyXG5cdFx0XHRcdGF3YWl0IGluc2VydE1hcmtkb3duVW5kZXJIZWFkaW5nKGZpbGUsIFwiVGVzdHNcIiwgdHRtayk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0Y29uc3QgaXRtayA9IGF3YWl0IGludGVyZmFjZXNUYWJsZShmaWxlKTtcclxuXHRcdFx0XHRhd2FpdCBpbnNlcnRNYXJrZG93blVuZGVySGVhZGluZyhmaWxlLCBcIkludGVyZmFjZXNcIiwgaXRtayk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0aW5kZXgrKztcclxuXHJcblx0XHRpZiAoaW5kZXggPiAyKVxyXG5cdFx0XHRhcHAubWV0YWRhdGFDYWNoZS5vZmYoXCJyZXNvbHZlXCIsIHJlc29sdmVIZWFkaW5nQ29tcG9uZW50KTtcclxuXHR9XHJcblxyXG5cdGFwcC5tZXRhZGF0YUNhY2hlLm9uKFwicmVzb2x2ZVwiLCByZXNvbHZlSGVhZGluZ0NvbXBvbmVudCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUludGVyZmFjZShmaWxlOiBURmlsZSkge1xyXG5cdGNvbnN0IHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQgfSA9IGFwcDtcclxuXHRjb25zdCBmbSA9IG1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlciBhcyB1bmtub3duIGFzIHtcclxuXHRcdFR5cGU6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xyXG5cdH07XHJcblxyXG5cdGlmICghZm0uVHlwZSkgcmV0dXJuO1xyXG5cclxuXHRpZiAoZm0uVHlwZS5pbmNsdWRlcyhcIkVsZWN0cmljYWxcIikpIHtcclxuXHRcdGF3YWl0IGFkZEljb25Ub05hbWUoZmlsZSwgYXBwLCBcIlx1MjZBMVwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0YXdhaXQgcmVtb3ZlSWNvbkZyb21OYW1lKGZpbGUsIGFwcCwgXCJcdTI2QTFcIik7XHJcblx0fVxyXG5cdGlmIChmbS5UeXBlLmluY2x1ZGVzKFwiTWVjaGFuaWNhbFwiKSkge1xyXG5cdFx0YXdhaXQgYWRkSWNvblRvTmFtZShmaWxlLCBhcHAsIFwiXHVEODNEXHVERUUwXHVGRTBGXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRhd2FpdCByZW1vdmVJY29uRnJvbU5hbWUoZmlsZSwgYXBwLCBcIlx1RDgzRFx1REVFMFx1RkUwRlwiKTtcclxuXHR9XHJcblx0aWYgKGZtLlR5cGUuaW5jbHVkZXMoXCJTb2Z0d2FyZVwiKSkge1xyXG5cdFx0YXdhaXQgYWRkSWNvblRvTmFtZShmaWxlLCBhcHAsIFwiXHVEODNEXHVEQ0JCXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRhd2FpdCByZW1vdmVJY29uRnJvbU5hbWUoZmlsZSwgYXBwLCBcIlx1RDgzRFx1RENCQlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlcXVpcmVtZW50KGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdC8vIGF3YWl0IGFkZEVtYmVkKGNvbnRlbnQpO1xyXG5cclxuXHQvLzFzdCBjaGVjayBpZiB0aGUgcmVxdWlyZW1lbnQgaGFzIGEgc291cmNlXHJcblxyXG5cdGNvbnN0IHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQgfSA9IGFwcDtcclxuXHRjb25zdCBoZWFkaW5ncyA9IG1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5oZWFkaW5ncyA/PyBbXTtcclxuXHRsZXQgdGV4dCA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblxyXG5cdC8vIGFwcC5maWxlTWFuYWdlci5pbnNlcnRUZXh0SW50b0ZpbGUoZmlsZSwgXCIjIyB0ZXN0XCIsIFwiXCIsIFwiXCIsIGZhbHNlKTtcclxuXHJcblx0Y29uc3QgZElkeCA9IGhlYWRpbmdzLmZpbmRJbmRleChcclxuXHRcdCh7IGhlYWRpbmcgfTogSGVhZGluZ0NhY2hlKSA9PiBoZWFkaW5nID09PSBcIkRlc2NyaXB0aW9uXCJcclxuXHQpO1xyXG5cclxuXHRjb25zdCBoSWR4ID0gaGVhZGluZ3MuZmluZEluZGV4KFxyXG5cdFx0KHsgaGVhZGluZyB9OiBIZWFkaW5nQ2FjaGUpID0+IGhlYWRpbmcgPT09IFwiU291cmNlXCJcclxuXHQpO1xyXG5cdGlmIChoSWR4ID09PSAtMSkge1xyXG5cdFx0dGV4dCA9IFwiXCI7XHJcblx0XHQvLyBzZXQgZmlsZSdzIG5hbWUgdG8gbm8gc291cmNlXHJcblx0XHRhd2FpdCBhZGRXYXJuaW5nKGZpbGUsIGFwcCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRleHQgPSB0ZXh0XHJcblx0XHRcdC5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHQuc2xpY2UoXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeF0ucG9zaXRpb24uc3RhcnQubGluZSArIDEsXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeCArIDFdPy5wb3NpdGlvbj8uc3RhcnQ/LmxpbmVcclxuXHRcdFx0KVxyXG5cdFx0XHQuam9pbihcIlxcblwiKVxyXG5cdFx0XHQudHJpbSgpO1xyXG5cclxuXHRcdGlmICh0ZXh0ID09PSBcIlwiKSB7XHJcblx0XHRcdGF3YWl0IGFkZFdhcm5pbmcoZmlsZSwgYXBwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGF3YWl0IHJlbW92ZVdhcm5pbmcoZmlsZSwgYXBwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNvbnN0IHRleHQyID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcclxuXHRjb25zdCB2YWx1ZXMgPSB7XHJcblx0XHRpZDogZmlsZS5iYXNlbmFtZS5yZXBsYWNlKC9bXlxcdy4sXFxzXS9nLCBcIlwiKS50cmltKCksXHJcblx0XHRkZXNjcmlwdGlvbjogdGV4dDJcclxuXHRcdFx0LnNwbGl0KFwiXFxuXCIpXHJcblx0XHRcdC5zbGljZShcclxuXHRcdFx0XHRoZWFkaW5nc1tkSWR4XS5wb3NpdGlvbi5zdGFydC5saW5lICsgMSxcclxuXHRcdFx0XHRoZWFkaW5nc1tkSWR4ICsgMV0/LnBvc2l0aW9uPy5zdGFydD8ubGluZVxyXG5cdFx0XHQpXHJcblx0XHRcdC5qb2luKFwiXFxuXCIpXHJcblx0XHRcdC50cmltKCksXHJcblx0XHRzb3VyY2U6IHRleHQyXHJcblx0XHRcdC5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHQuc2xpY2UoXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeF0ucG9zaXRpb24uc3RhcnQubGluZSArIDEsXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeCArIDFdPy5wb3NpdGlvbj8uc3RhcnQ/LmxpbmVcclxuXHRcdFx0KVxyXG5cdFx0XHQuam9pbihcIlxcblwiKVxyXG5cdFx0XHQudHJpbSgpLFxyXG5cdFx0c3lzdGVtOlxyXG5cdFx0XHRtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI/LlN5c3RlbSA/P1xyXG5cdFx0XHRcIlVuc3BlY2lmaWVkL0dlbmVyYWxcIixcclxuXHR9O1xyXG5cclxuXHRhZGRFbWJlZCh2YWx1ZXMsIGZpbGUpLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xyXG5cdFx0Y29uc3QgZGF0YSA9IGF3YWl0IGZpbGUudmF1bHQucmVhZChmaWxlKTtcclxuXHRcdC8vIHJlbW92ZSBhbnkgY29uZmxpY3RzIGZyb20gdGhlIGZpbGVcclxuXHJcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBjb21wYXJlUmVxdWlyZW1lbnRzKHJlcyk7XHJcblx0XHRjb25zdCB7IGZyb250bWF0dGVyIH0gPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKTtcclxuXHRcdGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcblx0XHQvLyBIZXJlIHlvdSBjYW4gZGV0ZXJtaW5lIHdoYXQgaXMgdGhlIG91dHB1dCBvZiB0aGUgY29tcGFyaXNvbiBhbGdvcml0aG0gYW5kIHdoYXQgdG8gZG8gd2l0aCBpdFxyXG5cdFx0aWYgKHJlc3VsdD8uaW5jbHVkZXMoXCJZRVNcIikpIHtcclxuXHRcdFx0Y29uc3QgbmV3RGF0YSA9IGRhdGEucmVwbGFjZShcclxuXHRcdFx0XHRhd2FpdCBnZXRTZWN0aW9uKGZpbGUsIFwiQ29uZmxpY3RcIiksXHJcblx0XHRcdFx0XCJcIlxyXG5cdFx0XHQpO1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgbmV3RGF0YSk7XHJcblx0XHRcdGF3YWl0IGFkZEVycm9yKGZpbGUsIHRoaXMuYXBwKTtcclxuXHRcdFx0Ly8gYWRkIHJlc3VsdCB0byB0aGUgZmlsZVxyXG5cdFx0XHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KGZpbGUsIG5ld0RhdGEgKyBgJHtyZXN1bHR9YCk7XHJcblxyXG5cdFx0XHRmcm9udG1hdHRlci5wb3N0VmFsdWVzKGZpbGUsIFtcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRuYW1lOiBcIlN0YXR1c1wiLFxyXG5cdFx0XHRcdFx0cGF5bG9hZDoge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogXCJjb25mbGljdFwiLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdG5hbWU6IFwiQ29uZmxpY3RpbmcgV2l0aFwiLFxyXG5cdFx0XHRcdFx0cGF5bG9hZDoge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogcmVzdWx0LnN1YnN0cmluZyhcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQuaW5kZXhPZihcIltbXCIpICsgMixcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQuaW5kZXhPZihcIl1dXCIpXHJcblx0XHRcdFx0XHRcdCksXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YXdhaXQgcmVtb3ZlRXJyb3IoZmlsZSwgdGhpcy5hcHApO1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoXHJcblx0XHRcdFx0ZmlsZSxcclxuXHRcdFx0XHRkYXRhLnJlcGxhY2UoYXdhaXQgZ2V0U2VjdGlvbihmaWxlLCBcIkNvbmZsaWN0XCIpLCBcIlwiKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0ZnJvbnRtYXR0ZXIucG9zdFZhbHVlcyhmaWxlLCBbXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bmFtZTogXCJTdGF0dXNcIixcclxuXHRcdFx0XHRcdHBheWxvYWQ6IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IFwiaW4tcmV2aWV3XCIsXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bmFtZTogXCJDb25mbGljdGluZyBXaXRoXCIsXHJcblx0XHRcdFx0XHRwYXlsb2FkOiB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBcIlwiLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xyXG5cclxuXHQvLyBHZXQgYSBHUFQgZW1iZWRkaW5nIGFuZCBjb21wYXJlIHRvIG90aGVyIGVtYmVkZGluZ3Mgb2YgdGhlIHNhbWUgY2xhc3MgaW4gdGhlIGRhdGFiYXNlXHJcbn1cclxuXHJcbmNsYXNzIENyZWF0ZUNvbXBvbmVudE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cdHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzO1xyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncykge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHR9XHJcblxyXG5cdG9uT3BlbigpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgYXBwID0gdGhpcy5hcHA7XHJcblx0XHRjb25zdCBjdXJyZW50RmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHQvLyBpbnB1dCB3aXRoIGEgcHJvbXB0IGZvciBjb21wb25lbnQgbmFtZVxyXG5cdFx0Y29udGVudEVsLmlubmVySFRNTCA9IGBcclxuXHRcdDxoMj5DcmVhdGUgQ29tcG9uZW50PC9oMj5cclxuXHRcdDxwPkVudGVyIGNvbXBvbmVudCBuYW1lPC9wPlxyXG5cdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJjb21wb25lbnQtbmFtZVwiIHBsYWNlaG9sZGVyPVwiQ29tcG9uZW50IG5hbWVcIiAvPlxyXG5cdFx0PHA+U2VsZWN0IGlmIHRoaXMgaXMgYSBjb21wb25lbnQ8L3A+XHJcblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJpcy1jb21wb25lbnRcIiAvPlxyXG5cdFx0PGJyPlxyXG5cdFx0PGJ1dHRvbiBpZD1cImNyZWF0ZS1jb21wb25lbnRcIj5DcmVhdGU8L2J1dHRvbj5cclxuXHRcdGA7XHJcblxyXG5cdFx0Y29uc3QgYnV0dG9uID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXCIjY3JlYXRlLWNvbXBvbmVudFwiKTtcclxuXHRcdGNvbnN0IGlucHV0ID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXHJcblx0XHRcdFwiI2NvbXBvbmVudC1uYW1lXCJcclxuXHRcdCkgYXMgSFRNTElucHV0RWxlbWVudDtcclxuXHRcdGNvbnN0IGlzQ29tcG9uZW50ID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXHJcblx0XHRcdFwiI2lzLWNvbXBvbmVudFwiXHJcblx0XHQpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG5cdFx0Y29uc3QgaXNDYW52YXMgPSBjdXJyZW50RmlsZT8uZXh0ZW5zaW9uID09PSBcImNhbnZhc1wiO1xyXG5cclxuXHRcdGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNyZWF0ZSgpIHtcclxuXHRcdFx0aWYgKCFpbnB1dC52YWx1ZSkgcmV0dXJuO1xyXG5cdFx0XHRjb25zdCBuYW1lID0gaW5wdXQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAoIWN1cnJlbnRGaWxlKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIkFjdGl2ZSBmaWxlIGlzIG5vdCBhIGNvbXBvbmVudFwiKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHJvb3RQYXRoID0gY3VycmVudEZpbGUucGF0aC5zcGxpdChjdXJyZW50RmlsZS5uYW1lKVswXTtcclxuXHRcdFx0aWYgKGlzQ2FudmFzKSB7XHJcblx0XHRcdFx0cm9vdFBhdGggPSB0aGlzLnNldHRpbmdzLnN5c3RlbV9kZXNpZ25fcm9vdF9mb2xkZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG5ld0NvbXBvbmVudCA9IGF3YWl0IGFkZENvbXBvbmVudCh7XHJcblx0XHRcdFx0c3lzdGVtOiBcIlRXUjJcIixcclxuXHRcdFx0XHRwYXRoOiByb290UGF0aCxcclxuXHRcdFx0XHRmaWxlTmFtZTogbmFtZSxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRhd2FpdCBhZGRUb1N5c3RlbURpYWdyYW0oe1xyXG5cdFx0XHRcdGZpbGU6IG5ld0NvbXBvbmVudCxcclxuXHRcdFx0XHRpc0NvbXBvbmVudDogaXNDb21wb25lbnQuY2hlY2tlZCxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBuZXcgZmlsZVxyXG5cdFx0XHRhcHAud29ya3NwYWNlXHJcblx0XHRcdFx0LmNyZWF0ZUxlYWZCeVNwbGl0KGFwcC53b3Jrc3BhY2UuZ2V0TGVhZigpKVxyXG5cdFx0XHRcdC5vcGVuRmlsZShuZXdDb21wb25lbnQpO1xyXG5cclxuXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJ1dHRvbj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNyZWF0ZS5iaW5kKHRoaXMpKTtcclxuXHRcdGNvbnRlbnRFbC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgKGUpID0+IHtcclxuXHRcdFx0aWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcclxuXHRcdFx0XHRoYW5kbGVDcmVhdGUuYmluZCh0aGlzKSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogTXlQbHVnaW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHR9XHJcblxyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiU2V0dGluZyAjMVwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcIkl0J3MgYSBzZWNyZXRcIilcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgeW91ciBzZWNyZXRcIilcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcpXHJcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZyA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiU3lzdGVtcyBkZXNpZ24gcm9vdCBmb2xkZXJcIilcclxuXHRcdFx0LnNldERlc2MoXCJUaGUgZm9sZGVyIHdoZXJlIHRoZSBzeXN0ZW1zIGRlc2lnbiBmaWxlcyBhcmUgc3RvcmVkXCIpXHJcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG5cdFx0XHRcdHRleHRcclxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHRoZSBmb2xkZXIgcGF0aFwiKVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKFwiMTEtU3lzdGVtX2Rlc2lnblwiKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5zeXN0ZW1fZGVzaWduX3Jvb3RfZm9sZGVyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHQvL2ZvbGRlciBmb3IgdGVzdHNcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIlRlc3RzIHJvb3QgZm9sZGVyXCIpXHJcblx0XHRcdC5zZXREZXNjKFwiVGhlIGZvbGRlciB3aGVyZSB0aGUgdGVzdHMgYXJlIHN0b3JlZFwiKVxyXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cclxuXHRcdFx0XHR0ZXh0XHJcblx0XHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciB0aGUgZm9sZGVyIHBhdGhcIilcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZShcIjA1LVRlc3RfZG9jdW1lbnRhdGlvblwiKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy50ZXN0X2RvY3VtZW50YXRpb25fcm9vdF9mb2xkZXIgPVxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0Ly9mb2xkZXIgZm9yIGludGVyZmFjZXNcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkludGVyZmFjZXMgcm9vdCBmb2xkZXJcIilcclxuXHRcdFx0LnNldERlc2MoXCJUaGUgZm9sZGVyIHdoZXJlIHRoZSBpbnRlcmZhY2VzIGFyZSBzdG9yZWRcIilcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgdGhlIGZvbGRlciBwYXRoXCIpXHJcblx0XHRcdFx0XHQuc2V0VmFsdWUoXCIxMi1JbnRlcmZhY2VzXCIpXHJcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmludGVyZmFjZXNfcm9vdF9mb2xkZXIgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5pbnRlcmZhY2UgUGx1Z2lucyB7XHJcblx0ZGF0YXZpZXc6IGFueTtcclxuXHRmcm9udG1hdHRlcjogYW55O1xyXG5cdHNrYV9zZToge1xyXG5cdFx0c2V0dGluZ3M6IHtcclxuXHRcdFx0bXlTZXR0aW5nOiBzdHJpbmc7XHJcblx0XHRcdHN5c3RlbV9kZXNpZ25fcm9vdF9mb2xkZXI6IHN0cmluZztcclxuXHRcdFx0dGVzdF9kb2N1bWVudGF0aW9uX3Jvb3RfZm9sZGVyOiBzdHJpbmc7XHJcblx0XHRcdGludGVyZmFjZXNfcm9vdF9mb2xkZXI6IHN0cmluZztcclxuXHRcdH07XHJcblx0fTtcclxufVxyXG5cclxuY2xhc3MgUGx1Z2luSGFuZGxlciB7XHJcblx0cGx1Z2luczogUGx1Z2lucztcclxuXHRhcHA6IEFwcDtcclxuXHRjb25zdHJ1Y3RvcigpIHt9XHJcblxyXG5cdGluaXQoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdH1cclxuXHJcblx0c2V0UGx1Z2lucyhwbHVnaW5zOiBQbHVnaW5zKSB7XHJcblx0XHR0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xyXG5cdH1cclxuXHJcblx0Z2V0UGx1Z2lucygpIHtcclxuXHRcdGlmICghdGhpcy5wbHVnaW5zKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Ly9AdHMtaWdub3JlXHJcblx0XHRcdFx0ZGF0YXZpZXc6IHRoaXMuYXBwLnBsdWdpbnMucGx1Z2luc1tcImRhdGF2aWV3XCJdLmFwaSxcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRmcm9udG1hdHRlcjogdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zW1wibWV0YWRhdGEtbWVudVwiXS5hcGksXHJcblx0XHRcdFx0c2thX3NlOiB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnNbXCJza2Etc2Utb2JzaWRpYW4tcGx1Z2luXCJdIC8vQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0LmFwaSBhcyBQbHVnaW5zW1wic2thX3NlXCJdLFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMucGx1Z2lucztcclxuXHR9XHJcbn1cclxuXHJcbmNvbnN0IHBsdWdpbkhhbmRsZXIgPSBuZXcgUGx1Z2luSGFuZGxlcigpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luSGFuZGxlcjtcclxuIiwgImltcG9ydCB7IFRGaWxlLCBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHBsdWdpbkhhbmRsZXIgZnJvbSBcIi4vZ2xvYmFsSGFuZGxlcnNcIjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVFcnJvcihmaWxlOiBURmlsZSwgYXBwOiBBcHApIHtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCJcdTI3NENcIikuam9pbihcIlwiKS50cmltKClcclxuXHQpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVXYXJuaW5nKGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdGF3YWl0IGFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKFxyXG5cdFx0ZmlsZSxcclxuXHRcdGZpbGUucGF0aC5zcGxpdChcIlx1MjZBMFx1RkUwRlwiKS5qb2luKFwiXCIpLnRyaW0oKVxyXG5cdCk7XHJcbn1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZEVycm9yKGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoXCJcdTI3NENcIikpIHJldHVybjtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCIubWRcIilbMF0udHJpbSgpICsgXCIgXHUyNzRDLm1kXCJcclxuXHQpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRXYXJuaW5nKGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoXCJcdTI2QTBcdUZFMEZcIikpIHJldHVybjtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCIubWRcIilbMF0udHJpbSgpICsgXCIgXHUyNkEwXHVGRTBGLm1kXCJcclxuXHQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkSWNvblRvTmFtZShmaWxlOiBURmlsZSwgYXBwOiBBcHAsIGljb246IHN0cmluZykge1xyXG5cdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoaWNvbikpIHJldHVybjtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCIubWRcIilbMF0udHJpbSgpICsgYCAke2ljb259Lm1kYFxyXG5cdCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVJY29uRnJvbU5hbWUoZmlsZTogVEZpbGUsIGFwcDogQXBwLCBpY29uOiBzdHJpbmcpIHtcclxuXHRpZiAoIWZpbGUucGF0aC5pbmNsdWRlcyhpY29uKSkgcmV0dXJuO1xyXG5cdGF3YWl0IGFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKFxyXG5cdFx0ZmlsZSxcclxuXHRcdGZpbGUucGF0aC5zcGxpdChpY29uKS5qb2luKFwiXCIpLnRyaW0oKVxyXG5cdCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZWN0aW9uKGZpbGU6IFRGaWxlLCBoZWFkaW5nVG9TZWFyY2g6IHN0cmluZykge1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cclxuXHRjb25zdCB7IG1ldGFkYXRhQ2FjaGUsIHZhdWx0IH0gPSBhcHA7XHJcblx0Y29uc3QgaGVhZGluZ3MgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uaGVhZGluZ3MgPz8gW107XHJcblx0bGV0IHRleHQgPSBhd2FpdCB2YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xyXG5cdGNvbnN0IGhJZHggPSBoZWFkaW5ncy5maW5kSW5kZXgoXHJcblx0XHQoeyBoZWFkaW5nIH06IGFueSkgPT4gaGVhZGluZyA9PT0gaGVhZGluZ1RvU2VhcmNoXHJcblx0KTtcclxuXHRpZiAoaElkeCA9PT0gLTEpIHtcclxuXHRcdHRleHQgPSBcIlwiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0ZXh0ID0gdGV4dFxyXG5cdFx0XHQuc3BsaXQoXCJcXG5cIilcclxuXHRcdFx0LnNsaWNlKFxyXG5cdFx0XHRcdGhlYWRpbmdzW2hJZHhdLnBvc2l0aW9uLnN0YXJ0LmxpbmUgKyAxLFxyXG5cdFx0XHRcdGhlYWRpbmdzW2hJZHggKyAxXT8ucG9zaXRpb24/LnN0YXJ0Py5saW5lXHJcblx0XHRcdClcclxuXHRcdFx0LmpvaW4oXCJcXG5cIilcclxuXHRcdFx0LnRyaW0oKTtcclxuXHR9XHJcblxyXG5cdGNvbnNvbGUubG9nKHRleHQpO1xyXG5cclxuXHRyZXR1cm4gdGV4dDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluc2VydE1hcmtkb3duVW5kZXJIZWFkaW5nKFxyXG5cdGZpbGU6IFRGaWxlLFxyXG5cdGhlYWRpbmdUb1NlYXJjaDogc3RyaW5nLFxyXG5cdG1hcmtkb3duOiBzdHJpbmcsXHJcblx0b2Zmc2V0OiBudW1iZXJbXSA9IFtdLFxyXG5cdG9mZnNldExpbmU6IG51bWJlcltdID0gW11cclxuKTogUHJvbWlzZTxudW1iZXJbXVtdPiB7XHJcblx0aWYgKCFtYXJrZG93bikgbWFya2Rvd24gPSBcIlwiO1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cclxuXHRjb25zdCB7IG1ldGFkYXRhQ2FjaGUsIHZhdWx0IH0gPSBhcHA7XHJcblx0Y29uc3QgY2FjaGUgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcclxuXHRjb25zdCBoZWFkaW5ncyA9IGNhY2hlPy5oZWFkaW5ncyA/PyBbXTtcclxuXHRjb25zdCBzZWN0aW9ucyA9IGNhY2hlPy5zZWN0aW9ucyA/PyBbXTtcclxuXHRsZXQgdGV4dCA9IGF3YWl0IHZhdWx0LnJlYWQoZmlsZSk7XHJcblx0bGV0IGRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuXHJcblx0Y29uc3QgaGVhZGluZyA9IGhlYWRpbmdzLmZpbmQoXHJcblx0XHQoeyBoZWFkaW5nIH06IGFueSkgPT4gaGVhZGluZyA9PT0gaGVhZGluZ1RvU2VhcmNoXHJcblx0KTtcclxuXHRpZiAoIWhlYWRpbmcpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiTm8gaGVhZGluZyBmb3VuZFwiKTtcclxuXHRcdHJldHVybiBbb2Zmc2V0LCBvZmZzZXRMaW5lXTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGhJZHggPSBzZWN0aW9ucy5maW5kSW5kZXgoXHJcblx0XHQoeyBwb3NpdGlvbiB9OiBhbnkpID0+XHJcblx0XHRcdHBvc2l0aW9uLmVuZC5vZmZzZXQgPT09IGhlYWRpbmcucG9zaXRpb24uZW5kLm9mZnNldFxyXG5cdCk7XHJcblx0Ly8gY2FsY3VsYXRlIHRoZSB0b3RhbCBvZmZzZXQgYnkgY2hlY2tpbmcgaWYgdGhlIGhlYWRpbmcgaXMgYmVsb3cgdGhlIG9mZnNldExpbmUgYW5kIGlmIHNvLCBhZGQgdGhlIG9mZnNldFxyXG5cdC8vIHRvIHRoZSB0b3RhbCBvZmZzZXRcclxuXHRjb25zdCB0b3RhbE9mZnNldCA9IG9mZnNldD8ucmVkdWNlKChhY2MsIGN1cnIsIGlkeCkgPT4ge1xyXG5cdFx0aWYgKG9mZnNldExpbmUgJiYgaGVhZGluZy5wb3NpdGlvbi5zdGFydC5saW5lID49IG9mZnNldExpbmVbaWR4XSkge1xyXG5cdFx0XHRyZXR1cm4gYWNjICsgY3VycjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhY2M7XHJcblx0fSwgMCk7XHJcblxyXG5cdGlmICghc2VjdGlvbnNbaElkeCArIDFdIHx8IHNlY3Rpb25zW2hJZHggKyAxXS50eXBlID09PSBcImhlYWRpbmdcIikge1xyXG5cdFx0Y29uc29sZS5sb2coXCJoZXJlXCIpO1xyXG5cdFx0Ly8gcHV0IHRoZSBkYXRhIGRpcmVjdGx5IHVuZGVyIHRoZSBoZWFkaW5nXHJcblx0XHR0ZXh0ID1cclxuXHRcdFx0dGV4dC5zbGljZSgwLCBoZWFkaW5nLnBvc2l0aW9uLmVuZC5vZmZzZXQgKyB0b3RhbE9mZnNldCkgK1xyXG5cdFx0XHRtYXJrZG93biArXHJcblx0XHRcdHRleHQuc2xpY2UoaGVhZGluZy5wb3NpdGlvbi5lbmQub2Zmc2V0ICsgdG90YWxPZmZzZXQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyByZW1vdmUgdGhlIGRhdGEgaW4gdGhpcyBzZWN0aW9uIGFuZCBwdXQgdGhlIG5ldyBkYXRhIHVuZGVyIHRoZSBoZWFkaW5nXHJcblx0XHR0ZXh0ID1cclxuXHRcdFx0dGV4dC5zbGljZSgwLCBoZWFkaW5nLnBvc2l0aW9uLmVuZC5vZmZzZXQgKyB0b3RhbE9mZnNldCkgK1xyXG5cdFx0XHRtYXJrZG93biArXHJcblx0XHRcdHRleHQuc2xpY2UoXHJcblx0XHRcdFx0c2VjdGlvbnNbaElkeCArIDFdLnBvc2l0aW9uLmVuZC5vZmZzZXQgKyAxICsgdG90YWxPZmZzZXRcclxuXHRcdFx0KTtcclxuXHR9XHJcblxyXG5cdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkoZmlsZSwgdGV4dCk7XHJcblxyXG5cdC8vIHVwZGF0ZSB0aGUgb2Zmc2V0cyBhbmQgcmV0dXJuXHJcblx0b2Zmc2V0LnB1c2godGV4dC5sZW5ndGggLSBkTGVuZ3RoKTtcclxuXHRvZmZzZXRMaW5lPy5wdXNoKGhlYWRpbmcucG9zaXRpb24uc3RhcnQubGluZSk7XHJcblxyXG5cdHJldHVybiBbb2Zmc2V0LCBvZmZzZXRMaW5lXTtcclxufVxyXG4iLCAiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4xMS4wJzsgLy8geC1yZWxlYXNlLXBsZWFzZS12ZXJzaW9uXG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0IHsgY2FzdFRvRXJyb3IsIEhlYWRlcnMgfSBmcm9tICcuL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gIHJlYWRvbmx5IHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkO1xuXG4gIHJlYWRvbmx5IGNvZGU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IHBhcmFtOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgZXJyb3I6IE9iamVjdCB8IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgaGVhZGVyczogSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgc3VwZXIoYCR7c3RhdHVzfSAke0FQSUVycm9yLm1ha2VNZXNzYWdlKGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXG4gICAgY29uc3QgZGF0YSA9IGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgdGhpcy5jb2RlID0gZGF0YT8uWydjb2RlJ107XG4gICAgdGhpcy5wYXJhbSA9IGRhdGE/LlsncGFyYW0nXTtcbiAgICB0aGlzLnR5cGUgPSBkYXRhPy5bJ3R5cGUnXTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG1ha2VNZXNzYWdlKGVycm9yOiBhbnksIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvcj8ubWVzc2FnZSA/XG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyA/IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKVxuICAgICAgOiBlcnJvciA/IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgOiBtZXNzYWdlIHx8ICdzdGF0dXMgY29kZSAobm8gYm9keSknXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZShcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvclJlc3BvbnNlOiBPYmplY3QgfCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICByZXR1cm4gbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiBjYXN0VG9FcnJvcihlcnJvclJlc3BvbnNlKSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IChlcnJvclJlc3BvbnNlIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pPy5bJ2Vycm9yJ107XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICAgIHJldHVybiBuZXcgQmFkUmVxdWVzdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwMSkge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgICAgcmV0dXJuIG5ldyBQZXJtaXNzaW9uRGVuaWVkRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICByZXR1cm4gbmV3IENvbmZsaWN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDIyKSB7XG4gICAgICByZXR1cm4gbmV3IFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA+PSA1MDApIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFQSUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElVc2VyQWJvcnRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH06IHsgbWVzc2FnZT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnUmVxdWVzdCB3YXMgYWJvcnRlZC4nLCB1bmRlZmluZWQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY2F1c2UgfTogeyBtZXNzYWdlPzogc3RyaW5nOyBjYXVzZT86IEVycm9yIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnQ29ubmVjdGlvbiBlcnJvci4nLCB1bmRlZmluZWQpO1xuICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzIHRoZSAnY2F1c2UnIHByb3BlcnR5IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGNhdXNlKSB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBBUElDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZTogbWVzc2FnZSA/PyAnUmVxdWVzdCB0aW1lZCBvdXQuJyB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBvdmVycmlkZSByZWFkb25seSBzdGF0dXM6IDQwMCA9IDQwMDtcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDAxID0gNDAxO1xufVxuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBvdmVycmlkZSByZWFkb25seSBzdGF0dXM6IDQwMyA9IDQwMztcbn1cblxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDA0ID0gNDA0O1xufVxuXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiA0MDkgPSA0MDk7XG59XG5cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDIyID0gNDIyO1xufVxuXG5leHBvcnQgY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDI5ID0gNDI5O1xufVxuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTZXJ2ZXJFcnJvciBleHRlbmRzIEFQSUVycm9yIHt9XG4iLCAiaW1wb3J0IHsgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5cbnR5cGUgQnl0ZXMgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG50eXBlIFNlcnZlclNlbnRFdmVudCA9IHtcbiAgZXZlbnQ6IHN0cmluZyB8IG51bGw7XG4gIGRhdGE6IHN0cmluZztcbiAgcmF3OiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCBjbGFzcyBTdHJlYW08SXRlbT4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+IHtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xuXG4gIHByaXZhdGUgcmVzcG9uc2U6IFJlc3BvbnNlO1xuICBwcml2YXRlIGRlY29kZXI6IFNTRURlY29kZXI7XG5cbiAgY29uc3RydWN0b3IocmVzcG9uc2U6IFJlc3BvbnNlLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU1NFRGVjb2RlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyAqaXRlck1lc3NhZ2VzKCk6IEFzeW5jR2VuZXJhdG9yPFNlcnZlclNlbnRFdmVudCwgdm9pZCwgdW5rbm93bj4ge1xuICAgIGlmICghdGhpcy5yZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgIH1cbiAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuXG4gICAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZTxCeXRlcz4odGhpcy5yZXNwb25zZS5ib2R5KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoY2h1bmspKSB7XG4gICAgICAgIGNvbnN0IHNzZSA9IHRoaXMuZGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgY29uc3Qgc3NlID0gdGhpcy5kZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhdG9yPEl0ZW0sIGFueSwgdW5kZWZpbmVkPiB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBzc2Ugb2YgdGhpcy5pdGVyTWVzc2FnZXMoKSkge1xuICAgICAgICBpZiAoZG9uZSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHNzZS5kYXRhLnN0YXJ0c1dpdGgoJ1tET05FXScpKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3NlLmV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHJldHVybjtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgaWYgKCFkb25lKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU1NFRGVjb2RlciB7XG4gIHByaXZhdGUgZGF0YTogc3RyaW5nW107XG4gIHByaXZhdGUgZXZlbnQ6IHN0cmluZyB8IG51bGw7XG4gIHByaXZhdGUgY2h1bmtzOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICB9XG5cbiAgZGVjb2RlKGxpbmU6IHN0cmluZykge1xuICAgIGlmIChsaW5lLmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKCFsaW5lKSB7XG4gICAgICAvLyBlbXB0eSBsaW5lIGFuZCB3ZSBkaWRuJ3QgcHJldmlvdXNseSBlbmNvdW50ZXIgYW55IG1lc3NhZ2VzXG4gICAgICBpZiAoIXRoaXMuZXZlbnQgJiYgIXRoaXMuZGF0YS5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBzc2U6IFNlcnZlclNlbnRFdmVudCA9IHtcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YS5qb2luKCdcXG4nKSxcbiAgICAgICAgcmF3OiB0aGlzLmNodW5rcyxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gICAgICByZXR1cm4gc3NlO1xuICAgIH1cblxuICAgIHRoaXMuY2h1bmtzLnB1c2gobGluZSk7XG5cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCc6JykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBbZmllbGRuYW1lLCBfLCB2YWx1ZV0gPSBwYXJ0aXRpb24obGluZSwgJzonKTtcblxuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGlmIChmaWVsZG5hbWUgPT09ICdldmVudCcpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkbmFtZSA9PT0gJ2RhdGEnKSB7XG4gICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlLWltcGxlbWVudGF0aW9uIG9mIGh0dHB4J3MgYExpbmVEZWNvZGVyYCBpbiBQeXRob24gdGhhdCBoYW5kbGVzIGluY3JlbWVudGFsbHlcbiAqIHJlYWRpbmcgbGluZXMgZnJvbSB0ZXh0LlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmNvZGUvaHR0cHgvYmxvYi85MjAzMzNlYTk4MTE4ZTljZjYxN2YyNDY5MDVkN2IyMDI1MTA5NDFjL2h0dHB4L19kZWNvZGVycy5weSNMMjU4XG4gKi9cbmNsYXNzIExpbmVEZWNvZGVyIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInLCAnXFx4MGInLCAnXFx4MGMnLCAnXFx4MWMnLCAnXFx4MWQnLCAnXFx4MWUnLCAnXFx4ODUnLCAnXFx1MjAyOCcsICdcXHUyMDI5J10pO1xuICBzdGF0aWMgTkVXTElORV9SRUdFWFAgPSAvXFxyXFxufFtcXG5cXHJcXHgwYlxceDBjXFx4MWNcXHgxZFxceDFlXFx4ODVcXHUyMDI4XFx1MjAyOV0vZztcblxuICBidWZmZXI6IHN0cmluZ1tdO1xuICB0cmFpbGluZ0NSOiBib29sZWFuO1xuICB0ZXh0RGVjb2RlcjogYW55OyAvLyBUZXh0RGVjb2RlciBmb3VuZCBpbiBicm93c2Vyczsgbm90IHR5cGVkIHRvIGF2b2lkIHB1bGxpbmcgaW4gZWl0aGVyIFwiZG9tXCIgb3IgXCJub2RlXCIgdHlwZXMuXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgfVxuXG4gIGRlY29kZShjaHVuazogQnl0ZXMpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHRleHQgPSB0aGlzLmRlY29kZVRleHQoY2h1bmspO1xuXG4gICAgaWYgKHRoaXMudHJhaWxpbmdDUikge1xuICAgICAgdGV4dCA9ICdcXHInICsgdGV4dDtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IHRydWU7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdHJhaWxpbmdOZXdsaW5lID0gTGluZURlY29kZXIuTkVXTElORV9DSEFSUy5oYXModGV4dFt0ZXh0Lmxlbmd0aCAtIDFdIHx8ICcnKTtcbiAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KExpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQKTtcblxuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEgJiYgIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChsaW5lc1swXSEpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKSArIGxpbmVzWzBdLCAuLi5saW5lcy5zbGljZSgxKV07XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cblxuICAgIGlmICghdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtsaW5lcy5wb3AoKSB8fCAnJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZGVjb2RlVGV4dChieXRlczogQnl0ZXMpOiBzdHJpbmcge1xuICAgIGlmIChieXRlcyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHJldHVybiBieXRlcztcblxuICAgIC8vIE5vZGU6XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkgKCR7Ynl0ZXMuY29uc3RydWN0b3IubmFtZX0pIHN0cmVhbSBjaHVuayBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsIFwiQnVmZmVyXCIgZGVmaW5lZCwgd2hpY2ggdGhpcyBsaWJyYXJ5IGFzc3VtZXMgdG8gYmUgTm9kZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJyb3dzZXJcbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPz89IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheS9BcnJheUJ1ZmZlciAoJHtcbiAgICAgICAgICAoYnl0ZXMgYXMgYW55KS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgIH0pIGluIGEgd2ViIHBsYXRmb3JtLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgYFVuZXhwZWN0ZWQ6IG5laXRoZXIgQnVmZmVyIG5vciBUZXh0RGVjb2RlciBhcmUgYXZhaWxhYmxlIGFzIGdsb2JhbHMuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gLFxuICAgICk7XG4gIH1cblxuICBmbHVzaCgpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXMudHJhaWxpbmdDUikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVzID0gW3RoaXMuYnVmZmVyLmpvaW4oJycpXTtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oc3RyOiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddIHtcbiAgY29uc3QgaW5kZXggPSBzdHIuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSwgZGVsaW1pdGVyLCBzdHIuc3Vic3RyaW5nKGluZGV4ICsgZGVsaW1pdGVyLmxlbmd0aCldO1xuICB9XG5cbiAgcmV0dXJuIFtzdHIsICcnLCAnJ107XG59XG5cbi8qKlxuICogTW9zdCBicm93c2VycyBkb24ndCB5ZXQgaGF2ZSBhc3luYyBpdGVyYWJsZSBzdXBwb3J0IGZvciBSZWFkYWJsZVN0cmVhbSxcbiAqIGFuZCBOb2RlIGhhcyBhIHZlcnkgZGlmZmVyZW50IHdheSBvZiByZWFkaW5nIGJ5dGVzIGZyb20gaXRzIFwiUmVhZGFibGVTdHJlYW1cIi5cbiAqXG4gKiBUaGlzIHBvbHlmaWxsIHdhcyBwdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbTogYW55KTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHJldHVybiBzdHJlYW07XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0Py5kb25lKSByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBhd2FpdCBjYW5jZWxQcm9taXNlO1xuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH07XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hpbXMge1xuICBraW5kOiBzdHJpbmc7XG4gIGZldGNoOiBhbnk7XG4gIFJlcXVlc3Q6IGFueTtcbiAgUmVzcG9uc2U6IGFueTtcbiAgSGVhZGVyczogYW55O1xuICBGb3JtRGF0YTogYW55O1xuICBCbG9iOiBhbnk7XG4gIEZpbGU6IGFueTtcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IDxUIGV4dGVuZHMge30gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgZm9ybTogU2hpbXNbJ0Zvcm1EYXRhJ10sXG4gICAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4gICkgPT4gUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUPj47XG4gIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiBhbnk7XG4gIGZpbGVGcm9tUGF0aDpcbiAgICB8ICgocGF0aDogc3RyaW5nLCBmaWxlbmFtZT86IHN0cmluZywgb3B0aW9ucz86IHt9KSA9PiBQcm9taXNlPFNoaW1zWydGaWxlJ10+KVxuICAgIHwgKChwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7fSkgPT4gUHJvbWlzZTxTaGltc1snRmlsZSddPik7XG4gIGlzRnNSZWFkU3RyZWFtOiAodmFsdWU6IGFueSkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGxldCBhdXRvID0gZmFsc2U7XG5leHBvcnQgbGV0IGtpbmQ6IFNoaW1zWydraW5kJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZldGNoOiBTaGltc1snZmV0Y2gnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVxdWVzdDogU2hpbXNbJ1JlcXVlc3QnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVzcG9uc2U6IFNoaW1zWydSZXNwb25zZSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBIZWFkZXJzOiBTaGltc1snSGVhZGVycyddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBGb3JtRGF0YTogU2hpbXNbJ0Zvcm1EYXRhJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEJsb2I6IFNoaW1zWydCbG9iJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZpbGU6IFNoaW1zWydGaWxlJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiBTaGltc1snZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0RGVmYXVsdEFnZW50OiBTaGltc1snZ2V0RGVmYXVsdEFnZW50J10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZpbGVGcm9tUGF0aDogU2hpbXNbJ2ZpbGVGcm9tUGF0aCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBpc0ZzUmVhZFN0cmVhbTogU2hpbXNbJ2lzRnNSZWFkU3RyZWFtJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTaGltcyhzaGltczogU2hpbXMsIG9wdGlvbnM6IHsgYXV0bzogYm9vbGVhbiB9ID0geyBhdXRvOiBmYWxzZSB9KSB7XG4gIGlmIChhdXRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHlvdSBtdXN0IFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7c2hpbXMua2luZH0nXFxgIGJlZm9yZSBpbXBvcnRpbmcgYW55dGhpbmcgZWxzZSBmcm9tIG9wZW5haWAsXG4gICAgKTtcbiAgfVxuICBpZiAoa2luZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtzaGltcy5raW5kfSdcXGAgYWZ0ZXIgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtraW5kfSdcXGBgKTtcbiAgfVxuICBhdXRvID0gb3B0aW9ucy5hdXRvO1xuICBraW5kID0gc2hpbXMua2luZDtcbiAgZmV0Y2ggPSBzaGltcy5mZXRjaDtcbiAgUmVxdWVzdCA9IHNoaW1zLlJlcXVlc3Q7XG4gIFJlc3BvbnNlID0gc2hpbXMuUmVzcG9uc2U7XG4gIEhlYWRlcnMgPSBzaGltcy5IZWFkZXJzO1xuICBGb3JtRGF0YSA9IHNoaW1zLkZvcm1EYXRhO1xuICBCbG9iID0gc2hpbXMuQmxvYjtcbiAgRmlsZSA9IHNoaW1zLkZpbGU7XG4gIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zID0gc2hpbXMuZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM7XG4gIGdldERlZmF1bHRBZ2VudCA9IHNoaW1zLmdldERlZmF1bHRBZ2VudDtcbiAgZmlsZUZyb21QYXRoID0gc2hpbXMuZmlsZUZyb21QYXRoO1xuICBpc0ZzUmVhZFN0cmVhbSA9IHNoaW1zLmlzRnNSZWFkU3RyZWFtO1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpcGFydEJvZHkge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgYm9keTogYW55KSB7fVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ011bHRpcGFydEJvZHknO1xuICB9XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgeyBNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi9NdWx0aXBhcnRCb2R5JztcbmltcG9ydCB7IHR5cGUgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHR5cGUgU2hpbXMgfSBmcm9tICcuL3JlZ2lzdHJ5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bnRpbWUoeyBtYW51YWxseUltcG9ydGVkIH06IHsgbWFudWFsbHlJbXBvcnRlZD86IGJvb2xlYW4gfSA9IHt9KTogU2hpbXMge1xuICBjb25zdCByZWNvbW1lbmRhdGlvbiA9XG4gICAgbWFudWFsbHlJbXBvcnRlZCA/XG4gICAgICBgWW91IG1heSBuZWVkIHRvIHVzZSBwb2x5ZmlsbHNgXG4gICAgOiBgQWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IFxcYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ1xcYDpcbi0gXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdcXGAgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4tIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidcXGAgKG90aGVyd2lzZSlcbmA7XG5cbiAgbGV0IF9mZXRjaCwgX1JlcXVlc3QsIF9SZXNwb25zZSwgX0hlYWRlcnM7XG4gIHRyeSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9SZXNwb25zZSA9IFJlc3BvbnNlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfSGVhZGVycyA9IEhlYWRlcnM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHRoaXMgZW52aXJvbm1lbnQgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIFdlYiBGZXRjaCBBUEkgdHlwZTogJHtcbiAgICAgICAgKGVycm9yIGFzIGFueSkubWVzc2FnZVxuICAgICAgfS4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtpbmQ6ICd3ZWInLFxuICAgIGZldGNoOiBfZmV0Y2gsXG4gICAgUmVxdWVzdDogX1JlcXVlc3QsXG4gICAgUmVzcG9uc2U6IF9SZXNwb25zZSxcbiAgICBIZWFkZXJzOiBfSGVhZGVycyxcbiAgICBGb3JtRGF0YTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IChcbiAgICAgICAgY2xhc3MgRm9ybURhdGEge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGb3JtRGF0YScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBCbG9iOlxuICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IChcbiAgICAgICAgY2xhc3MgQmxvYiB7XG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnQmxvYicgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBGaWxlOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnID8gRmlsZSA6IChcbiAgICAgICAgY2xhc3MgRmlsZSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0ZpbGUnIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IGFzeW5jIDxUIGV4dGVuZHMge30gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBmb3JtOiBGb3JtRGF0YSxcbiAgICAgIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuICAgICk6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VD4+ID0+ICh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgYm9keTogbmV3IE11bHRpcGFydEJvZHkoZm9ybSkgYXMgYW55LFxuICAgIH0pLFxuICAgIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiB1bmRlZmluZWQsXG4gICAgZmlsZUZyb21QYXRoOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgYGZpbGVGcm9tUGF0aGAgZnVuY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gTm9kZS4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgZGV0YWlsczogaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUjZmlsZS11cGxvYWRzJyxcbiAgICAgICk7XG4gICAgfSxcbiAgICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlOiBhbnkpID0+IGZhbHNlLFxuICB9O1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0ICogYXMgc2hpbXMgZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuaW1wb3J0ICogYXMgYXV0byBmcm9tICdvcGVuYWkvX3NoaW1zL2F1dG8vcnVudGltZSc7XG5pZiAoIXNoaW1zLmtpbmQpIHNoaW1zLnNldFNoaW1zKGF1dG8uZ2V0UnVudGltZSgpLCB7IGF1dG86IHRydWUgfSk7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG4iLCAiaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQge1xuICBGb3JtRGF0YSxcbiAgRmlsZSxcbiAgdHlwZSBCbG9iLFxuICB0eXBlIEZpbGVQcm9wZXJ0eUJhZyxcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMsXG4gIHR5cGUgRnNSZWFkU3RyZWFtLFxuICBpc0ZzUmVhZFN0cmVhbSxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vX3NoaW1zL011bHRpcGFydEJvZHknO1xuZXhwb3J0IHsgZmlsZUZyb21QYXRoIH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuXG50eXBlIEJsb2JMaWtlUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYkxpa2UgfCBVaW50OEFycmF5IHwgRGF0YVZpZXc7XG5leHBvcnQgdHlwZSBCbG9iUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYiB8IFVpbnQ4QXJyYXkgfCBEYXRhVmlldztcblxuLyoqXG4gKiBUeXBpY2FsbHksIHRoaXMgaXMgYSBuYXRpdmUgXCJGaWxlXCIgY2xhc3MuXG4gKlxuICogV2UgcHJvdmlkZSB0aGUge0BsaW5rIHRvRmlsZX0gdXRpbGl0eSB0byBjb252ZXJ0IGEgdmFyaWV0eSBvZiBvYmplY3RzXG4gKiBpbnRvIHRoZSBGaWxlIGNsYXNzLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBmZXRjaCBSZXNwb25zZSwgb3IgaW4gTm9kZSxcbiAqIHRoZSByZXN1bHQgb2YgZnMuY3JlYXRlUmVhZFN0cmVhbSgpLlxuICovXG5leHBvcnQgdHlwZSBVcGxvYWRhYmxlID0gRmlsZUxpa2UgfCBSZXNwb25zZUxpa2UgfCBGc1JlYWRTdHJlYW07XG5cbi8qKlxuICogSW50ZW5kZWQgdG8gbWF0Y2ggd2ViLkJsb2IsIG5vZGUuQmxvYiwgbm9kZS1mZXRjaC5CbG9iLCBldGMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvYkxpa2Uge1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3NpemUpICovXG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi90eXBlKSAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2IvdGV4dCkgKi9cbiAgdGV4dCgpOiBQcm9taXNlPHN0cmluZz47XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2Ivc2xpY2UpICovXG4gIHNsaWNlKHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpOiBCbG9iTGlrZTtcbiAgLy8gdW5mb3J0dW5hdGVseSBAdHlwZXMvbm9kZS1mZXRjaEBeMi42LjQgZG9lc24ndCB0eXBlIHRoZSBhcnJheUJ1ZmZlciBtZXRob2Rcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuRmlsZSwgbm9kZS5GaWxlLCBub2RlLWZldGNoLkZpbGUsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlTGlrZSBleHRlbmRzIEJsb2JMaWtlIHtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRmlsZS9sYXN0TW9kaWZpZWQpICovXG4gIHJlYWRvbmx5IGxhc3RNb2RpZmllZDogbnVtYmVyO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GaWxlL25hbWUpICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuUmVzcG9uc2UsIG5vZGUuUmVzcG9uc2UsIG5vZGUtZmV0Y2guUmVzcG9uc2UsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUxpa2Uge1xuICB1cmw6IHN0cmluZztcbiAgYmxvYigpOiBQcm9taXNlPEJsb2JMaWtlPjtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZXNwb25zZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS5ibG9iID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgRmlsZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS5uYW1lID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICBpc0Jsb2JMaWtlKHZhbHVlKTtcblxuLyoqXG4gKiBUaGUgQmxvYkxpa2UgdHlwZSBvbWl0cyBhcnJheUJ1ZmZlcigpIGJlY2F1c2UgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGxhY2tzIGl0OyBidXQgdGhpcyBjaGVja1xuICogYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2JMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBCbG9iTGlrZSAmIHsgYXJyYXlCdWZmZXIoKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gfSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInICYmXG4gIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgdmFsdWUuc2xpY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNVcGxvYWRhYmxlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBVcGxvYWRhYmxlID0+IHtcbiAgcmV0dXJuIGlzRmlsZUxpa2UodmFsdWUpIHx8IGlzUmVzcG9uc2VMaWtlKHZhbHVlKSB8fCBpc0ZzUmVhZFN0cmVhbSh2YWx1ZSk7XG59O1xuXG5leHBvcnQgdHlwZSBUb0ZpbGVJbnB1dCA9IFVwbG9hZGFibGUgfCBFeGNsdWRlPEJsb2JMaWtlUGFydCwgc3RyaW5nPiB8IEFzeW5jSXRlcmFibGU8QmxvYkxpa2VQYXJ0PjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNyZWF0aW5nIGEge0BsaW5rIEZpbGV9IHRvIHBhc3MgdG8gYW4gU0RLIHVwbG9hZCBtZXRob2QgZnJvbSBhIHZhcmlldHkgb2YgZGlmZmVyZW50IGRhdGEgZm9ybWF0c1xuICogQHBhcmFtIHZhbHVlIHRoZSByYXcgY29udGVudCBvZiB0aGUgZmlsZS4gIENhbiBiZSBhbiB7QGxpbmsgVXBsb2FkYWJsZX0sIHtAbGluayBCbG9iTGlrZVBhcnR9LCBvciB7QGxpbmsgQXN5bmNJdGVyYWJsZX0gb2Yge0BsaW5rIEJsb2JMaWtlUGFydH1zXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUuIElmIG9taXR0ZWQsIHRvRmlsZSB3aWxsIHRyeSB0byBkZXRlcm1pbmUgYSBmaWxlIG5hbWUgZnJvbSBiaXRzIGlmIHBvc3NpYmxlXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudHlwZSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubGFzdE1vZGlmaWVkIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWVzdGFtcFxuICogQHJldHVybnMgYSB7QGxpbmsgRmlsZX0gd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9GaWxlKFxuICB2YWx1ZTogVG9GaWxlSW5wdXQgfCBQcm9taXNlTGlrZTxUb0ZpbGVJbnB1dD4sXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBvcHRpb25zOiBGaWxlUHJvcGVydHlCYWcgfCB1bmRlZmluZWQgPSB7fSxcbik6IFByb21pc2U8RmlsZUxpa2U+IHtcbiAgLy8gSWYgaXQncyBhIHByb21pc2UsIHJlc29sdmUgaXQuXG4gIHZhbHVlID0gYXdhaXQgdmFsdWU7XG5cbiAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB2YWx1ZS5ibG9iKCk7XG4gICAgbmFtZSB8fD0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgPz8gJ3Vua25vd25fZmlsZSc7XG5cbiAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2IgYXMgYW55XSwgbmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBiaXRzID0gYXdhaXQgZ2V0Qnl0ZXModmFsdWUpO1xuXG4gIG5hbWUgfHw9IGdldE5hbWUodmFsdWUpID8/ICd1bmtub3duX2ZpbGUnO1xuXG4gIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IChiaXRzWzBdIGFzIGFueSk/LnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRmlsZShiaXRzLCBuYW1lLCBvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWU6IFRvRmlsZUlucHV0KTogUHJvbWlzZTxBcnJheTxCbG9iUGFydD4+IHtcbiAgbGV0IHBhcnRzOiBBcnJheTxCbG9iUGFydD4gPSBbXTtcbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgKSB7XG4gICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICBwYXJ0cy5wdXNoKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKFxuICAgIGlzQXN5bmNJdGVyYWJsZUl0ZXJhdG9yKHZhbHVlKSAvLyBpbmNsdWRlcyBSZWFkYWJsZSwgUmVhZGFibGVTdHJlYW0sIGV0Yy5cbiAgKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB2YWx1ZSkge1xuICAgICAgcGFydHMucHVzaChjaHVuayBhcyBCbG9iUGFydCk7IC8vIFRPRE8sIGNvbnNpZGVyIHZhbGlkYXRpbmc/XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkIGRhdGEgdHlwZTogJHt0eXBlb2YgdmFsdWV9OyBjb25zdHJ1Y3RvcjogJHtcbiAgICAgICAgdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lXG4gICAgICB9OyBwcm9wczogJHtwcm9wc0ZvckVycm9yKHZhbHVlKX1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICByZXR1cm4gYFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cblxuZnVuY3Rpb24gZ2V0TmFtZSh2YWx1ZTogYW55KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUubmFtZSkgfHxcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUuZmlsZW5hbWUpIHx8XG4gICAgLy8gRm9yIGZzLlJlYWRTdHJlYW1cbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUucGF0aCk/LnNwbGl0KC9bXFxcXC9dLykucG9wKClcbiAgKTtcbn1cblxuY29uc3QgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyID0gKHg6IHN0cmluZyB8IEJ1ZmZlciB8IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSByZXR1cm4geDtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBCdWZmZXIpIHJldHVybiBTdHJpbmcoeCk7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBpc0FzeW5jSXRlcmFibGVJdGVyYXRvciA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPHVua25vd24+ID0+XG4gIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNNdWx0aXBhcnRCb2R5ID0gKGJvZHk6IGFueSk6IGJvZHkgaXMgTXVsdGlwYXJ0Qm9keSA9PlxuICBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiBib2R5LmJvZHkgJiYgYm9keVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTXVsdGlwYXJ0Qm9keSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG11bHRpcGFydC9mb3JtLWRhdGEgcmVxdWVzdCBpZiBhbnkgcGFydCBvZiB0aGUgZ2l2ZW4gcmVxdWVzdCBib2R5IGNvbnRhaW5zIGEgRmlsZSAvIEJsb2IgdmFsdWUuXG4gKiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcmVxdWVzdCBhcyBpcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1heWJlTXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgZXh0ZW5kcyB7fSA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBpZiAoIWhhc1VwbG9hZGFibGVWYWx1ZShvcHRzLmJvZHkpKSByZXR1cm4gb3B0cztcblxuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgZXh0ZW5kcyB7fSA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRm9ybSA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KGJvZHk6IFQgfCB1bmRlZmluZWQpOiBQcm9taXNlPEZvcm1EYXRhPiA9PiB7XG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoYm9keSB8fCB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXksIHZhbHVlKSkpO1xuICByZXR1cm4gZm9ybTtcbn07XG5cbmNvbnN0IGhhc1VwbG9hZGFibGVWYWx1ZSA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLnNvbWUoaGFzVXBsb2FkYWJsZVZhbHVlKTtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChoYXNVcGxvYWRhYmxlVmFsdWUoKHZhbHVlIGFzIGFueSlba10pKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgYWRkRm9ybVZhbHVlID0gYXN5bmMgKGZvcm06IEZvcm1EYXRhLCBrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFJlY2VpdmVkIG51bGwgZm9yIFwiJHtrZXl9XCI7IHRvIHBhc3MgbnVsbCBpbiBGb3JtRGF0YSwgeW91IG11c3QgdXNlIHRoZSBzdHJpbmcgJ251bGwnYCxcbiAgICApO1xuICB9XG5cbiAgLy8gVE9ETzogbWFrZSBuZXN0ZWQgZm9ybWF0cyBjb25maWd1cmFibGVcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkge1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0b0ZpbGUodmFsdWUpO1xuICAgIGZvcm0uYXBwZW5kKGtleSwgZmlsZSBhcyBGaWxlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoZW50cnkpID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXkgKyAnW10nLCBlbnRyeSkpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbbmFtZSwgcHJvcF0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBgJHtrZXl9WyR7bmFtZX1dYCwgcHJvcCkpLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGdpdmVuIHRvIGZvcm0sIGV4cGVjdGVkIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCwgQXJyYXksIEZpbGUgb3IgQmxvYiBidXQgZ290ICR7dmFsdWV9IGluc3RlYWRgLFxuICAgICk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vdmVyc2lvbic7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuL3N0cmVhbWluZyc7XG5pbXBvcnQge1xuICBPcGVuQUlFcnJvcixcbiAgQVBJRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25FcnJvcixcbiAgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcixcbiAgQVBJVXNlckFib3J0RXJyb3IsXG59IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHtcbiAga2luZCBhcyBzaGltc0tpbmQsXG4gIHR5cGUgUmVhZGFibGUsXG4gIGdldERlZmF1bHRBZ2VudCxcbiAgdHlwZSBBZ2VudCxcbiAgZmV0Y2gsXG4gIHR5cGUgUmVxdWVzdEluZm8sXG4gIHR5cGUgUmVxdWVzdEluaXQsXG4gIHR5cGUgUmVzcG9uc2UsXG4gIHR5cGUgSGVhZGVyc0luaXQsXG59IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmV4cG9ydCB7IHR5cGUgUmVzcG9uc2UgfTtcbmltcG9ydCB7IGlzTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vdXBsb2Fkcyc7XG5leHBvcnQge1xuICBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyxcbiAgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLFxuICBjcmVhdGVGb3JtLFxuICB0eXBlIFVwbG9hZGFibGUsXG59IGZyb20gJy4vdXBsb2Fkcyc7XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gMjtcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSAodXJsOiBSZXF1ZXN0SW5mbywgaW5pdD86IFJlcXVlc3RJbml0KSA9PiBQcm9taXNlPFJlc3BvbnNlPjtcblxudHlwZSBQcm9taXNlT3JWYWx1ZTxUPiA9IFQgfCBQcm9taXNlPFQ+O1xuXG50eXBlIEFQSVJlc3BvbnNlUHJvcHMgPSB7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdFBhcnNlUmVzcG9uc2U8VD4ocHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXNwb25zZSB9ID0gcHJvcHM7XG4gIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFuIGludmFyaWFudCBoZXJlIHRoYXQgaXNuJ3QgcmVwcmVzZW50ZWQgaW4gdGhlIHR5cGUgc3lzdGVtXG4gICAgLy8gdGhhdCBpZiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgIHRoZSByZXNwb25zZSB0eXBlIG11c3QgYWxzbyBiZSBgU3RyZWFtPFQ+YFxuICAgIHJldHVybiBuZXcgU3RyZWFtKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKSBhcyBhbnk7XG4gIH1cblxuICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsLCByZXNwb25zZS5oZWFkZXJzLCBqc29uKTtcblxuICAgIHJldHVybiBqc29uIGFzIFQ7XG4gIH1cblxuICAvLyBUT0RPIGhhbmRsZSBibG9iLCBhcnJheWJ1ZmZlciwgb3RoZXIgY29udGVudCB0eXBlcywgZXRjLlxuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgdGV4dCk7XG4gIHJldHVybiB0ZXh0IGFzIGFueSBhcyBUO1xufVxuXG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgYFByb21pc2VgIHByb3ZpZGluZyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzXG4gKiBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgU0RLLlxuICovXG5leHBvcnQgY2xhc3MgQVBJUHJvbWlzZTxUPiBleHRlbmRzIFByb21pc2U8VD4ge1xuICBwcml2YXRlIHBhcnNlZFByb21pc2U6IFByb21pc2U8VD4gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZXNwb25zZVByb21pc2U6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4sXG4gICAgcHJpdmF0ZSBwYXJzZVJlc3BvbnNlOiAocHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpID0+IFByb21pc2VPclZhbHVlPFQ+ID0gZGVmYXVsdFBhcnNlUmVzcG9uc2UsXG4gICkge1xuICAgIHN1cGVyKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyB0aGlzIGlzIG1heWJlIGEgYml0IHdlaXJkIGJ1dCB0aGlzIGhhcyB0byBiZSBhIG5vLW9wIHRvIG5vdCBpbXBsaWNpdGx5XG4gICAgICAvLyBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keTsgaW5zdGVhZCAudGhlbiwgLmNhdGNoLCAuZmluYWxseSBhcmUgb3ZlcnJpZGRlblxuICAgICAgLy8gdG8gcGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgICByZXNvbHZlKG51bGwgYXMgYW55KTtcbiAgICB9KTtcbiAgfVxuXG4gIF90aGVuVW53cmFwPFU+KHRyYW5zZm9ybTogKGRhdGE6IFQpID0+IFUpOiBBUElQcm9taXNlPFU+IHtcbiAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcy5yZXNwb25zZVByb21pc2UsIGFzeW5jIChwcm9wcykgPT4gdHJhbnNmb3JtKGF3YWl0IHRoaXMucGFyc2VSZXNwb25zZShwcm9wcykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAqIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzUmVzcG9uc2UoKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKChwKSA9PiBwLnJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcGFyc2VkIHJlc3BvbnNlIGRhdGEgYW5kIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZS5cbiAgICpcbiAgICogSWYgeW91IGp1c3Qgd2FudCB0byBnZXQgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIHdpdGhvdXQgcGFyc2luZyBpdCxcbiAgICogeW91IGNhbiB1c2Uge0BsaW5rIGFzUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzeW5jIHdpdGhSZXNwb25zZSgpOiBQcm9taXNlPHsgZGF0YTogVDsgcmVzcG9uc2U6IFJlc3BvbnNlIH0+IHtcbiAgICBjb25zdCBbZGF0YSwgcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICByZXR1cm4geyBkYXRhLCByZXNwb25zZSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZSgpOiBQcm9taXNlPFQ+IHtcbiAgICBpZiAoIXRoaXMucGFyc2VkUHJvbWlzZSkge1xuICAgICAgdGhpcy5wYXJzZWRQcm9taXNlID0gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbih0aGlzLnBhcnNlUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZWRQcm9taXNlO1xuICB9XG5cbiAgb3ZlcnJpZGUgdGhlbjxUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PikgfCB1bmRlZmluZWQgfCBudWxsLFxuICApOiBQcm9taXNlPFQgfCBUUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGZpbmFsbHkob25maW5hbGx5PzogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkIHwgbnVsbCk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBUElDbGllbnQge1xuICBiYXNlVVJMOiBzdHJpbmc7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgdGltZW91dDogbnVtYmVyO1xuICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgZmV0Y2g6IEZldGNoO1xuICBwcm90ZWN0ZWQgaWRlbXBvdGVuY3lIZWFkZXI/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVUkwsXG4gICAgbWF4UmV0cmllcyxcbiAgICB0aW1lb3V0ID0gNjAwMDAwLCAvLyAxMCBtaW51dGVzXG4gICAgaHR0cEFnZW50LFxuICAgIGZldGNoOiBvdmVycmlkZW5GZXRjaCxcbiAgfToge1xuICAgIGJhc2VVUkw6IHN0cmluZztcbiAgICBtYXhSZXRyaWVzPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIHRpbWVvdXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuICAgIGZldGNoOiBGZXRjaCB8IHVuZGVmaW5lZDtcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgdGhpcy5tYXhSZXRyaWVzID0gdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ21heFJldHJpZXMnLCBtYXhSZXRyaWVzID8/IE1BWF9SRVRSSUVTKTtcbiAgICB0aGlzLnRpbWVvdXQgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIHRpbWVvdXQpO1xuICAgIHRoaXMuaHR0cEFnZW50ID0gaHR0cEFnZW50O1xuXG4gICAgdGhpcy5mZXRjaCA9IG92ZXJyaWRlbkZldGNoID8/IGZldGNoO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF1dGhIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHtcbiAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICogICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAxMjMnLFxuICAgKiAgfVxuICAgKi9cbiAgcHJvdGVjdGVkIGRlZmF1bHRIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ1VzZXItQWdlbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLFxuICAgICAgLi4uZ2V0UGxhdGZvcm1IZWFkZXJzKCksXG4gICAgICAuLi50aGlzLmF1dGhIZWFkZXJzKG9wdHMpLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZGVmYXVsdFF1ZXJ5KCk6IERlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gaGVhZGVycyB2YWxpZGF0aW9uOlxuICAgKi9cbiAgcHJvdGVjdGVkIHZhbGlkYXRlSGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzLCBjdXN0b21IZWFkZXJzOiBIZWFkZXJzKSB7fVxuXG4gIHByb3RlY3RlZCBkZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICB9XG5cbiAgZ2V0PFJlcSBleHRlbmRzIHt9LCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBvc3Q8UmVxIGV4dGVuZHMge30sIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBhdGNoPFJlcSBleHRlbmRzIHt9LCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcHV0PFJlcSBleHRlbmRzIHt9LCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIGRlbGV0ZTxSZXEgZXh0ZW5kcyB7fSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwcml2YXRlIG1ldGhvZFJlcXVlc3Q8UmVxIGV4dGVuZHMge30sIFJzcD4oXG4gICAgbWV0aG9kOiBIVFRQTWV0aG9kLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChQcm9taXNlLnJlc29sdmUob3B0cykudGhlbigob3B0cykgPT4gKHsgbWV0aG9kLCBwYXRoLCAuLi5vcHRzIH0pKSk7XG4gIH1cblxuICBnZXRBUElMaXN0PEl0ZW0sIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiA9IEFic3RyYWN0UGFnZTxJdGVtPj4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFBhZ2VDbGFzcyxcbiAgICBvcHRzPzogUmVxdWVzdE9wdGlvbnM8YW55PixcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFQSUxpc3QoUGFnZSwgeyBtZXRob2Q6ICdnZXQnLCBwYXRoLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHk6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHksICd1dGY4JykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoYm9keSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYnVpbGRSZXF1ZXN0PFJlcSBleHRlbmRzIHt9PihcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4sXG4gICk6IHsgcmVxOiBSZXF1ZXN0SW5pdDsgdXJsOiBzdHJpbmc7IHRpbWVvdXQ6IG51bWJlciB9IHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGhlYWRlcnM6IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJvZHkgPVxuICAgICAgaXNNdWx0aXBhcnRCb2R5KG9wdGlvbnMuYm9keSkgPyBvcHRpb25zLmJvZHkuYm9keVxuICAgICAgOiBvcHRpb25zLmJvZHkgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHksIG51bGwsIDIpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXMuY2FsY3VsYXRlQ29udGVudExlbmd0aChib2R5KTtcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVUkwocGF0aCEsIHF1ZXJ5KTtcbiAgICBpZiAoJ3RpbWVvdXQnIGluIG9wdGlvbnMpIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0Jywgb3B0aW9ucy50aW1lb3V0KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICBjb25zdCBodHRwQWdlbnQgPSBvcHRpb25zLmh0dHBBZ2VudCA/PyB0aGlzLmh0dHBBZ2VudCA/PyBnZXREZWZhdWx0QWdlbnQodXJsKTtcbiAgICBjb25zdCBtaW5BZ2VudFRpbWVvdXQgPSB0aW1lb3V0ICsgMTAwMDtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgKGh0dHBBZ2VudCBhcyBhbnkpPy5vcHRpb25zPy50aW1lb3V0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgbWluQWdlbnRUaW1lb3V0ID4gKChodHRwQWdlbnQgYXMgYW55KS5vcHRpb25zLnRpbWVvdXQgPz8gMClcbiAgICApIHtcbiAgICAgIC8vIEFsbG93IGFueSBnaXZlbiByZXF1ZXN0IHRvIGJ1bXAgb3VyIGFnZW50IGFjdGl2ZSBzb2NrZXQgdGltZW91dC5cbiAgICAgIC8vIFRoaXMgbWF5IHNlZW0gc3RyYW5nZSwgYnV0IGxlYWtpbmcgYWN0aXZlIHNvY2tldHMgc2hvdWxkIGJlIHJhcmUgYW5kIG5vdCBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMsXG4gICAgICAvLyBhbmQgd2l0aG91dCBtdXRhdGluZyBhZ2VudCB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBtb3JlIG9mIHRoZW0uXG4gICAgICAvLyBUaGlzIHRyYWRlb2ZmIG9wdGltaXplcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAoaHR0cEFnZW50IGFzIGFueSkub3B0aW9ucy50aW1lb3V0ID0gbWluQWdlbnRUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlkZW1wb3RlbmN5SGVhZGVyICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgIGlmICghb3B0aW9ucy5pZGVtcG90ZW5jeUtleSkgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICBoZWFkZXJzW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gb3B0aW9ucy5pZGVtcG90ZW5jeUtleTtcbiAgICB9XG5cbiAgICBjb25zdCByZXFIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgLi4uKGNvbnRlbnRMZW5ndGggJiYgeyAnQ29udGVudC1MZW5ndGgnOiBjb250ZW50TGVuZ3RoIH0pLFxuICAgICAgLi4udGhpcy5kZWZhdWx0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfTtcbiAgICAvLyBsZXQgYnVpbHRpbiBmZXRjaCBzZXQgdGhlIENvbnRlbnQtVHlwZSBmb3IgbXVsdGlwYXJ0IGJvZGllc1xuICAgIGlmIChpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSAmJiBzaGltc0tpbmQgIT09ICdub2RlJykge1xuICAgICAgZGVsZXRlIHJlcUhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIGFueSBoZWFkZXJzIGJlaW5nIGV4cGxpY2l0bHkgb21pdHRlZCB3aXRoIG51bGxcbiAgICBPYmplY3Qua2V5cyhyZXFIZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHJlcUhlYWRlcnNba2V5XSA9PT0gbnVsbCAmJiBkZWxldGUgcmVxSGVhZGVyc1trZXldKTtcblxuICAgIGNvbnN0IHJlcTogUmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICAuLi4oYm9keSAmJiB7IGJvZHk6IGJvZHkgYXMgYW55IH0pLFxuICAgICAgaGVhZGVyczogcmVxSGVhZGVycyxcbiAgICAgIC4uLihodHRwQWdlbnQgJiYgeyBhZ2VudDogaHR0cEFnZW50IH0pLFxuICAgICAgLy8gQHRzLWlnbm9yZSBub2RlLWZldGNoIHVzZXMgYSBjdXN0b20gQWJvcnRTaWduYWwgdHlwZSB0aGF0IGlzXG4gICAgICAvLyBub3QgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkIHdlYiB0eXBlc1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCA/PyBudWxsLFxuICAgIH07XG5cbiAgICB0aGlzLnZhbGlkYXRlSGVhZGVycyhyZXFIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0IH07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYFJlcXVlc3RJbml0YCBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3Ugd2FudCB0byBhZGQgY2VydGFpbiBoZWFkZXJzIGJhc2VkIG9mZiBvZlxuICAgKiB0aGUgcmVxdWVzdCBwcm9wZXJ0aWVzLCBlLmcuIGBtZXRob2RgIG9yIGB1cmxgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHByZXBhcmVSZXF1ZXN0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3RJbml0LFxuICAgIHsgdXJsLCBvcHRpb25zIH06IHsgdXJsOiBzdHJpbmc7IG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMgfSxcbiAgKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIHByb3RlY3RlZCBwYXJzZUhlYWRlcnMoaGVhZGVyczogSGVhZGVyc0luaXQgfCBudWxsIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgICFoZWFkZXJzID8ge31cbiAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIGhlYWRlcnMgP1xuICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShoZWFkZXJzIGFzIEl0ZXJhYmxlPHN0cmluZ1tdPikubWFwKChoZWFkZXIpID0+IFsuLi5oZWFkZXJdKSlcbiAgICAgIDogeyAuLi5oZWFkZXJzIH1cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1ha2VTdGF0dXNFcnJvcihcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICByZXR1cm4gQVBJRXJyb3IuZ2VuZXJhdGUoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cblxuICByZXF1ZXN0PFJlcSBleHRlbmRzIHt9LCBSc3A+KFxuICAgIG9wdGlvbnM6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICAgcmVtYWluaW5nUmV0cmllczogbnVtYmVyIHwgbnVsbCA9IG51bGwsXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdChcbiAgICBvcHRpb25zSW5wdXQ6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM+LFxuICAgIHJldHJpZXNSZW1haW5pbmc6IG51bWJlciB8IG51bGwsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zSW5wdXQ7XG4gICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZXEsIHVybCwgdGltZW91dCB9ID0gdGhpcy5idWlsZFJlcXVlc3Qob3B0aW9ucyk7XG5cbiAgICBhd2FpdCB0aGlzLnByZXBhcmVSZXF1ZXN0KHJlcSwgeyB1cmwsIG9wdGlvbnMgfSk7XG5cbiAgICBkZWJ1ZygncmVxdWVzdCcsIHVybCwgb3B0aW9ucywgcmVxLmhlYWRlcnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgcmVxLCB0aW1lb3V0LCBjb250cm9sbGVyKS5jYXRjaChjYXN0VG9FcnJvcik7XG5cbiAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBjcmVhdGVSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmV0cmllc1JlbWFpbmluZyAmJiB0aGlzLnNob3VsZFJldHJ5KHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZywgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZSkgPT4gY2FzdFRvRXJyb3IoZSkubWVzc2FnZSk7XG4gICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG5cbiAgICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMsIGVyck1lc3NhZ2UpO1xuXG4gICAgICBjb25zdCBlcnIgPSB0aGlzLm1ha2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIGVyckpTT04sIGVyck1lc3NhZ2UsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcmVzcG9uc2UsIG9wdGlvbnMsIGNvbnRyb2xsZXIgfTtcbiAgfVxuXG4gIHJlcXVlc3RBUElMaXN0PEl0ZW0gPSB1bmtub3duLCBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4gPSBBYnN0cmFjdFBhZ2U8SXRlbT4+KFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgbnVsbCk7XG4gICAgcmV0dXJuIG5ldyBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+KHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICB9XG5cbiAgYnVpbGRVUkw8UmVxIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KHBhdGg6IHN0cmluZywgcXVlcnk6IFJlcSB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybCA9XG4gICAgICBpc0Fic29sdXRlVVJMKHBhdGgpID9cbiAgICAgICAgbmV3IFVSTChwYXRoKVxuICAgICAgOiBuZXcgVVJMKHRoaXMuYmFzZVVSTCArICh0aGlzLmJhc2VVUkwuZW5kc1dpdGgoJy8nKSAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdGguc2xpY2UoMSkgOiBwYXRoKSk7XG5cbiAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgIGlmICghaXNFbXB0eU9iaihkZWZhdWx0UXVlcnkpKSB7XG4gICAgICBxdWVyeSA9IHsgLi4uZGVmYXVsdFF1ZXJ5LCAuLi5xdWVyeSB9IGFzIFJlcTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RyaW5naWZ5UXVlcnkocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocXVlcnkpXG4gICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBzdHJpbmdpZnkgdHlwZSAke3R5cGVvZiB2YWx1ZX07IEV4cGVjdGVkIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsLiBJZiB5b3UgbmVlZCB0byBwYXNzIG5lc3RlZCBxdWVyeSBwYXJhbWV0ZXJzLCB5b3UgY2FuIG1hbnVhbGx5IGVuY29kZSB0aGVtLCBlLmcuIHsgcXVlcnk6IHsgJ2Zvb1trZXkxXSc6IHZhbHVlMSwgJ2Zvb1trZXkyXSc6IHZhbHVlMiB9IH0sIGFuZCBwbGVhc2Ugb3BlbiBhIEdpdEh1YiBpc3N1ZSByZXF1ZXN0aW5nIGJldHRlciBzdXBwb3J0IGZvciB5b3VyIHVzZSBjYXNlLmAsXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQoXG4gICAgdXJsOiBSZXF1ZXN0SW5mbyxcbiAgICBpbml0OiBSZXF1ZXN0SW5pdCB8IHVuZGVmaW5lZCxcbiAgICBtczogbnVtYmVyLFxuICAgIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbiAgKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgc2lnbmFsLCAuLi5vcHRpb25zIH0gPSBpbml0IHx8IHt9O1xuICAgIGlmIChzaWduYWwpIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG5cbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIG1zKTtcblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmdldFJlcXVlc3RDbGllbnQoKVxuICAgICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgICAuZmV0Y2guY2FsbCh1bmRlZmluZWQsIHVybCwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIGFzIGFueSwgLi4ub3B0aW9ucyB9KVxuICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0UmVxdWVzdENsaWVudCgpOiBSZXF1ZXN0Q2xpZW50IHtcbiAgICByZXR1cm4geyBmZXRjaDogdGhpcy5mZXRjaCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRSZXRyeShyZXNwb25zZTogUmVzcG9uc2UpOiBib29sZWFuIHtcbiAgICAvLyBOb3RlIHRoaXMgaXMgbm90IGEgc3RhbmRhcmQgaGVhZGVyLlxuICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG5cbiAgICAvLyBJZiB0aGUgc2VydmVyIGV4cGxpY2l0bHkgc2F5cyB3aGV0aGVyIG9yIG5vdCB0byByZXRyeSwgb2JleS5cbiAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAnZmFsc2UnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBSZXRyeSBvbiByZXF1ZXN0IHRpbWVvdXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBvbiByYXRlIGxpbWl0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgaW50ZXJuYWwgZXJyb3JzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmV0cnlSZXF1ZXN0KFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMsXG4gICAgcmV0cmllc1JlbWFpbmluZzogbnVtYmVyLFxuICAgIHJlc3BvbnNlSGVhZGVycz86IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIHJldHJpZXNSZW1haW5pbmcgLT0gMTtcblxuICAgIC8vIEFib3V0IHRoZSBSZXRyeS1BZnRlciBoZWFkZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZXRyeS1BZnRlclxuICAgIGxldCB0aW1lb3V0TWlsbGlzOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IHJlc3BvbnNlSGVhZGVycz8uWydyZXRyeS1hZnRlciddO1xuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7XG4gICAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IHBhcnNlSW50KHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0U2Vjb25kcyAqIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0TWlsbGlzID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVySGVhZGVyKSAtIERhdGUubm93KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIEFQSSBhc2tzIHVzIHRvIHdhaXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChhbmQgaXQncyBhIHJlYXNvbmFibGUgYW1vdW50KSxcbiAgICAvLyBqdXN0IGRvIHdoYXQgaXQgc2F5cywgYnV0IG90aGVyd2lzZSBjYWxjdWxhdGUgYSBkZWZhdWx0XG4gICAgaWYgKFxuICAgICAgIXRpbWVvdXRNaWxsaXMgfHxcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHRpbWVvdXRNaWxsaXMpIHx8XG4gICAgICB0aW1lb3V0TWlsbGlzIDw9IDAgfHxcbiAgICAgIHRpbWVvdXRNaWxsaXMgPiA2MCAqIDEwMDBcbiAgICApIHtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gdGhpcy5tYXhSZXRyaWVzO1xuICAgICAgdGltZW91dE1pbGxpcyA9IHRoaXMuY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nLCBtYXhSZXRyaWVzKTtcbiAgICB9XG4gICAgYXdhaXQgc2xlZXAodGltZW91dE1pbGxpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nOiBudW1iZXIsIG1heFJldHJpZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaW5pdGlhbFJldHJ5RGVsYXkgPSAwLjU7XG4gICAgY29uc3QgbWF4UmV0cnlEZWxheSA9IDI7XG5cbiAgICBjb25zdCBudW1SZXRyaWVzID0gbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmc7XG5cbiAgICAvLyBBcHBseSBleHBvbmVudGlhbCBiYWNrb2ZmLCBidXQgbm90IG1vcmUgdGhhbiB0aGUgbWF4LlxuICAgIGNvbnN0IHNsZWVwU2Vjb25kcyA9IE1hdGgubWluKGluaXRpYWxSZXRyeURlbGF5ICogTWF0aC5wb3cobnVtUmV0cmllcyAtIDEsIDIpLCBtYXhSZXRyeURlbGF5KTtcblxuICAgIC8vIEFwcGx5IHNvbWUgaml0dGVyLCBwbHVzLW9yLW1pbnVzIGhhbGYgYSBzZWNvbmQuXG4gICAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAtIDAuNTtcblxuICAgIHJldHVybiAoc2xlZXBTZWNvbmRzICsgaml0dGVyKSAqIDEwMDA7XG4gIH1cblxuICBwcml2YXRlIGdldFVzZXJBZ2VudCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7VkVSU0lPTn1gO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElSZXNvdXJjZSB7XG4gIHByb3RlY3RlZCBjbGllbnQ6IEFQSUNsaWVudDtcbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcblxuICAgIHRoaXMuZ2V0ID0gY2xpZW50LmdldC5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5wb3N0ID0gY2xpZW50LnBvc3QuYmluZChjbGllbnQpO1xuICAgIHRoaXMucGF0Y2ggPSBjbGllbnQucGF0Y2guYmluZChjbGllbnQpO1xuICAgIHRoaXMucHV0ID0gY2xpZW50LnB1dC5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5kZWxldGUgPSBjbGllbnQuZGVsZXRlLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLmdldEFQSUxpc3QgPSBjbGllbnQuZ2V0QVBJTGlzdC5iaW5kKGNsaWVudCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0OiBBUElDbGllbnRbJ2dldCddO1xuICBwcm90ZWN0ZWQgcG9zdDogQVBJQ2xpZW50Wydwb3N0J107XG4gIHByb3RlY3RlZCBwYXRjaDogQVBJQ2xpZW50WydwYXRjaCddO1xuICBwcm90ZWN0ZWQgcHV0OiBBUElDbGllbnRbJ3B1dCddO1xuICBwcm90ZWN0ZWQgZGVsZXRlOiBBUElDbGllbnRbJ2RlbGV0ZSddO1xuICBwcm90ZWN0ZWQgZ2V0QVBJTGlzdDogQVBJQ2xpZW50WydnZXRBUElMaXN0J107XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VJbmZvID0geyB1cmw6IFVSTCB9IHwgeyBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCB9O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPiB7XG4gICNjbGllbnQ6IEFQSUNsaWVudDtcbiAgcHJvdGVjdGVkIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG5cbiAgcHJvdGVjdGVkIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgcHJvdGVjdGVkIGJvZHk6IHVua25vd247XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogdW5rbm93biwgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucykge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBuZXh0UGFnZUluZm8gaW5zdGVhZFxuICAgKi9cbiAgYWJzdHJhY3QgbmV4dFBhZ2VQYXJhbXMoKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gfCBudWxsO1xuICBhYnN0cmFjdCBuZXh0UGFnZUluZm8oKTogUGFnZUluZm8gfCBudWxsO1xuXG4gIGFic3RyYWN0IGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXTtcblxuICBoYXNOZXh0UGFnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm5leHRQYWdlSW5mbygpICE9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXROZXh0UGFnZSgpOiBQcm9taXNlPHRoaXM+IHtcbiAgICBjb25zdCBuZXh0SW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgaWYgKCFuZXh0SW5mbykge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAnTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBuZXh0T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG4gICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvKSB7XG4gICAgICBuZXh0T3B0aW9ucy5xdWVyeSA9IHsgLi4ubmV4dE9wdGlvbnMucXVlcnksIC4uLm5leHRJbmZvLnBhcmFtcyB9O1xuICAgIH0gZWxzZSBpZiAoJ3VybCcgaW4gbmV4dEluZm8pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsuLi5PYmplY3QuZW50cmllcyhuZXh0T3B0aW9ucy5xdWVyeSB8fCB7fSksIC4uLm5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuZW50cmllcygpXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICBuZXh0SW5mby51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlIGFzIGFueSk7XG4gICAgICB9XG4gICAgICBuZXh0T3B0aW9ucy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgIG5leHRPcHRpb25zLnBhdGggPSBuZXh0SW5mby51cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NsaWVudC5yZXF1ZXN0QVBJTGlzdCh0aGlzLmNvbnN0cnVjdG9yIGFzIGFueSwgbmV4dE9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgKml0ZXJQYWdlcygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBsZXQgcGFnZTogQWJzdHJhY3RQYWdlPEl0ZW0+ID0gdGhpcztcbiAgICB5aWVsZCBwYWdlO1xuICAgIHdoaWxlIChwYWdlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgIHBhZ2UgPSBhd2FpdCBwYWdlLmdldE5leHRQYWdlKCk7XG4gICAgICB5aWVsZCBwYWdlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFnZSBvZiB0aGlzLml0ZXJQYWdlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFnZS5nZXRQYWdpbmF0ZWRJdGVtcygpKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBzdWJjbGFzcyBvZiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB0byBhbiBpbnN0YW50aWF0ZWQgUGFnZSBvbmNlIHRoZSByZXF1ZXN0IGNvbXBsZXRlcy5cbiAqXG4gKiBJdCBhbHNvIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZSB0byBhbGxvdyBhdXRvLXBhZ2luYXRpbmcgaXRlcmF0aW9uIG9uIGFuIHVuYXdhaXRlZCBsaXN0IGNhbGwsIGVnOlxuICpcbiAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gKiAgICAgIGNvbnNvbGUubG9nKGl0ZW0pXG4gKiAgICB9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlUHJvbWlzZTxcbiAgICBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4sXG4gICAgSXRlbSA9IFJldHVyblR5cGU8UGFnZUNsYXNzWydnZXRQYWdpbmF0ZWRJdGVtcyddPltudW1iZXJdLFxuICA+XG4gIGV4dGVuZHMgQVBJUHJvbWlzZTxQYWdlQ2xhc3M+XG4gIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPlxue1xuICBjb25zdHJ1Y3RvcihcbiAgICBjbGllbnQ6IEFQSUNsaWVudCxcbiAgICByZXF1ZXN0OiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+LFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGFzeW5jIChwcm9wcykgPT4gbmV3IFBhZ2UoY2xpZW50LCBwcm9wcy5yZXNwb25zZSwgYXdhaXQgZGVmYXVsdFBhcnNlUmVzcG9uc2UocHJvcHMpLCBwcm9wcy5vcHRpb25zKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAqXG4gICAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICogICAgfVxuICAgKi9cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXM7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHBhZ2UpIHtcbiAgICAgIHlpZWxkIGl0ZW07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNwb25zZUhlYWRlcnMgPSAoXG4gIGhlYWRlcnM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTxGZXRjaD4+WydoZWFkZXJzJ10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBoZWFkZXJzLmVudHJpZXMoKSxcbiAgICApLFxuICAgIHtcbiAgICAgIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleS50b0xvd2VyQ2FzZSgpXSB8fCB0YXJnZXRba2V5XTtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcbn07XG5cbnR5cGUgSFRUUE1ldGhvZCA9ICdnZXQnIHwgJ3Bvc3QnIHwgJ3B1dCcgfCAncGF0Y2gnIHwgJ2RlbGV0ZSc7XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RDbGllbnQgPSB7IGZldGNoOiBGZXRjaCB9O1xuZXhwb3J0IHR5cGUgSGVhZGVycyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgRGVmYXVsdFF1ZXJ5ID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcbmV4cG9ydCB0eXBlIEtleXNFbnVtPFQ+ID0geyBbUCBpbiBrZXlvZiBSZXF1aXJlZDxUPl06IHRydWUgfTtcblxuZXhwb3J0IHR5cGUgUmVxdWVzdE9wdGlvbnM8UmVxIGV4dGVuZHMge30gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlYWRhYmxlPiA9IHtcbiAgbWV0aG9kPzogSFRUUE1ldGhvZDtcbiAgcGF0aD86IHN0cmluZztcbiAgcXVlcnk/OiBSZXEgfCB1bmRlZmluZWQ7XG4gIGJvZHk/OiBSZXEgfCB1bmRlZmluZWQ7XG4gIGhlYWRlcnM/OiBIZWFkZXJzIHwgdW5kZWZpbmVkO1xuXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIHN0cmVhbT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIGh0dHBBZ2VudD86IEFnZW50O1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbCB8IHVuZGVmaW5lZCB8IG51bGw7XG4gIGlkZW1wb3RlbmN5S2V5Pzogc3RyaW5nO1xufTtcblxuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzOiBLZXlzRW51bTxSZXF1ZXN0T3B0aW9ucz4gPSB7XG4gIG1ldGhvZDogdHJ1ZSxcbiAgcGF0aDogdHJ1ZSxcbiAgcXVlcnk6IHRydWUsXG4gIGJvZHk6IHRydWUsXG4gIGhlYWRlcnM6IHRydWUsXG5cbiAgbWF4UmV0cmllczogdHJ1ZSxcbiAgc3RyZWFtOiB0cnVlLFxuICB0aW1lb3V0OiB0cnVlLFxuICBodHRwQWdlbnQ6IHRydWUsXG4gIHNpZ25hbDogdHJ1ZSxcbiAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgaXNSZXF1ZXN0T3B0aW9ucyA9IChvYmo6IHVua25vd24pOiBvYmogaXMgUmVxdWVzdE9wdGlvbnM8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBSZWFkYWJsZT4gPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgb2JqICE9PSBudWxsICYmXG4gICAgIWlzRW1wdHlPYmoob2JqKSAmJlxuICAgIE9iamVjdC5rZXlzKG9iaikuZXZlcnkoKGspID0+IGhhc093bihyZXF1ZXN0T3B0aW9uc0tleXMsIGspKVxuICApO1xufTtcblxuZXhwb3J0IHR5cGUgRmluYWxSZXF1ZXN0T3B0aW9uczxSZXEgZXh0ZW5kcyB7fSA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgUmVhZGFibGU+ID0gUmVxdWVzdE9wdGlvbnM8UmVxPiAmIHtcbiAgbWV0aG9kOiBIVFRQTWV0aG9kO1xuICBwYXRoOiBzdHJpbmc7XG59O1xuXG5kZWNsYXJlIGNvbnN0IERlbm86IGFueTtcbmRlY2xhcmUgY29uc3QgRWRnZVJ1bnRpbWU6IGFueTtcbnR5cGUgQXJjaCA9ICd4MzInIHwgJ3g2NCcgfCAnYXJtJyB8ICdhcm02NCcgfCBgb3RoZXI6JHtzdHJpbmd9YCB8ICd1bmtub3duJztcbnR5cGUgUGxhdGZvcm1OYW1lID1cbiAgfCAnTWFjT1MnXG4gIHwgJ0xpbnV4J1xuICB8ICdXaW5kb3dzJ1xuICB8ICdGcmVlQlNEJ1xuICB8ICdPcGVuQlNEJ1xuICB8ICdpT1MnXG4gIHwgJ0FuZHJvaWQnXG4gIHwgYE90aGVyOiR7c3RyaW5nfWBcbiAgfCAnVW5rbm93bic7XG50eXBlIEJyb3dzZXIgPSAnaWUnIHwgJ2VkZ2UnIHwgJ2Nocm9tZScgfCAnZmlyZWZveCcgfCAnc2FmYXJpJztcbnR5cGUgUGxhdGZvcm1Qcm9wZXJ0aWVzID0ge1xuICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcyc7XG4gICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBzdHJpbmc7XG4gICdYLVN0YWlubGVzcy1PUyc6IFBsYXRmb3JtTmFtZTtcbiAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBBcmNoO1xuICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyB8ICdkZW5vJyB8ICdlZGdlJyB8IGBicm93c2VyOiR7QnJvd3Nlcn1gIHwgJ3Vua25vd24nO1xuICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogc3RyaW5nO1xufTtcbmNvbnN0IGdldFBsYXRmb3JtUHJvcGVydGllcyA9ICgpOiBQbGF0Zm9ybVByb3BlcnRpZXMgPT4ge1xuICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIERlbm8uYnVpbGQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKERlbm8uYnVpbGQub3MpLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKERlbm8uYnVpbGQuYXJjaCksXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdkZW5vJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBEZW5vLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICB9O1xuICB9XG4gIC8vIENoZWNrIGlmIE5vZGUuanNcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKHByb2Nlc3MucGxhdGZvcm0pLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKHByb2Nlc3MuYXJjaCksXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGJyb3dzZXJJbmZvID0gZ2V0QnJvd3NlckluZm8oKTtcbiAgaWYgKGJyb3dzZXJJbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiAndW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6IGBicm93c2VyOiR7YnJvd3NlckluZm8uYnJvd3Nlcn1gLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IGJyb3dzZXJJbmZvLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE8gYWRkIHN1cHBvcnQgZm9yIENsb3VkZmxhcmUgd29ya2VycywgZXRjLlxuICByZXR1cm4ge1xuICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiAndW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAndW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6ICd1bmtub3duJyxcbiAgfTtcbn07XG5cbnR5cGUgQnJvd3NlckluZm8gPSB7XG4gIGJyb3dzZXI6IEJyb3dzZXI7XG4gIHZlcnNpb246IHN0cmluZztcbn07XG5cbmRlY2xhcmUgY29uc3QgbmF2aWdhdG9yOiB7IHVzZXJBZ2VudDogc3RyaW5nIH0gfCB1bmRlZmluZWQ7XG5cbi8vIE5vdGU6IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0pTLURldlRvb2xzL2hvc3QtZW52aXJvbm1lbnQvYmxvYi9iMWFiNzllY2RlMzdkYjVkNmUxNjNjMDUwZTU0ZmU3ZDI4N2Q3YzkyL3NyYy9pc29tb3JwaGljLmJyb3dzZXIudHNcbmZ1bmN0aW9uIGdldEJyb3dzZXJJbmZvKCk6IEJyb3dzZXJJbmZvIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOT1RFOiBUaGUgb3JkZXIgbWF0dGVycyBoZXJlIVxuICBjb25zdCBicm93c2VyUGF0dGVybnMgPSBbXG4gICAgeyBrZXk6ICdlZGdlJyBhcyBjb25zdCwgcGF0dGVybjogL0VkZ2UoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2llJyBhcyBjb25zdCwgcGF0dGVybjogL01TSUUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2llJyBhcyBjb25zdCwgcGF0dGVybjogL1RyaWRlbnQoPzouKnJ2XFw6KFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2Nocm9tZScgYXMgY29uc3QsIHBhdHRlcm46IC9DaHJvbWUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2ZpcmVmb3gnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvRmlyZWZveCg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnc2FmYXJpJyBhcyBjb25zdCwgcGF0dGVybjogLyg/OlZlcnNpb25cXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPyg/OlxcVytNb2JpbGVcXFMqKT9cXFcrU2FmYXJpLyB9LFxuICBdO1xuXG4gIC8vIEZpbmQgdGhlIEZJUlNUIG1hdGNoaW5nIGJyb3dzZXJcbiAgZm9yIChjb25zdCB7IGtleSwgcGF0dGVybiB9IG9mIGJyb3dzZXJQYXR0ZXJucykge1xuICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbWFqb3IgPSBtYXRjaFsxXSB8fCAwO1xuICAgICAgY29uc3QgbWlub3IgPSBtYXRjaFsyXSB8fCAwO1xuICAgICAgY29uc3QgcGF0Y2ggPSBtYXRjaFszXSB8fCAwO1xuXG4gICAgICByZXR1cm4geyBicm93c2VyOiBrZXksIHZlcnNpb246IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3Qgbm9ybWFsaXplQXJjaCA9IChhcmNoOiBzdHJpbmcpOiBBcmNoID0+IHtcbiAgLy8gTm9kZSBkb2NzOlxuICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NhcmNoXG4gIC8vIERlbm8gZG9jczpcbiAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gIGlmIChhcmNoID09PSAneDMyJykgcmV0dXJuICd4MzInO1xuICBpZiAoYXJjaCA9PT0gJ3g4Nl82NCcgfHwgYXJjaCA9PT0gJ3g2NCcpIHJldHVybiAneDY0JztcbiAgaWYgKGFyY2ggPT09ICdhcm0nKSByZXR1cm4gJ2FybSc7XG4gIGlmIChhcmNoID09PSAnYWFyY2g2NCcgfHwgYXJjaCA9PT0gJ2FybTY0JykgcmV0dXJuICdhcm02NCc7XG4gIGlmIChhcmNoKSByZXR1cm4gYG90aGVyOiR7YXJjaH1gO1xuICByZXR1cm4gJ3Vua25vd24nO1xufTtcblxuY29uc3Qgbm9ybWFsaXplUGxhdGZvcm0gPSAocGxhdGZvcm06IHN0cmluZyk6IFBsYXRmb3JtTmFtZSA9PiB7XG4gIC8vIE5vZGUgcGxhdGZvcm1zOlxuICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NwbGF0Zm9ybVxuICAvLyBEZW5vIHBsYXRmb3JtczpcbiAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzE0Nzk5XG5cbiAgcGxhdGZvcm0gPSBwbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIE5PVEU6IHRoaXMgaU9TIGNoZWNrIGlzIHVudGVzdGVkIGFuZCBtYXkgbm90IHdvcmtcbiAgLy8gTm9kZSBkb2VzIG5vdCB3b3JrIG5hdGl2ZWx5IG9uIElPUywgdGhlcmUgaXMgYSBmb3JrIGF0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMtbW9iaWxlL25vZGVqcy1tb2JpbGVcbiAgLy8gaG93ZXZlciBpdCBpcyB1bmtub3duIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaG93IHRvIGRldGVjdCBpZiBpdCBpcyBydW5uaW5nXG4gIGlmIChwbGF0Zm9ybS5pbmNsdWRlcygnaW9zJykpIHJldHVybiAnaU9TJztcbiAgaWYgKHBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHJldHVybiAnQW5kcm9pZCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHJldHVybiAnTWFjT1MnO1xuICBpZiAocGxhdGZvcm0gPT09ICd3aW4zMicpIHJldHVybiAnV2luZG93cyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKSByZXR1cm4gJ0ZyZWVCU0QnO1xuICBpZiAocGxhdGZvcm0gPT09ICdvcGVuYnNkJykgcmV0dXJuICdPcGVuQlNEJztcbiAgaWYgKHBsYXRmb3JtID09PSAnbGludXgnKSByZXR1cm4gJ0xpbnV4JztcbiAgaWYgKHBsYXRmb3JtKSByZXR1cm4gYE90aGVyOiR7cGxhdGZvcm19YDtcbiAgcmV0dXJuICdVbmtub3duJztcbn07XG5cbmxldCBfcGxhdGZvcm1IZWFkZXJzOiBQbGF0Zm9ybVByb3BlcnRpZXM7XG5jb25zdCBnZXRQbGF0Zm9ybUhlYWRlcnMgPSAoKSA9PiB7XG4gIHJldHVybiAoX3BsYXRmb3JtSGVhZGVycyA/Pz0gZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNhZmVKU09OID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk3MDk4NDZcbmNvbnN0IHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAgPSBuZXcgUmVnRXhwKCdeKD86W2Etel0rOik/Ly8nLCAnaScpO1xuY29uc3QgaXNBYnNvbHV0ZVVSTCA9ICh1cmw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gc3RhcnRzV2l0aFNjaGVtZVJlZ2V4cC50ZXN0KHVybCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuY29uc3QgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIgPSAobmFtZTogc3RyaW5nLCBuOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgfVxuICBpZiAobiA8IDApIHtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXN0VG9FcnJvciA9IChlcnI6IGFueSk6IEVycm9yID0+IHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICByZXR1cm4gbmV3IEVycm9yKGVycik7XG59O1xuXG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9IDxUPih2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBUID0+IHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBPcGVuQUlFcnJvcihgRXhwZWN0ZWQgYSB2YWx1ZSB0byBiZSBnaXZlbiBidXQgcmVjZWl2ZWQgJHt2YWx1ZX0gaW5zdGVhZC5gKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgZG9lc24ndCBleGlzdCBvciBjYW5ub3QgYmUgYWNjZXNzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRW52ID0gKGVudjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudj8uW2Vudl0gPz8gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gRGVuby5lbnY/LmdldD8uKGVudik7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQ291bGQgbm90IGNvZXJjZSAke3ZhbHVlfSAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSBpbnRvIGEgbnVtYmVyYCk7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlRmxvYXQgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQ291bGQgbm90IGNvZXJjZSAke3ZhbHVlfSAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSBpbnRvIGEgbnVtYmVyYCk7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlQm9vbGVhbiA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnO1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VJbnRlZ2VyKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUZsb2F0ID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VGbG9hdCh2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VCb29sZWFuID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlQm9vbGVhbih2YWx1ZSk7XG59O1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODdcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iajogT2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICBpZiAoIW9iaikgcmV0dXJuIHRydWU7XG4gIGZvciAoY29uc3QgX2sgaW4gb2JqKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwczovL2VzbGludC5vcmcvZG9jcy9sYXRlc3QvcnVsZXMvbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iajogT2JqZWN0LCBrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKGFjdGlvbjogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydERUJVRyddID09PSAndHJ1ZScpIHtcbiAgICBjb25zb2xlLmxvZyhgT3BlbkFJOkRFQlVHOiR7YWN0aW9ufWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqL1xuY29uc3QgdXVpZDQgPSAoKSA9PiB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMDtcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUnVubmluZ0luQnJvd3NlciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGVyc1Byb3RvY29sIHtcbiAgZ2V0OiAoaGVhZGVyOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5leHBvcnQgdHlwZSBIZWFkZXJzTGlrZSA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPiB8IEhlYWRlcnNQcm90b2NvbDtcblxuZXhwb3J0IGNvbnN0IGlzSGVhZGVyc1Byb3RvY29sID0gKGhlYWRlcnM6IGFueSk6IGhlYWRlcnMgaXMgSGVhZGVyc1Byb3RvY29sID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBoZWFkZXJzPy5nZXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SGVhZGVyID0gKGhlYWRlcnM6IEhlYWRlcnNMaWtlLCBrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoaXNIZWFkZXJzUHJvdG9jb2woaGVhZGVycykpIHJldHVybiBoZWFkZXJzLmdldChrZXkpIHx8IGhlYWRlcnMuZ2V0KGxvd2VyS2V5KTtcbiAgY29uc3QgdmFsdWUgPSBoZWFkZXJzW2tleV0gfHwgaGVhZGVyc1tsb3dlcktleV07XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMSkgcmV0dXJuIHZhbHVlWzBdO1xuICAgIGNvbnNvbGUud2FybihgUmVjZWl2ZWQgJHt2YWx1ZS5sZW5ndGh9IGVudHJpZXMgZm9yIHRoZSAke2tleX0gaGVhZGVyLCB1c2luZyB0aGUgZmlyc3QgZW50cnkuYCk7XG4gICAgcmV0dXJuIHZhbHVlWzBdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB0byBCYXNlNjQgZm9ybWF0LlxuICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjQgPSAoc3RyOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nID0+IHtcbiAgaWYgKCFzdHIpIHJldHVybiAnJztcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBidG9hKHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSBiNjQgc3RyaW5nOyBFeHBlY3RlZCBgQnVmZmVyYCBvciBgYnRvYWAgdG8gYmUgZGVmaW5lZCcpO1xufTtcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBBYnN0cmFjdFBhZ2UsIFJlc3BvbnNlLCBBUElDbGllbnQsIEZpbmFsUmVxdWVzdE9wdGlvbnMsIFBhZ2VJbmZvIH0gZnJvbSAnLi9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdlUmVzcG9uc2U8SXRlbT4ge1xuICBkYXRhOiBBcnJheTxJdGVtPjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3RlOiBubyBwYWdpbmF0aW9uIGFjdHVhbGx5IG9jY3VycyB5ZXQsIHRoaXMgaXMgZm9yIGZvcndhcmRzLWNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlPEl0ZW0+IGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogUGFnZVJlc3BvbnNlPEl0ZW0+LCBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKSB7XG4gICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9iamVjdCA9IGJvZHkub2JqZWN0O1xuICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YTtcbiAgfVxuXG4gIGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIC8qKlxuICAgKiBUaGlzIHBhZ2UgcmVwcmVzZW50cyBhIHJlc3BvbnNlIHRoYXQgaXNuJ3QgYWN0dWFsbHkgcGFnaW5hdGVkIGF0IHRoZSBBUEkgbGV2ZWxcbiAgICogc28gdGhlcmUgd2lsbCBuZXZlciBiZSBhbnkgbmV4dCBwYWdlIHBhcmFtcy5cbiAgICovXG4gIG5leHRQYWdlUGFyYW1zKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbmV4dFBhZ2VJbmZvKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3Vyc29yUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgZGF0YTogQXJyYXk8SXRlbT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgbGFzdCBqb2IgZnJvbSB0aGUgcHJldmlvdXMgcGFnaW5hdGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgYWZ0ZXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBmaW5lLXR1bmluZyBqb2JzIHRvIHJldHJpZXZlLlxuICAgKi9cbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDdXJzb3JQYWdlPEl0ZW0gZXh0ZW5kcyB7IGlkOiBzdHJpbmcgfT5cbiAgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT5cbiAgaW1wbGVtZW50cyBDdXJzb3JQYWdlUmVzcG9uc2U8SXRlbT5cbntcbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2xpZW50OiBBUElDbGllbnQsXG4gICAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICAgIGJvZHk6IEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPixcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihjbGllbnQsIHJlc3BvbnNlLCBib2R5LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YTtcbiAgfVxuXG4gIGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIG5leHRQYWdlUGFyYW1zKCk6IFBhcnRpYWw8Q3Vyc29yUGFnZVBhcmFtcz4gfCBudWxsIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5uZXh0UGFnZUluZm8oKTtcbiAgICBpZiAoIWluZm8pIHJldHVybiBudWxsO1xuICAgIGlmICgncGFyYW1zJyBpbiBpbmZvKSByZXR1cm4gaW5mby5wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKGluZm8udXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIG5leHRQYWdlSW5mbygpOiBQYWdlSW5mbyB8IG51bGwge1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdPy5pZDtcbiAgICBpZiAoIW5leHQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7IHBhcmFtczogeyBhZnRlcjogbmV4dCB9IH07XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgdHlwZSB7IE9wZW5BSSB9IGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgQVBJUmVzb3VyY2Uge1xuICBwcm90ZWN0ZWQgY2xpZW50OiBPcGVuQUk7XG4gIGNvbnN0cnVjdG9yKGNsaWVudDogT3BlbkFJKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG5cbiAgICB0aGlzLmdldCA9IGNsaWVudC5nZXQuYmluZChjbGllbnQpO1xuICAgIHRoaXMucG9zdCA9IGNsaWVudC5wb3N0LmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLnBhdGNoID0gY2xpZW50LnBhdGNoLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLnB1dCA9IGNsaWVudC5wdXQuYmluZChjbGllbnQpO1xuICAgIHRoaXMuZGVsZXRlID0gY2xpZW50LmRlbGV0ZS5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5nZXRBUElMaXN0ID0gY2xpZW50LmdldEFQSUxpc3QuYmluZChjbGllbnQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldDogT3BlbkFJWydnZXQnXTtcbiAgcHJvdGVjdGVkIHBvc3Q6IE9wZW5BSVsncG9zdCddO1xuICBwcm90ZWN0ZWQgcGF0Y2g6IE9wZW5BSVsncGF0Y2gnXTtcbiAgcHJvdGVjdGVkIHB1dDogT3BlbkFJWydwdXQnXTtcbiAgcHJvdGVjdGVkIGRlbGV0ZTogT3BlbkFJWydkZWxldGUnXTtcbiAgcHJvdGVjdGVkIGdldEFQSUxpc3Q6IE9wZW5BSVsnZ2V0QVBJTGlzdCddO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyB0eXBlIFVwbG9hZGFibGUsIG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi9jb3JlXCI7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zY3JpYmVzIGF1ZGlvIGludG8gdGhlIGlucHV0IGxhbmd1YWdlLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb24ge1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRvIHRyYW5zY3JpYmUsIGluIG9uZSBvZiB0aGVzZSBmb3JtYXRzOlxuICAgKiBmbGFjLCBtcDMsIG1wNCwgbXBlZywgbXBnYSwgbTRhLCBvZ2csIHdhdiwgb3Igd2VibS5cbiAgICovXG4gIGZpbGU6IFVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIE9ubHkgYHdoaXNwZXItMWAgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3doaXNwZXItMSc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgaW5wdXQgYXVkaW8uIFN1cHBseWluZyB0aGUgaW5wdXQgbGFuZ3VhZ2UgaW5cbiAgICogW0lTTy02MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpIGZvcm1hdCB3aWxsXG4gICAqIGltcHJvdmUgYWNjdXJhY3kgYW5kIGxhdGVuY3kuXG4gICAqL1xuICBsYW5ndWFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgdGV4dCB0byBndWlkZSB0aGUgbW9kZWwncyBzdHlsZSBvciBjb250aW51ZSBhIHByZXZpb3VzIGF1ZGlvXG4gICAqIHNlZ21lbnQuIFRoZVxuICAgKiBbcHJvbXB0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3BlZWNoLXRvLXRleHQvcHJvbXB0aW5nKVxuICAgKiBzaG91bGQgbWF0Y2ggdGhlIGF1ZGlvIGxhbmd1YWdlLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSB0cmFuc2NyaXB0IG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGpzb24sIHRleHQsIHNydCxcbiAgICogdmVyYm9zZV9qc29uLCBvciB2dHQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAnanNvbicgfCAndGV4dCcgfCAnc3J0JyB8ICd2ZXJib3NlX2pzb24nIHwgJ3Z0dCc7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhbnNjcmlwdGlvbnMge1xuICBleHBvcnQgaW1wb3J0IFRyYW5zY3JpcHRpb24gPSBBUEkuVHJhbnNjcmlwdGlvbjtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLlRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IHR5cGUgVXBsb2FkYWJsZSwgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcblxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgYXVkaW8gaW50byBFbmdsaXNoLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9hdWRpby90cmFuc2xhdGlvbnMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uIHtcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBmaWxlIG9iamVjdCAobm90IGZpbGUgbmFtZSkgdHJhbnNsYXRlLCBpbiBvbmUgb2YgdGhlc2UgZm9ybWF0czogZmxhYyxcbiAgICogbXAzLCBtcDQsIG1wZWcsIG1wZ2EsIG00YSwgb2dnLCB3YXYsIG9yIHdlYm0uXG4gICAqL1xuICBmaWxlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBPbmx5IGB3aGlzcGVyLTFgIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8ICd3aGlzcGVyLTEnO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCB0ZXh0IHRvIGd1aWRlIHRoZSBtb2RlbCdzIHN0eWxlIG9yIGNvbnRpbnVlIGEgcHJldmlvdXMgYXVkaW9cbiAgICogc2VnbWVudC4gVGhlXG4gICAqIFtwcm9tcHRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zcGVlY2gtdG8tdGV4dC9wcm9tcHRpbmcpXG4gICAqIHNob3VsZCBiZSBpbiBFbmdsaXNoLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSB0cmFuc2NyaXB0IG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGpzb24sIHRleHQsIHNydCxcbiAgICogdmVyYm9zZV9qc29uLCBvciB2dHQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhbnNsYXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbiA9IEFQSS5UcmFuc2xhdGlvbjtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5UcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZVwiO1xuaW1wb3J0IHsgVHJhbnNjcmlwdGlvbnMgfSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcbmltcG9ydCB7IFRyYW5zbGF0aW9ucyB9IGZyb20gJy4vdHJhbnNsYXRpb25zJztcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICB0cmFuc2NyaXB0aW9uczogVHJhbnNjcmlwdGlvbnMgPSBuZXcgVHJhbnNjcmlwdGlvbnModGhpcy5jbGllbnQpO1xuICB0cmFuc2xhdGlvbnM6IFRyYW5zbGF0aW9ucyA9IG5ldyBUcmFuc2xhdGlvbnModGhpcy5jbGllbnQpO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEF1ZGlvIHtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2NyaXB0aW9ucyA9IEFQSS5UcmFuc2NyaXB0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2NyaXB0aW9uID0gQVBJLlRyYW5zY3JpcHRpb247XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5UcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zO1xuXG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNsYXRpb25zID0gQVBJLlRyYW5zbGF0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbiA9IEFQSS5UcmFuc2xhdGlvbjtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5UcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi8uLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc18gZnJvbSBcIi4uL2NvbXBsZXRpb25zXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi4vLi4vc3RyZWFtaW5nXCI7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtb2RlbCByZXNwb25zZSBmb3IgdGhlIGdpdmVuIGNoYXQgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+IHwgQ2hhdENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+IHwgQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvY2hhdC9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPlxuICAgICAgfCBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBjb21wbGV0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMuIENhbiBiZSBtb3JlIHRoYW4gb25lIGlmIGBuYCBpcyBncmVhdGVyXG4gICAqIHRoYW4gMS5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uLkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBjaGF0LmNvbXBsZXRpb25gLlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25zXy5Db21wbGV0aW9uVXNhZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgb3IgYGZ1bmN0aW9uX2NhbGxgXG4gICAgICogaWYgdGhlIG1vZGVsIGNhbGxlZCBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2hvaWNlIGluIHRoZSBsaXN0IG9mIGNob2ljZXMuXG4gICAgICovXG4gICAgaW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RyZWFtZWQgY2h1bmsgb2YgYSBjaGF0IGNvbXBsZXRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uIGNodW5rLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gYmUgbW9yZSB0aGFuIG9uZSBpZiBgbmAgaXMgZ3JlYXRlclxuICAgKiB0aGFuIDEuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbkNodW5rLkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIGNodW5rIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgY2hhdC5jb21wbGV0aW9uLmNodW5rYC5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBkZWx0YTogQ2hvaWNlLkRlbHRhO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgb3IgYGZ1bmN0aW9uX2NhbGxgXG4gICAgICogaWYgdGhlIG1vZGVsIGNhbGxlZCBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgJ2NvbnRlbnRfZmlsdGVyJyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIERlbHRhIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBjaHVuayBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAgICAgKiBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb25fY2FsbD86IERlbHRhLkZ1bmN0aW9uQ2FsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgcm9sZT86IENoYXRDb21wbGV0aW9uUm9sZTtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIERlbHRhIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSBjaGF0IGNvbXBsZXRpb24gbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIHJvbGU6IENoYXRDb21wbGV0aW9uUm9sZTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgKiBtb2RlbC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLiBgY29udGVudGAgaXMgcmVxdWlyZWQgZm9yIGFsbCBtZXNzYWdlcywgYW5kIG1heSBiZVxuICAgKiBudWxsIGZvciBhc3Npc3RhbnQgbWVzc2FnZXMgd2l0aCBmdW5jdGlvbiBjYWxscy5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IuIE9uZSBvZiBgc3lzdGVtYCwgYHVzZXJgLCBgYXNzaXN0YW50YCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHJvbGU6ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAnZnVuY3Rpb24nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLkZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuIGBuYW1lYCBpcyByZXF1aXJlZCBpZiByb2xlIGlzXG4gICAqIGBmdW5jdGlvbmAsIGFuZCBpdCBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHdob3NlIHJlc3BvbnNlIGlzIGluIHRoZVxuICAgKiBgY29udGVudGAuIE1heSBjb250YWluIGEteiwgQS1aLCAwLTksIGFuZCB1bmRlcnNjb3Jlcywgd2l0aCBhIG1heGltdW0gbGVuZ3RoIG9mXG4gICAqIDY0IGNoYXJhY3RlcnMuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGVcbiAgICogbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlID0gJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICdmdW5jdGlvbic7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlID0gQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW07XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID1cbiAgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZ1xuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgbWVzc2FnZXMgY29tcHJpc2luZyB0aGUgY29udmVyc2F0aW9uIHNvIGZhci5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLWNvb2tib29rL2Jsb2IvbWFpbi9leGFtcGxlcy9Ib3dfdG9fZm9ybWF0X2lucHV0c190b19DaGF0R1BUX21vZGVscy5pcHluYikuXG4gICAqL1xuICBtZXNzYWdlczogQXJyYXk8Q2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBTZWUgdGhlXG4gICAqIFttb2RlbCBlbmRwb2ludCBjb21wYXRpYmlsaXR5XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvbW9kZWwtZW5kcG9pbnQtY29tcGF0aWJpbGl0eSlcbiAgICogdGFibGUgZm9yIGRldGFpbHMgb24gd2hpY2ggbW9kZWxzIHdvcmsgd2l0aCB0aGUgQ2hhdCBBUEkuXG4gICAqL1xuICBtb2RlbDpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMzAxJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJztcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvbiB0aGVpclxuICAgKiBleGlzdGluZyBmcmVxdWVuY3kgaW4gdGhlIHRleHQgc28gZmFyLCBkZWNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogcmVwZWF0IHRoZSBzYW1lIGxpbmUgdmVyYmF0aW0uXG4gICAqXG4gICAqIFtTZWUgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBmcmVxdWVuY3kgYW5kIHByZXNlbmNlIHBlbmFsdGllcy5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9ncHQvcGFyYW1ldGVyLWRldGFpbHMpXG4gICAqL1xuICBmcmVxdWVuY3lfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgbW9kZWwgcmVzcG9uZHMgdG8gZnVuY3Rpb24gY2FsbHMuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgZG9lc1xuICAgKiBub3QgY2FsbCBhIGZ1bmN0aW9uLCBhbmQgcmVzcG9uZHMgdG8gdGhlIGVuZC11c2VyLiBgYXV0b2AgbWVhbnMgdGhlIG1vZGVsIGNhblxuICAgKiBwaWNrIGJldHdlZW4gYW4gZW5kLXVzZXIgb3IgY2FsbGluZyBhIGZ1bmN0aW9uLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciBmdW5jdGlvblxuICAgKiB2aWEgYHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifWAgZm9yY2VzIHRoZSBtb2RlbCB0byBjYWxsIHRoYXQgZnVuY3Rpb24uIGBub25lYCBpc1xuICAgKiB0aGUgZGVmYXVsdCB3aGVuIG5vIGZ1bmN0aW9ucyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmIGZ1bmN0aW9uc1xuICAgKiBhcmUgcHJlc2VudC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiAnbm9uZScgfCAnYXV0bycgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbkNhbGxPcHRpb247XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBmdW5jdGlvbnMgdGhlIG1vZGVsIG1heSBnZW5lcmF0ZSBKU09OIGlucHV0cyBmb3IuXG4gICAqL1xuICBmdW5jdGlvbnM/OiBBcnJheTxDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbj47XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgbGlrZWxpaG9vZCBvZiBzcGVjaWZpZWQgdG9rZW5zIGFwcGVhcmluZyBpbiB0aGUgY29tcGxldGlvbi5cbiAgICpcbiAgICogQWNjZXB0cyBhIGpzb24gb2JqZWN0IHRoYXQgbWFwcyB0b2tlbnMgKHNwZWNpZmllZCBieSB0aGVpciB0b2tlbiBJRCBpbiB0aGVcbiAgICogdG9rZW5pemVyKSB0byBhbiBhc3NvY2lhdGVkIGJpYXMgdmFsdWUgZnJvbSAtMTAwIHRvIDEwMC4gTWF0aGVtYXRpY2FsbHksIHRoZVxuICAgKiBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0byBzYW1wbGluZy4gVGhlIGV4YWN0XG4gICAqIGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLCBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDEgc2hvdWxkIGRlY3JlYXNlIG9yXG4gICAqIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uOyB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMCBzaG91bGQgcmVzdWx0IGluIGEgYmFuXG4gICAqIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlIHJlbGV2YW50IHRva2VuLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgW3Rva2Vuc10oL3Rva2VuaXplcikgdG8gZ2VuZXJhdGUgaW4gdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICpcbiAgICogVGhlIHRvdGFsIGxlbmd0aCBvZiBpbnB1dCB0b2tlbnMgYW5kIGdlbmVyYXRlZCB0b2tlbnMgaXMgbGltaXRlZCBieSB0aGUgbW9kZWwnc1xuICAgKiBjb250ZXh0IGxlbmd0aC5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLWNvb2tib29rL2Jsb2IvbWFpbi9leGFtcGxlcy9Ib3dfdG9fY291bnRfdG9rZW5zX3dpdGhfdGlrdG9rZW4uaXB5bmIpXG4gICAqIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAqL1xuICBtYXhfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSG93IG1hbnkgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggaW5wdXQgbWVzc2FnZS5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uXG4gICAqIHdoZXRoZXIgdGhleSBhcHBlYXIgaW4gdGhlIHRleHQgc28gZmFyLCBpbmNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogdGFsayBhYm91dCBuZXcgdG9waWNzLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZ3B0L3BhcmFtZXRlci1kZXRhaWxzKVxuICAgKi9cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzL2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGxPcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuIE11c3QgYmUgYS16LCBBLVosIDAtOSwgb3IgY29udGFpblxuICAgICAqIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMsIHdpdGggYSBtYXhpbXVtIGxlbmd0aCBvZiA2NC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb25zIGFjY2VwdHMsIGRlc2NyaWJlZCBhcyBhIEpTT04gU2NoZW1hIG9iamVjdC4gU2VlIHRoZVxuICAgICAqIFtndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2dwdC9mdW5jdGlvbi1jYWxsaW5nKSBmb3JcbiAgICAgKiBleGFtcGxlcywgYW5kIHRoZVxuICAgICAqIFtKU09OIFNjaGVtYSByZWZlcmVuY2VdKGh0dHBzOi8vanNvbi1zY2hlbWEub3JnL3VuZGVyc3RhbmRpbmctanNvbi1zY2hlbWEvKSBmb3JcbiAgICAgKiBkb2N1bWVudGF0aW9uIGFib3V0IHRoZSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBUbyBkZXNjcmliZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBubyBwYXJhbWV0ZXJzLCBwcm92aWRlIHRoZSB2YWx1ZVxuICAgICAqIGB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwicHJvcGVydGllc1wiOiB7fX1gLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmRcbiAgICAgKiBob3cgdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IEFQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbiA9IEFQSS5DaGF0Q29tcGxldGlvbjtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbkNodW5rID0gQVBJLkNoYXRDb21wbGV0aW9uQ2h1bms7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25NZXNzYWdlID0gQVBJLkNoYXRDb21wbGV0aW9uTWVzc2FnZTtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSA9IEFQSS5DaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbTtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvblJvbGUgPSBBUEkuQ2hhdENvbXBsZXRpb25Sb2xlO1xuICBleHBvcnQgaW1wb3J0IENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UgPSBBUEkuQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZTtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZVwiO1xuaW1wb3J0IHsgQ29tcGxldGlvbnMgfSBmcm9tICcuL2NvbXBsZXRpb25zJztcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIENoYXQgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGNvbXBsZXRpb25zOiBDb21wbGV0aW9ucyA9IG5ldyBDb21wbGV0aW9ucyh0aGlzLmNsaWVudCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdCB7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBBUEkuQ29tcGxldGlvbnM7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb24gPSBBUEkuQ2hhdENvbXBsZXRpb247XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25DaHVuayA9IEFQSS5DaGF0Q29tcGxldGlvbkNodW5rO1xuICBleHBvcnQgaW1wb3J0IENoYXRDb21wbGV0aW9uTWVzc2FnZSA9IEFQSS5DaGF0Q29tcGxldGlvbk1lc3NhZ2U7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gPSBBUEkuQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW07XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25Sb2xlID0gQVBJLkNoYXRDb21wbGV0aW9uUm9sZTtcbiAgZXhwb3J0IGltcG9ydCBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlID0gQVBJLkNyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2U7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IEFQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSBcIi4uL3N0cmVhbWluZ1wiO1xuXG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcGxldGlvbiBmb3IgdGhlIHByb3ZpZGVkIHByb21wdCBhbmQgcGFyYW1ldGVycy5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IEFQSVByb21pc2U8Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4gfCBDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q29tcGxldGlvbj4gfCBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENvbXBsZXRpb24+XG4gICAgICB8IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+PjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wbGV0aW9uIHJlc3BvbnNlIGZyb20gdGhlIEFQSS4gTm90ZTogYm90aCB0aGUgc3RyZWFtZWQgYW5kXG4gKiBub24tc3RyZWFtZWQgcmVzcG9uc2Ugb2JqZWN0cyBzaGFyZSB0aGUgc2FtZSBzaGFwZSAodW5saWtlIHRoZSBjaGF0IGVuZHBvaW50KS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY29tcGxldGlvbiBjaG9pY2VzIHRoZSBtb2RlbCBnZW5lcmF0ZWQgZm9yIHRoZSBpbnB1dCBwcm9tcHQuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDb21wbGV0aW9uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwidGV4dF9jb21wbGV0aW9uXCJcbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U/OiBDb21wbGV0aW9uVXNhZ2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgb3IgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLlxuICAgKi9cbiAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCcgfCAnY29udGVudF9maWx0ZXInO1xuXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgbG9ncHJvYnM6IENvbXBsZXRpb25DaG9pY2UuTG9ncHJvYnMgfCBudWxsO1xuXG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb21wbGV0aW9uQ2hvaWNlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgdGV4dF9vZmZzZXQ/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgdG9rZW5fbG9ncHJvYnM/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgdG9rZW5zPzogQXJyYXk8c3RyaW5nPjtcblxuICAgIHRvcF9sb2dwcm9icz86IEFycmF5PFJlY29yZDxzdHJpbmcsIG51bWJlcj4+O1xuICB9XG59XG5cbi8qKlxuICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uVXNhZ2Uge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2VuZXJhdGVkIGNvbXBsZXRpb24uXG4gICAqL1xuICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcmVxdWVzdCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAqL1xuICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9vdmVydmlldykgZm9yXG4gICAqIGRlc2NyaXB0aW9ucyBvZiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnYmFiYmFnZS0wMDInXG4gICAgfCAnZGF2aW5jaS0wMDInXG4gICAgfCAnZ3B0LTMuNS10dXJiby1pbnN0cnVjdCdcbiAgICB8ICd0ZXh0LWRhdmluY2ktMDAzJ1xuICAgIHwgJ3RleHQtZGF2aW5jaS0wMDInXG4gICAgfCAndGV4dC1kYXZpbmNpLTAwMSdcbiAgICB8ICdjb2RlLWRhdmluY2ktMDAyJ1xuICAgIHwgJ3RleHQtY3VyaWUtMDAxJ1xuICAgIHwgJ3RleHQtYmFiYmFnZS0wMDEnXG4gICAgfCAndGV4dC1hZGEtMDAxJztcblxuICAvKipcbiAgICogVGhlIHByb21wdChzKSB0byBnZW5lcmF0ZSBjb21wbGV0aW9ucyBmb3IsIGVuY29kZWQgYXMgYSBzdHJpbmcsIGFycmF5IG9mXG4gICAqIHN0cmluZ3MsIGFycmF5IG9mIHRva2Vucywgb3IgYXJyYXkgb2YgdG9rZW4gYXJyYXlzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgPHxlbmRvZnRleHR8PiBpcyB0aGUgZG9jdW1lbnQgc2VwYXJhdG9yIHRoYXQgdGhlIG1vZGVsIHNlZXMgZHVyaW5nXG4gICAqIHRyYWluaW5nLCBzbyBpZiBhIHByb21wdCBpcyBub3Qgc3BlY2lmaWVkIHRoZSBtb2RlbCB3aWxsIGdlbmVyYXRlIGFzIGlmIGZyb20gdGhlXG4gICAqIGJlZ2lubmluZyBvZiBhIG5ldyBkb2N1bWVudC5cbiAgICovXG4gIHByb21wdDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IEFycmF5PG51bWJlcj4gfCBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBgYmVzdF9vZmAgY29tcGxldGlvbnMgc2VydmVyLXNpZGUgYW5kIHJldHVybnMgdGhlIFwiYmVzdFwiICh0aGUgb25lIHdpdGhcbiAgICogdGhlIGhpZ2hlc3QgbG9nIHByb2JhYmlsaXR5IHBlciB0b2tlbikuIFJlc3VsdHMgY2Fubm90IGJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBXaGVuIHVzZWQgd2l0aCBgbmAsIGBiZXN0X29mYCBjb250cm9scyB0aGUgbnVtYmVyIG9mIGNhbmRpZGF0ZSBjb21wbGV0aW9ucyBhbmRcbiAgICogYG5gIHNwZWNpZmllcyBob3cgbWFueSB0byByZXR1cm4gXHUyMDEzIGBiZXN0X29mYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgbmAuXG4gICAqXG4gICAqICoqTm90ZToqKiBCZWNhdXNlIHRoaXMgcGFyYW1ldGVyIGdlbmVyYXRlcyBtYW55IGNvbXBsZXRpb25zLCBpdCBjYW4gcXVpY2tseVxuICAgKiBjb25zdW1lIHlvdXIgdG9rZW4gcXVvdGEuIFVzZSBjYXJlZnVsbHkgYW5kIGVuc3VyZSB0aGF0IHlvdSBoYXZlIHJlYXNvbmFibGVcbiAgICogc2V0dGluZ3MgZm9yIGBtYXhfdG9rZW5zYCBhbmQgYHN0b3BgLlxuICAgKi9cbiAgYmVzdF9vZj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVjaG8gYmFjayB0aGUgcHJvbXB0IGluIGFkZGl0aW9uIHRvIHRoZSBjb21wbGV0aW9uXG4gICAqL1xuICBlY2hvPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb24gdGhlaXJcbiAgICogZXhpc3RpbmcgZnJlcXVlbmN5IGluIHRoZSB0ZXh0IHNvIGZhciwgZGVjcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHJlcGVhdCB0aGUgc2FtZSBsaW5lIHZlcmJhdGltLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZ3B0L3BhcmFtZXRlci1kZXRhaWxzKVxuICAgKi9cbiAgZnJlcXVlbmN5X3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpa2VsaWhvb2Qgb2Ygc3BlY2lmaWVkIHRva2VucyBhcHBlYXJpbmcgaW4gdGhlIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIEFjY2VwdHMgYSBqc29uIG9iamVjdCB0aGF0IG1hcHMgdG9rZW5zIChzcGVjaWZpZWQgYnkgdGhlaXIgdG9rZW4gSUQgaW4gdGhlIEdQVFxuICAgKiB0b2tlbml6ZXIpIHRvIGFuIGFzc29jaWF0ZWQgYmlhcyB2YWx1ZSBmcm9tIC0xMDAgdG8gMTAwLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAqIFt0b2tlbml6ZXIgdG9vbF0oL3Rva2VuaXplcj92aWV3PWJwZSkgKHdoaWNoIHdvcmtzIGZvciBib3RoIEdQVC0yIGFuZCBHUFQtMykgdG9cbiAgICogY29udmVydCB0ZXh0IHRvIHRva2VuIElEcy4gTWF0aGVtYXRpY2FsbHksIHRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHNcbiAgICogZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0byBzYW1wbGluZy4gVGhlIGV4YWN0IGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLFxuICAgKiBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDEgc2hvdWxkIGRlY3JlYXNlIG9yIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uO1xuICAgKiB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMCBzaG91bGQgcmVzdWx0IGluIGEgYmFuIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlXG4gICAqIHJlbGV2YW50IHRva2VuLlxuICAgKlxuICAgKiBBcyBhbiBleGFtcGxlLCB5b3UgY2FuIHBhc3MgYHtcIjUwMjU2XCI6IC0xMDB9YCB0byBwcmV2ZW50IHRoZSA8fGVuZG9mdGV4dHw+IHRva2VuXG4gICAqIGZyb20gYmVpbmcgZ2VuZXJhdGVkLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHRoZSBsb2cgcHJvYmFiaWxpdGllcyBvbiB0aGUgYGxvZ3Byb2JzYCBtb3N0IGxpa2VseSB0b2tlbnMsIGFzIHdlbGwgdGhlXG4gICAqIGNob3NlbiB0b2tlbnMuIEZvciBleGFtcGxlLCBpZiBgbG9ncHJvYnNgIGlzIDUsIHRoZSBBUEkgd2lsbCByZXR1cm4gYSBsaXN0IG9mXG4gICAqIHRoZSA1IG1vc3QgbGlrZWx5IHRva2Vucy4gVGhlIEFQSSB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIGBsb2dwcm9iYCBvZiB0aGVcbiAgICogc2FtcGxlZCB0b2tlbiwgc28gdGhlcmUgbWF5IGJlIHVwIHRvIGBsb2dwcm9icysxYCBlbGVtZW50cyBpbiB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBgbG9ncHJvYnNgIGlzIDUuXG4gICAqL1xuICBsb2dwcm9icz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBbdG9rZW5zXSgvdG9rZW5pemVyKSB0byBnZW5lcmF0ZSBpbiB0aGUgY29tcGxldGlvbi5cbiAgICpcbiAgICogVGhlIHRva2VuIGNvdW50IG9mIHlvdXIgcHJvbXB0IHBsdXMgYG1heF90b2tlbnNgIGNhbm5vdCBleGNlZWQgdGhlIG1vZGVsJ3NcbiAgICogY29udGV4dCBsZW5ndGguXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX2NvdW50X3Rva2Vuc193aXRoX3Rpa3Rva2VuLmlweW5iKVxuICAgKiBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgKi9cbiAgbWF4X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IGNvbXBsZXRpb25zIHRvIGdlbmVyYXRlIGZvciBlYWNoIHByb21wdC5cbiAgICpcbiAgICogKipOb3RlOioqIEJlY2F1c2UgdGhpcyBwYXJhbWV0ZXIgZ2VuZXJhdGVzIG1hbnkgY29tcGxldGlvbnMsIGl0IGNhbiBxdWlja2x5XG4gICAqIGNvbnN1bWUgeW91ciB0b2tlbiBxdW90YS4gVXNlIGNhcmVmdWxseSBhbmQgZW5zdXJlIHRoYXQgeW91IGhhdmUgcmVhc29uYWJsZVxuICAgKiBzZXR0aW5ncyBmb3IgYG1heF90b2tlbnNgIGFuZCBgc3RvcGAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvblxuICAgKiB3aGV0aGVyIHRoZXkgYXBwZWFyIGluIHRoZSB0ZXh0IHNvIGZhciwgaW5jcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHRhbGsgYWJvdXQgbmV3IHRvcGljcy5cbiAgICpcbiAgICogW1NlZSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGZyZXF1ZW5jeSBhbmQgcHJlc2VuY2UgcGVuYWx0aWVzLl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2dwdC9wYXJhbWV0ZXItZGV0YWlscylcbiAgICovXG4gIHByZXNlbmNlX3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBVcCB0byA0IHNlcXVlbmNlcyB3aGVyZSB0aGUgQVBJIHdpbGwgc3RvcCBnZW5lcmF0aW5nIGZ1cnRoZXIgdG9rZW5zLiBUaGVcbiAgICogcmV0dXJuZWQgdGV4dCB3aWxsIG5vdCBjb250YWluIHRoZSBzdG9wIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RvcD86IHN0cmluZyB8IG51bGwgfCBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN1ZmZpeCB0aGF0IGNvbWVzIGFmdGVyIGEgY29tcGxldGlvbiBvZiBpbnNlcnRlZCB0ZXh0LlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzL2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMge1xuICBleHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogV2hldGhlciB0byBzdHJlYW0gYmFjayBwYXJ0aWFsIHByb2dyZXNzLiBJZiBzZXQsIHRva2VucyB3aWxsIGJlIHNlbnQgYXNcbiAgICogZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktY29va2Jvb2svYmxvYi9tYWluL2V4YW1wbGVzL0hvd190b19zdHJlYW1fY29tcGxldGlvbnMuaXB5bmIpLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29tcGxldGlvbnMge1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb24gPSBBUEkuQ29tcGxldGlvbjtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ2hvaWNlID0gQVBJLkNvbXBsZXRpb25DaG9pY2U7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvblVzYWdlID0gQVBJLkNvbXBsZXRpb25Vc2FnZTtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgRW1iZWRkaW5ncyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1iZWRkaW5nIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogRW1iZWRkaW5nQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8Q3JlYXRlRW1iZWRkaW5nUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvZW1iZWRkaW5ncycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGVtYmVkZGluZ3MgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGRhdGE6IEFycmF5PEVtYmVkZGluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBlbWJlZGRpbmcuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImVtYmVkZGluZ1wiLlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1c2FnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZTogQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UuVXNhZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVzYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVXNhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgYnkgdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGJ5IHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJldHVybmVkIGJ5IGVtYmVkZGluZyBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmcge1xuICAvKipcbiAgICogVGhlIGVtYmVkZGluZyB2ZWN0b3IsIHdoaWNoIGlzIGEgbGlzdCBvZiBmbG9hdHMuIFRoZSBsZW5ndGggb2YgdmVjdG9yIGRlcGVuZHMgb25cbiAgICogdGhlIG1vZGVsIGFzIGxpc3RlZCBpbiB0aGVcbiAgICogW2VtYmVkZGluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2VtYmVkZGluZ3MpLlxuICAgKi9cbiAgZW1iZWRkaW5nOiBBcnJheTxudW1iZXI+O1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGVtYmVkZGluZyBpbiB0aGUgbGlzdCBvZiBlbWJlZGRpbmdzLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJlbWJlZGRpbmdcIi5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJbnB1dCB0ZXh0IHRvIGVtYmVkLCBlbmNvZGVkIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHRva2Vucy4gVG8gZW1iZWQgbXVsdGlwbGVcbiAgICogaW5wdXRzIGluIGEgc2luZ2xlIHJlcXVlc3QsIHBhc3MgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBhcnJheSBvZiB0b2tlbiBhcnJheXMuXG4gICAqIEVhY2ggaW5wdXQgbXVzdCBub3QgZXhjZWVkIHRoZSBtYXggaW5wdXQgdG9rZW5zIGZvciB0aGUgbW9kZWwgKDgxOTEgdG9rZW5zIGZvclxuICAgKiBgdGV4dC1lbWJlZGRpbmctYWRhLTAwMmApIGFuZCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktY29va2Jvb2svYmxvYi9tYWluL2V4YW1wbGVzL0hvd190b19jb3VudF90b2tlbnNfd2l0aF90aWt0b2tlbi5pcHluYilcbiAgICogZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgQXJyYXk8bnVtYmVyPiB8IEFycmF5PEFycmF5PG51bWJlcj4+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvb3ZlcnZpZXcpIGZvclxuICAgKiBkZXNjcmlwdGlvbnMgb2YgdGhlbS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcy9lbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFbWJlZGRpbmdzIHtcbiAgZXhwb3J0IGltcG9ydCBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSA9IEFQSS5DcmVhdGVFbWJlZGRpbmdSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBFbWJlZGRpbmcgPSBBUEkuRW1iZWRkaW5nO1xuICBleHBvcnQgaW1wb3J0IEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyA9IEFQSS5FbWJlZGRpbmdDcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCIuL2NvbXBsZXRpb25zXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBFZGl0cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZWRpdCBmb3IgdGhlIHByb3ZpZGVkIGlucHV0LCBpbnN0cnVjdGlvbiwgYW5kIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBFZGl0cyBBUEkgaXMgZGVwcmVjYXRlZDsgcGxlYXNlIHVzZSBDaGF0IENvbXBsZXRpb25zIGluc3RlYWQuXG4gICAqXG4gICAqIGh0dHBzOi8vb3BlbmFpLmNvbS9ibG9nL2dwdC00LWFwaS1nZW5lcmFsLWF2YWlsYWJpbGl0eSNkZXByZWNhdGlvbi1vZi10aGUtZWRpdHMtYXBpXG4gICAqL1xuICBjcmVhdGUoYm9keTogRWRpdENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RWRpdD4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9lZGl0cycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXQge1xuICAvKipcbiAgICogQSBsaXN0IG9mIGVkaXQgY2hvaWNlcy4gQ2FuIGJlIG1vcmUgdGhhbiBvbmUgaWYgYG5gIGlzIGdyZWF0ZXIgdGhhbiAxLlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8RWRpdC5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGVkaXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBlZGl0YC5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U6IENvbXBsZXRpb25zLkNvbXBsZXRpb25Vc2FnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFZGl0IHtcbiAgZXhwb3J0IGludGVyZmFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgb3IgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMuXG4gICAgICovXG4gICAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0ZXh0OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFZGl0Q3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBpbnN0cnVjdGlvbiB0aGF0IHRlbGxzIHRoZSBtb2RlbCBob3cgdG8gZWRpdCB0aGUgcHJvbXB0LlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb246IHN0cmluZztcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlIGB0ZXh0LWRhdmluY2ktZWRpdC0wMDFgIG9yXG4gICAqIGBjb2RlLWRhdmluY2ktZWRpdC0wMDFgIG1vZGVsIHdpdGggdGhpcyBlbmRwb2ludC5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3RleHQtZGF2aW5jaS1lZGl0LTAwMScgfCAnY29kZS1kYXZpbmNpLWVkaXQtMDAxJztcblxuICAvKipcbiAgICogVGhlIGlucHV0IHRleHQgdG8gdXNlIGFzIGEgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBlZGl0LlxuICAgKi9cbiAgaW5wdXQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBlZGl0cyB0byBnZW5lcmF0ZSBmb3IgdGhlIGlucHV0IGFuZCBpbnN0cnVjdGlvbi5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIGB0b3BfcGAgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdGVtcGVyYXR1cmVgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFZGl0cyB7XG4gIGV4cG9ydCBpbXBvcnQgRWRpdCA9IEFQSS5FZGl0O1xuICBleHBvcnQgaW1wb3J0IEVkaXRDcmVhdGVQYXJhbXMgPSBBUEkuRWRpdENyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciB9IGZyb20gXCIuLi9lcnJvclwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgdHlwZSBVcGxvYWRhYmxlLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFVwbG9hZCBhIGZpbGUgdGhhdCBjb250YWlucyBkb2N1bWVudChzKSB0byBiZSB1c2VkIGFjcm9zcyB2YXJpb3VzXG4gICAqIGVuZHBvaW50cy9mZWF0dXJlcy4gQ3VycmVudGx5LCB0aGUgc2l6ZSBvZiBhbGwgdGhlIGZpbGVzIHVwbG9hZGVkIGJ5IG9uZVxuICAgKiBvcmdhbml6YXRpb24gY2FuIGJlIHVwIHRvIDEgR0IuIFBsZWFzZSBjb250YWN0IHVzIGlmIHlvdSBuZWVkIHRvIGluY3JlYXNlIHRoZVxuICAgKiBzdG9yYWdlIGxpbWl0LlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvZmlsZXMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZmlsZS5cbiAgICovXG4gIHJldHJpZXZlKGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHVzZXIncyBvcmdhbml6YXRpb24uXG4gICAqL1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxGaWxlT2JqZWN0c1BhZ2UsIEZpbGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KCcvZmlsZXMnLCBGaWxlT2JqZWN0c1BhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbGUuXG4gICAqL1xuICBkZWwoZmlsZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlKGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgKi9cbiAgcmV0cmlldmVDb250ZW50KGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBnaXZlbiBmaWxlIHRvIGJlIHByb2Nlc3NlZCwgZGVmYXVsdCB0aW1lb3V0IGlzIDMwIG1pbnMuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yUHJvY2Vzc2luZyhcbiAgICBpZDogc3RyaW5nLFxuICAgIHsgcG9sbEludGVydmFsID0gNTAwMCwgbWF4V2FpdCA9IDMwICogNjAgKiAxMDAwIH06IHsgcG9sbEludGVydmFsPzogbnVtYmVyOyBtYXhXYWl0PzogbnVtYmVyIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgY29uc3QgVEVSTUlOQUxfU1RBVEVTID0gbmV3IFNldChbJ3Byb2Nlc3NlZCcsICdlcnJvcicsICdkZWxldGVkJ10pO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBmaWxlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZShpZCk7XG5cbiAgICB3aGlsZSAoIWZpbGUuc3RhdHVzIHx8ICFURVJNSU5BTF9TVEFURVMuaGFzKGZpbGUuc3RhdHVzKSkge1xuICAgICAgYXdhaXQgc2xlZXAocG9sbEludGVydmFsKTtcblxuICAgICAgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IG1heFdhaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBHaXZpbmcgdXAgb24gd2FpdGluZyBmb3IgZmlsZSAke2lkfSB0byBmaW5pc2ggcHJvY2Vzc2luZyBhZnRlciAke21heFdhaXR9IG1pbGxpc2Vjb25kcy5gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVPYmplY3RzUGFnZSBleHRlbmRzIFBhZ2U8RmlsZU9iamVjdD4ge31cbi8vIGFsaWFzIHNvIHdlIGNhbiBleHBvcnQgaXQgaW4gdGhlIG5hbWVzcGFjZVxudHlwZSBfRmlsZU9iamVjdHNQYWdlID0gRmlsZU9iamVjdHNQYWdlO1xuXG5leHBvcnQgdHlwZSBGaWxlQ29udGVudCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBGaWxlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGUgYEZpbGVgIG9iamVjdCByZXByZXNlbnRzIGEgZG9jdW1lbnQgdGhhdCBoYXMgYmVlbiB1cGxvYWRlZCB0byBPcGVuQUkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZU9iamVjdCB7XG4gIC8qKlxuICAgKiBUaGUgZmlsZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLlxuICAgKi9cbiAgYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmlsZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbGVcIi5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgZmlsZS4gQ3VycmVudGx5LCBvbmx5IFwiZmluZS10dW5lXCIgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgcHVycG9zZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGZpbGUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYHVwbG9hZGVkYCwgYHByb2Nlc3NlZGAsXG4gICAqIGBwZW5kaW5nYCwgYGVycm9yYCwgYGRlbGV0aW5nYCBvciBgZGVsZXRlZGAuXG4gICAqL1xuICBzdGF0dXM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgc3RhdHVzIG9mIHRoZSBmaWxlLiBJZiB0aGUgZmlsZSBpcyBpbiB0aGUgYGVycm9yYFxuICAgKiBzdGF0ZSwgdGhpcyB3aWxsIGluY2x1ZGUgYSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGVycm9yLlxuICAgKi9cbiAgc3RhdHVzX2RldGFpbHM/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgW0pTT04gTGluZXNdKGh0dHBzOi8vanNvbmxpbmVzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC8pIGZpbGUgdG8gYmVcbiAgICogdXBsb2FkZWQuXG4gICAqXG4gICAqIElmIHRoZSBgcHVycG9zZWAgaXMgc2V0IHRvIFwiZmluZS10dW5lXCIsIHRoZSBmaWxlIHdpbGwgYmUgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBmaWxlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZG9jdW1lbnRzLlxuICAgKlxuICAgKiBVc2UgXCJmaW5lLXR1bmVcIiBmb3JcbiAgICogW2ZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nKS4gVGhpc1xuICAgKiBhbGxvd3MgdXMgdG8gdmFsaWRhdGUgdGhlIGZvcm1hdCBvZiB0aGUgdXBsb2FkZWQgZmlsZS5cbiAgICovXG4gIHB1cnBvc2U6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlcyB7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZUNvbnRlbnQgPSBBUEkuRmlsZUNvbnRlbnQ7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZURlbGV0ZWQgPSBBUEkuRmlsZURlbGV0ZWQ7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZU9iamVjdCA9IEFQSS5GaWxlT2JqZWN0O1xuICBleHBvcnQgdHlwZSBGaWxlT2JqZWN0c1BhZ2UgPSBfRmlsZU9iamVjdHNQYWdlO1xuICBleHBvcnQgaW1wb3J0IEZpbGVDcmVhdGVQYXJhbXMgPSBBUEkuRmlsZUNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBGaWxlcyBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uXCI7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi4vc3RyZWFtaW5nXCI7XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgam9iIHRoYXQgZmluZS10dW5lcyBhIHNwZWNpZmllZCBtb2RlbCBmcm9tIGEgZ2l2ZW4gZGF0YXNldC5cbiAgICpcbiAgICogUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZVxuICAgKiBvZiB0aGUgZmluZS10dW5lZCBtb2RlbHMgb25jZSBjb21wbGV0ZS5cbiAgICpcbiAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9sZWdhY3ktZmluZS10dW5pbmcpXG4gICAqL1xuICBjcmVhdGUoYm9keTogRmluZVR1bmVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5lPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ZpbmUtdHVuZXMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBpbmZvIGFib3V0IHRoZSBmaW5lLXR1bmUgam9iLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZylcbiAgICovXG4gIHJldHJpZXZlKGZpbmVUdW5lSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmU+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maW5lLXR1bmVzLyR7ZmluZVR1bmVJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHlvdXIgb3JnYW5pemF0aW9uJ3MgZmluZS10dW5pbmcgam9ic1xuICAgKi9cbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmVzUGFnZSwgRmluZVR1bmU+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KCcvZmluZS10dW5lcycsIEZpbmVUdW5lc1BhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZmluZVR1bmVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuZT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9maW5lLXR1bmVzLyR7ZmluZVR1bmVJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZpbmUtZ3JhaW5lZCBzdGF0dXMgdXBkYXRlcyBmb3IgYSBmaW5lLXR1bmUgam9iLlxuICAgKi9cbiAgbGlzdEV2ZW50cyhcbiAgICBmaW5lVHVuZUlkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8RmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2U+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5lSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxGaW5lVHVuZUV2ZW50Pj47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmVJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zQmFzZSB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08RmluZVR1bmVFdmVudD4gfCBGaW5lVHVuZUV2ZW50c0xpc3RSZXNwb25zZT47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmVJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPEZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlPiB8IEFQSVByb21pc2U8U3RyZWFtPEZpbmVUdW5lRXZlbnQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvZmluZS10dW5lcy8ke2ZpbmVUdW5lSWR9L2V2ZW50c2AsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgdGltZW91dDogODY0MDAwMDAsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc3RyZWFtOiBxdWVyeT8uc3RyZWFtID8/IGZhbHNlLFxuICAgIH0pIGFzIEFQSVByb21pc2U8RmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2U+IHwgQVBJUHJvbWlzZTxTdHJlYW08RmluZVR1bmVFdmVudD4+O1xuICB9XG59XG5cbi8qKlxuICogTm90ZTogbm8gcGFnaW5hdGlvbiBhY3R1YWxseSBvY2N1cnMgeWV0LCB0aGlzIGlzIGZvciBmb3J3YXJkcy1jb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgRmluZVR1bmVzUGFnZSBleHRlbmRzIFBhZ2U8RmluZVR1bmU+IHt9XG4vLyBhbGlhcyBzbyB3ZSBjYW4gZXhwb3J0IGl0IGluIHRoZSBuYW1lc3BhY2VcbnR5cGUgX0ZpbmVUdW5lc1BhZ2UgPSBGaW5lVHVuZXNQYWdlO1xuXG4vKipcbiAqIFRoZSBgRmluZVR1bmVgIG9iamVjdCByZXByZXNlbnRzIGEgbGVnYWN5IGZpbmUtdHVuZSBqb2IgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG4gKiB0aHJvdWdoIHRoZSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmUge1xuICAvKipcbiAgICogVGhlIG9iamVjdCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWwgdGhhdCBpcyBiZWluZyBjcmVhdGVkLlxuICAgKi9cbiAgZmluZV90dW5lZF9tb2RlbDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBTZWUgdGhlXG4gICAqIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9oeXBlcnBhcmFtZXRlcnMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBoeXBlcnBhcmFtczogRmluZVR1bmUuSHlwZXJwYXJhbXM7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIG1vZGVsIHRoYXQgaXMgYmVpbmcgZmluZS10dW5lZC5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwiZmluZS10dW5lXCIuXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9yZ2FuaXphdGlvbiB0aGF0IG93bnMgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIG9yZ2FuaXphdGlvbl9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29tcGlsZWQgcmVzdWx0cyBmaWxlcyBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIHJlc3VsdF9maWxlczogQXJyYXk8RmlsZXMuRmlsZU9iamVjdD47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZmluZS10dW5pbmcgam9iLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBjcmVhdGVkYCxcbiAgICogYHJ1bm5pbmdgLCBgc3VjY2VlZGVkYCwgYGZhaWxlZGAsIG9yIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGZpbGVzIHVzZWQgZm9yIHRyYWluaW5nLlxuICAgKi9cbiAgdHJhaW5pbmdfZmlsZXM6IEFycmF5PEZpbGVzLkZpbGVPYmplY3Q+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGxhc3QgdXBkYXRlZC5cbiAgICovXG4gIHVwZGF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZmlsZXMgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZXM6IEFycmF5PEZpbGVzLkZpbGVPYmplY3Q+O1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBldmVudHMgdGhhdCBoYXZlIGJlZW4gb2JzZXJ2ZWQgaW4gdGhlIGxpZmVjeWNsZSBvZiB0aGUgRmluZVR1bmUgam9iLlxuICAgKi9cbiAgZXZlbnRzPzogQXJyYXk8RmluZVR1bmVFdmVudD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmluZVR1bmUge1xuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBTZWUgdGhlXG4gICAqIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9oeXBlcnBhcmFtZXRlcnMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1zIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmF0Y2ggc2l6ZSB0byB1c2UgZm9yIHRyYWluaW5nLiBUaGUgYmF0Y2ggc2l6ZSBpcyB0aGUgbnVtYmVyIG9mIHRyYWluaW5nXG4gICAgICogZXhhbXBsZXMgdXNlZCB0byB0cmFpbiBhIHNpbmdsZSBmb3J3YXJkIGFuZCBiYWNrd2FyZCBwYXNzLlxuICAgICAqL1xuICAgIGJhdGNoX3NpemU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsZWFybmluZyByYXRlIG11bHRpcGxpZXIgdG8gdXNlIGZvciB0cmFpbmluZy5cbiAgICAgKi9cbiAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICovXG4gICAgbl9lcG9jaHM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3ZWlnaHQgdG8gdXNlIGZvciBsb3NzIG9uIHRoZSBwcm9tcHQgdG9rZW5zLlxuICAgICAqL1xuICAgIHByb21wdF9sb3NzX3dlaWdodDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjbGFzc2VzIHRvIHVzZSBmb3IgY29tcHV0aW5nIGNsYXNzaWZpY2F0aW9uIG1ldHJpY3MuXG4gICAgICovXG4gICAgY2xhc3NpZmljYXRpb25fbl9jbGFzc2VzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aXZlIGNsYXNzIHRvIHVzZSBmb3IgY29tcHV0aW5nIGNsYXNzaWZpY2F0aW9uIG1ldHJpY3MuXG4gICAgICovXG4gICAgY2xhc3NpZmljYXRpb25fcG9zaXRpdmVfY2xhc3M/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3NpZmljYXRpb24gbWV0cmljcyB0byBjb21wdXRlIHVzaW5nIHRoZSB2YWxpZGF0aW9uIGRhdGFzZXQgYXQgdGhlIGVuZCBvZlxuICAgICAqIGV2ZXJ5IGVwb2NoLlxuICAgICAqL1xuICAgIGNvbXB1dGVfY2xhc3NpZmljYXRpb25fbWV0cmljcz86IGJvb2xlYW47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuZUV2ZW50IHtcbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGxldmVsOiBzdHJpbmc7XG5cbiAgbWVzc2FnZTogc3RyaW5nO1xuXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlIHtcbiAgZGF0YTogQXJyYXk8RmluZVR1bmVFdmVudD47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyB0cmFpbmluZyBkYXRhLlxuICAgKlxuICAgKiBTZWUgW3VwbG9hZCBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3VwbG9hZClcbiAgICogZm9yIGhvdyB0byB1cGxvYWQgYSBmaWxlLlxuICAgKlxuICAgKiBZb3VyIGRhdGFzZXQgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgYSBKU09OTCBmaWxlLCB3aGVyZSBlYWNoIHRyYWluaW5nIGV4YW1wbGUgaXMgYVxuICAgKiBKU09OIG9iamVjdCB3aXRoIHRoZSBrZXlzIFwicHJvbXB0XCIgYW5kIFwiY29tcGxldGlvblwiLiBBZGRpdGlvbmFsbHksIHlvdSBtdXN0XG4gICAqIHVwbG9hZCB5b3VyIGZpbGUgd2l0aCB0aGUgcHVycG9zZSBgZmluZS10dW5lYC5cbiAgICpcbiAgICogU2VlIHRoZVxuICAgKiBbZmluZS10dW5pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9sZWdhY3ktZmluZS10dW5pbmcvY3JlYXRpbmctdHJhaW5pbmctZGF0YSlcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHRyYWluaW5nX2ZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGJhdGNoIHNpemUgdG8gdXNlIGZvciB0cmFpbmluZy4gVGhlIGJhdGNoIHNpemUgaXMgdGhlIG51bWJlciBvZiB0cmFpbmluZ1xuICAgKiBleGFtcGxlcyB1c2VkIHRvIHRyYWluIGEgc2luZ2xlIGZvcndhcmQgYW5kIGJhY2t3YXJkIHBhc3MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBiYXRjaCBzaXplIHdpbGwgYmUgZHluYW1pY2FsbHkgY29uZmlndXJlZCB0byBiZSB+MC4yJSBvZiB0aGVcbiAgICogbnVtYmVyIG9mIGV4YW1wbGVzIGluIHRoZSB0cmFpbmluZyBzZXQsIGNhcHBlZCBhdCAyNTYgLSBpbiBnZW5lcmFsLCB3ZSd2ZSBmb3VuZFxuICAgKiB0aGF0IGxhcmdlciBiYXRjaCBzaXplcyB0ZW5kIHRvIHdvcmsgYmV0dGVyIGZvciBsYXJnZXIgZGF0YXNldHMuXG4gICAqL1xuICBiYXRjaF9zaXplPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgdGhpcyBpcyBwcm92aWRlZCwgd2UgY2FsY3VsYXRlIEYtYmV0YSBzY29yZXMgYXQgdGhlIHNwZWNpZmllZCBiZXRhIHZhbHVlcy5cbiAgICogVGhlIEYtYmV0YSBzY29yZSBpcyBhIGdlbmVyYWxpemF0aW9uIG9mIEYtMSBzY29yZS4gVGhpcyBpcyBvbmx5IHVzZWQgZm9yIGJpbmFyeVxuICAgKiBjbGFzc2lmaWNhdGlvbi5cbiAgICpcbiAgICogV2l0aCBhIGJldGEgb2YgMSAoaS5lLiB0aGUgRi0xIHNjb3JlKSwgcHJlY2lzaW9uIGFuZCByZWNhbGwgYXJlIGdpdmVuIHRoZSBzYW1lXG4gICAqIHdlaWdodC4gQSBsYXJnZXIgYmV0YSBzY29yZSBwdXRzIG1vcmUgd2VpZ2h0IG9uIHJlY2FsbCBhbmQgbGVzcyBvbiBwcmVjaXNpb24uIEFcbiAgICogc21hbGxlciBiZXRhIHNjb3JlIHB1dHMgbW9yZSB3ZWlnaHQgb24gcHJlY2lzaW9uIGFuZCBsZXNzIG9uIHJlY2FsbC5cbiAgICovXG4gIGNsYXNzaWZpY2F0aW9uX2JldGFzPzogQXJyYXk8bnVtYmVyPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY2xhc3NlcyBpbiBhIGNsYXNzaWZpY2F0aW9uIHRhc2suXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGZvciBtdWx0aWNsYXNzIGNsYXNzaWZpY2F0aW9uLlxuICAgKi9cbiAgY2xhc3NpZmljYXRpb25fbl9jbGFzc2VzPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHBvc2l0aXZlIGNsYXNzIGluIGJpbmFyeSBjbGFzc2lmaWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHRvIGdlbmVyYXRlIHByZWNpc2lvbiwgcmVjYWxsLCBhbmQgRjEgbWV0cmljcyB3aGVuXG4gICAqIGRvaW5nIGJpbmFyeSBjbGFzc2lmaWNhdGlvbi5cbiAgICovXG4gIGNsYXNzaWZpY2F0aW9uX3Bvc2l0aXZlX2NsYXNzPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgc2V0LCB3ZSBjYWxjdWxhdGUgY2xhc3NpZmljYXRpb24tc3BlY2lmaWMgbWV0cmljcyBzdWNoIGFzIGFjY3VyYWN5IGFuZCBGLTFcbiAgICogc2NvcmUgdXNpbmcgdGhlIHZhbGlkYXRpb24gc2V0IGF0IHRoZSBlbmQgb2YgZXZlcnkgZXBvY2guIFRoZXNlIG1ldHJpY3MgY2FuIGJlXG4gICAqIHZpZXdlZCBpbiB0aGVcbiAgICogW3Jlc3VsdHMgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9hbmFseXppbmcteW91ci1maW5lLXR1bmVkLW1vZGVsKS5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gY29tcHV0ZSBjbGFzc2lmaWNhdGlvbiBtZXRyaWNzLCB5b3UgbXVzdCBwcm92aWRlIGFcbiAgICogYHZhbGlkYXRpb25fZmlsZWAuIEFkZGl0aW9uYWxseSwgeW91IG11c3Qgc3BlY2lmeSBgY2xhc3NpZmljYXRpb25fbl9jbGFzc2VzYCBmb3JcbiAgICogbXVsdGljbGFzcyBjbGFzc2lmaWNhdGlvbiBvciBgY2xhc3NpZmljYXRpb25fcG9zaXRpdmVfY2xhc3NgIGZvciBiaW5hcnlcbiAgICogY2xhc3NpZmljYXRpb24uXG4gICAqL1xuICBjb21wdXRlX2NsYXNzaWZpY2F0aW9uX21ldHJpY3M/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxlYXJuaW5nIHJhdGUgbXVsdGlwbGllciB0byB1c2UgZm9yIHRyYWluaW5nLiBUaGUgZmluZS10dW5pbmcgbGVhcm5pbmcgcmF0ZVxuICAgKiBpcyB0aGUgb3JpZ2luYWwgbGVhcm5pbmcgcmF0ZSB1c2VkIGZvciBwcmV0cmFpbmluZyBtdWx0aXBsaWVkIGJ5IHRoaXMgdmFsdWUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBsZWFybmluZyByYXRlIG11bHRpcGxpZXIgaXMgdGhlIDAuMDUsIDAuMSwgb3IgMC4yIGRlcGVuZGluZyBvblxuICAgKiBmaW5hbCBgYmF0Y2hfc2l6ZWAgKGxhcmdlciBsZWFybmluZyByYXRlcyB0ZW5kIHRvIHBlcmZvcm0gYmV0dGVyIHdpdGggbGFyZ2VyXG4gICAqIGJhdGNoIHNpemVzKS4gV2UgcmVjb21tZW5kIGV4cGVyaW1lbnRpbmcgd2l0aCB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAuMDIgdG8gMC4yIHRvXG4gICAqIHNlZSB3aGF0IHByb2R1Y2VzIHRoZSBiZXN0IHJlc3VsdHMuXG4gICAqL1xuICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYmFzZSBtb2RlbCB0byBmaW5lLXR1bmUuIFlvdSBjYW4gc2VsZWN0IG9uZSBvZiBcImFkYVwiLCBcImJhYmJhZ2VcIixcbiAgICogXCJjdXJpZVwiLCBcImRhdmluY2lcIiwgb3IgYSBmaW5lLXR1bmVkIG1vZGVsIGNyZWF0ZWQgYWZ0ZXIgMjAyMi0wNC0yMSBhbmQgYmVmb3JlXG4gICAqIDIwMjMtMDgtMjIuIFRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlc2UgbW9kZWxzLCBzZWUgdGhlXG4gICAqIFtNb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZG9jdW1lbnRhdGlvbi5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8ICdhZGEnIHwgJ2JhYmJhZ2UnIHwgJ2N1cmllJyB8ICdkYXZpbmNpJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgKi9cbiAgbl9lcG9jaHM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0IHRvIHVzZSBmb3IgbG9zcyBvbiB0aGUgcHJvbXB0IHRva2Vucy4gVGhpcyBjb250cm9scyBob3cgbXVjaCB0aGVcbiAgICogbW9kZWwgdHJpZXMgdG8gbGVhcm4gdG8gZ2VuZXJhdGUgdGhlIHByb21wdCAoYXMgY29tcGFyZWQgdG8gdGhlIGNvbXBsZXRpb24gd2hpY2hcbiAgICogYWx3YXlzIGhhcyBhIHdlaWdodCBvZiAxLjApLCBhbmQgY2FuIGFkZCBhIHN0YWJpbGl6aW5nIGVmZmVjdCB0byB0cmFpbmluZyB3aGVuXG4gICAqIGNvbXBsZXRpb25zIGFyZSBzaG9ydC5cbiAgICpcbiAgICogSWYgcHJvbXB0cyBhcmUgZXh0cmVtZWx5IGxvbmcgKHJlbGF0aXZlIHRvIGNvbXBsZXRpb25zKSwgaXQgbWF5IG1ha2Ugc2Vuc2UgdG9cbiAgICogcmVkdWNlIHRoaXMgd2VpZ2h0IHNvIGFzIHRvIGF2b2lkIG92ZXItcHJpb3JpdGl6aW5nIGxlYXJuaW5nIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfbG9zc193ZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB1cCB0byA0MCBjaGFyYWN0ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB5b3VyIGZpbmUtdHVuZWQgbW9kZWxcbiAgICogbmFtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgYHN1ZmZpeGAgb2YgXCJjdXN0b20tbW9kZWwtbmFtZVwiIHdvdWxkIHByb2R1Y2UgYSBtb2RlbCBuYW1lIGxpa2VcbiAgICogYGFkYTpmdC15b3VyLW9yZzpjdXN0b20tbW9kZWwtbmFtZS0yMDIyLTAyLTE1LTA0LTIxLTA0YC5cbiAgICovXG4gIHN1ZmZpeD86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgdmFsaWRhdGlvbiBkYXRhLlxuICAgKlxuICAgKiBJZiB5b3UgcHJvdmlkZSB0aGlzIGZpbGUsIHRoZSBkYXRhIGlzIHVzZWQgdG8gZ2VuZXJhdGUgdmFsaWRhdGlvbiBtZXRyaWNzXG4gICAqIHBlcmlvZGljYWxseSBkdXJpbmcgZmluZS10dW5pbmcuIFRoZXNlIG1ldHJpY3MgY2FuIGJlIHZpZXdlZCBpbiB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIHJlc3VsdHMgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9hbmFseXppbmcteW91ci1maW5lLXR1bmVkLW1vZGVsKS5cbiAgICogWW91ciB0cmFpbiBhbmQgdmFsaWRhdGlvbiBkYXRhIHNob3VsZCBiZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUsIHdoZXJlIGVhY2ggdmFsaWRhdGlvbiBleGFtcGxlIGlzXG4gICAqIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUga2V5cyBcInByb21wdFwiIGFuZCBcImNvbXBsZXRpb25cIi4gQWRkaXRpb25hbGx5LCB5b3UgbXVzdFxuICAgKiB1cGxvYWQgeW91ciBmaWxlIHdpdGggdGhlIHB1cnBvc2UgYGZpbmUtdHVuZWAuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvbGVnYWN5LWZpbmUtdHVuaW5nL2NyZWF0aW5nLXRyYWluaW5nLWRhdGEpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB2YWxpZGF0aW9uX2ZpbGU/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXMgPVxuICB8IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc05vblN0cmVhbWluZ1xuICB8IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGV2ZW50cyBmb3IgdGhlIGZpbmUtdHVuZSBqb2IuIElmIHNldCB0byB0cnVlLCBldmVudHMgd2lsbCBiZVxuICAgKiBzZW50IGFzIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUuIFRoZSBzdHJlYW0gd2lsbCB0ZXJtaW5hdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2Ugd2hlbiB0aGUgam9iIGlzIGZpbmlzaGVkIChzdWNjZWVkZWQsIGNhbmNlbGxlZCwgb3IgZmFpbGVkKS5cbiAgICpcbiAgICogSWYgc2V0IHRvIGZhbHNlLCBvbmx5IGV2ZW50cyBnZW5lcmF0ZWQgc28gZmFyIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtcyB7XG4gIGV4cG9ydCB0eXBlIEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc05vblN0cmVhbWluZyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc1N0cmVhbWluZyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBldmVudHMgZm9yIHRoZSBmaW5lLXR1bmUgam9iLiBJZiBzZXQgdG8gdHJ1ZSwgZXZlbnRzIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLiBUaGUgc3RyZWFtIHdpbGwgdGVybWluYXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlIHdoZW4gdGhlIGpvYiBpcyBmaW5pc2hlZCAoc3VjY2VlZGVkLCBjYW5jZWxsZWQsIG9yIGZhaWxlZCkuXG4gICAqXG4gICAqIElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgZ2VuZXJhdGVkIHNvIGZhciB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBldmVudHMgZm9yIHRoZSBmaW5lLXR1bmUgam9iLiBJZiBzZXQgdG8gdHJ1ZSwgZXZlbnRzIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLiBUaGUgc3RyZWFtIHdpbGwgdGVybWluYXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlIHdoZW4gdGhlIGpvYiBpcyBmaW5pc2hlZCAoc3VjY2VlZGVkLCBjYW5jZWxsZWQsIG9yIGZhaWxlZCkuXG4gICAqXG4gICAqIElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgZ2VuZXJhdGVkIHNvIGZhciB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbmVUdW5lcyB7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmUgPSBBUEkuRmluZVR1bmU7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVFdmVudCA9IEFQSS5GaW5lVHVuZUV2ZW50O1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlID0gQVBJLkZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlO1xuICBleHBvcnQgdHlwZSBGaW5lVHVuZXNQYWdlID0gX0ZpbmVUdW5lc1BhZ2U7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVDcmVhdGVQYXJhbXMgPSBBUEkuRmluZVR1bmVDcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zID0gQVBJLkZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNOb25TdHJlYW1pbmcgPSBBUEkuRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc1N0cmVhbWluZyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNTdHJlYW1pbmc7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gXCIuLi8uLi9wYWdpbmF0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBKb2JzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGpvYiB0aGF0IGZpbmUtdHVuZXMgYSBzcGVjaWZpZWQgbW9kZWwgZnJvbSBhIGdpdmVuIGRhdGFzZXQuXG4gICAqXG4gICAqIFJlc3BvbnNlIGluY2x1ZGVzIGRldGFpbHMgb2YgdGhlIGVucXVldWVkIGpvYiBpbmNsdWRpbmcgam9iIHN0YXR1cyBhbmQgdGhlIG5hbWVcbiAgICogb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWxzIG9uY2UgY29tcGxldGUuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICBjcmVhdGUoYm9keTogSm9iQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ZpbmVfdHVuaW5nL2pvYnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm8gYWJvdXQgYSBmaW5lLXR1bmluZyBqb2IuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICByZXRyaWV2ZShmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmluZ0pvYj4ge1xuICAgIHJldHVybiB0aGlzLmdldChgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB5b3VyIG9yZ2FuaXphdGlvbidzIGZpbmUtdHVuaW5nIGpvYnNcbiAgICovXG4gIGxpc3QoXG4gICAgcXVlcnk/OiBKb2JMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEpvYkxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYnNQYWdlLCBGaW5lVHVuaW5nSm9iPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEFQSUxpc3QoJy9maW5lX3R1bmluZy9qb2JzJywgRmluZVR1bmluZ0pvYnNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5pbmdKb2I+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0YXR1cyB1cGRhdGVzIGZvciBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBKb2JMaXN0RXZlbnRzUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RFdmVudHMoZmluZVR1bmluZ0pvYklkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vZXZlbnRzYCwgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYnNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaW5lVHVuaW5nSm9iPiB7fVxuLy8gYWxpYXMgc28gd2UgY2FuIGV4cG9ydCBpdCBpbiB0aGUgbmFtZXNwYWNlXG50eXBlIF9GaW5lVHVuaW5nSm9ic1BhZ2UgPSBGaW5lVHVuaW5nSm9ic1BhZ2U7XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYkV2ZW50PiB7fVxuLy8gYWxpYXMgc28gd2UgY2FuIGV4cG9ydCBpdCBpbiB0aGUgbmFtZXNwYWNlXG50eXBlIF9GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlO1xuXG4vKipcbiAqIFRoZSBgZmluZV90dW5pbmcuam9iYCBvYmplY3QgcmVwcmVzZW50cyBhIGZpbmUtdHVuaW5nIGpvYiB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcbiAqIHRocm91Z2ggdGhlIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBlcnJvcjogRmluZVR1bmluZ0pvYi5FcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVsIHRoYXQgaXMgYmVpbmcgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmUgbnVsbFxuICAgKiBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICBmaW5lX3R1bmVkX21vZGVsOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGZpbmlzaGVkLiBUaGVcbiAgICogdmFsdWUgd2lsbCBiZSBudWxsIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIGZpbmlzaGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFNlZSB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpIGZvclxuICAgKiBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBoeXBlcnBhcmFtZXRlcnM6IEZpbmVUdW5pbmdKb2IuSHlwZXJwYXJhbWV0ZXJzO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBtb2RlbCB0aGF0IGlzIGJlaW5nIGZpbmUtdHVuZWQuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYlwiLlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmdhbml6YXRpb24gdGhhdCBvd25zIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBvcmdhbml6YXRpb25faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbXBpbGVkIHJlc3VsdHMgZmlsZSBJRChzKSBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gWW91IGNhbiByZXRyaWV2ZSB0aGVcbiAgICogcmVzdWx0cyB3aXRoIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHJlc3VsdF9maWxlczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBmaW5lLXR1bmluZyBqb2IsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICogYHZhbGlkYXRpbmdfZmlsZXNgLCBgcXVldWVkYCwgYHJ1bm5pbmdgLCBgc3VjY2VlZGVkYCwgYGZhaWxlZGAsIG9yIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYmlsbGFibGUgdG9rZW5zIHByb2Nlc3NlZCBieSB0aGlzIGZpbmUtdHVuaW5nIGpvYi4gVGhlIHZhbHVlXG4gICAqIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICB0cmFpbmVkX3Rva2VuczogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZpbGUgSUQgdXNlZCBmb3IgdHJhaW5pbmcuIFlvdSBjYW4gcmV0cmlldmUgdGhlIHRyYWluaW5nIGRhdGEgd2l0aCB0aGVcbiAgICogW0ZpbGVzIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9yZXRyaWV2ZS1jb250ZW50cykuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmaWxlIElEIHVzZWQgZm9yIHZhbGlkYXRpb24uIFlvdSBjYW4gcmV0cmlldmUgdGhlIHZhbGlkYXRpb24gcmVzdWx0cyB3aXRoXG4gICAqIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZTogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBBIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZS5cbiAgICAgKi9cbiAgICBjb2RlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmFtZXRlciB0aGF0IHdhcyBpbnZhbGlkLCB1c3VhbGx5IGB0cmFpbmluZ19maWxlYCBvciBgdmFsaWRhdGlvbl9maWxlYC5cbiAgICAgKiBUaGlzIGZpZWxkIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmFpbHVyZSB3YXMgbm90IHBhcmFtZXRlci1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBwYXJhbTogc3RyaW5nIHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFNlZSB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpIGZvclxuICAgKiBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC4gXCJhdXRvXCIgZGVjaWRlcyB0aGUgb3B0aW1hbCBudW1iZXIgb2YgZXBvY2hzIGJhc2VkXG4gICAgICogb24gdGhlIHNpemUgb2YgdGhlIGRhdGFzZXQuIElmIHNldHRpbmcgdGhlIG51bWJlciBtYW51YWxseSwgd2Ugc3VwcG9ydCBhbnlcbiAgICAgKiBudW1iZXIgYmV0d2VlbiAxIGFuZCA1MCBlcG9jaHMuXG4gICAgICovXG4gICAgbl9lcG9jaHM6ICdhdXRvJyB8IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JFdmVudCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGxldmVsOiAnaW5mbycgfCAnd2FybicgfCAnZXJyb3InO1xuXG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2JDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIGZpbmUtdHVuZS4gWW91IGNhbiBzZWxlY3Qgb25lIG9mIHRoZVxuICAgKiBbc3VwcG9ydGVkIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nL3doYXQtbW9kZWxzLWNhbi1iZS1maW5lLXR1bmVkKS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ2JhYmJhZ2UtMDAyJyB8ICdkYXZpbmNpLTAwMicgfCAnZ3B0LTMuNS10dXJibyc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgdHJhaW5pbmcgZGF0YS5cbiAgICpcbiAgICogU2VlIFt1cGxvYWQgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy91cGxvYWQpXG4gICAqIGZvciBob3cgdG8gdXBsb2FkIGEgZmlsZS5cbiAgICpcbiAgICogWW91ciBkYXRhc2V0IG11c3QgYmUgZm9ybWF0dGVkIGFzIGEgSlNPTkwgZmlsZS4gQWRkaXRpb25hbGx5LCB5b3UgbXVzdCB1cGxvYWRcbiAgICogeW91ciBmaWxlIHdpdGggdGhlIHB1cnBvc2UgYGZpbmUtdHVuZWAuXG4gICAqXG4gICAqIFNlZSB0aGUgW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGh5cGVycGFyYW1ldGVycz86IEpvYkNyZWF0ZVBhcmFtcy5IeXBlcnBhcmFtZXRlcnM7XG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHVwIHRvIDE4IGNoYXJhY3RlcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHlvdXIgZmluZS10dW5lZCBtb2RlbFxuICAgKiBuYW1lLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgYSBgc3VmZml4YCBvZiBcImN1c3RvbS1tb2RlbC1uYW1lXCIgd291bGQgcHJvZHVjZSBhIG1vZGVsIG5hbWUgbGlrZVxuICAgKiBgZnQ6Z3B0LTMuNS10dXJibzpvcGVuYWk6Y3VzdG9tLW1vZGVsLW5hbWU6N3A0bFVSZWxgLlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyB2YWxpZGF0aW9uIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIHRoaXMgZmlsZSwgdGhlIGRhdGEgaXMgdXNlZCB0byBnZW5lcmF0ZSB2YWxpZGF0aW9uIG1ldHJpY3NcbiAgICogcGVyaW9kaWNhbGx5IGR1cmluZyBmaW5lLXR1bmluZy4gVGhlc2UgbWV0cmljcyBjYW4gYmUgdmlld2VkIGluIHRoZSBmaW5lLXR1bmluZ1xuICAgKiByZXN1bHRzIGZpbGUuIFRoZSBzYW1lIGRhdGEgc2hvdWxkIG5vdCBiZSBwcmVzZW50IGluIGJvdGggdHJhaW4gYW5kIHZhbGlkYXRpb25cbiAgICogZmlsZXMuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUuIFlvdSBtdXN0IHVwbG9hZCB5b3VyIGZpbGUgd2l0aFxuICAgKiB0aGUgcHVycG9zZSBgZmluZS10dW5lYC5cbiAgICpcbiAgICogU2VlIHRoZSBbZmluZS10dW5pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZT86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgSm9iQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAqL1xuICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9iTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuZXhwb3J0IGludGVyZmFjZSBKb2JMaXN0RXZlbnRzUGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5leHBvcnQgbmFtZXNwYWNlIEpvYnMge1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5pbmdKb2IgPSBBUEkuRmluZVR1bmluZ0pvYjtcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuaW5nSm9iRXZlbnQgPSBBUEkuRmluZVR1bmluZ0pvYkV2ZW50O1xuICBleHBvcnQgdHlwZSBGaW5lVHVuaW5nSm9ic1BhZ2UgPSBfRmluZVR1bmluZ0pvYnNQYWdlO1xuICBleHBvcnQgdHlwZSBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IF9GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBKb2JDcmVhdGVQYXJhbXMgPSBBUEkuSm9iQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEpvYkxpc3RQYXJhbXMgPSBBUEkuSm9iTGlzdFBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBKb2JMaXN0RXZlbnRzUGFyYW1zID0gQVBJLkpvYkxpc3RFdmVudHNQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCB7IEpvYnMgfSBmcm9tICcuL2pvYnMnO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgam9iczogSm9icyA9IG5ldyBKb2JzKHRoaXMuY2xpZW50KTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nIHtcbiAgZXhwb3J0IGltcG9ydCBKb2JzID0gQVBJLkpvYnM7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmluZ0pvYiA9IEFQSS5GaW5lVHVuaW5nSm9iO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5pbmdKb2JFdmVudCA9IEFQSS5GaW5lVHVuaW5nSm9iRXZlbnQ7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmluZ0pvYnNQYWdlID0gQVBJLkZpbmVUdW5pbmdKb2JzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEFQSS5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBKb2JDcmVhdGVQYXJhbXMgPSBBUEkuSm9iQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEpvYkxpc3RQYXJhbXMgPSBBUEkuSm9iTGlzdFBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBKb2JMaXN0RXZlbnRzUGFyYW1zID0gQVBJLkpvYkxpc3RFdmVudHNQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IHR5cGUgVXBsb2FkYWJsZSwgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuZXhwb3J0IGNsYXNzIEltYWdlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB2YXJpYXRpb24gb2YgYSBnaXZlbiBpbWFnZS5cbiAgICovXG4gIGNyZWF0ZVZhcmlhdGlvbihcbiAgICBib2R5OiBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ltYWdlcy92YXJpYXRpb25zJywgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlZGl0ZWQgb3IgZXh0ZW5kZWQgaW1hZ2UgZ2l2ZW4gYW4gb3JpZ2luYWwgaW1hZ2UgYW5kIGEgcHJvbXB0LlxuICAgKi9cbiAgZWRpdChib2R5OiBJbWFnZUVkaXRQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ltYWdlcy9lZGl0cycsIG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW1hZ2UgZ2l2ZW4gYSBwcm9tcHQuXG4gICAqL1xuICBnZW5lcmF0ZShib2R5OiBJbWFnZUdlbmVyYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9pbWFnZXMvZ2VuZXJhdGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB1cmwgb3IgdGhlIGNvbnRlbnQgb2YgYW4gaW1hZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBPcGVuQUkgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlNjQtZW5jb2RlZCBKU09OIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2UsIGlmIGByZXNwb25zZV9mb3JtYXRgIGlzXG4gICAqIGBiNjRfanNvbmAuXG4gICAqL1xuICBiNjRfanNvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlLCBpZiBgcmVzcG9uc2VfZm9ybWF0YCBpcyBgdXJsYCAoZGVmYXVsdCkuXG4gICAqL1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VzUmVzcG9uc2Uge1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgZGF0YTogQXJyYXk8SW1hZ2U+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBpbWFnZSB0byB1c2UgYXMgdGhlIGJhc2lzIGZvciB0aGUgdmFyaWF0aW9uKHMpLiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsXG4gICAqIGxlc3MgdGhhbiA0TUIsIGFuZCBzcXVhcmUuXG4gICAqL1xuICBpbWFnZTogVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcy9lbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUVkaXRQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGltYWdlIHRvIGVkaXQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS4gSWYgbWFza1xuICAgKiBpcyBub3QgcHJvdmlkZWQsIGltYWdlIG11c3QgaGF2ZSB0cmFuc3BhcmVuY3ksIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgbWFzay5cbiAgICovXG4gIGltYWdlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gYWRkaXRpb25hbCBpbWFnZSB3aG9zZSBmdWxseSB0cmFuc3BhcmVudCBhcmVhcyAoZS5nLiB3aGVyZSBhbHBoYSBpcyB6ZXJvKVxuICAgKiBpbmRpY2F0ZSB3aGVyZSBgaW1hZ2VgIHNob3VsZCBiZSBlZGl0ZWQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuXG4gICAqIDRNQiwgYW5kIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyBgaW1hZ2VgLlxuICAgKi9cbiAgbWFzaz86IFVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mIGB1cmxgIG9yXG4gICAqIGBiNjRfanNvbmAuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAndXJsJyB8ICdiNjRfanNvbicgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgYDI1NngyNTZgLCBgNTEyeDUxMmAsIG9yXG4gICAqIGAxMDI0eDEwMjRgLlxuICAgKi9cbiAgc2l6ZT86ICcyNTZ4MjU2JyB8ICc1MTJ4NTEyJyB8ICcxMDI0eDEwMjQnIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMvZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VHZW5lcmF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcy9lbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBJbWFnZXMge1xuICBleHBvcnQgaW1wb3J0IEltYWdlID0gQVBJLkltYWdlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlc1Jlc3BvbnNlID0gQVBJLkltYWdlc1Jlc3BvbnNlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zID0gQVBJLkltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEltYWdlRWRpdFBhcmFtcyA9IEFQSS5JbWFnZUVkaXRQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgSW1hZ2VHZW5lcmF0ZVBhcmFtcyA9IEFQSS5JbWFnZUdlbmVyYXRlUGFyYW1zO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSBcIi4uL3BhZ2luYXRpb25cIjtcblxuZXhwb3J0IGNsYXNzIE1vZGVscyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXNcbiAgICogdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgKi9cbiAgcmV0cmlldmUobW9kZWw6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoXG4gICAqIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgKi9cbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8TW9kZWxzUGFnZSwgTW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KCcvbW9kZWxzJywgTW9kZWxzUGFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZmluZS10dW5lZCBtb2RlbC4gWW91IG11c3QgaGF2ZSB0aGUgT3duZXIgcm9sZSBpbiB5b3VyIG9yZ2FuaXphdGlvbiB0b1xuICAgKiBkZWxldGUgYSBtb2RlbC5cbiAgICovXG4gIGRlbChtb2RlbDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNb2RlbERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5kZWxldGUoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsc1BhZ2UgZXh0ZW5kcyBQYWdlPE1vZGVsPiB7fVxuLy8gYWxpYXMgc28gd2UgY2FuIGV4cG9ydCBpdCBpbiB0aGUgbmFtZXNwYWNlXG50eXBlIF9Nb2RlbHNQYWdlID0gTW9kZWxzUGFnZTtcblxuLyoqXG4gKiBEZXNjcmliZXMgYW4gT3BlbkFJIG1vZGVsIG9mZmVyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsIHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgd2hlbiB0aGUgbW9kZWwgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwibW9kZWxcIi5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JnYW5pemF0aW9uIHRoYXQgb3ducyB0aGUgbW9kZWwuXG4gICAqL1xuICBvd25lZF9ieTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RlbHMge1xuICBleHBvcnQgaW1wb3J0IE1vZGVsID0gQVBJLk1vZGVsO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsRGVsZXRlZCA9IEFQSS5Nb2RlbERlbGV0ZWQ7XG4gIGV4cG9ydCB0eXBlIE1vZGVsc1BhZ2UgPSBfTW9kZWxzUGFnZTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgTW9kZXJhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDbGFzc2lmaWVzIGlmIHRleHQgdmlvbGF0ZXMgT3BlbkFJJ3MgQ29udGVudCBQb2xpY3lcbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL21vZGVyYXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIGZsYWdnZWQgb3Igbm90LlxuICAgKi9cbiAgY2F0ZWdvcmllczogTW9kZXJhdGlvbi5DYXRlZ29yaWVzO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMgYWxvbmcgd2l0aCB0aGVpciBzY29yZXMgYXMgcHJlZGljdGVkIGJ5IG1vZGVsLlxuICAgKi9cbiAgY2F0ZWdvcnlfc2NvcmVzOiBNb2RlcmF0aW9uLkNhdGVnb3J5U2NvcmVzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb250ZW50IHZpb2xhdGVzXG4gICAqIFtPcGVuQUkncyB1c2FnZSBwb2xpY2llc10oL3BvbGljaWVzL3VzYWdlLXBvbGljaWVzKS5cbiAgICovXG4gIGZsYWdnZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIGZsYWdnZWQgb3Igbm90LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yaWVzIHtcbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZXhwcmVzc2VzLCBpbmNpdGVzLCBvciBwcm9tb3RlcyBoYXJhc3NpbmcgbGFuZ3VhZ2UgdG93YXJkcyBhbnlcbiAgICAgKiB0YXJnZXQuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhhcmFzc21lbnQgY29udGVudCB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2Ugb3Igc2VyaW91cyBoYXJtIHRvd2FyZHMgYW55XG4gICAgICogdGFyZ2V0LlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBleHByZXNzZXMsIGluY2l0ZXMsIG9yIHByb21vdGVzIGhhdGUgYmFzZWQgb24gcmFjZSwgZ2VuZGVyLFxuICAgICAqIGV0aG5pY2l0eSwgcmVsaWdpb24sIG5hdGlvbmFsaXR5LCBzZXh1YWwgb3JpZW50YXRpb24sIGRpc2FiaWxpdHkgc3RhdHVzLCBvclxuICAgICAqIGNhc3RlLiBIYXRlZnVsIGNvbnRlbnQgYWltZWQgYXQgbm9uLXByb3RlY3RlZCBncm91cHMgKGUuZy4sIGNoZXNzIHBsYXllcnMpIGlzXG4gICAgICogaGFycmFzc21lbnQuXG4gICAgICovXG4gICAgaGF0ZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhhdGVmdWwgY29udGVudCB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2Ugb3Igc2VyaW91cyBoYXJtIHRvd2FyZHMgdGhlIHRhcmdldGVkXG4gICAgICogZ3JvdXAgYmFzZWQgb24gcmFjZSwgZ2VuZGVyLCBldGhuaWNpdHksIHJlbGlnaW9uLCBuYXRpb25hbGl0eSwgc2V4dWFsXG4gICAgICogb3JpZW50YXRpb24sIGRpc2FiaWxpdHkgc3RhdHVzLCBvciBjYXN0ZS5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgcHJvbW90ZXMsIGVuY291cmFnZXMsIG9yIGRlcGljdHMgYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXNcbiAgICAgKiBzdWljaWRlLCBjdXR0aW5nLCBhbmQgZWF0aW5nIGRpc29yZGVycy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBlbmNvdXJhZ2VzIHBlcmZvcm1pbmcgYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXMgc3VpY2lkZSwgY3V0dGluZyxcbiAgICAgKiBhbmQgZWF0aW5nIGRpc29yZGVycywgb3IgdGhhdCBnaXZlcyBpbnN0cnVjdGlvbnMgb3IgYWR2aWNlIG9uIGhvdyB0byBjb21taXQgc3VjaFxuICAgICAqIGFjdHMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB3aGVyZSB0aGUgc3BlYWtlciBleHByZXNzZXMgdGhhdCB0aGV5IGFyZSBlbmdhZ2luZyBvciBpbnRlbmQgdG8gZW5nYWdlXG4gICAgICogaW4gYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXMgc3VpY2lkZSwgY3V0dGluZywgYW5kIGVhdGluZyBkaXNvcmRlcnMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBtZWFudCB0byBhcm91c2Ugc2V4dWFsIGV4Y2l0ZW1lbnQsIHN1Y2ggYXMgdGhlIGRlc2NyaXB0aW9uIG9mIHNleHVhbFxuICAgICAqIGFjdGl2aXR5LCBvciB0aGF0IHByb21vdGVzIHNleHVhbCBzZXJ2aWNlcyAoZXhjbHVkaW5nIHNleCBlZHVjYXRpb24gYW5kXG4gICAgICogd2VsbG5lc3MpLlxuICAgICAqL1xuICAgIHNleHVhbDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNleHVhbCBjb250ZW50IHRoYXQgaW5jbHVkZXMgYW4gaW5kaXZpZHVhbCB3aG8gaXMgdW5kZXIgMTggeWVhcnMgb2xkLlxuICAgICAqL1xuICAgICdzZXh1YWwvbWlub3JzJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBkZXBpY3RzIGRlYXRoLCB2aW9sZW5jZSwgb3IgcGh5c2ljYWwgaW5qdXJ5LlxuICAgICAqL1xuICAgIHZpb2xlbmNlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGRlcGljdHMgZGVhdGgsIHZpb2xlbmNlLCBvciBwaHlzaWNhbCBpbmp1cnkgaW4gZ3JhcGhpYyBkZXRhaWwuXG4gICAgICovXG4gICAgJ3Zpb2xlbmNlL2dyYXBoaWMnOiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZWlyIHNjb3JlcyBhcyBwcmVkaWN0ZWQgYnkgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5U2NvcmVzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudCcuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUnLlxuICAgICAqL1xuICAgIGhhdGU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlL3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0nLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0nOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2luc3RydWN0aW9ucycuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2ludGVudCcuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsJy5cbiAgICAgKi9cbiAgICBzZXh1YWw6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwvbWlub3JzJy5cbiAgICAgKi9cbiAgICAnc2V4dWFsL21pbm9ycyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZScuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZS9ncmFwaGljJy5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgcG9saWN5IGNvbXBsaWFuY2UgcmVwb3J0IGJ5IE9wZW5BSSdzIGNvbnRlbnQgbW9kZXJhdGlvbiBtb2RlbCBhZ2FpbnN0XG4gKiBhIGdpdmVuIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBtb2RlcmF0aW9uIHJlcXVlc3QuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbW9kZXJhdGlvbiByZXN1bHRzLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIG1vZGVyYXRpb24gb2JqZWN0cy5cbiAgICovXG4gIHJlc3VsdHM6IEFycmF5PE1vZGVyYXRpb24+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGlucHV0IHRleHQgdG8gY2xhc3NpZnlcbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBUd28gY29udGVudCBtb2RlcmF0aW9ucyBtb2RlbHMgYXJlIGF2YWlsYWJsZTogYHRleHQtbW9kZXJhdGlvbi1zdGFibGVgIGFuZFxuICAgKiBgdGV4dC1tb2RlcmF0aW9uLWxhdGVzdGAuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGlzIGB0ZXh0LW1vZGVyYXRpb24tbGF0ZXN0YCB3aGljaCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXBncmFkZWRcbiAgICogb3ZlciB0aW1lLiBUaGlzIGVuc3VyZXMgeW91IGFyZSBhbHdheXMgdXNpbmcgb3VyIG1vc3QgYWNjdXJhdGUgbW9kZWwuIElmIHlvdSB1c2VcbiAgICogYHRleHQtbW9kZXJhdGlvbi1zdGFibGVgLCB3ZSB3aWxsIHByb3ZpZGUgYWR2YW5jZWQgbm90aWNlIGJlZm9yZSB1cGRhdGluZyB0aGVcbiAgICogbW9kZWwuIEFjY3VyYWN5IG9mIGB0ZXh0LW1vZGVyYXRpb24tc3RhYmxlYCBtYXkgYmUgc2xpZ2h0bHkgbG93ZXIgdGhhbiBmb3JcbiAgICogYHRleHQtbW9kZXJhdGlvbi1sYXRlc3RgLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgJ3RleHQtbW9kZXJhdGlvbi1sYXRlc3QnIHwgJ3RleHQtbW9kZXJhdGlvbi1zdGFibGUnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1vZGVyYXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uID0gQVBJLk1vZGVyYXRpb247XG4gIGV4cG9ydCBpbXBvcnQgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlID0gQVBJLk1vZGVyYXRpb25DcmVhdGVSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLk1vZGVyYXRpb25DcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0ICogYXMgUGFnaW5hdGlvbiBmcm9tICcuL3BhZ2luYXRpb24nO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vcmVzb3VyY2VzL2luZGV4JztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IHR5cGUgQWdlbnQgfSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5pbXBvcnQgKiBhcyBVcGxvYWRzIGZyb20gJy4vdXBsb2Fkcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudltcIk9QRU5BSV9BUElfS0VZXCJdLlxuICAgKi9cbiAgYXBpS2V5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSSwgZS5nLiwgXCJodHRwczovL2FwaS5leGFtcGxlLmNvbS92Mi9cIlxuICAgKi9cbiAgYmFzZVVSTD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB3YWl0IGZvciBhIHJlc3BvbnNlXG4gICAqIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgdGltaW5nIG91dCBhIHNpbmdsZSByZXF1ZXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcmVxdWVzdCB0aW1lb3V0cyBhcmUgcmV0cmllZCBieSBkZWZhdWx0LCBzbyBpbiBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8geW91IG1heSB3YWl0XG4gICAqIG11Y2ggbG9uZ2VyIHRoYW4gdGhpcyB0aW1lb3V0IGJlZm9yZSB0aGUgcHJvbWlzZSBzdWNjZWVkcyBvciBmYWlscy5cbiAgICovXG4gIHRpbWVvdXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChTKSBjb25uZWN0aW9ucy5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCBhbiBhZ2VudCB3aWxsIGJlIGNvbnN0cnVjdGVkIGJ5IGRlZmF1bHQgaW4gdGhlIE5vZGUuanMgZW52aXJvbm1lbnQsXG4gICAqIG90aGVyd2lzZSBubyBhZ2VudCBpcyB1c2VkLlxuICAgKi9cbiAgaHR0cEFnZW50PzogQWdlbnQ7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB3ZSB1c2UgYG5vZGUtZmV0Y2hgIG9uIE5vZGUuanMgYW5kIG90aGVyd2lzZSBleHBlY3QgdGhhdCBgZmV0Y2hgIGlzXG4gICAqIGRlZmluZWQgZ2xvYmFsbHkuXG4gICAqL1xuICBmZXRjaD86IENvcmUuRmV0Y2ggfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QgaW4gY2FzZSBvZiBhXG4gICAqIHRlbXBvcmFyeSBmYWlsdXJlLCBsaWtlIGEgbmV0d29yayBlcnJvciBvciBhIDVYWCBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgcmVtb3ZlZCBpbiBpbmRpdmlkdWFsIHJlcXVlc3RzIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB0aGVcbiAgICogaGVhZGVyIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAqL1xuICBkZWZhdWx0SGVhZGVycz86IENvcmUuSGVhZGVycztcblxuICAvKipcbiAgICogRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSByZW1vdmVkIGluIGluZGl2aWR1YWwgcmVxdWVzdHMgYnkgZXhwbGljaXRseSBzZXR0aW5nIHRoZVxuICAgKiBwYXJhbSB0byBgdW5kZWZpbmVkYCBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAqL1xuICBkZWZhdWx0UXVlcnk/OiBDb3JlLkRlZmF1bHRRdWVyeTtcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICogT25seSBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB1bmRlcnN0YW5kIHRoZSByaXNrcyBhbmQgaGF2ZSBhcHByb3ByaWF0ZSBtaXRpZ2F0aW9ucyBpbiBwbGFjZS5cbiAgICovXG4gIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyPzogYm9vbGVhbjtcblxuICBvcmdhbml6YXRpb24/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQUkgZXh0ZW5kcyBDb3JlLkFQSUNsaWVudCB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBvcmdhbml6YXRpb24/OiBzdHJpbmcgfCBudWxsO1xuXG4gIHByaXZhdGUgX29wdGlvbnM6IENsaWVudE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfS0VZJ11dIC0gVGhlIEFQSSBLZXkgdG8gc2VuZCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFzZVVSTF0gLSBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MTAgbWludXRlc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmh0dHBBZ2VudF0gLSBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAocykgY29ubmVjdGlvbnMuXG4gICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge0NvcmUuSGVhZGVyc30gb3B0cy5kZWZhdWx0SGVhZGVycyAtIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW29wdHMub3JnYW5pemF0aW9uXVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGFwaUtleSA9IENvcmUucmVhZEVudignT1BFTkFJX0FQSV9LRVknKSxcbiAgICBvcmdhbml6YXRpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9PUkdfSUQnKSA/PyBudWxsLFxuICAgIC4uLm9wdHNcbiAgfTogQ2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIlRoZSBPUEVOQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nIG9yIGVtcHR5OyBlaXRoZXIgcHJvdmlkZSBpdCwgb3IgaW5zdGFudGlhdGUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlLZXkgb3B0aW9uLCBsaWtlIG5ldyBPcGVuQUkoeyBhcGlLZXk6ICdteSBhcGlLZXknIH0pLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBDbGllbnRPcHRpb25zID0ge1xuICAgICAgYXBpS2V5LFxuICAgICAgb3JnYW5pemF0aW9uLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIGJhc2VVUkw6IG9wdHMuYmFzZVVSTCA/PyBgaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MWAsXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93QnJvd3NlciAmJiBDb3JlLmlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyLWxpa2UgZW52aXJvbm1lbnQuXFxuXFxuVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxcbklmIHlvdSB1bmRlcnN0YW5kIHRoZSByaXNrcyBhbmQgaGF2ZSBhcHByb3ByaWF0ZSBtaXRpZ2F0aW9ucyBpbiBwbGFjZSxcXG55b3UgY2FuIHNldCB0aGUgYGRhbmdlcm91c2x5QWxsb3dCcm93c2VyYCBvcHRpb24gdG8gYHRydWVgLCBlLmcuLFxcblxcbm5ldyBPcGVuQUkoeyBhcGlLZXksIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlIH0pO1xcblxcbmh0dHBzOi8vaGVscC5vcGVuYWkuY29tL2VuL2FydGljbGVzLzUxMTI1OTUtYmVzdC1wcmFjdGljZXMtZm9yLWFwaS1rZXktc2FmZXR5XFxuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIHN1cGVyKHtcbiAgICAgIGJhc2VVUkw6IG9wdGlvbnMuYmFzZVVSTCEsXG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgPz8gNjAwMDAwIC8qIDEwIG1pbnV0ZXMgKi8sXG4gICAgICBodHRwQWdlbnQ6IG9wdGlvbnMuaHR0cEFnZW50LFxuICAgICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgfSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB0aGlzLm9yZ2FuaXphdGlvbiA9IG9yZ2FuaXphdGlvbjtcbiAgfVxuXG4gIGNvbXBsZXRpb25zOiBBUEkuQ29tcGxldGlvbnMgPSBuZXcgQVBJLkNvbXBsZXRpb25zKHRoaXMpO1xuICBjaGF0OiBBUEkuQ2hhdCA9IG5ldyBBUEkuQ2hhdCh0aGlzKTtcbiAgZWRpdHM6IEFQSS5FZGl0cyA9IG5ldyBBUEkuRWRpdHModGhpcyk7XG4gIGVtYmVkZGluZ3M6IEFQSS5FbWJlZGRpbmdzID0gbmV3IEFQSS5FbWJlZGRpbmdzKHRoaXMpO1xuICBmaWxlczogQVBJLkZpbGVzID0gbmV3IEFQSS5GaWxlcyh0aGlzKTtcbiAgaW1hZ2VzOiBBUEkuSW1hZ2VzID0gbmV3IEFQSS5JbWFnZXModGhpcyk7XG4gIGF1ZGlvOiBBUEkuQXVkaW8gPSBuZXcgQVBJLkF1ZGlvKHRoaXMpO1xuICBtb2RlcmF0aW9uczogQVBJLk1vZGVyYXRpb25zID0gbmV3IEFQSS5Nb2RlcmF0aW9ucyh0aGlzKTtcbiAgbW9kZWxzOiBBUEkuTW9kZWxzID0gbmV3IEFQSS5Nb2RlbHModGhpcyk7XG4gIGZpbmVUdW5pbmc6IEFQSS5GaW5lVHVuaW5nID0gbmV3IEFQSS5GaW5lVHVuaW5nKHRoaXMpO1xuICBmaW5lVHVuZXM6IEFQSS5GaW5lVHVuZXMgPSBuZXcgQVBJLkZpbmVUdW5lcyh0aGlzKTtcblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdFF1ZXJ5KCk6IENvcmUuRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5kZWZhdWx0UXVlcnk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMob3B0cyksXG4gICAgICAnT3BlbkFJLU9yZ2FuaXphdGlvbic6IHRoaXMub3JnYW5pemF0aW9uLFxuICAgICAgLi4udGhpcy5fb3B0aW9ucy5kZWZhdWx0SGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGF1dGhIZWFkZXJzKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9ucyk6IENvcmUuSGVhZGVycyB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWAgfTtcbiAgfVxuXG4gIHN0YXRpYyBPcGVuQUkgPSB0aGlzO1xuXG4gIHN0YXRpYyBPcGVuQUlFcnJvciA9IEVycm9ycy5PcGVuQUlFcnJvcjtcbiAgc3RhdGljIEFQSUVycm9yID0gRXJyb3JzLkFQSUVycm9yO1xuICBzdGF0aWMgQVBJQ29ubmVjdGlvbkVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25FcnJvcjtcbiAgc3RhdGljIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgPSBFcnJvcnMuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbiAgc3RhdGljIEFQSVVzZXJBYm9ydEVycm9yID0gRXJyb3JzLkFQSVVzZXJBYm9ydEVycm9yO1xuICBzdGF0aWMgTm90Rm91bmRFcnJvciA9IEVycm9ycy5Ob3RGb3VuZEVycm9yO1xuICBzdGF0aWMgQ29uZmxpY3RFcnJvciA9IEVycm9ycy5Db25mbGljdEVycm9yO1xuICBzdGF0aWMgUmF0ZUxpbWl0RXJyb3IgPSBFcnJvcnMuUmF0ZUxpbWl0RXJyb3I7XG4gIHN0YXRpYyBCYWRSZXF1ZXN0RXJyb3IgPSBFcnJvcnMuQmFkUmVxdWVzdEVycm9yO1xuICBzdGF0aWMgQXV0aGVudGljYXRpb25FcnJvciA9IEVycm9ycy5BdXRoZW50aWNhdGlvbkVycm9yO1xuICBzdGF0aWMgSW50ZXJuYWxTZXJ2ZXJFcnJvciA9IEVycm9ycy5JbnRlcm5hbFNlcnZlckVycm9yO1xuICBzdGF0aWMgUGVybWlzc2lvbkRlbmllZEVycm9yID0gRXJyb3JzLlBlcm1pc3Npb25EZW5pZWRFcnJvcjtcbiAgc3RhdGljIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciA9IEVycm9ycy5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3I7XG59XG5cbmV4cG9ydCBjb25zdCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgQ29uZmxpY3RFcnJvcixcbiAgUmF0ZUxpbWl0RXJyb3IsXG4gIEJhZFJlcXVlc3RFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvcixcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgUGVybWlzc2lvbkRlbmllZEVycm9yLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IsXG59ID0gRXJyb3JzO1xuXG5leHBvcnQgaW1wb3J0IHRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuZXhwb3J0IGltcG9ydCBmaWxlRnJvbVBhdGggPSBVcGxvYWRzLmZpbGVGcm9tUGF0aDtcblxuZXhwb3J0IG5hbWVzcGFjZSBPcGVuQUkge1xuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIGV4cG9ydCBpbXBvcnQgdG9GaWxlID0gVXBsb2Fkcy50b0ZpbGU7XG4gIGV4cG9ydCBpbXBvcnQgZmlsZUZyb21QYXRoID0gVXBsb2Fkcy5maWxlRnJvbVBhdGg7XG5cbiAgZXhwb3J0IGltcG9ydCBSZXF1ZXN0T3B0aW9ucyA9IENvcmUuUmVxdWVzdE9wdGlvbnM7XG5cbiAgZXhwb3J0IGltcG9ydCBQYWdlID0gUGFnaW5hdGlvbi5QYWdlO1xuICBleHBvcnQgaW1wb3J0IFBhZ2VSZXNwb25zZSA9IFBhZ2luYXRpb24uUGFnZVJlc3BvbnNlO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ3Vyc29yUGFnZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBDdXJzb3JQYWdlUGFyYW1zID0gUGFnaW5hdGlvbi5DdXJzb3JQYWdlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEN1cnNvclBhZ2VSZXNwb25zZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZVJlc3BvbnNlO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBBUEkuQ29tcGxldGlvbnM7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbiA9IEFQSS5Db21wbGV0aW9uO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DaG9pY2UgPSBBUEkuQ29tcGxldGlvbkNob2ljZTtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uVXNhZ2UgPSBBUEkuQ29tcGxldGlvblVzYWdlO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ2hhdCA9IEFQSS5DaGF0O1xuXG4gIGV4cG9ydCBpbXBvcnQgRWRpdHMgPSBBUEkuRWRpdHM7XG4gIGV4cG9ydCBpbXBvcnQgRWRpdCA9IEFQSS5FZGl0O1xuICBleHBvcnQgaW1wb3J0IEVkaXRDcmVhdGVQYXJhbXMgPSBBUEkuRWRpdENyZWF0ZVBhcmFtcztcblxuICBleHBvcnQgaW1wb3J0IEVtYmVkZGluZ3MgPSBBUEkuRW1iZWRkaW5ncztcbiAgZXhwb3J0IGltcG9ydCBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSA9IEFQSS5DcmVhdGVFbWJlZGRpbmdSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBFbWJlZGRpbmcgPSBBUEkuRW1iZWRkaW5nO1xuICBleHBvcnQgaW1wb3J0IEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyA9IEFQSS5FbWJlZGRpbmdDcmVhdGVQYXJhbXM7XG5cbiAgZXhwb3J0IGltcG9ydCBGaWxlcyA9IEFQSS5GaWxlcztcbiAgZXhwb3J0IGltcG9ydCBGaWxlQ29udGVudCA9IEFQSS5GaWxlQ29udGVudDtcbiAgZXhwb3J0IGltcG9ydCBGaWxlRGVsZXRlZCA9IEFQSS5GaWxlRGVsZXRlZDtcbiAgZXhwb3J0IGltcG9ydCBGaWxlT2JqZWN0ID0gQVBJLkZpbGVPYmplY3Q7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZU9iamVjdHNQYWdlID0gQVBJLkZpbGVPYmplY3RzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBGaWxlQ3JlYXRlUGFyYW1zID0gQVBJLkZpbGVDcmVhdGVQYXJhbXM7XG5cbiAgZXhwb3J0IGltcG9ydCBJbWFnZXMgPSBBUEkuSW1hZ2VzO1xuICBleHBvcnQgaW1wb3J0IEltYWdlID0gQVBJLkltYWdlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlc1Jlc3BvbnNlID0gQVBJLkltYWdlc1Jlc3BvbnNlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zID0gQVBJLkltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEltYWdlRWRpdFBhcmFtcyA9IEFQSS5JbWFnZUVkaXRQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgSW1hZ2VHZW5lcmF0ZVBhcmFtcyA9IEFQSS5JbWFnZUdlbmVyYXRlUGFyYW1zO1xuXG4gIGV4cG9ydCBpbXBvcnQgQXVkaW8gPSBBUEkuQXVkaW87XG5cbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9ucyA9IEFQSS5Nb2RlcmF0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uID0gQVBJLk1vZGVyYXRpb247XG4gIGV4cG9ydCBpbXBvcnQgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlID0gQVBJLk1vZGVyYXRpb25DcmVhdGVSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLk1vZGVyYXRpb25DcmVhdGVQYXJhbXM7XG5cbiAgZXhwb3J0IGltcG9ydCBNb2RlbHMgPSBBUEkuTW9kZWxzO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsID0gQVBJLk1vZGVsO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsRGVsZXRlZCA9IEFQSS5Nb2RlbERlbGV0ZWQ7XG4gIGV4cG9ydCBpbXBvcnQgTW9kZWxzUGFnZSA9IEFQSS5Nb2RlbHNQYWdlO1xuXG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmluZyA9IEFQSS5GaW5lVHVuaW5nO1xuXG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVzID0gQVBJLkZpbmVUdW5lcztcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZSA9IEFQSS5GaW5lVHVuZTtcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZUV2ZW50ID0gQVBJLkZpbmVUdW5lRXZlbnQ7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2UgPSBBUEkuRmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2U7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVzUGFnZSA9IEFQSS5GaW5lVHVuZXNQYWdlO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lQ3JlYXRlUGFyYW1zID0gQVBJLkZpbmVUdW5lQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtcyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNTdHJlYW1pbmcgPSBBUEkuRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBPcGVuQUk7XG4iLCAiaW1wb3J0IE9wZW5BSSBmcm9tIFwib3BlbmFpXCI7XHJcblxyXG5pbXBvcnQge1xyXG5cdFBpbmVjb25lLFxyXG5cdFBpbmVjb25lUmVjb3JkLFxyXG5cdFJlY29yZE1ldGFkYXRhLFxyXG59IGZyb20gXCJAcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmVcIjtcclxuaW1wb3J0IHBsdWdpbkhhbmRsZXIgZnJvbSBcIi4vZ2xvYmFsSGFuZGxlcnNcIjtcclxuaW1wb3J0IHsgTWFya2Rvd25WaWV3LCBURmlsZSwgcGFyc2VMaW5rdGV4dCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBhZGRSZXF1aXJlbWVudCB9IGZyb20gXCIuL3RlbXBsYXRlc1wiO1xyXG5pbXBvcnQgeyBpbnNlcnRNYXJrZG93blVuZGVySGVhZGluZyB9IGZyb20gXCIuL2ZpbGVzXCI7XHJcbi8vIGltcG9ydCB7IHJlcXVpcmVtZW50c0RCIH0gZnJvbSBcIi4vZGF0YWJhc2VBZGFwdGVyXCI7XHJcblxyXG5jb25zdCBwaW5lY29uZSA9IG5ldyBQaW5lY29uZSh7XHJcblx0YXBpS2V5OiBcIjgxZjU2ZDgxLWI2ZmYtNGFmNC1iM2Y1LTMxMDhkNzMwYmI4OFwiLFxyXG5cdGVudmlyb25tZW50OiBcImdjcC1zdGFydGVyXCIsXHJcbn0pO1xyXG5cclxuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7XHJcblx0YXBpS2V5OiBcInNrLUpqaEQ1M1Q0bUpHQmVCNmlJS0ZrVDNCbGJrRkpCYmpsZ0N6RUxpdFJFSlB4amx2Q1wiLCAvLyBkZWZhdWx0cyB0byBwcm9jZXNzLmVudltcIk9QRU5BSV9BUElfS0VZXCJdXHJcblx0ZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsXHJcbn0pO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0RW1iZWRNYXJrZG93bih7XHJcblx0cGF0aCxcclxuXHRzdWJwYXRoLFxyXG59OiB7XHJcblx0cGF0aDogc3RyaW5nO1xyXG5cdHN1YnBhdGg6IHN0cmluZztcclxufSkge1xyXG5cdGNvbnN0IHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQgfSA9IGFwcDtcclxuXHRjb25zdCBmaWxlID0gbWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCBcIlwiKSBhcyBURmlsZTtcclxuXHRjb25zdCBoZWFkaW5ncyA9IG1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5oZWFkaW5ncyA/PyBbXTtcclxuXHRsZXQgdGV4dCA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblx0aWYgKHN1YnBhdGgpIHtcclxuXHRcdGNvbnN0IGhJZHggPSBoZWFkaW5ncy5maW5kSW5kZXgoXHJcblx0XHRcdCh7IGhlYWRpbmcgfTogYW55KSA9PiBoZWFkaW5nID09PSBzdWJwYXRoXHJcblx0XHQpO1xyXG5cdFx0aWYgKGhJZHggPT09IC0xKSB7XHJcblx0XHRcdHRleHQgPSBcIlwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGV4dCA9IHRleHRcclxuXHRcdFx0XHQuc3BsaXQoXCJcXG5cIilcclxuXHRcdFx0XHQuc2xpY2UoXHJcblx0XHRcdFx0XHRoZWFkaW5nc1toSWR4XS5wb3NpdGlvbi5zdGFydC5saW5lICsgMSxcclxuXHRcdFx0XHRcdGhlYWRpbmdzW2hJZHggKyAxXT8ucG9zaXRpb24/LnN0YXJ0Py5saW5lXHJcblx0XHRcdFx0KVxyXG5cdFx0XHRcdC5qb2luKFwiIFwiKVxyXG5cdFx0XHRcdC50cmltKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0ZXh0XHJcblx0XHQuc3BsaXQoXCJcXG5cIilcclxuXHRcdC5tYXAoKGxpbmU6IHN0cmluZykgPT4gbGluZS50cmltKCkpXHJcblx0XHQuam9pbihcIiBcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRlcmZhY2VzVGFibGUoZmlsZTogVEZpbGUpIHtcclxuXHRjb25zdCB7IGRhdGF2aWV3OiBkdiB9ID0gcGx1Z2luSGFuZGxlci5nZXRQbHVnaW5zKCk7XHJcblx0Y29uc3QgYXBwID0gcGx1Z2luSGFuZGxlci5hcHA7XHJcblxyXG5cdGNvbnN0IHJlbmRlciA9IFtdO1xyXG5cclxuXHRjb25zdCBjb25uZWN0aW9uc0pzb24gPSBKU09OLnBhcnNlKFxyXG5cdFx0YXdhaXQgYXBwLnZhdWx0LnJlYWQoXHJcblx0XHRcdGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KFxyXG5cdFx0XHRcdFwiU3lzdGVtIERpYWdyYW0uY2FudmFzXCIsXHJcblx0XHRcdFx0XCJcIlxyXG5cdFx0XHQpIGFzIFRGaWxlXHJcblx0XHQpXHJcblx0KTtcclxuXHJcblx0Ly8ge1wiaWRcIjpcIjk4ZjMyYWE5Y2ZlZGU5YjVcIixcInR5cGVcIjpcImdyb3VwXCIsXCJmaWxlXCI6XCJSb2NrZXQgU3lzdGVtcy9SZWNvdmVyeS9Ob3NlY29uZSBFamVjdGlvbiBTeXN0ZW0ubWRcIixcInhcIjo3NDAsXCJ5XCI6LTQyMCxcIndpZHRoXCI6MjYwLFwiaGVpZ2h0XCI6MTIwLFwibGFiZWxcIjpcIk5vc2Vjb25lIEVqZWN0aW9uIFN5c3RlbVwifSxcclxuXHRjb25zdCB0aGlzTm9kZSA9IGNvbm5lY3Rpb25zSnNvbi5ub2Rlcy5maW5kKChub2RlOiBhbnkpID0+XHJcblx0XHRmaWxlLnBhdGguaW5jbHVkZXMobm9kZS5maWxlKVxyXG5cdCk7XHJcblxyXG5cdC8vIHtcImlkXCI6XCI3NzQzYmI0MzVkODMxMWE3XCIsXCJmcm9tTm9kZVwiOlwiOThmMzJhYTljZmVkZTliNVwiLFwiZnJvbVNpZGVcIjpcImJvdHRvbVwiLFwidG9Ob2RlXCI6XCIyYzJiZmVlMzRjOGI1NDc2XCIsXCJ0b1NpZGVcIjpcInJpZ2h0XCIsXCJsYWJlbFwiOlwiXHUyNkEwXHVGRTBGXCJ9LFxyXG5cclxuXHRjb25zdCBjb25uZWN0aW5nVG8gPSBjb25uZWN0aW9uc0pzb24uZWRnZXMuZmlsdGVyKFxyXG5cdFx0KGVkZ2U6IGFueSkgPT4gZWRnZS5mcm9tTm9kZSA9PT0gdGhpc05vZGUuaWRcclxuXHQpO1xyXG5cdGNvbnN0IGNvbm5lY3RpbmdGcm9tID0gY29ubmVjdGlvbnNKc29uLmVkZ2VzLmZpbHRlcihcclxuXHRcdChlZGdlOiBhbnkpID0+IGVkZ2UudG9Ob2RlID09PSB0aGlzTm9kZS5pZFxyXG5cdCk7XHJcblxyXG5cdGNvbnN0IGNvbm5lY3Rpb25zID0gWy4uLmNvbm5lY3RpbmdUbywgLi4uY29ubmVjdGluZ0Zyb21dO1xyXG5cclxuXHRmb3IgKGxldCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25zKSB7XHJcblx0XHQvLyBnZXQgdGhlIGZpbGUgdGhhdCB0aGUgY29ubmVjdGlvbiBpcyBwb2ludGluZyB0byBhbmQgdGhlIGludGVyZmFjZSBuYW1lXHJcblx0XHRjb25zdCBpbnQgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChcclxuXHRcdFx0Y29ubmVjdGlvbi5sYWJlbCxcclxuXHRcdFx0XCJcIlxyXG5cdFx0KSBhcyBURmlsZTtcclxuXHJcblx0XHRjb25zdCBub2RlID0gY29ubmVjdGlvbnNKc29uLm5vZGVzLmZpbmQoXHJcblx0XHRcdChub2RlOiBhbnkpID0+XHJcblx0XHRcdFx0KGNvbm5lY3Rpb24uZnJvbU5vZGUgPT09IG5vZGUuaWQgJiZcclxuXHRcdFx0XHRcdGNvbm5lY3Rpb24udG9Ob2RlID09PSB0aGlzTm9kZS5pZCkgfHxcclxuXHRcdFx0XHQoY29ubmVjdGlvbi50b05vZGUgPT09IG5vZGUuaWQgJiZcclxuXHRcdFx0XHRcdGNvbm5lY3Rpb24uZnJvbU5vZGUgPT09IHRoaXNOb2RlLmlkKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBub2RlRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KG5vZGUuZmlsZSwgXCJcIik7XHJcblxyXG5cdFx0cmVuZGVyLnB1c2goW1xyXG5cdFx0XHRpbnQgPyBgW1ske2ludC5iYXNlbmFtZX1dXWAgOiBcIk5vbmVcdTI2QTBcdUZFMEZcIixcclxuXHRcdFx0YFtbJHtub2RlRmlsZT8uYmFzZW5hbWV9XV1gLFxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRjb25zdCB0YWJsZU1hcmtkb3duID0gcmVuZGVyLmxlbmd0aFxyXG5cdFx0PyBcIlxcblwiICsgZHYubWFya2Rvd25UYWJsZShbXCJJbnRlcmZhY2UgTmFtZVwiLCBcIkNvbm5lY3RpbmcgVG9cIl0sIHJlbmRlcilcclxuXHRcdDogXCJcIjtcclxuXHRyZXR1cm4gdGFibGVNYXJrZG93bjtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RzVGFibGUoZmlsZTogVEZpbGUpIHtcclxuXHRjb25zdCB7IGRhdGF2aWV3OiBkdiwgc2thX3NlIH0gPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKTtcclxuXHRjb25zdCBhcHAgPSBwbHVnaW5IYW5kbGVyLmFwcDtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSBhcyBURmlsZSk7XHJcblxyXG5cdGNvbnN0IHRlc3RzID0gZHZcclxuXHRcdC5wYWdlcyhgXCIke3NrYV9zZS5zZXR0aW5ncy50ZXN0X2RvY3VtZW50YXRpb25fcm9vdF9mb2xkZXJ9XCJgKVxyXG5cdFx0LndoZXJlKCh0ZXN0OiBhbnkpID0+IHtcclxuXHRcdFx0cmV0dXJuIHRlc3QuU3lzdGVtICYmIHRlc3QuU3lzdGVtLnBhdGguaW5jbHVkZXMoZmlsZS5wYXRoKTtcclxuXHRcdH0pLnZhbHVlcztcclxuXHJcblx0aWYgKHRlc3RzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiXCI7XHJcblxyXG5cdC8vbW9kaWZ5IHRoZSB0ZXN0cyBsaXN0LiAxLiBGaW5kIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIgXCJTeXN0ZW0gVGVzdHNcIi4gMi4gaW5zZXJ0IHRoZSB0ZXN0cyBsaXN0IGFmdGVyIHRoZSBoZWFkZXJcclxuXHRjb25zdCB0ZXN0c1NlY3Rpb24gPSBjYWNoZT8uaGVhZGluZ3M/LmZpbmQoXHJcblx0XHQoaCkgPT4gaC5oZWFkaW5nID09PSBcIlN5c3RlbSBUZXN0c1wiXHJcblx0KTtcclxuXHRjb25zdCB0ZXN0c0hlYWRpbmdJbmRleCA9IGNhY2hlPy5zZWN0aW9ucz8uZmluZEluZGV4KFxyXG5cdFx0KHNlY3Rpb24pID0+XHJcblx0XHRcdHNlY3Rpb24ucG9zaXRpb24uc3RhcnQubGluZSA9PT0gdGVzdHNTZWN0aW9uPy5wb3NpdGlvbi5zdGFydC5saW5lXHJcblx0KTtcclxuXHJcblx0Y29uc3QgbGlzdERhdGEgPVxyXG5cdFx0XCJcXG5cIiArXHJcblx0XHRkdi5tYXJrZG93bkxpc3QoXHJcblx0XHRcdHRlc3RzLm1hcChcclxuXHRcdFx0XHQodGVzdDogYW55KSA9PlxyXG5cdFx0XHRcdFx0YFtbJHt0ZXN0LmZpbGUucGF0aH18JHt0ZXN0LmZpbGUubmFtZX1dXSAke1xyXG5cdFx0XHRcdFx0XHR0ZXN0LlN0YXR1cyA9PT0gXCJzdWNjZXNzXCIgPyBcIlxcdFx1MjcwNVwiIDogXCJcXHRcdTI3NENcIlxyXG5cdFx0XHRcdFx0fWBcclxuXHRcdFx0KVxyXG5cdFx0KTtcclxuXHJcblx0cmV0dXJuIGxpc3REYXRhID8/IFwiXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXF1aXJlbWVudHNUYWJsZTIoZmlsZTogVEZpbGUpIHtcclxuXHRjb25zdCB7IGRhdGF2aWV3OiBkdiwgc2thX3NlIH0gPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKTtcclxuXHRjb25zdCBhcHAgPSBwbHVnaW5IYW5kbGVyLmFwcDtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSBhcyBURmlsZSk7XHJcblxyXG5cdGNvbnN0IHRoaXNSZXF1aXJlbWVudHMgPSBkdlxyXG5cdFx0LnBhZ2VzKGBcIiR7c2thX3NlLnNldHRpbmdzLnN5c3RlbV9kZXNpZ25fcm9vdF9mb2xkZXJ9L1JlcXVpcmVtZW50c1wiYClcclxuXHRcdC53aGVyZSgocmVxOiBhbnkpID0+IHtcclxuXHRcdFx0cmV0dXJuIHJlcS5TeXN0ZW0gJiYgcmVxLlN5c3RlbSA9PSBjYWNoZT8uZnJvbnRtYXR0ZXI/LklEO1xyXG5cdFx0fSkudmFsdWVzO1xyXG5cclxuXHRpZiAodGhpc1JlcXVpcmVtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBcIlwiO1xyXG5cclxuXHQvLyBleHRyYWN0IHRoZSByZXF1aXJlbWVudHMgZGF0YSBmcm9tIHRoZSB0aGlzUmVxdWlyZW1lbnRzIGxpc3RcclxuXHJcblx0Y29uc3QgdGFibGVWYWx1ZXM6IFtzdHJpbmcsIHN0cmluZ11bXSA9IFtdO1xyXG5cclxuXHRmb3IgKGNvbnN0IHJlcSBvZiB0aGlzUmVxdWlyZW1lbnRzKSB7XHJcblx0XHRjb25zdCB0b1JldHVybjogW3N0cmluZywgc3RyaW5nXSA9IFtcIlwiLCBcIlwiXTtcclxuXHRcdHRvUmV0dXJuWzBdID0gYXdhaXQgZ2V0RW1iZWRNYXJrZG93bih7XHJcblx0XHRcdHBhdGg6IHJlcS5maWxlLnBhdGgsXHJcblx0XHRcdHN1YnBhdGg6IFwiRGVzY3JpcHRpb25cIixcclxuXHRcdH0pO1xyXG5cdFx0dG9SZXR1cm5bMV0gPSBcIltbXCIgKyByZXEuZmlsZS5wYXRoLnNwbGl0KFwiL1wiKS5wb3AoKSArIFwiXV1cIjtcclxuXHRcdHRhYmxlVmFsdWVzLnB1c2godG9SZXR1cm4pO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgdGFibGVIZWFkZXJzID0gW1wiRGVzY3JpcHRpb25cIiwgXCJTb3VyY2VcIl07XHJcblxyXG5cdGNvbnN0IHRhYmxlTWFya2Rvd24gPSBcIlxcblwiICsgZHYubWFya2Rvd25UYWJsZSh0YWJsZUhlYWRlcnMsIHRhYmxlVmFsdWVzKTtcclxuXHRyZXR1cm4gdGFibGVNYXJrZG93biA/PyBcIlwiO1xyXG59XHJcblxyXG50eXBlIFZlY3RvclR5cGUgPSB7XHJcblx0aWQ6IHN0cmluZztcclxuXHRkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG5cdHNvdXJjZTogc3RyaW5nO1xyXG5cdHN5c3RlbTogc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXBhcmVSZXF1aXJlbWVudHMoXHJcblx0cmVzOiBQaW5lY29uZVJlY29yZDxSZWNvcmRNZXRhZGF0YT4gfCB1bmRlZmluZWRcclxuKSB7XHJcblx0Ly8gdGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gYSBzZWFyY2ggaW4gYSB2ZWN0b3IgZGF0YWJhc2UgYW5kIHJldHVybiBhIGxpc3Qgb2YgcmVxdWlyZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHNlYXJjaCBhYm92ZSBhIGNlcnRhaW4gdGhyZXNob2xkXHJcblx0Ly8gdGhlIHRocmVzaG9sZCBpcyBzZXQgdG8gMC43IGZvciBub3csIGJ1dCBjYW4gYmUgY2hhbmdlZCBsYXRlclxyXG5cdC8vIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzLCBjb25mbGljdGluZyByZXF1aXJlbWVudCBzaG91bGQgYmUgcmV0dXJuZWRcclxuXHJcblx0aWYgKCFyZXMpIHJldHVybjtcclxuXHJcblx0Y29uc3Qgc2VhcmNoUmVzdWx0ID0gYXdhaXQgcGluZWNvbmUuaW5kZXgoXCJyZXF1aXJlbWVudHNcIikucXVlcnkoe1xyXG5cdFx0dmVjdG9yOiByZXMudmFsdWVzLFxyXG5cdFx0dG9wSzogMTAsXHJcblx0XHRpbmNsdWRlTWV0YWRhdGE6IHRydWUsXHJcblx0fSk7XHJcblxyXG5cdGNvbnN0IHBvdGVudGlhbENvbmZsaWN0cyA9IHNlYXJjaFJlc3VsdC5tYXRjaGVzXHJcblx0XHQ/LmZpbHRlcihcclxuXHRcdFx0KG1hdGNoKSA9PlxyXG5cdFx0XHRcdG1hdGNoLnNjb3JlICYmXHJcblx0XHRcdFx0bWF0Y2guc2NvcmUgPiAwLjkgJiZcclxuXHRcdFx0XHRtYXRjaC5zY29yZSA8IDAuOTkgJiZcclxuXHRcdFx0XHRtYXRjaC5tZXRhZGF0YT8uZGVzY3JpcHRpb24gIT09IHJlcy5tZXRhZGF0YT8uZGVzY3JpcHRpb25cclxuXHRcdClcclxuXHRcdC5tYXAoXHJcblx0XHRcdChtYXRjaCkgPT5cclxuXHRcdFx0XHRcIi0gXCIgK1xyXG5cdFx0XHRcdG1hdGNoLm1ldGFkYXRhPy5kZXNjcmlwdGlvbiArXHJcblx0XHRcdFx0YFxcbkZpbGUgcGF0aDogJHttYXRjaC5tZXRhZGF0YT8ucGF0aH1gXHJcblx0XHQpXHJcblx0XHQuam9pbihcIlxcblxcblwiKTtcclxuXHJcblx0aWYgKCFwb3RlbnRpYWxDb25mbGljdHMgfHwgcG90ZW50aWFsQ29uZmxpY3RzID09PSBcIlwiKSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIk5vIGNvbmZsaWN0cyBmb3VuZFwiKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGNvbnNvbGUubG9nKHBvdGVudGlhbENvbmZsaWN0cyk7XHJcblxyXG5cdGNvbnN0IHByb21wdCA9IGBHaXZlbiByZXF1aXJlbWVudDpcclxuXHRcdCR7cmVzLm1ldGFkYXRhPy5kZXNjcmlwdGlvbn1cclxuXHRcdFxyXG5cdFx0UmVxdWlyZW1lbnRzIHRvIGNvbXBhcmUgdG86XHJcblx0XHQke3BvdGVudGlhbENvbmZsaWN0c31cclxuXHJcblx0XHQtLS1cclxuXHRcdEFyZSB0aGVyZSBhbnkgY29uZmxpY3RzIGJldHdlZW4gdGhlIGdpdmVuIHJlcXVpcmVtZW50IGFuZCB0aGUgcmVxdWlyZW1lbnRzIHRvIGNvbXBhcmU/IFlFUy9OTyAtIHNob3J0IHJlYXNvbmluZyAtIFtbZmlsZSBwYXRoXV1gO1xyXG5cclxuXHRjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xyXG5cdFx0bW9kZWw6IFwiZ3B0LTRcIixcclxuXHRcdG1lc3NhZ2VzOiBbXHJcblx0XHRcdHtcclxuXHRcdFx0XHRyb2xlOiBcInN5c3RlbVwiLFxyXG5cdFx0XHRcdGNvbnRlbnQ6IGBZb3UgYXJlIGFuIGVuZ2luZWVyaW5nIGFzc2lzdGFudCB0YXNrZWQgd2l0aCBjb21wYXJpbmcgYSBzZXQgb2YgcmVxdWlyZW1lbnRzIGFuZCBkZXRlY3RpbmcgaWYgdGhlcmUgYXJlIGFueSBwb3RlbnRpYWwgY29uZmxpY3RzIGJldHdlZW4gdGhlbS5cclxuXHRcdFx0XHRcdFlvdSBzaG91bGQgb25seSByZXNwb25kIGluIGEgZm9sbG93aW5nIGZvcm1hdDogWUVTL05PL1VOQ0xFQVIgLSBzaG9ydCByZWFzb25pbmcgLSBbW2ZpbGUgcGF0aF1dLiBSZW1lbWJlciBhYm91dCB0aGUgZG91YmxlIGJyYWNrZXRzIGFyb3VuZCB0aGUgZmlsZSBwYXRoLlxyXG5cdFx0XHRcdFx0UmVtZW1iZXIgdG8gcHJvdmlkZSByZWFzb25pbmcgaW4gYSBzaG9ydCBidXQgY2xlYXIgd2F5LiBJZiB0aGUgYW5zd2VyIGlzIFlFUywgeW91IHNob3VsZCBhbHNvIHByb3ZpZGUgYSBicmllZiBkZXNjcmlwdGlvbiBvZiBhIHBvc3NpYmxlIHdheXMgdG8gcmVzb2x2ZSB0aGUgaXNzdWUuXHJcblx0XHRcdFx0XHRJZiB0aGUgYW5zd2VyIGlzIFVOQ0xFQVIgcHJvdmlkZSBhIHNob3J0IGluc3RydWN0aW9uIG9uIGhvdyB0aGUgcmVxdWlyZW1lbnQgY2FuIGJlIGltcHJvdmVkLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29uZmxpY3RzLCBwcm92aWRlIGEgcmVzcG9uc2Ugb25seSBmb3IgdGhlIG9uZSB0aGF0IGlzIGNvbmZsaWN0aW5nYCxcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJvbGU6IFwidXNlclwiLFxyXG5cdFx0XHRcdGNvbnRlbnQ6IHByb21wdCxcclxuXHRcdFx0fSxcclxuXHRcdF0sXHJcblx0fSk7XHJcblxyXG5cdHJldHVybiByZXN1bHQuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRFbWJlZCh2YWx1ZTogVmVjdG9yVHlwZSwgZmlsZTogeyBwYXRoOiBzdHJpbmcgfSkge1xyXG5cdC8vIHRoaXMgY2FuIGJlIGFkanVzdGVkIHRvIGNyZWF0ZSBhIGJldHRlciBlbWJlZGRpbmcsIGFkZGluZyBtb3JlIGNvbnRleHQgdG8gdGhlIGlucHV0XHJcblx0Y29uc3QgdGV4dCA9IGBTeXN0ZW06IFxyXG5cdFx0JHt2YWx1ZS5zeXN0ZW19XHJcblxyXG5cdFx0RGVzY3JpcHRpb246XHJcblx0XHQke3ZhbHVlLmRlc2NyaXB0aW9ufVxyXG5cclxuXHRcdFNvdXJjZTpcclxuXHRcdCR7dmFsdWUuc291cmNlfWA7XHJcblxyXG5cdGNvbnN0IHJlcyA9IChhd2FpdCBwaW5lY29uZS5pbmRleChcInJlcXVpcmVtZW50c1wiKS5mZXRjaChbdmFsdWUuaWRdKSlcclxuXHRcdC5yZWNvcmRzPy5bdmFsdWUuaWRdO1xyXG5cclxuXHQvL2NvbXBhcmUgdGhlIHJlcyBvYmplY3Qgd2l0aCB0aGUgcGFzc2VkIHZhbHVlXHJcblx0Ly9pZiB0aGV5IGFyZSB0aGUgc2FtZSwgcmV0dXJuXHJcblx0Ly9lbHNlLCB1cGRhdGUgdGhlIGVtYmVkZGluZ1xyXG5cdGlmIChcclxuXHRcdHJlcz8ubWV0YWRhdGE/LmRlc2NyaXB0aW9uID09PSB2YWx1ZS5kZXNjcmlwdGlvbiAmJlxyXG5cdFx0cmVzLm1ldGFkYXRhLnNvdXJjZSA9PT0gdmFsdWUuc291cmNlXHJcblx0KSB7XHJcblx0XHRpZiAocmVzPy5tZXRhZGF0YT8ucGF0aCAhPT0gZmlsZS5wYXRoKSB7XHJcblx0XHRcdGF3YWl0IHBpbmVjb25lXHJcblx0XHRcdFx0LmluZGV4KFwicmVxdWlyZW1lbnRzXCIpXHJcblx0XHRcdFx0LnVwZGF0ZSh7IGlkOiByZXMuaWQsIG1ldGFkYXRhOiB7IHBhdGg6IGZpbGUucGF0aCB9IH0pO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdC4uLnJlcyxcclxuXHRcdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdFx0Li4ucmVzLm1ldGFkYXRhLFxyXG5cdFx0XHRcdFx0cGF0aDogZmlsZS5wYXRoLFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y29uc3QgZW1iZWRkaW5nID0gYXdhaXQgb3BlbmFpLmVtYmVkZGluZ3MuY3JlYXRlKHtcclxuXHRcdGlucHV0OiB0ZXh0LFxyXG5cdFx0bW9kZWw6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLFxyXG5cdH0pO1xyXG5cclxuXHRhd2FpdCBwaW5lY29uZS5pbmRleChcInJlcXVpcmVtZW50c1wiKS51cHNlcnQoW1xyXG5cdFx0e1xyXG5cdFx0XHRpZDogdmFsdWUuaWQsXHJcblx0XHRcdHZhbHVlczogZW1iZWRkaW5nLmRhdGFbMF0uZW1iZWRkaW5nLFxyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvbixcclxuXHRcdFx0XHRzb3VyY2U6IHZhbHVlLnNvdXJjZSxcclxuXHRcdFx0XHRzeXN0ZW06IHZhbHVlLnN5c3RlbSxcclxuXHRcdFx0XHRwYXRoOiBmaWxlLnBhdGgsXHJcblx0XHRcdH0sXHJcblx0XHR9LFxyXG5cdF0pO1xyXG5cclxuXHRjb25zdCByZXNBZGRlZCA9IChhd2FpdCBwaW5lY29uZS5pbmRleChcInJlcXVpcmVtZW50c1wiKS5mZXRjaChbdmFsdWUuaWRdKSlcclxuXHRcdC5yZWNvcmRzPy5bdmFsdWUuaWRdO1xyXG5cclxuXHRyZXR1cm4gcmVzQWRkZWQ7XHJcbn1cclxuIiwgImltcG9ydCB7IFRGaWxlLCBURm9sZGVyLCBXb3Jrc3BhY2VTcGxpdCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgcGx1Z2luSGFuZGxlciBmcm9tIFwiLi9nbG9iYWxIYW5kbGVyc1wiO1xyXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gXCJmcy9wcm9taXNlc1wiO1xyXG5cclxudHlwZSBBZGRSZXF1aXJlbWVudEFyZ3MgPSB7XHJcblx0ZGVzY3JpcHRpb246IHN0cmluZztcclxuXHRzb3VyY2U6IHN0cmluZztcclxuXHRzeXN0ZW06IHN0cmluZztcclxuXHRpZD86IHN0cmluZztcclxufTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRSZXF1aXJlbWVudChhcmdzOiBBZGRSZXF1aXJlbWVudEFyZ3MpIHtcclxuXHRjb25zdCBhcHAgPSBwbHVnaW5IYW5kbGVyLmFwcDtcclxuXHRjb25zdCB7IHNrYV9zZSB9ID0gcGx1Z2luSGFuZGxlci5nZXRQbHVnaW5zKCk7XHJcblxyXG5cdGNvbnN0IHJlcXVpcmVtZW50VGVtcGxhdGUgPSBhd2FpdCByZWFkRmlsZShcclxuXHRcdGFwcC52YXVsdC5hZGFwdGVyLmdldEJhc2VQYXRoKCkgK1xyXG5cdFx0XHRcIi8ub2JzaWRpYW4vcGx1Z2lucy9za2Ffc2UvdGVtcGxhdGVzL3JlcXVpcmVtZW50LnRlbXBsYXRlLm1kXCJcclxuXHQpO1xyXG5cclxuXHQvLyByZXBsYWNlICVzeXN0ZW0lIHdpdGggc3lzdGVtJ3MgbmFtZSBhbmQgJWlkJSB3aXRoIGNvbXBvbmVudCdzIGlkIHdoaWNoIGlzIHN5c3RlbSBuYW1lICsgY29tcG9uZW50IG5hbWVcclxuXHRsZXQgZGF0YSA9IHJlcXVpcmVtZW50VGVtcGxhdGVcclxuXHRcdC50b1N0cmluZygpXHJcblx0XHQucmVwbGFjZSgvJXN5c3RlbSUvZywgYXJncy5zeXN0ZW0pXHJcblx0XHQucmVwbGFjZSgvJWRlc2NyaXB0aW9uJS9nLCBhcmdzLmRlc2NyaXB0aW9uKVxyXG5cdFx0LnJlcGxhY2UoLyVzb3VyY2UlL2csIGFyZ3Muc291cmNlKTtcclxuXHJcblx0aWYgKCFhcmdzLmlkKSB7XHJcblx0XHRjb25zdCBudW1fZXF1aXJlbWVudHMgPSBhcHAudmF1bHRcclxuXHRcdFx0LmdldEZpbGVzKClcclxuXHRcdFx0LmZpbHRlcigoZmlsZSkgPT5cclxuXHRcdFx0XHRmaWxlLmJhc2VuYW1lLnN0YXJ0c1dpdGgoYFJFUS4ke2FyZ3Muc3lzdGVtfS5gKVxyXG5cdFx0XHQpLmxlbmd0aDtcclxuXHRcdGFyZ3MuaWQgPSBgUkVRLiR7YXJncy5zeXN0ZW19LiR7bnVtX2VxdWlyZW1lbnRzICsgMX1gO1xyXG5cdH1cclxuXHJcblx0aWYgKGFyZ3MuaWQpIHtcclxuXHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UoLyVpZCUvZywgYXJncy5pZC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLyAvZywgXCJfXCIpKTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHJvb3RQYXRoID0gc2thX3NlLnNldHRpbmdzLnN5c3RlbV9kZXNpZ25fcm9vdF9mb2xkZXI7XHJcblxyXG5cdHJldHVybiBhd2FpdCBhcHAudmF1bHQuY3JlYXRlKFxyXG5cdFx0cm9vdFBhdGggKyBcIi9SZXF1aXJlbWVudHMvXCIgKyBhcmdzLmlkICsgXCIubWRcIixcclxuXHRcdGRhdGFcclxuXHQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkQ29tcG9uZW50KHtcclxuXHRzeXN0ZW0sXHJcblx0cGF0aCxcclxuXHRmaWxlTmFtZSxcclxuXHRpZCxcclxufToge1xyXG5cdHN5c3RlbTogc3RyaW5nO1xyXG5cdHBhdGg6IHN0cmluZztcclxuXHRmaWxlTmFtZTogc3RyaW5nO1xyXG5cdGlkPzogc3RyaW5nO1xyXG59KSB7XHJcblx0Y29uc3QgYXBwID0gcGx1Z2luSGFuZGxlci5hcHA7XHJcblxyXG5cdGNvbnN0IGNvbXBvbmVudFRlbXBsYXRlID0gYXdhaXQgcmVhZEZpbGUoXHJcblx0XHRhcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpICtcclxuXHRcdFx0XCIvLm9ic2lkaWFuL3BsdWdpbnMvc2thX3NlL3RlbXBsYXRlcy9jb21wb25lbnQudGVtcGxhdGUubWRcIlxyXG5cdCk7XHJcblxyXG5cdC8vIHJlcGxhY2UgJXN5c3RlbSUgd2l0aCBzeXN0ZW0ncyBuYW1lIGFuZCAlaWQlIHdpdGggY29tcG9uZW50J3MgaWQgd2hpY2ggaXMgc3lzdGVtIG5hbWUgKyBjb21wb25lbnQgbmFtZVxyXG5cdGxldCBkYXRhID0gY29tcG9uZW50VGVtcGxhdGUudG9TdHJpbmcoKS5yZXBsYWNlKC8lc3lzdGVtJS9nLCBzeXN0ZW0pO1xyXG5cclxuXHRpZiAoaWQpIHtcclxuXHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UoLyVpZCUvZywgaWQudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8gL2csIFwiX1wiKSk7XHJcblx0fVxyXG5cclxuXHRhd2FpdCBhcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBhdGggKyBcIi9cIiArIGZpbGVOYW1lKTtcclxuXHJcblx0cmV0dXJuIGF3YWl0IGFwcC52YXVsdC5jcmVhdGUoXHJcblx0XHRwYXRoICsgXCIvXCIgKyBmaWxlTmFtZSArIFwiL1wiICsgZmlsZU5hbWUgKyBcIi5tZFwiLFxyXG5cdFx0ZGF0YVxyXG5cdCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRUb1N5c3RlbURpYWdyYW0oe1xyXG5cdGZpbGUsXHJcblx0aXNDb21wb25lbnQsXHJcbn06IHtcclxuXHRmaWxlOiBURmlsZTtcclxuXHRpc0NvbXBvbmVudD86IGJvb2xlYW47XHJcbn0pIHtcclxuXHRjb25zdCBhcHAgPSBwbHVnaW5IYW5kbGVyLmFwcDtcclxuXHRjb25zdCBzeXN0ZW1EaWFncmFtID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoXHJcblx0XHRcIlN5c3RlbSBEaWFncmFtLmNhbnZhc1wiLFxyXG5cdFx0XCJcIlxyXG5cdCk7XHJcblx0Y29uc29sZS5sb2coc3lzdGVtRGlhZ3JhbSk7XHJcblx0aWYgKCFzeXN0ZW1EaWFncmFtKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzeXN0ZW0gZGlhZ3JhbSBmb3VuZFwiKTtcclxuXHRjb25zdCBkID0gYXdhaXQgYXBwLnZhdWx0LmNhY2hlZFJlYWQoc3lzdGVtRGlhZ3JhbSk7XHJcblx0Y29uc3QgZGF0YUpzb24gPSBKU09OLnBhcnNlKGQpO1xyXG5cclxuXHQvL3tcInR5cGVcIjpcImdyb3VwXCIsXCJpZFwiOlwiOTZlZGI0NTJhMmUyN2ZmMFwiLFwiZmlsZVwiOlwiUm9ja2V0IFN5c3RlbXMvUHJvcHVsc2lvbi9Qcm9wdWxzaW9uLm1kXCIsXCJ4XCI6LTE2NDAsXCJ5XCI6LTE4NjAsXCJ3aWR0aFwiOjc0MCxcImhlaWdodFwiOjcwMCxcImxhYmVsXCI6XCJQcm9wdWxzaW9uXCJ9XHJcblxyXG5cdC8vIHRyYW5zZm9ybTogdHJhbnNsYXRlKDQ4MC41cHgsIDQ5My41cHgpIHNjYWxlKDAuODAyNDk2KSB0cmFuc2xhdGUoLTM3OS4wMzNweCwgMTM0LjE3MXB4KTtcclxuXHQvLyBnZXQgY2FudmFzIHRyYW5zbGF0ZSBhcyB4IGFuZCB5XHJcblx0Y29uc3QgY2FudmFzU3R5bGUgPSBhcHAud29ya3NwYWNlXHJcblx0XHQuZ2V0TGVhZigpXHJcblx0XHQuZ2V0Q29udGFpbmVyKClcclxuXHRcdD8uZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJjYW52YXNcIilbMF1cclxuXHRcdD8uZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XHJcblxyXG5cdGNvbnN0IGNhbnZhc1RyYW5zbGF0ZSA9IGNhbnZhc1N0eWxlXHJcblx0XHQ/LnNwbGl0KFwidHJhbnNsYXRlKFwiKVsyXVxyXG5cdFx0Py5zcGxpdChcInB4KVwiKVswXVxyXG5cdFx0Py5zcGxpdChcInB4LCBcIikgPz8gWzAsIDBdO1xyXG5cclxuXHRkYXRhSnNvbi5ub2Rlcy5wdXNoKHtcclxuXHRcdHR5cGU6IGlzQ29tcG9uZW50ID8gXCJ0ZXh0XCIgOiBcImdyb3VwXCIsXHJcblx0XHRpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE0KSxcclxuXHRcdGZpbGU6IGZpbGUucGF0aCxcclxuXHRcdHg6IE51bWJlcigtY2FudmFzVHJhbnNsYXRlWzBdKSAtIDE1MCxcclxuXHRcdHk6IE51bWJlcigtY2FudmFzVHJhbnNsYXRlWzFdKSAtIDEwMCxcclxuXHRcdHdpZHRoOiAzMDAsXHJcblx0XHRoZWlnaHQ6IDIwMCxcclxuXHRcdGxhYmVsOiBmaWxlLmJhc2VuYW1lLFxyXG5cdFx0Li4uKGlzQ29tcG9uZW50ID8geyB0ZXh0OiBmaWxlLmJhc2VuYW1lIH0gOiB7fSksXHJcblx0fSk7XHJcblxyXG5cdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkoc3lzdGVtRGlhZ3JhbSwgSlNPTi5zdHJpbmdpZnkoZGF0YUpzb24pKTtcclxufVxyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZWEsWUFBQSxZQUFZLGtEQUFrRCxRQUFRLFFBQVEsRUFBRTtBQWU3RixRQUFBOztNQUFBLFdBQUE7QUFDSSxpQkFBQUEsZUFBb0IsZUFBMkM7QUFBM0MsY0FBQSxrQkFBQSxRQUFBO0FBQUEsNEJBQUEsQ0FBQTtVQUEyQztBQUEzQyxlQUFBLGdCQUFBO1FBQThDO0FBRWxFLGVBQUEsZUFBSUEsZUFBQSxXQUFBLFVBQU07ZUFBVixTQUFXLGVBQTRCO0FBQ25DLGlCQUFLLGdCQUFnQjtVQUN6Qjs7OztBQUVBLGVBQUEsZUFBSUEsZUFBQSxXQUFBLFlBQVE7ZUFBWixXQUFBO0FBQ0ksbUJBQU8sS0FBSyxjQUFjLFlBQVksT0FBTyxLQUFLLGNBQWMsV0FBVyxRQUFBO1VBQy9FOzs7O0FBRUEsZUFBQSxlQUFJQSxlQUFBLFdBQUEsWUFBUTtlQUFaLFdBQUE7QUFDSSxtQkFBTyxLQUFLLGNBQWM7VUFDOUI7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxjQUFVO2VBQWQsV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYyxjQUFjLENBQUE7VUFDNUM7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSx3QkFBb0I7ZUFBeEIsV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYyx3QkFBd0I7VUFDdEQ7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxZQUFRO2VBQVosV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYztVQUM5Qjs7OztBQUVBLGVBQUEsZUFBSUEsZUFBQSxXQUFBLFlBQVE7ZUFBWixXQUFBO0FBQ0ksbUJBQU8sS0FBSyxjQUFjO1VBQzlCOzs7O0FBRUEsZUFBQSxlQUFJQSxlQUFBLFdBQUEsVUFBTTtlQUFWLFdBQUE7QUFDSSxnQkFBTSxTQUFTLEtBQUssY0FBYztBQUNsQyxnQkFBSSxRQUFRO0FBQ1IscUJBQU8sT0FBTyxXQUFXLGFBQWEsU0FBUyxXQUFBO0FBQU0sdUJBQUE7Y0FBQTs7QUFFekQsbUJBQU87VUFDWDs7OztBQUVBLGVBQUEsZUFBSUEsZUFBQSxXQUFBLGVBQVc7ZUFBZixXQUFBO0FBQUEsZ0JBQUEsUUFBQTtBQUNJLGdCQUFNLGNBQWMsS0FBSyxjQUFjO0FBQ3ZDLGdCQUFJLGFBQWE7QUFDYixxQkFBTyxPQUFPLGdCQUFnQixhQUFhLGNBQWMsV0FBQTtBQUFBLHVCQUFBLFVBQUEsT0FBQSxRQUFBLFFBQUEsV0FBQTtBQUFBLHlCQUFBLFlBQUEsTUFBQSxTQUFBQyxLQUFBO0FBQVksMkJBQUEsQ0FBQSxHQUFBLFdBQVc7Ozs7O0FBRXBGLG1CQUFPO1VBQ1g7Ozs7QUFFQSxlQUFBLGVBQUlELGVBQUEsV0FBQSxXQUFPO2VBQVgsV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYztVQUM5Qjs7OztBQUVBLGVBQUEsZUFBSUEsZUFBQSxXQUFBLGVBQVc7ZUFBZixXQUFBO0FBQ0ksbUJBQU8sS0FBSyxjQUFjO1VBQzlCOzs7O0FBQ0osZUFBQUE7TUFBQSxFQXREQTs7QUFBYSxZQUFBLGdCQUFBO0FBd0RBLFlBQUEsZ0JBQWdCLElBQUksY0FBYTtBQUs5QyxRQUFBOztNQUFBLFdBQUE7QUFLSSxpQkFBQUUsU0FBc0IsZUFBNkI7QUFBN0IsY0FBQSxrQkFBQSxRQUFBO0FBQUEsNEJBQWdCLFFBQUE7VUFBYTtBQUFuRCxjQUFBLFFBQUE7QUFBc0IsZUFBQSxnQkFBQTtBQWlHZCxlQUFBLFdBQVcsU0FBTyxLQUFhLE1BQWlCO0FBQUEsbUJBQUEsVUFBQSxPQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUNoRCxrQ0FBYyxFQUFFLEtBQUssS0FBSTs0QkFDSkQsTUFBQSxLQUFLOzs7MEJBQUwsS0FBQUEsSUFBQTtBQUFlLDZCQUFBLENBQUEsR0FBQSxDQUFBO0FBQTdCLGlDQUFVQSxJQUFBLEVBQUE7eUJBQ2IsV0FBVztBQUFYLDZCQUFBLENBQUEsR0FBQSxDQUFBO0FBQ2MsMkJBQUEsQ0FBQSxHQUFNLFdBQVcsSUFBRyxTQUFBLEVBQzlCLE9BQU8sS0FBSyxTQUFRLEdBQ2pCLFdBQVcsQ0FBQSxDQUNoQjs7QUFIRixrQ0FBYyxHQUFBLEtBQUEsS0FHUjs7O0FBTFc7OztBQVFyQiwrQkFBaUM7Ozs7QUFFdEIsMkJBQUEsQ0FBQSxJQUFPLEtBQUssY0FBYyxZQUFZLE9BQU8sWUFBWSxLQUFLLFlBQVksSUFBSSxDQUFDOztBQUExRiwrQkFBVyxHQUFBLEtBQUE7Ozs7NEJBRWMsS0FBQSxLQUFLOzs7MEJBQUwsS0FBQSxHQUFBO0FBQWUsNkJBQUEsQ0FBQSxHQUFBLEVBQUE7QUFBN0IsaUNBQVUsR0FBQSxFQUFBO3lCQUNiLFdBQVc7QUFBWCw2QkFBQSxDQUFBLEdBQUEsRUFBQTtBQUNXLDJCQUFBLENBQUEsR0FBTSxXQUFXLFFBQVE7c0JBQ2hDLE9BQU8sS0FBSztzQkFDWixLQUFLLFlBQVk7c0JBQ2pCLE1BQU0sWUFBWTtzQkFDbEIsT0FBTztzQkFDUCxVQUFVLFdBQVcsU0FBUyxNQUFLLElBQUs7cUJBQzNDLENBQUM7O0FBTkYsK0JBQVcsR0FBQSxLQUFBLEtBTUw7OztBQVJXOzs7QUFXekIsd0JBQUksYUFBYSxRQUFXO0FBQzFCLDBCQUFJLGVBQWEsT0FBTztBQUN0Qiw4QkFBTSxJQUFJLFdBQVcsS0FBRyxnRkFBZ0Y7NkJBQ25HO0FBQ0wsOEJBQU07Ozs7OzRCQUlXLEtBQUEsS0FBSzs7OzBCQUFMLEtBQUEsR0FBQTtBQUFlLDZCQUFBLENBQUEsR0FBQSxFQUFBO0FBQTdCLGlDQUFVLEdBQUEsRUFBQTt5QkFDYixXQUFXO0FBQVgsNkJBQUEsQ0FBQSxHQUFBLEVBQUE7QUFDVywyQkFBQSxDQUFBLEdBQU0sV0FBVyxLQUFLO3NCQUM3QixPQUFPLEtBQUs7c0JBQ1osS0FBSyxZQUFZO3NCQUNqQixNQUFNLFlBQVk7c0JBQ2xCLFVBQVUsU0FBUyxNQUFLO3FCQUMzQixDQUFDOztBQUxGLCtCQUFXLEdBQUEsS0FBQSxLQUtMOzs7QUFQVzs7O0FBVXpCLDJCQUFBLENBQUEsR0FBTyxRQUFROzs7OztBQTNJZixlQUFLLGFBQWEsY0FBYztRQUNwQztBQUVBLFFBQUFDLFNBQUEsVUFBQSxpQkFBQSxXQUFBOztBQUEyQyxjQUFBLGNBQUEsQ0FBQTttQkFBQSxLQUFBLEdBQUEsS0FBQSxVQUFBLFFBQUEsTUFBNEI7QUFBNUIsd0JBQUEsRUFBQSxJQUFBLFVBQUEsRUFBQTs7QUFDdkMsY0FBTSxPQUFPLEtBQUssTUFBSztBQUN2QixlQUFLLGNBQWFELE1BQUEsS0FBSyxZQUFXLE9BQU0sTUFBQUEsS0FBSSxXQUFXO0FBQ3ZELGlCQUFPO1FBQ1g7QUFFQSxRQUFBQyxTQUFBLFVBQUEsb0JBQUEsV0FBQTtBQUE4QyxjQUFBLGlCQUFBLENBQUE7bUJBQUEsS0FBQSxHQUFBLEtBQUEsVUFBQSxRQUFBLE1BQTJDO0FBQTNDLDJCQUFBLEVBQUEsSUFBQSxVQUFBLEVBQUE7O0FBQzFDLGNBQU0sY0FBYyxlQUFlLElBQUksU0FBQyxLQUFHO0FBQUssbUJBQUMsRUFBRSxJQUFHO1VBQU4sQ0FBUztBQUN6RCxpQkFBTyxLQUFLLGVBQWMsTUFBbkIsTUFBMEIsV0FBVztRQUNoRDtBQUVBLFFBQUFBLFNBQUEsVUFBQSxxQkFBQSxXQUFBO0FBQStDLGNBQUEsa0JBQUEsQ0FBQTttQkFBQSxLQUFBLEdBQUEsS0FBQSxVQUFBLFFBQUEsTUFBNkM7QUFBN0MsNEJBQUEsRUFBQSxJQUFBLFVBQUEsRUFBQTs7QUFDM0MsY0FBTSxjQUFjLGdCQUFnQixJQUFJLFNBQUMsTUFBSTtBQUFLLG1CQUFDLEVBQUUsS0FBSTtVQUFQLENBQVU7QUFDNUQsaUJBQU8sS0FBSyxlQUFjLE1BQW5CLE1BQTBCLFdBQVc7UUFDaEQ7QUFZVSxRQUFBQSxTQUFBLFVBQUEsYUFBVixTQUFxQixNQUErQjtBQUNoRCxjQUFJLENBQUMsTUFBTTtBQUNQLG1CQUFPOztBQUVYLGlCQUFPQSxTQUFRLFVBQVUsS0FBSyxJQUFJO1FBQ3RDO0FBRWdCLFFBQUFBLFNBQUEsVUFBQSxVQUFoQixTQUF3QixTQUFzQixlQUFrRDs7Ozs7O0FBQ3RFLHlCQUFBLENBQUEsR0FBTSxLQUFLLGtCQUFrQixTQUFTLGFBQWEsQ0FBQzs7QUFBcEUsa0JBQUFELE1BQWdCLEdBQUEsS0FBQSxHQUFkLE1BQUdBLElBQUEsS0FBRSxPQUFJQSxJQUFBO0FBQ0EseUJBQUEsQ0FBQSxHQUFNLEtBQUssU0FBUyxLQUFLLElBQUksQ0FBQzs7QUFBekMsNkJBQVcsR0FBQSxLQUFBO0FBQ2pCLHNCQUFJLGFBQWEsU0FBUyxVQUFVLE9BQU8sU0FBUyxTQUFTLE1BQU07QUFDL0QsMkJBQUEsQ0FBQSxHQUFPLFFBQVE7O0FBRW5CLHdCQUFNLElBQUksY0FBYyxVQUFVLGlDQUFpQzs7Ozs7QUFHekQsUUFBQUMsU0FBQSxVQUFBLG9CQUFkLFNBQWdDLFNBQXNCLGVBQWtEOzs7Ozs7O0FBQ2hHLHdCQUFNLEtBQUssY0FBYyxXQUFXLFFBQVE7QUFDaEQsc0JBQUksUUFBUSxVQUFVLFVBQWEsT0FBTyxLQUFLLFFBQVEsS0FBSyxFQUFFLFdBQVcsR0FBRztBQUl4RSwyQkFBTyxNQUFNLEtBQUssY0FBYyxxQkFBcUIsUUFBUSxLQUFLOztBQUdoRSw0QkFBVSxPQUFPLE9BQU8sQ0FBQSxHQUFJLEtBQUssY0FBYyxTQUFTLFFBQVEsT0FBTztBQUM3RSx5QkFBTyxLQUFLLE9BQU8sRUFBRSxRQUFRLFNBQUEsS0FBRztBQUFJLDJCQUFBLFFBQVEsR0FBRyxNQUFNLFNBQVksT0FBTyxRQUFRLEdBQUcsSUFBSSxDQUFBO2tCQUFuRCxDQUFxRDtBQUVuRixtQ0FDRixPQUFPLGtCQUFrQixhQUNuQixnQkFDQSxXQUFBO0FBQUEsMkJBQUEsVUFBQSxPQUFBLFFBQUEsUUFBQSxXQUFBO0FBQUEsNkJBQUEsWUFBQSxNQUFBLFNBQUFELEtBQUE7QUFBWSwrQkFBQSxDQUFBLEdBQUEsYUFBYTs7OztBQUU3QiwrQkFBYTtvQkFDZixRQUFRLFFBQVE7b0JBQ2hCO29CQUNBLE1BQU0sUUFBUTtvQkFDZCxhQUFhLEtBQUssY0FBYzs7c0NBSTdCLFVBQVUsQ0FBQTtBQUNULHlCQUFBLENBQUEsR0FBTSxlQUFlO29CQUNyQixNQUFNO29CQUNOO21CQUNILENBQUM7O0FBTEEsbUNBQWMsU0FBQSxNQUFBLFFBQUFBLElBQUEsT0FBQSxDQUVaLEdBQUEsS0FBQSxDQUdELENBQUEsQ0FBQTtBQUlQLHNCQUFJLFdBQVcsZUFBZSxJQUFJLEtBQzFCLGVBQWUsZ0JBQWdCLG1CQUNoQyxPQUFPLGVBQWUsSUFBSSxHQUFHO0FBQ2xDLDJCQUFPLGVBQWU7NkJBQ2IsS0FBSyxXQUFXLFFBQVEsY0FBYyxDQUFDLEdBQUc7QUFDbkQsMkJBQU8sS0FBSyxVQUFVLGVBQWUsSUFBSTt5QkFDcEM7QUFDTCwyQkFBTyxlQUFlOztBQUdsQix5QkFBSSxTQUFBLFNBQUEsQ0FBQSxHQUNILGNBQWMsR0FBQSxFQUNqQixLQUFJLENBQUE7QUFHUix5QkFBQSxDQUFBLEdBQU8sRUFBRSxLQUFLLEtBQUksQ0FBRTs7Ozs7QUFxRGhCLFFBQUFDLFNBQUEsVUFBQSxRQUFSLFdBQUE7QUFDSSxjQUFNLGNBQWMsS0FBSztBQUN6QixjQUFNLE9BQU8sSUFBSSxZQUFZLEtBQUssYUFBYTtBQUMvQyxlQUFLLGFBQWEsS0FBSyxXQUFXLE1BQUs7QUFDdkMsaUJBQU87UUFDWDtBQTNKc0IsUUFBQUEsU0FBQSxZQUFZLElBQUksT0FBTyxnRUFBcUUsR0FBRztBQTRKekgsZUFBQUE7UUE5SkE7O0FBQWEsWUFBQSxVQUFBO0FBZ0tiLGFBQVMsT0FBTyxPQUFVO0FBQ3RCLGFBQU8sT0FBTyxTQUFTLGVBQWUsaUJBQWlCO0lBQzNEO0FBRUEsYUFBUyxXQUFXLE9BQVU7QUFDMUIsYUFBTyxPQUFPLGFBQWEsZUFBZSxpQkFBaUI7SUFDL0Q7QUFFQSxRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUFtQyxrQkFBQUMsZ0JBQUEsTUFBQTtBQUUvQixpQkFBQUEsZUFBbUIsVUFBb0IsS0FBWTtBQUFuRCxjQUFBLFFBQ0ksT0FBQSxLQUFBLE1BQU0sR0FBRyxLQUFDO0FBREssZ0JBQUEsV0FBQTtBQURWLGdCQUFBLE9BQXdCOztRQUdqQztBQUNKLGVBQUFBO01BQUEsRUFMbUMsS0FBSzs7QUFBM0IsWUFBQSxnQkFBQTtBQU9iLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQWdDLGtCQUFBQyxhQUFBLE1BQUE7QUFFNUIsaUJBQUFBLFlBQW1CLE9BQWMsS0FBWTtBQUE3QyxjQUFBLFFBQ0ksT0FBQSxLQUFBLE1BQU0sR0FBRyxLQUFDO0FBREssZ0JBQUEsUUFBQTtBQURWLGdCQUFBLE9BQXFCOztRQUc5QjtBQUNKLGVBQUFBO01BQUEsRUFMZ0MsS0FBSzs7QUFBeEIsWUFBQSxhQUFBO0FBT2IsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBbUMsa0JBQUFDLGdCQUFBLE1BQUE7QUFFL0IsaUJBQUFBLGVBQW1CLE9BQWUsS0FBWTtBQUE5QyxjQUFBLFFBQ0ksT0FBQSxLQUFBLE1BQU0sR0FBRyxLQUFDO0FBREssZ0JBQUEsUUFBQTtBQURWLGdCQUFBLE9BQXdCOztRQUdqQztBQUNKLGVBQUFBO01BQUEsRUFMbUMsS0FBSzs7QUFBM0IsWUFBQSxnQkFBQTtBQU9BLFlBQUEscUJBQXFCO01BQzlCLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87O0FBNEJYLGFBQWdCLE9BQU8sTUFBVyxLQUFXO0FBQ3pDLFVBQU0sUUFBUSxLQUFLLEdBQUc7QUFDdEIsYUFBTyxVQUFVLFFBQVEsVUFBVTtJQUN2QztBQUhBLFlBQUEsU0FBQTtBQUtBLGFBQWdCLFlBQVksUUFBbUIsUUFBbUI7QUFBbkIsVUFBQSxXQUFBLFFBQUE7QUFBQSxpQkFBQTtNQUFtQjtBQUM5RCxhQUFPLE9BQU8sS0FBSyxNQUFNLEVBQ3BCLElBQUksU0FBQSxLQUFHO0FBQUksZUFBQSxxQkFBcUIsS0FBSyxPQUFPLEdBQUcsR0FBRyxNQUFNO01BQTdDLENBQThDLEVBQ3pELE9BQU8sU0FBQSxNQUFJO0FBQUksZUFBQSxLQUFLLFNBQVM7TUFBZCxDQUFlLEVBQzlCLEtBQUssR0FBRztJQUNqQjtBQUxBLFlBQUEsY0FBQTtBQU9BLGFBQVMscUJBQXFCLEtBQWEsT0FBbUosV0FBc0I7QUFBdEIsVUFBQSxjQUFBLFFBQUE7QUFBQSxvQkFBQTtNQUFzQjtBQUNoTixVQUFNLFVBQVUsYUFBYSxVQUFVLFNBQVMsSUFBQSxPQUFJLEtBQUcsR0FBQSxJQUFNO0FBQzdELFVBQUksaUJBQWlCLE9BQU87QUFDeEIsWUFBTSxhQUFhLE1BQU0sSUFBSSxTQUFBLGFBQVc7QUFBSSxpQkFBQSxtQkFBbUIsT0FBTyxXQUFXLENBQUM7UUFBdEMsQ0FBdUMsRUFDOUUsS0FBSyxJQUFBLE9BQUksbUJBQW1CLE9BQU8sR0FBQyxHQUFBLENBQUc7QUFDNUMsZUFBTyxHQUFBLE9BQUcsbUJBQW1CLE9BQU8sR0FBQyxHQUFBLEVBQUEsT0FBSSxVQUFVOztBQUV2RCxVQUFJLGlCQUFpQixLQUFLO0FBQ3RCLFlBQU0sZUFBZSxNQUFNLEtBQUssS0FBSztBQUNyQyxlQUFPLHFCQUFxQixLQUFLLGNBQWMsU0FBUzs7QUFFNUQsVUFBSSxpQkFBaUIsTUFBTTtBQUN2QixlQUFPLEdBQUEsT0FBRyxtQkFBbUIsT0FBTyxHQUFDLEdBQUEsRUFBQSxPQUFJLG1CQUFtQixNQUFNLFlBQVcsQ0FBRSxDQUFDOztBQUVwRixVQUFJLGlCQUFpQixRQUFRO0FBQ3pCLGVBQU8sWUFBWSxPQUFvQixPQUFPOztBQUVsRCxhQUFPLEdBQUEsT0FBRyxtQkFBbUIsT0FBTyxHQUFDLEdBQUEsRUFBQSxPQUFJLG1CQUFtQixPQUFPLEtBQUssQ0FBQyxDQUFDO0lBQzlFO0FBRUEsYUFBZ0IsVUFBVSxNQUFXLElBQXNCO0FBQ3pELGFBQU8sT0FBTyxLQUFLLElBQUksRUFBRSxPQUN2QixTQUFDLEtBQUssS0FBRzs7QUFBSyxlQUFBLFNBQUEsU0FBQSxDQUFBLEdBQU0sR0FBRyxJQUFBSixNQUFBLENBQUEsR0FBQUEsSUFBRyxHQUFHLElBQUcsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFDQSxJQUFBO01BQS9CLEdBQ2QsQ0FBQSxDQUFFO0lBRU47QUFMQSxZQUFBLFlBQUE7QUFPQSxhQUFnQixlQUFlLFVBQW1CO0FBQzlDLGVBQXNCLEtBQUEsR0FBQSxhQUFBLFVBQUEsS0FBQSxXQUFBLFFBQUEsTUFBVTtBQUEzQixZQUFNLFVBQU8sV0FBQSxFQUFBO0FBQ2QsWUFBSSwwQkFBMEIsUUFBUSxhQUFhO0FBQy9DLGlCQUFPOzs7QUFHZixhQUFPO0lBQ1g7QUFQQSxZQUFBLGlCQUFBO0FBaURBLFFBQUE7O01BQUEsV0FBQTtBQUNJLGlCQUFBSyxpQkFBbUIsS0FBdUIsYUFBbUU7QUFBbkUsY0FBQSxnQkFBQSxRQUFBO0FBQUEsMEJBQUEsU0FBdUMsV0FBYztBQUFLLHFCQUFBO1lBQUE7VUFBUztBQUExRixlQUFBLE1BQUE7QUFBdUIsZUFBQSxjQUFBO1FBQXNFO0FBRTFHLFFBQUFBLGlCQUFBLFVBQUEsUUFBTixXQUFBOzs7Ozs7QUFDVyxrQkFBQUwsTUFBQSxLQUFLO0FBQVkseUJBQUEsQ0FBQSxHQUFNLEtBQUssSUFBSSxLQUFJLENBQUU7O0FBQTdDLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxNQUFBLE1BQUksQ0FBYSxHQUFBLEtBQUEsQ0FBcUIsQ0FBQSxDQUFDOzs7OztBQUV0RCxlQUFBSztNQUFBLEVBTkE7O0FBQWEsWUFBQSxrQkFBQTtBQVFiLFFBQUE7O01BQUEsV0FBQTtBQUNJLGlCQUFBQyxpQkFBbUIsS0FBYTtBQUFiLGVBQUEsTUFBQTtRQUFnQjtBQUU3QixRQUFBQSxpQkFBQSxVQUFBLFFBQU4sV0FBQTs7O0FBQ0kscUJBQUEsQ0FBQSxHQUFPLE1BQVM7Ozs7QUFFeEIsZUFBQUE7TUFBQSxFQU5BOztBQUFhLFlBQUEsa0JBQUE7QUFRYixRQUFBOztNQUFBLFdBQUE7QUFDSSxpQkFBQUMsaUJBQW1CLEtBQWE7QUFBYixlQUFBLE1BQUE7UUFBZ0I7QUFFN0IsUUFBQUEsaUJBQUEsVUFBQSxRQUFOLFdBQUE7Ozs7O0FBQ1cseUJBQUEsQ0FBQSxHQUFNLEtBQUssSUFBSSxLQUFJLENBQUU7O0FBQTVCLHlCQUFBLENBQUEsR0FBT1AsSUFBQSxLQUFBLENBQXFCOzs7OztBQUMvQjtBQUNMLGVBQUFPO01BQUEsRUFOQTs7QUFBYSxZQUFBLGtCQUFBO0FBUWIsUUFBQTs7TUFBQSxXQUFBO0FBQ0ksaUJBQUFDLGlCQUFtQixLQUFhO0FBQWIsZUFBQSxNQUFBO1FBQWdCO0FBRTdCLFFBQUFBLGlCQUFBLFVBQUEsUUFBTixXQUFBOzs7OztBQUNXLHlCQUFBLENBQUEsR0FBTSxLQUFLLElBQUksS0FBSSxDQUFFOztBQUE1Qix5QkFBQSxDQUFBLEdBQU9SLElBQUEsS0FBQSxDQUFxQjs7Ozs7QUFDL0I7QUFDTCxlQUFBUTtNQUFBLEVBTkE7O0FBQWEsWUFBQSxrQkFBQTs7Ozs7Ozs7OztBQzFaYixRQUFBLFlBQUE7QUF3QkEsYUFBZ0IsNkJBQTZCLE9BQWE7QUFDdEQsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsK0JBQUE7QUFNQSxhQUFnQiwyQkFBMkIsTUFBUztBQUNoRCxhQUFPLGdDQUFnQyxNQUFNLEtBQUs7SUFDdEQ7QUFGQSxZQUFBLDZCQUFBO0FBSUEsYUFBZ0IsZ0NBQWdDLE1BQVcscUJBQTRCO0FBQ25GLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxTQUFTLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7UUFDNUQsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFROztJQUVyRTtBQVRBLFlBQUEsa0NBQUE7QUFXQSxhQUFnQix5QkFBeUIsT0FBaUM7QUFDdEUsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxVQUFVLE1BQU07UUFDaEIsVUFBVSxNQUFNOztJQUV4QjtBQVpBLFlBQUEsMkJBQUE7Ozs7Ozs7Ozs7QUM3Q0EsUUFBQSxZQUFBO0FBMENBLGFBQWdCLHlCQUF5QixPQUFhO0FBQ2xELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLDJCQUFBO0FBTUEsYUFBZ0IsdUJBQXVCLE1BQVM7QUFDNUMsYUFBTyw0QkFBNEIsTUFBTSxLQUFLO0lBQ2xEO0FBRkEsWUFBQSx5QkFBQTtBQUlBLGFBQWdCLDRCQUE0QixNQUFXLHFCQUE0QjtBQUMvRSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sTUFBTSxJQUFJLFNBQVksS0FBSyxNQUFNO1FBQ3ZELFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxVQUFVLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7UUFDN0QsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXO1FBQ3RFLGVBQWUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGNBQWMsSUFBSSxTQUFZLEtBQUssY0FBYzs7SUFFdEY7QUFaQSxZQUFBLDhCQUFBO0FBY0EsYUFBZ0IscUJBQXFCLE9BQTZCO0FBQzlELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxNQUFNO1FBQ2QsUUFBUSxNQUFNO1FBQ2QsVUFBVSxNQUFNO1FBQ2hCLGFBQWEsTUFBTTtRQUNuQixnQkFBZ0IsTUFBTTs7SUFFOUI7QUFmQSxZQUFBLHVCQUFBOzs7Ozs7Ozs7O0FDMUNBLGFBQWdCLGtDQUFrQyxPQUFhO0FBQzNELFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLFVBQVU7QUFDckMsbUJBQWEsY0FBYyxZQUFZO0FBRXZDLGFBQU87SUFDWDtBQU5BLFlBQUEsb0NBQUE7QUFRQSxhQUFnQixnQ0FBZ0MsTUFBUztBQUNyRCxhQUFPLHFDQUFxQyxNQUFNLEtBQUs7SUFDM0Q7QUFGQSxZQUFBLGtDQUFBO0FBSUEsYUFBZ0IscUNBQXFDLE1BQVcscUJBQTRCO0FBQ3hGLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxRQUFRLEtBQUssTUFBTTtRQUNuQixVQUFVLEtBQUssUUFBUTs7SUFFL0I7QUFUQSxZQUFBLHVDQUFBO0FBV0EsYUFBZ0IsOEJBQThCLE9BQXNDO0FBQ2hGLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxNQUFNO1FBQ2QsVUFBVSxNQUFNOztJQUV4QjtBQVpBLFlBQUEsZ0NBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQ0EsUUFBQSx1QkFBQTtBQWVBLGFBQWdCLGlDQUFpQyxNQUFTO0FBQ3RELGFBQU8sc0NBQXNDLE1BQU0sS0FBSztJQUM1RDtBQUZBLFlBQUEsbUNBQUE7QUFJQSxhQUFnQixzQ0FBc0MsTUFBVyxxQkFBNEI7QUFDekYsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBQSxTQUFBLENBQUEsSUFBWSxHQUFBLHFCQUFBLGlDQUFnQyxNQUFNLElBQUksQ0FBQztJQUMzRDtBQUxBLFlBQUEsd0NBQUE7QUFPQSxhQUFnQiwrQkFBK0IsT0FBdUM7QUFDbEYsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUdYLFdBQUksR0FBQSxxQkFBQSw4QkFBNkIsS0FBSyxHQUFHO0FBQ3JDLGdCQUFPLEdBQUEscUJBQUEsMEJBQXlCLEtBQTJCOztBQUcvRCxhQUFPLENBQUE7SUFDWDtBQWJBLFlBQUEsaUNBQUE7Ozs7Ozs7Ozs7QUMxQkEsUUFBQSxZQUFBO0FBRUEsUUFBQSw2QkFBQTtBQXdGQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxVQUFVO0FBQ3JDLG1CQUFhLGNBQWMsZUFBZTtBQUUxQyxhQUFPO0lBQ1g7QUFOQSxZQUFBLDBCQUFBO0FBUUEsYUFBZ0Isc0JBQXNCLE1BQVM7QUFDM0MsYUFBTywyQkFBMkIsTUFBTSxLQUFLO0lBQ2pEO0FBRkEsWUFBQSx3QkFBQTtBQUlBLGFBQWdCLDJCQUEyQixNQUFXLHFCQUE0QjtBQUM5RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxLQUFLLE1BQU07UUFDbkIsYUFBYSxLQUFLLFdBQVc7UUFDN0IsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sWUFBWSxJQUFJLFNBQVksS0FBSyxZQUFZO1FBQ3hFLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTtRQUM3RCxRQUFRLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxNQUFNLElBQUksU0FBWSxLQUFLLE1BQU07UUFDdkQsWUFBWSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sVUFBVSxJQUFJLFNBQVksS0FBSyxVQUFVO1FBQ25FLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTtRQUM3RCxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxVQUFVLElBQUksU0FBWSxLQUFLLFVBQVU7UUFDbEUsZUFBZSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sY0FBYyxJQUFJLFVBQVksR0FBQSwyQkFBQSxrQ0FBaUMsS0FBSyxjQUFjLENBQUM7UUFDaEgsa0JBQWtCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxpQkFBaUIsSUFBSSxTQUFZLEtBQUssaUJBQWlCO1FBQ3ZGLG9CQUFvQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sbUJBQW1CLElBQUksU0FBWSxLQUFLLG1CQUFtQjs7SUFFckc7QUFsQkEsWUFBQSw2QkFBQTtBQW9CQSxhQUFnQixvQkFBb0IsT0FBNEI7QUFDNUQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxRQUFRLE1BQU07UUFDZCxhQUFhLE1BQU07UUFDbkIsY0FBYyxNQUFNO1FBQ3BCLFVBQVUsTUFBTTtRQUNoQixRQUFRLE1BQU07UUFDZCxZQUFZLE1BQU07UUFDbEIsVUFBVSxNQUFNO1FBQ2hCLFlBQVksTUFBTTtRQUNsQixpQkFBZ0IsR0FBQSwyQkFBQSxnQ0FBK0IsTUFBTSxXQUFXO1FBQ2hFLG1CQUFtQixNQUFNO1FBQ3pCLHFCQUFxQixNQUFNOztJQUVuQztBQXJCQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7O0FDMUhBLFFBQUEsWUFBQTtBQXNDQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwwQkFBQTtBQU1BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILE9BQU8sRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLEtBQUssSUFBSSxTQUFZLEtBQUssS0FBSztRQUNwRCxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7UUFDdEUsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXO1FBQ3RFLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTs7SUFFckU7QUFYQSxZQUFBLDZCQUFBO0FBYUEsYUFBZ0Isb0JBQW9CLE9BQTRCO0FBQzVELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsT0FBTyxNQUFNO1FBQ2IsYUFBYSxNQUFNO1FBQ25CLGFBQWEsTUFBTTtRQUNuQixVQUFVLE1BQU07O0lBRXhCO0FBZEEsWUFBQSxzQkFBQTs7Ozs7Ozs7OztBQzdEQSxRQUFBLFlBQUE7QUFvQkEsYUFBZ0Isb0NBQW9DLE9BQWE7QUFDN0QsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsc0NBQUE7QUFNQSxhQUFnQixrQ0FBa0MsTUFBUztBQUN2RCxhQUFPLHVDQUF1QyxNQUFNLEtBQUs7SUFDN0Q7QUFGQSxZQUFBLG9DQUFBO0FBSUEsYUFBZ0IsdUNBQXVDLE1BQVcscUJBQTRCO0FBQzFGLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxVQUFVLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7O0lBRXJFO0FBUkEsWUFBQSx5Q0FBQTtBQVVBLGFBQWdCLGdDQUFnQyxPQUF3QztBQUNwRixVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFVBQVUsTUFBTTs7SUFFeEI7QUFYQSxZQUFBLGtDQUFBOzs7Ozs7Ozs7O0FDeENBLFFBQUEsWUFBQTtBQW1CQSxhQUFnQiwyQkFBMkIsT0FBYTtBQUNwRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSw2QkFBQTtBQU1BLGFBQWdCLHlCQUF5QixNQUFTO0FBQzlDLGFBQU8sOEJBQThCLE1BQU0sS0FBSztJQUNwRDtBQUZBLFlBQUEsMkJBQUE7QUFJQSxhQUFnQiw4QkFBOEIsTUFBVyxxQkFBNEI7QUFDakYsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGVBQWUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGFBQWEsSUFBSSxTQUFZLEtBQUssYUFBYTs7SUFFcEY7QUFSQSxZQUFBLGdDQUFBO0FBVUEsYUFBZ0IsdUJBQXVCLE9BQStCO0FBQ2xFLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsZUFBZSxNQUFNOztJQUU3QjtBQVhBLFlBQUEseUJBQUE7Ozs7Ozs7Ozs7QUN2Q0EsUUFBQSxZQUFBO0FBRUEsUUFBQSxxQkFBQTtBQTJDQSxhQUFnQixxQ0FBcUMsT0FBYTtBQUM5RCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSx1Q0FBQTtBQU1BLGFBQWdCLG1DQUFtQyxNQUFTO0FBQ3hELGFBQU8sd0NBQXdDLE1BQU0sS0FBSztJQUM5RDtBQUZBLFlBQUEscUNBQUE7QUFJQSxhQUFnQix3Q0FBd0MsTUFBVyxxQkFBNEI7QUFDM0YsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGNBQWMsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFlBQVksSUFBSSxVQUFhLEdBQUEsVUFBQSxXQUFVLEtBQUssWUFBWSxHQUFHLG1CQUFBLHdCQUF3QjtRQUMvRyxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7UUFDdEUsaUJBQWlCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxlQUFlLElBQUksU0FBWSxLQUFLLGVBQWU7UUFDbEYsb0JBQW9CLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxrQkFBa0IsSUFBSSxTQUFZLEtBQUssa0JBQWtCOztJQUVuRztBQVhBLFlBQUEsMENBQUE7QUFhQSxhQUFnQixpQ0FBaUMsT0FBeUM7QUFDdEYsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxjQUFjLE1BQU0sZUFBZSxTQUFZLFVBQWEsR0FBQSxVQUFBLFdBQVUsTUFBTSxZQUFZLG1CQUFBLHNCQUFzQjtRQUM5RyxhQUFhLE1BQU07UUFDbkIsaUJBQWlCLE1BQU07UUFDdkIsb0JBQW9CLE1BQU07O0lBRWxDO0FBZEEsWUFBQSxtQ0FBQTs7Ozs7Ozs7OztBQzVDQSxhQUFnQix1QkFBdUIsT0FBYTtBQUNoRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxhQUFhO0FBQ3hDLG1CQUFhLGNBQWMsWUFBWTtBQUV2QyxhQUFPO0lBQ1g7QUFOQSxZQUFBLHlCQUFBO0FBUUEsYUFBZ0IscUJBQXFCLE1BQVM7QUFDMUMsYUFBTywwQkFBMEIsTUFBTSxLQUFLO0lBQ2hEO0FBRkEsWUFBQSx1QkFBQTtBQUlBLGFBQWdCLDBCQUEwQixNQUFXLHFCQUE0QjtBQUM3RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBVyxLQUFLLFNBQVM7UUFDekIsVUFBVSxLQUFLLFFBQVE7O0lBRS9CO0FBVEEsWUFBQSw0QkFBQTtBQVdBLGFBQWdCLG1CQUFtQixPQUEyQjtBQUMxRCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsTUFBTTtRQUNqQixVQUFVLE1BQU07O0lBRXhCO0FBWkEsWUFBQSxxQkFBQTs7Ozs7Ozs7OztBQy9DQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlCQUFBO0FBeUNBLGFBQWdCLGlCQUFpQixPQUFhO0FBQzFDLFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLFFBQVE7QUFDbkMsbUJBQWEsY0FBYyxZQUFZO0FBRXZDLGFBQU87SUFDWDtBQU5BLFlBQUEsbUJBQUE7QUFRQSxhQUFnQixlQUFlLE1BQVM7QUFDcEMsYUFBTyxvQkFBb0IsTUFBTSxLQUFLO0lBQzFDO0FBRkEsWUFBQSxpQkFBQTtBQUlBLGFBQWdCLG9CQUFvQixNQUFXLHFCQUE0QjtBQUN2RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxLQUFLLElBQUk7UUFDZixVQUFVLEtBQUssUUFBUTtRQUN2QixnQkFBZ0IsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGNBQWMsSUFBSSxVQUFZLEdBQUEsZUFBQSxzQkFBcUIsS0FBSyxjQUFjLENBQUM7UUFDckcsWUFBWSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sVUFBVSxJQUFJLFNBQVksS0FBSyxVQUFVOztJQUUzRTtBQVhBLFlBQUEsc0JBQUE7QUFhQSxhQUFnQixhQUFhLE9BQXFCO0FBQzlDLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxNQUFNO1FBQ1osVUFBVSxNQUFNO1FBQ2hCLGlCQUFnQixHQUFBLGVBQUEsb0JBQW1CLE1BQU0sWUFBWTtRQUNyRCxZQUFZLE1BQU07O0lBRTFCO0FBZEEsWUFBQSxlQUFBOzs7Ozs7Ozs7O0FDcEVBLFFBQUEsWUFBQTtBQUVBLFFBQUEsV0FBQTtBQTZCQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwwQkFBQTtBQU1BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxVQUFhLEdBQUEsVUFBQSxXQUFVLEtBQUssU0FBUyxHQUFHLFNBQUEsY0FBYztRQUM1RixhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7O0lBRTlFO0FBVEEsWUFBQSw2QkFBQTtBQVdBLGFBQWdCLG9CQUFvQixPQUE0QjtBQUM1RCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsTUFBTSxZQUFZLFNBQVksVUFBYSxHQUFBLFVBQUEsV0FBVSxNQUFNLFNBQVMsU0FBQSxZQUFZO1FBQzNGLGFBQWEsTUFBTTs7SUFFM0I7QUFaQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7O0FDcERBLFFBQUEsWUFBQTtBQW9DQSxhQUFnQixxQkFBcUIsT0FBYTtBQUM5QyxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSx1QkFBQTtBQU1BLGFBQWdCLG1CQUFtQixNQUFTO0FBQ3hDLGFBQU8sd0JBQXdCLE1BQU0sS0FBSztJQUM5QztBQUZBLFlBQUEscUJBQUE7QUFJQSxhQUFnQix3QkFBd0IsTUFBVyxxQkFBNEI7QUFDM0UsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGtCQUFrQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0saUJBQWlCLElBQUksU0FBWSxLQUFLLGlCQUFpQjtRQUN2RixNQUFNLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxJQUFJLElBQUksU0FBWSxLQUFLLElBQUk7UUFDakQsS0FBSyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sR0FBRyxJQUFJLFNBQVksS0FBSyxHQUFHO1FBQzlDLGVBQWUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGNBQWMsSUFBSSxTQUFZLEtBQUssY0FBYzs7SUFFdEY7QUFYQSxZQUFBLDBCQUFBO0FBYUEsYUFBZ0IsaUJBQWlCLE9BQXlCO0FBQ3RELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsbUJBQW1CLE1BQU07UUFDekIsTUFBTSxNQUFNO1FBQ1osS0FBSyxNQUFNO1FBQ1gsZ0JBQWdCLE1BQU07O0lBRTlCO0FBZEEsWUFBQSxtQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNEQSxRQUFBLHVCQUFBO0FBZUEsYUFBZ0IscUNBQXFDLE1BQVM7QUFDMUQsYUFBTywwQ0FBMEMsTUFBTSxLQUFLO0lBQ2hFO0FBRkEsWUFBQSx1Q0FBQTtBQUlBLGFBQWdCLDBDQUEwQyxNQUFXLHFCQUE0QjtBQUM3RixVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFBLFNBQUEsQ0FBQSxJQUFZLEdBQUEscUJBQUEsaUNBQWdDLE1BQU0sSUFBSSxDQUFDO0lBQzNEO0FBTEEsWUFBQSw0Q0FBQTtBQU9BLGFBQWdCLG1DQUFtQyxPQUEyQztBQUMxRixVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBR1gsV0FBSSxHQUFBLHFCQUFBLDhCQUE2QixLQUFLLEdBQUc7QUFDckMsZ0JBQU8sR0FBQSxxQkFBQSwwQkFBeUIsS0FBMkI7O0FBRy9ELGFBQU8sQ0FBQTtJQUNYO0FBYkEsWUFBQSxxQ0FBQTs7Ozs7Ozs7OztBQzFCQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlDQUFBO0FBOEVBLGFBQWdCLDRCQUE0QixPQUFhO0FBQ3JELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLDhCQUFBO0FBTUEsYUFBZ0IsMEJBQTBCLE1BQVM7QUFDL0MsYUFBTywrQkFBK0IsTUFBTSxLQUFLO0lBQ3JEO0FBRkEsWUFBQSw0QkFBQTtBQUlBLGFBQWdCLCtCQUErQixNQUFXLHFCQUE0QjtBQUNsRixVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sTUFBTSxJQUFJLFNBQVksS0FBSyxNQUFNO1FBQ3ZELGFBQWEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFdBQVcsSUFBSSxTQUFZLEtBQUssV0FBVztRQUN0RSxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxZQUFZLElBQUksU0FBWSxLQUFLLFlBQVk7UUFDeEUsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxZQUFZLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxVQUFVLElBQUksU0FBWSxLQUFLLFVBQVU7UUFDbkUsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFVBQVUsSUFBSSxTQUFZLEtBQUssVUFBVTtRQUNsRSxlQUFlLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxjQUFjLElBQUksVUFBWSxHQUFBLCtCQUFBLHNDQUFxQyxLQUFLLGNBQWMsQ0FBQztRQUNwSCxrQkFBa0IsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGlCQUFpQixJQUFJLFNBQVksS0FBSyxpQkFBaUI7O0lBRS9GO0FBakJBLFlBQUEsaUNBQUE7QUFtQkEsYUFBZ0Isd0JBQXdCLE9BQWdDO0FBQ3BFLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxNQUFNO1FBQ2QsYUFBYSxNQUFNO1FBQ25CLGNBQWMsTUFBTTtRQUNwQixVQUFVLE1BQU07UUFDaEIsUUFBUSxNQUFNO1FBQ2QsWUFBWSxNQUFNO1FBQ2xCLFVBQVUsTUFBTTtRQUNoQixZQUFZLE1BQU07UUFDbEIsaUJBQWdCLEdBQUEsK0JBQUEsb0NBQW1DLE1BQU0sV0FBVztRQUNwRSxtQkFBbUIsTUFBTTs7SUFFakM7QUFwQkEsWUFBQSwwQkFBQTs7Ozs7Ozs7OztBQzdHQSxRQUFBLFlBQUE7QUFxQ2EsWUFBQSwyQkFBMkI7TUFDcEMsY0FBYztNQUNkLHNCQUFzQjtNQUN0QixXQUFXO01BQ1gsYUFBYTtNQUNiLGtCQUFrQjtNQUNsQixvQkFBb0I7TUFDcEIsYUFBYTtNQUNiLE9BQU87O0FBUVgsYUFBZ0IsMEJBQTBCLE9BQWE7QUFDbkQsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsNEJBQUE7QUFNQSxhQUFnQix3QkFBd0IsTUFBUztBQUM3QyxhQUFPLDZCQUE2QixNQUFNLEtBQUs7SUFDbkQ7QUFGQSxZQUFBLDBCQUFBO0FBSUEsYUFBZ0IsNkJBQTZCLE1BQVcscUJBQTRCO0FBQ2hGLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxTQUFTLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxPQUFPLElBQUksU0FBWSxLQUFLLE9BQU87UUFDMUQsU0FBUyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sT0FBTyxJQUFJLFNBQVksS0FBSyxPQUFPO1FBQzFELFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxRQUFRLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxNQUFNLElBQUksU0FBWSxLQUFLLE1BQU07O0lBRS9EO0FBWEEsWUFBQSwrQkFBQTtBQWFBLGFBQWdCLHNCQUFzQixPQUE4QjtBQUNoRSxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFNBQVMsTUFBTTtRQUNmLFNBQVMsTUFBTTtRQUNmLFFBQVEsTUFBTTtRQUNkLFFBQVEsTUFBTTs7SUFFdEI7QUFkQSxZQUFBLHdCQUFBOzs7Ozs7Ozs7O0FDNUVBLFFBQUEsWUFBQTtBQUVBLFFBQUEsc0JBQUE7QUFNQSxRQUFBLG9CQUFBO0FBNkJBLGFBQWdCLG9CQUFvQixPQUFhO0FBQzdDLFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLHNCQUFBO0FBTUEsYUFBZ0Isa0JBQWtCLE1BQVM7QUFDdkMsYUFBTyx1QkFBdUIsTUFBTSxLQUFLO0lBQzdDO0FBRkEsWUFBQSxvQkFBQTtBQUlBLGFBQWdCLHVCQUF1QixNQUFXLHFCQUE0QjtBQUMxRSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsWUFBWSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sVUFBVSxJQUFJLFVBQVksR0FBQSxvQkFBQSwyQkFBMEIsS0FBSyxVQUFVLENBQUM7UUFDOUYsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFVBQVksR0FBQSxrQkFBQSx5QkFBd0IsS0FBSyxRQUFRLENBQUM7O0lBRTlGO0FBVEEsWUFBQSx5QkFBQTtBQVdBLGFBQWdCLGdCQUFnQixPQUF3QjtBQUNwRCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILGFBQVksR0FBQSxvQkFBQSx5QkFBd0IsTUFBTSxRQUFRO1FBQ2xELFdBQVUsR0FBQSxrQkFBQSx1QkFBc0IsTUFBTSxNQUFNOztJQUVwRDtBQVpBLFlBQUEsa0JBQUE7Ozs7Ozs7Ozs7QUMxREEsUUFBQSxZQUFBO0FBd0JBLGFBQWdCLHVCQUF1QixPQUFhO0FBQ2hELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLHlCQUFBO0FBTUEsYUFBZ0IscUJBQXFCLE1BQVM7QUFDMUMsYUFBTywwQkFBMEIsTUFBTSxLQUFLO0lBQ2hEO0FBRkEsWUFBQSx1QkFBQTtBQUlBLGFBQWdCLDBCQUEwQixNQUFXLHFCQUE0QjtBQUM3RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsWUFBWSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sVUFBVSxJQUFJLFNBQVksS0FBSyxVQUFVO1FBQ25FLFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFVBQVUsSUFBSSxTQUFZLEtBQUssVUFBVTs7SUFFMUU7QUFUQSxZQUFBLDRCQUFBO0FBV0EsYUFBZ0IsbUJBQW1CLE9BQTJCO0FBQzFELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsWUFBWSxNQUFNO1FBQ2xCLFlBQVksTUFBTTs7SUFFMUI7QUFaQSxZQUFBLHFCQUFBOzs7Ozs7Ozs7O0FDN0NBLFFBQUEsWUFBQTtBQXdCQSxhQUFnQixzQkFBc0IsT0FBYTtBQUMvQyxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSx3QkFBQTtBQU1BLGFBQWdCLG9CQUFvQixNQUFTO0FBQ3pDLGFBQU8seUJBQXlCLE1BQU0sS0FBSztJQUMvQztBQUZBLFlBQUEsc0JBQUE7QUFJQSxhQUFnQix5QkFBeUIsTUFBVyxxQkFBNEI7QUFDNUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxTQUFZLEtBQUssU0FBUztRQUNoRSxTQUFTLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxPQUFPLElBQUksU0FBWSxLQUFLLE9BQU87O0lBRWxFO0FBVEEsWUFBQSwyQkFBQTtBQVdBLGFBQWdCLGtCQUFrQixPQUEwQjtBQUN4RCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsTUFBTTtRQUNqQixTQUFTLE1BQU07O0lBRXZCO0FBWkEsWUFBQSxvQkFBQTs7Ozs7Ozs7OztBQ25DYSxZQUFBLG9CQUFvQjtNQUM3QixXQUFXOztBQUtmLGFBQWdCLDBCQUEwQixNQUFTO0FBQy9DLGFBQU8sK0JBQStCLE1BQU0sS0FBSztJQUNyRDtBQUZBLFlBQUEsNEJBQUE7QUFJQSxhQUFnQiwrQkFBK0IsTUFBVyxxQkFBNEI7QUFDbEYsYUFBTztJQUNYO0FBRkEsWUFBQSxpQ0FBQTtBQUlBLGFBQWdCLHdCQUF3QixPQUFnQztBQUNwRSxhQUFPO0lBQ1g7QUFGQSxZQUFBLDBCQUFBOzs7Ozs7Ozs7O0FDeEJBLFFBQUEsWUFBQTtBQUVBLFFBQUEsaUJBQUE7QUErQ0EsYUFBZ0Isc0JBQXNCLE9BQWE7QUFDL0MsVUFBSSxhQUFhO0FBQ2pCLG1CQUFhLGNBQWMsWUFBWTtBQUV2QyxhQUFPO0lBQ1g7QUFMQSxZQUFBLHdCQUFBO0FBT0EsYUFBZ0Isb0JBQW9CLE1BQVM7QUFDekMsYUFBTyx5QkFBeUIsTUFBTSxLQUFLO0lBQy9DO0FBRkEsWUFBQSxzQkFBQTtBQUlBLGFBQWdCLHlCQUF5QixNQUFXLHFCQUE0QjtBQUM1RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsVUFBVSxLQUFLLFFBQVE7UUFDdkIsZ0JBQWdCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxjQUFjLElBQUksVUFBWSxHQUFBLGVBQUEsc0JBQXFCLEtBQUssY0FBYyxDQUFDO1FBQ3JHLFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7UUFDdEUsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFROztJQUVyRTtBQVpBLFlBQUEsMkJBQUE7QUFjQSxhQUFnQixrQkFBa0IsT0FBMEI7QUFDeEQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxVQUFVLE1BQU07UUFDaEIsaUJBQWdCLEdBQUEsZUFBQSxvQkFBbUIsTUFBTSxZQUFZO1FBQ3JELFFBQVEsTUFBTTtRQUNkLGFBQWEsTUFBTTtRQUNuQixVQUFVLE1BQU07O0lBRXhCO0FBZkEsWUFBQSxvQkFBQTs7Ozs7Ozs7OztBQzFFQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGdCQUFBO0FBTUEsUUFBQSxpQkFBQTtBQXdFQSxhQUFnQix1QkFBdUIsT0FBYTtBQUNoRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxVQUFVO0FBRXJDLGFBQU87SUFDWDtBQUxBLFlBQUEseUJBQUE7QUFPQSxhQUFnQixxQkFBcUIsTUFBUztBQUMxQyxhQUFPLDBCQUEwQixNQUFNLEtBQUs7SUFDaEQ7QUFGQSxZQUFBLHVCQUFBO0FBSUEsYUFBZ0IsMEJBQTBCLE1BQVcscUJBQTRCO0FBQzdFLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7UUFDdEUsUUFBUSxLQUFLLE1BQU07UUFDbkIsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELGlCQUFpQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sZUFBZSxJQUFJLFNBQVksS0FBSyxlQUFlO1FBQ2xGLG1CQUFtQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0saUJBQWlCLElBQUksU0FBWSxLQUFLLGlCQUFpQjtRQUN4RixXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxTQUFTLElBQUksU0FBYyxLQUFLLFNBQVMsRUFBaUIsSUFBSSxjQUFBLG1CQUFtQjtRQUMxRyxVQUFVLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7UUFDN0QsZ0JBQWdCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxjQUFjLElBQUksVUFBWSxHQUFBLGVBQUEsc0JBQXFCLEtBQUssY0FBYyxDQUFDO1FBQ3JHLE1BQU0sRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLElBQUksSUFBSSxTQUFZLEtBQUssSUFBSTs7SUFFekQ7QUFoQkEsWUFBQSw0QkFBQTtBQWtCQSxhQUFnQixtQkFBbUIsT0FBMkI7QUFDMUQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxhQUFhLE1BQU07UUFDbkIsUUFBUSxNQUFNO1FBQ2QsVUFBVSxNQUFNO1FBQ2hCLGlCQUFpQixNQUFNO1FBQ3ZCLG1CQUFtQixNQUFNO1FBQ3pCLFdBQVcsTUFBTSxZQUFZLFNBQVksU0FBYyxNQUFNLFFBQXVCLElBQUksY0FBQSxpQkFBaUI7UUFDekcsVUFBVSxNQUFNO1FBQ2hCLGlCQUFnQixHQUFBLGVBQUEsb0JBQW1CLE1BQU0sWUFBWTtRQUNyRCxNQUFNLE1BQU07O0lBRXBCO0FBbkJBLFlBQUEscUJBQUE7Ozs7Ozs7Ozs7QUM3R0EsUUFBQSxZQUFBO0FBRUEsUUFBQSxpQkFBQTtBQStDQSxhQUFnQix1QkFBdUIsT0FBYTtBQUNoRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxRQUFRO0FBRW5DLGFBQU87SUFDWDtBQUxBLFlBQUEseUJBQUE7QUFPQSxhQUFnQixxQkFBcUIsTUFBUztBQUMxQyxhQUFPLDBCQUEwQixNQUFNLEtBQUs7SUFDaEQ7QUFGQSxZQUFBLHVCQUFBO0FBSUEsYUFBZ0IsMEJBQTBCLE1BQVcscUJBQTRCO0FBQzdFLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxNQUFNLEtBQUssSUFBSTtRQUNmLFNBQVMsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE9BQU8sSUFBSSxTQUFZLEtBQUssT0FBTztRQUMxRCxVQUFVLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7UUFDN0QsZ0JBQWdCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxjQUFjLElBQUksVUFBWSxHQUFBLGVBQUEsc0JBQXFCLEtBQUssY0FBYyxDQUFDO1FBQ3JHLFlBQVksRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFVBQVUsSUFBSSxTQUFZLEtBQUssVUFBVTs7SUFFM0U7QUFaQSxZQUFBLDRCQUFBO0FBY0EsYUFBZ0IsbUJBQW1CLE9BQTJCO0FBQzFELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxNQUFNO1FBQ1osU0FBUyxNQUFNO1FBQ2YsVUFBVSxNQUFNO1FBQ2hCLGlCQUFnQixHQUFBLGVBQUEsb0JBQW1CLE1BQU0sWUFBWTtRQUNyRCxZQUFZLE1BQU07O0lBRTFCO0FBZkEsWUFBQSxxQkFBQTs7Ozs7Ozs7OztBQzFFQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlCQUFBO0FBNkJBLGFBQWdCLDZCQUE2QixPQUFhO0FBQ3RELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLCtCQUFBO0FBTUEsYUFBZ0IsMkJBQTJCLE1BQVM7QUFDaEQsYUFBTyxnQ0FBZ0MsTUFBTSxLQUFLO0lBQ3REO0FBRkEsWUFBQSw2QkFBQTtBQUlBLGFBQWdCLGdDQUFnQyxNQUFXLHFCQUE0QjtBQUNuRixVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBVyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sU0FBUyxJQUFJLFNBQWMsS0FBSyxTQUFTLEVBQWlCLElBQUksZUFBQSxvQkFBb0I7UUFDM0csYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXOztJQUU5RTtBQVRBLFlBQUEsa0NBQUE7QUFXQSxhQUFnQix5QkFBeUIsT0FBaUM7QUFDdEUsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxXQUFXLE1BQU0sWUFBWSxTQUFZLFNBQWMsTUFBTSxRQUF1QixJQUFJLGVBQUEsa0JBQWtCO1FBQzFHLGFBQWEsTUFBTTs7SUFFM0I7QUFaQSxZQUFBLDJCQUFBOzs7Ozs7Ozs7O0FDcERBLFFBQUEsWUFBQTtBQUVBLFFBQUEsaUJBQUE7QUFNQSxRQUFBLHVCQUFBO0FBb0NBLGFBQWdCLHdCQUF3QixPQUFhO0FBQ2pELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLDBCQUFBO0FBTUEsYUFBZ0Isc0JBQXNCLE1BQVM7QUFDM0MsYUFBTywyQkFBMkIsTUFBTSxLQUFLO0lBQ2pEO0FBRkEsWUFBQSx3QkFBQTtBQUlBLGFBQWdCLDJCQUEyQixNQUFXLHFCQUE0QjtBQUM5RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBVyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sU0FBUyxJQUFJLFNBQWMsS0FBSyxTQUFTLEVBQWlCLElBQUkscUJBQUEsMEJBQTBCO1FBQ2pILFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxTQUFjLEtBQUssU0FBUyxFQUFpQixJQUFJLGVBQUEsb0JBQW9CO1FBQzNHLGFBQWEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFdBQVcsSUFBSSxTQUFZLEtBQUssV0FBVzs7SUFFOUU7QUFWQSxZQUFBLDZCQUFBO0FBWUEsYUFBZ0Isb0JBQW9CLE9BQTRCO0FBQzVELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBVyxNQUFNLFlBQVksU0FBWSxTQUFjLE1BQU0sUUFBdUIsSUFBSSxxQkFBQSx3QkFBd0I7UUFDaEgsV0FBVyxNQUFNLFlBQVksU0FBWSxTQUFjLE1BQU0sUUFBdUIsSUFBSSxlQUFBLGtCQUFrQjtRQUMxRyxhQUFhLE1BQU07O0lBRTNCO0FBYkEsWUFBQSxzQkFBQTs7Ozs7Ozs7OztBQ2xFQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGdCQUFBO0FBbUNBLGFBQWdCLG9CQUFvQixPQUFhO0FBQzdDLFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLHNCQUFBO0FBTUEsYUFBZ0Isa0JBQWtCLE1BQVM7QUFDdkMsYUFBTyx1QkFBdUIsTUFBTSxLQUFLO0lBQzdDO0FBRkEsWUFBQSxvQkFBQTtBQUlBLGFBQWdCLHVCQUF1QixNQUFXLHFCQUE0QjtBQUMxRSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sTUFBTSxJQUFJLFNBQVksS0FBSyxNQUFNO1FBQ3ZELFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxTQUFZLEtBQUssU0FBUztRQUNoRSxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxTQUFTLElBQUksU0FBYyxLQUFLLFNBQVMsRUFBaUIsSUFBSSxjQUFBLG1CQUFtQjs7SUFFbEg7QUFWQSxZQUFBLHlCQUFBO0FBWUEsYUFBZ0IsZ0JBQWdCLE9BQXdCO0FBQ3BELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxNQUFNO1FBQ2QsV0FBVyxNQUFNO1FBQ2pCLFdBQVcsTUFBTSxZQUFZLFNBQVksU0FBYyxNQUFNLFFBQXVCLElBQUksY0FBQSxpQkFBaUI7O0lBRWpIO0FBYkEsWUFBQSxrQkFBQTs7Ozs7Ozs7OztBQzNEQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlCQUFBO0FBK0NBLGFBQWdCLHdCQUF3QixPQUFhO0FBQ2pELFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLFFBQVE7QUFFbkMsYUFBTztJQUNYO0FBTEEsWUFBQSwwQkFBQTtBQU9BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILE1BQU0sS0FBSyxJQUFJO1FBQ2YsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELGdCQUFnQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sY0FBYyxJQUFJLFVBQVksR0FBQSxlQUFBLHNCQUFxQixLQUFLLGNBQWMsQ0FBQztRQUNyRyxlQUFlLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxhQUFhLElBQUksU0FBWSxLQUFLLGFBQWE7UUFDNUUsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXOztJQUU5RTtBQVpBLFlBQUEsNkJBQUE7QUFjQSxhQUFnQixvQkFBb0IsT0FBNEI7QUFDNUQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxNQUFNLE1BQU07UUFDWixVQUFVLE1BQU07UUFDaEIsaUJBQWdCLEdBQUEsZUFBQSxvQkFBbUIsTUFBTSxZQUFZO1FBQ3JELGVBQWUsTUFBTTtRQUNyQixhQUFhLE1BQU07O0lBRTNCO0FBZkEsWUFBQSxzQkFBQTs7Ozs7Ozs7OztBQzFFQSxRQUFBLFlBQUE7QUFFQSxRQUFBLFdBQUE7QUE2QkEsYUFBZ0Isd0JBQXdCLE9BQWE7QUFDakQsVUFBSSxhQUFhO0FBQ2pCLG1CQUFhLGNBQWMsYUFBYTtBQUV4QyxhQUFPO0lBQ1g7QUFMQSxZQUFBLDBCQUFBO0FBT0EsYUFBZ0Isc0JBQXNCLE1BQVM7QUFDM0MsYUFBTywyQkFBMkIsTUFBTSxLQUFLO0lBQ2pEO0FBRkEsWUFBQSx3QkFBQTtBQUlBLGFBQWdCLDJCQUEyQixNQUFXLHFCQUE0QjtBQUM5RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBYSxLQUFLLFNBQVMsRUFBaUIsSUFBSSxTQUFBLGNBQWM7UUFDOUQsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXOztJQUU5RTtBQVRBLFlBQUEsNkJBQUE7QUFXQSxhQUFnQixvQkFBb0IsT0FBNEI7QUFDNUQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxXQUFhLE1BQU0sUUFBdUIsSUFBSSxTQUFBLFlBQVk7UUFDMUQsYUFBYSxNQUFNOztJQUUzQjtBQVpBLFlBQUEsc0JBQUE7Ozs7Ozs7Ozs7QUNyREEsUUFBQSxZQUFBO0FBa0JBLGFBQWdCLHlCQUF5QixPQUFhO0FBQ2xELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLDJCQUFBO0FBTUEsYUFBZ0IsdUJBQXVCLE1BQVM7QUFDNUMsYUFBTyw0QkFBNEIsTUFBTSxLQUFLO0lBQ2xEO0FBRkEsWUFBQSx5QkFBQTtBQUlBLGFBQWdCLDRCQUE0QixNQUFXLHFCQUE0QjtBQUMvRSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsaUJBQWlCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxlQUFlLElBQUksU0FBWSxLQUFLLGVBQWU7O0lBRTFGO0FBUkEsWUFBQSw4QkFBQTtBQVVBLGFBQWdCLHFCQUFxQixPQUE2QjtBQUM5RCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILGlCQUFpQixNQUFNOztJQUUvQjtBQVhBLFlBQUEsdUJBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbERBLGlCQUFBLDhCQUFBLE9BQUE7QUFDQSxpQkFBQSwwQkFBQSxPQUFBO0FBQ0EsaUJBQUEsbUNBQUEsT0FBQTtBQUNBLGlCQUFBLHlCQUFBLE9BQUE7QUFDQSxpQkFBQSxvQ0FBQSxPQUFBO0FBQ0EsaUJBQUEseUJBQUEsT0FBQTtBQUNBLGlCQUFBLHFDQUFBLE9BQUE7QUFDQSxpQkFBQSxzQ0FBQSxPQUFBO0FBQ0EsaUJBQUEseUJBQUEsT0FBQTtBQUNBLGlCQUFBLHNCQUFBLE9BQUE7QUFDQSxpQkFBQSxxQkFBQSxPQUFBO0FBQ0EsaUJBQUEsNkJBQUEsT0FBQTtBQUNBLGlCQUFBLHdDQUFBLE9BQUE7QUFDQSxpQkFBQSwyQkFBQSxPQUFBO0FBQ0EsaUJBQUEsNEJBQUEsT0FBQTtBQUNBLGlCQUFBLHdCQUFBLE9BQUE7QUFDQSxpQkFBQSx1QkFBQSxPQUFBO0FBQ0EsaUJBQUEsNkJBQUEsT0FBQTtBQUNBLGlCQUFBLHdCQUFBLE9BQUE7QUFDQSxpQkFBQSx5QkFBQSxPQUFBO0FBQ0EsaUJBQUEsdUJBQUEsT0FBQTtBQUNBLGlCQUFBLHFCQUFBLE9BQUE7QUFDQSxpQkFBQSx3QkFBQSxPQUFBO0FBQ0EsaUJBQUEsOEJBQUEsT0FBQTtBQUNBLGlCQUFBLHdCQUFBLE9BQUE7QUFDQSxpQkFBQSx5QkFBQSxPQUFBO0FBQ0EsaUJBQUEseUJBQUEsT0FBQTtBQUNBLGlCQUFBLDBCQUFBLE9BQUE7QUFDQSxpQkFBQSxrQkFBQSxPQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkEsUUFBQSxVQUFBLGFBQUEsaUJBQUE7QUFRQSxRQUFBLFVBQUE7QUE2Q0EsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBd0Msa0JBQUFDLHFCQUFBLE1BQUE7QUFBeEMsaUJBQUFBLHNCQUFBOztRQWlVQTtBQTVUVSxRQUFBQSxvQkFBQSxVQUFBLG9CQUFOLFNBQXdCLG1CQUEwQyxlQUEwRDs7Ozs7O0FBQ3hILHNCQUFJLGtCQUFrQixjQUFjLFFBQVEsa0JBQWtCLGNBQWMsUUFBVztBQUNuRiwwQkFBTSxJQUFJLFFBQVEsY0FBYyxhQUFZLG1HQUFtRzs7QUFHN0ksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU0seUJBQXlCLFFBQVEsSUFBQSxPQUFJLGFBQVcsR0FBQSxHQUFLLG1CQUFtQixPQUFPLGtCQUFrQixTQUFTLENBQUMsQ0FBQztvQkFDbEgsUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFFBQUEsb0JBQW1CLGtCQUFrQixZQUFZO3FCQUN4RCxhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQixzQkFBSSxLQUFLLFdBQVcsU0FBUyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUc7QUFDdkQsMkJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBd0IsUUFBUSxDQUFDO3lCQUNqRDtBQUNILDJCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFFBQVEsQ0FBUTs7Ozs7Ozs7OztBQU9yRCxRQUFBRCxvQkFBQSxVQUFBLGlCQUFOLFNBQXFCLG1CQUEwQyxlQUEwRDs7Ozs7O0FBQ3BHLHlCQUFBLENBQUEsR0FBTSxLQUFLLGtCQUFrQixtQkFBbUIsYUFBYSxDQUFDOztBQUF6RSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxzQkFBTixTQUEwQixtQkFBcUQsZUFBMEQ7Ozs7OztBQUMvSCxvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxtQ0FBaUIsY0FBYyxJQUFJO0FBRW5DLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztvQkFDUCxPQUFNLEdBQUEsUUFBQSwrQkFBOEIsa0JBQWtCLHVCQUF1QjtxQkFDOUUsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIsc0JBQUksS0FBSyxXQUFXLFNBQVMsUUFBUSxJQUFJLGNBQWMsQ0FBQyxHQUFHO0FBQ3ZELDJCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQXdCLFFBQVEsQ0FBQzt5QkFDakQ7QUFDSCwyQkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixRQUFRLENBQVE7Ozs7Ozs7Ozs7QUFPckQsUUFBQUQsb0JBQUEsVUFBQSxtQkFBTixTQUF1QixtQkFBMEQsZUFBMEQ7QUFBcEgsY0FBQSxzQkFBQSxRQUFBO0FBQUEsZ0NBQUEsQ0FBQTtVQUF3RDs7Ozs7O0FBQzFELHlCQUFBLENBQUEsR0FBTSxLQUFLLG9CQUFvQixtQkFBbUIsYUFBYSxDQUFDOztBQUEzRSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxpQkFBTixTQUFxQixtQkFBdUMsZUFBMEQ7Ozs7OztBQUM1RyxvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxtQ0FBaUIsY0FBYyxJQUFJO0FBRW5DLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztvQkFDUCxPQUFNLEdBQUEsUUFBQSxxQkFBb0Isa0JBQWtCLGFBQWE7cUJBQzFELGFBQWEsQ0FBQzs7QUFOWCw2QkFBV0MsSUFBQSxLQUFBO0FBUWpCLHNCQUFJLEtBQUssV0FBVyxTQUFTLFFBQVEsSUFBSSxjQUFjLENBQUMsR0FBRztBQUN2RCwyQkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUF3QixRQUFRLENBQUM7eUJBQ2pEO0FBQ0gsMkJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsUUFBUSxDQUFROzs7Ozs7Ozs7O0FBT3JELFFBQUFELG9CQUFBLFVBQUEsY0FBTixTQUFrQixtQkFBNEMsZUFBMEQ7QUFBdEcsY0FBQSxzQkFBQSxRQUFBO0FBQUEsZ0NBQUEsQ0FBQTtVQUEwQzs7Ozs7O0FBQ3ZDLHlCQUFBLENBQUEsR0FBTSxLQUFLLGVBQWUsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBdEUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTTNCLFFBQUFELG9CQUFBLFVBQUEsc0JBQU4sU0FBMEIsbUJBQTRDLGVBQTBEOzs7Ozs7QUFDNUgsc0JBQUksa0JBQWtCLG1CQUFtQixRQUFRLGtCQUFrQixtQkFBbUIsUUFBVztBQUM3RiwwQkFBTSxJQUFJLFFBQVEsY0FBYyxrQkFBaUIsMEdBQTBHOztBQUd6SixvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU0sZ0NBQWdDLFFBQVEsSUFBQSxPQUFJLGtCQUFnQixHQUFBLEdBQUssbUJBQW1CLE9BQU8sa0JBQWtCLGNBQWMsQ0FBQyxDQUFDO29CQUNuSSxRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQixzQkFBSSxLQUFLLFdBQVcsU0FBUyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUc7QUFDdkQsMkJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBd0IsUUFBUSxDQUFDO3lCQUNqRDtBQUNILDJCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFFBQVEsQ0FBUTs7Ozs7Ozs7OztBQU9yRCxRQUFBRCxvQkFBQSxVQUFBLG1CQUFOLFNBQXVCLG1CQUE0QyxlQUEwRDs7Ozs7O0FBQ3hHLHlCQUFBLENBQUEsR0FBTSxLQUFLLG9CQUFvQixtQkFBbUIsYUFBYSxDQUFDOztBQUEzRSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxpQkFBTixTQUFxQixtQkFBdUMsZUFBMEQ7Ozs7OztBQUNsSCxzQkFBSSxrQkFBa0IsY0FBYyxRQUFRLGtCQUFrQixjQUFjLFFBQVc7QUFDbkYsMEJBQU0sSUFBSSxRQUFRLGNBQWMsYUFBWSxnR0FBZ0c7O0FBRzFJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTSx5QkFBeUIsUUFBUSxJQUFBLE9BQUksYUFBVyxHQUFBLEdBQUssbUJBQW1CLE9BQU8sa0JBQWtCLFNBQVMsQ0FBQyxDQUFDO29CQUNsSCxRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQixzQkFBSSxLQUFLLFdBQVcsU0FBUyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUc7QUFDdkQsMkJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBd0IsUUFBUSxDQUFDO3lCQUNqRDtBQUNILDJCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFFBQVEsQ0FBUTs7Ozs7Ozs7OztBQU9yRCxRQUFBRCxvQkFBQSxVQUFBLGNBQU4sU0FBa0IsbUJBQXVDLGVBQTBEOzs7Ozs7QUFDOUYseUJBQUEsQ0FBQSxHQUFNLEtBQUssZUFBZSxtQkFBbUIsYUFBYSxDQUFDOztBQUF0RSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSx3QkFBTixTQUE0QixtQkFBOEMsZUFBMEQ7Ozs7OztBQUNoSSxzQkFBSSxrQkFBa0IsbUJBQW1CLFFBQVEsa0JBQWtCLG1CQUFtQixRQUFXO0FBQzdGLDBCQUFNLElBQUksUUFBUSxjQUFjLGtCQUFpQiw0R0FBNEc7O0FBRzNKLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTSxnQ0FBZ0MsUUFBUSxJQUFBLE9BQUksa0JBQWdCLEdBQUEsR0FBSyxtQkFBbUIsT0FBTyxrQkFBa0IsY0FBYyxDQUFDLENBQUM7b0JBQ25JLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO3FCQUNSLGFBQWEsQ0FBQzs7QUFMWCw2QkFBV0MsSUFBQSxLQUFBO0FBT2pCLHlCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFVBQVUsU0FBQyxXQUFTO0FBQUssNEJBQUEsR0FBQSxRQUFBLHdCQUF1QixTQUFTO2tCQUFoQyxDQUFpQyxDQUFDOzs7OztBQU01RixRQUFBRCxvQkFBQSxVQUFBLHFCQUFOLFNBQXlCLG1CQUE4QyxlQUEwRDs7Ozs7O0FBQzVHLHlCQUFBLENBQUEsR0FBTSxLQUFLLHNCQUFzQixtQkFBbUIsYUFBYSxDQUFDOztBQUE3RSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxtQkFBTixTQUF1QixtQkFBeUMsZUFBMEQ7Ozs7OztBQUN0SCxzQkFBSSxrQkFBa0IsY0FBYyxRQUFRLGtCQUFrQixjQUFjLFFBQVc7QUFDbkYsMEJBQU0sSUFBSSxRQUFRLGNBQWMsYUFBWSxrR0FBa0c7O0FBRzVJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTSx5QkFBeUIsUUFBUSxJQUFBLE9BQUksYUFBVyxHQUFBLEdBQUssbUJBQW1CLE9BQU8sa0JBQWtCLFNBQVMsQ0FBQyxDQUFDO29CQUNsSCxRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixVQUFVLFNBQUMsV0FBUztBQUFLLDRCQUFBLEdBQUEsUUFBQSxtQkFBa0IsU0FBUztrQkFBM0IsQ0FBNEIsQ0FBQzs7Ozs7QUFNdkYsUUFBQUQsb0JBQUEsVUFBQSxnQkFBTixTQUFvQixtQkFBeUMsZUFBMEQ7Ozs7OztBQUNsRyx5QkFBQSxDQUFBLEdBQU0sS0FBSyxpQkFBaUIsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBeEUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTTNCLFFBQUFELG9CQUFBLFVBQUEscUJBQU4sU0FBeUIsZUFBMEQ7Ozs7OztBQUN6RSxvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87cUJBQ1IsYUFBYSxDQUFDOztBQUxYLDZCQUFXQyxJQUFBLEtBQUE7QUFPakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBcUIsUUFBUSxDQUFDOzs7OztBQU0vQyxRQUFBRCxvQkFBQSxVQUFBLGtCQUFOLFNBQXNCLGVBQTBEOzs7Ozs7QUFDM0QseUJBQUEsQ0FBQSxHQUFNLEtBQUssbUJBQW1CLGFBQWEsQ0FBQzs7QUFBdkQsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTTNCLFFBQUFELG9CQUFBLFVBQUEsaUJBQU4sU0FBcUIsZUFBMEQ7Ozs7OztBQUNyRSxvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87cUJBQ1IsYUFBYSxDQUFDOztBQUxYLDZCQUFXQyxJQUFBLEtBQUE7QUFPakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBcUIsUUFBUSxDQUFDOzs7OztBQU0vQyxRQUFBRCxvQkFBQSxVQUFBLGNBQU4sU0FBa0IsZUFBMEQ7Ozs7OztBQUN2RCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxlQUFlLGFBQWEsQ0FBQzs7QUFBbkQsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBR3JDLGVBQUFEO01BQUEsRUFqVXdDLFFBQVEsT0FBTzs7QUFBMUMsWUFBQSxxQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JEYixRQUFBLFVBQUEsYUFBQSxpQkFBQTtBQWFBLFFBQUEsVUFBQTtBQXlEQSxRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUF5QyxrQkFBQUUsc0JBQUEsTUFBQTtBQUF6QyxpQkFBQUEsdUJBQUE7O1FBNlRBO0FBdlRVLFFBQUFBLHFCQUFBLFVBQUEsYUFBTixTQUFpQixtQkFBMkMsZUFBMEQ7Ozs7OztBQUNsSCxzQkFBSSxrQkFBa0Isa0JBQWtCLFFBQVEsa0JBQWtCLGtCQUFrQixRQUFXO0FBQzNGLDBCQUFNLElBQUksUUFBUSxjQUFjLGlCQUFnQixnR0FBZ0c7O0FBRzlJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLG1DQUFpQixjQUFjLElBQUk7QUFFbkMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO29CQUNQLE9BQU0sR0FBQSxRQUFBLHFCQUFvQixrQkFBa0IsYUFBYTtxQkFDMUQsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBcUIsUUFBUSxDQUFDOzs7OztBQU8vQyxRQUFBRCxxQkFBQSxVQUFBLFVBQU4sU0FBYyxtQkFBMkMsZUFBMEQ7Ozs7OztBQUM5Rix5QkFBQSxDQUFBLEdBQU0sS0FBSyxXQUFXLG1CQUFtQixhQUFhLENBQUM7O0FBQWxFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU8zQixRQUFBRCxxQkFBQSxVQUFBLGFBQU4sU0FBaUIsbUJBQW1DLGVBQTBEOzs7Ozs7QUFDcEcsb0NBQXVCLENBQUE7QUFFN0Isc0JBQUksa0JBQWtCLEtBQUs7QUFDdkIsb0NBQWdCLEtBQUssSUFBSSxrQkFBa0I7O0FBRy9DLHNCQUFJLGtCQUFrQixjQUFjLFFBQVc7QUFDM0Msb0NBQWdCLFdBQVcsSUFBSSxrQkFBa0I7O0FBR3JELHNCQUFJLGtCQUFrQixjQUFjLFFBQVc7QUFDM0Msb0NBQWdCLFdBQVcsSUFBSSxrQkFBa0I7O0FBRy9DLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFxQixRQUFRLENBQUM7Ozs7O0FBTy9DLFFBQUFELHFCQUFBLFVBQUEsVUFBTixTQUFjLG1CQUF3QyxlQUEwRDtBQUFsRyxjQUFBLHNCQUFBLFFBQUE7QUFBQSxnQ0FBQSxDQUFBO1VBQXNDOzs7Ozs7QUFDL0IseUJBQUEsQ0FBQSxHQUFNLEtBQUssV0FBVyxtQkFBbUIsYUFBYSxDQUFDOztBQUFsRSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFPM0IsUUFBQUQscUJBQUEsVUFBQSx3QkFBTixTQUE0QixtQkFBdUQsZUFBMEQ7Ozs7OztBQUN6SSxzQkFBSSxrQkFBa0IsOEJBQThCLFFBQVEsa0JBQWtCLDhCQUE4QixRQUFXO0FBQ25ILDBCQUFNLElBQUksUUFBUSxjQUFjLDZCQUE0Qix1SEFBdUg7O0FBR2pMLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLG1DQUFpQixjQUFjLElBQUk7QUFFbkMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO29CQUNQLE9BQU0sR0FBQSxRQUFBLGlDQUFnQyxrQkFBa0IseUJBQXlCO3FCQUNsRixhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixVQUFVLFNBQUMsV0FBUztBQUFLLDRCQUFBLEdBQUEsUUFBQSxvQ0FBbUMsU0FBUztrQkFBNUMsQ0FBNkMsQ0FBQzs7Ozs7QUFPeEcsUUFBQUQscUJBQUEsVUFBQSxxQkFBTixTQUF5QixtQkFBdUQsZUFBMEQ7Ozs7OztBQUNySCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxzQkFBc0IsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBN0UsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTzNCLFFBQUFELHFCQUFBLFVBQUEseUJBQU4sU0FBNkIsZUFBMEQ7Ozs7OztBQUM3RSxvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87cUJBQ1IsYUFBYSxDQUFDOztBQUxYLDZCQUFXQyxJQUFBLEtBQUE7QUFPakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsVUFBVSxTQUFDLFdBQVM7QUFBSyw0QkFBQSxHQUFBLFFBQUEsb0NBQW1DLFNBQVM7a0JBQTVDLENBQTZDLENBQUM7Ozs7O0FBT3hHLFFBQUFELHFCQUFBLFVBQUEsc0JBQU4sU0FBMEIsZUFBMEQ7Ozs7OztBQUMvRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyx1QkFBdUIsYUFBYSxDQUFDOztBQUEzRCw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFPM0IsUUFBQUQscUJBQUEsVUFBQSxXQUFOLFNBQWUsbUJBQWlDLGVBQTBEOzs7Ozs7QUFDdEcsc0JBQUksa0JBQWtCLFFBQVEsUUFBUSxrQkFBa0IsUUFBUSxRQUFXO0FBQ3ZFLDBCQUFNLElBQUksUUFBUSxjQUFjLE9BQU0sb0ZBQW9GOztBQUd4SCxvQ0FBdUIsQ0FBQTtBQUU3QixzQkFBSSxrQkFBa0IsS0FBSztBQUN2QixvQ0FBZ0IsS0FBSyxJQUFJLGtCQUFrQjs7QUFHL0Msc0JBQUksa0JBQWtCLGNBQWMsUUFBVztBQUMzQyxvQ0FBZ0IsV0FBVyxJQUFJLGtCQUFrQjs7QUFHL0MscUNBQXdDLENBQUE7QUFFOUMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO3FCQUNSLGFBQWEsQ0FBQzs7QUFMWCw2QkFBV0MsSUFBQSxLQUFBO0FBT2pCLHlCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFVBQVUsU0FBQyxXQUFTO0FBQUssNEJBQUEsR0FBQSxRQUFBLHVCQUFzQixTQUFTO2tCQUEvQixDQUFnQyxDQUFDOzs7OztBQU8zRixRQUFBRCxxQkFBQSxVQUFBLFFBQU4sU0FBWSxtQkFBaUMsZUFBMEQ7Ozs7OztBQUNsRix5QkFBQSxDQUFBLEdBQU0sS0FBSyxTQUFTLG1CQUFtQixhQUFhLENBQUM7O0FBQWhFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU8zQixRQUFBRCxxQkFBQSxVQUFBLFdBQU4sU0FBZSxtQkFBMEMsZUFBMEQ7Ozs7OztBQUMvRyxzQkFBSSxrQkFBa0IsaUJBQWlCLFFBQVEsa0JBQWtCLGlCQUFpQixRQUFXO0FBQ3pGLDBCQUFNLElBQUksUUFBUSxjQUFjLGdCQUFlLDZGQUE2Rjs7QUFHMUksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFFBQUEsb0JBQW1CLGtCQUFrQixZQUFZO3FCQUN4RCxhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixVQUFVLFNBQUMsV0FBUztBQUFLLDRCQUFBLEdBQUEsUUFBQSx1QkFBc0IsU0FBUztrQkFBL0IsQ0FBZ0MsQ0FBQzs7Ozs7QUFPM0YsUUFBQUQscUJBQUEsVUFBQSxRQUFOLFNBQVksbUJBQTBDLGVBQTBEOzs7Ozs7QUFDM0YseUJBQUEsQ0FBQSxHQUFNLEtBQUssU0FBUyxtQkFBbUIsYUFBYSxDQUFDOztBQUFoRSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFPM0IsUUFBQUQscUJBQUEsVUFBQSxZQUFOLFNBQWdCLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQ2pILHNCQUFJLGtCQUFrQixrQkFBa0IsUUFBUSxrQkFBa0Isa0JBQWtCLFFBQVc7QUFDM0YsMEJBQU0sSUFBSSxRQUFRLGNBQWMsaUJBQWdCLCtGQUErRjs7QUFHN0ksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFFBQUEscUJBQW9CLGtCQUFrQixhQUFhO3FCQUMxRCxhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFxQixRQUFRLENBQUM7Ozs7O0FBTy9DLFFBQUFELHFCQUFBLFVBQUEsU0FBTixTQUFhLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQzdGLHlCQUFBLENBQUEsR0FBTSxLQUFLLFVBQVUsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBakUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTzNCLFFBQUFELHFCQUFBLFVBQUEsWUFBTixTQUFnQixtQkFBMkMsZUFBMEQ7Ozs7OztBQUNqSCxzQkFBSSxrQkFBa0Isa0JBQWtCLFFBQVEsa0JBQWtCLGtCQUFrQixRQUFXO0FBQzNGLDBCQUFNLElBQUksUUFBUSxjQUFjLGlCQUFnQiwrRkFBK0Y7O0FBRzdJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLG1DQUFpQixjQUFjLElBQUk7QUFFbkMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO29CQUNQLE9BQU0sR0FBQSxRQUFBLHFCQUFvQixrQkFBa0IsYUFBYTtxQkFDMUQsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsVUFBVSxTQUFDLFdBQVM7QUFBSyw0QkFBQSxHQUFBLFFBQUEsd0JBQXVCLFNBQVM7a0JBQWhDLENBQWlDLENBQUM7Ozs7O0FBTzVGLFFBQUFELHFCQUFBLFVBQUEsU0FBTixTQUFhLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQzdGLHlCQUFBLENBQUEsR0FBTSxLQUFLLFVBQVUsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBakUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBR3JDLGVBQUFEO01BQUEsRUE3VHlDLFFBQVEsT0FBTzs7QUFBM0MsWUFBQSxzQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRmIsaUJBQUEsOEJBQUEsT0FBQTtBQUNBLGlCQUFBLCtCQUFBLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDREEsaUJBQUEsbUJBQUEsT0FBQTtBQUNBLGlCQUFBLGdCQUFBLE9BQUE7QUFDQSxpQkFBQSxrQkFBQSxPQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkEsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBdUMsa0JBQUFFLG9CQUFBLE1BQUE7QUFDckMsaUJBQUFBLG1CQUFZLFNBQWdCOztBQUE1QixjQUFBLFFBQ0UsT0FBQSxLQUFBLE1BQU0sT0FBTyxLQUFDO0FBR2QsaUJBQU8sZUFBZSxPQUFNLFdBQVcsU0FBUztBQUdoRCxjQUFJLE1BQU0sbUJBQW1CO0FBQzNCLGtCQUFNLGtCQUFrQixPQUFJLFVBQUE7O0FBSTlCLGdCQUFLLE9BQU8sTUFBSyxZQUFZOztRQUMvQjtBQUNGLGVBQUFBO01BQUEsRUFmdUMsS0FBSzs7QUFBL0IsWUFBQSxvQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FiLFFBQUEsU0FBQTtBQUVBLFFBQU0sY0FBYztBQUVwQixRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUFnRCxrQkFBQUMsNkJBQUEsTUFBQTtBQUM5QyxpQkFBQUEsNEJBQVksU0FBZTtBQUEzQixjQUFBLFFBQ0UsT0FBQSxLQUFBLE1BQU0sR0FBQSxPQUFHLFNBQU8sR0FBQSxFQUFBLE9BQUksV0FBVyxDQUFFLEtBQUM7QUFDbEMsZ0JBQUssT0FBTzs7UUFDZDtBQUNGLGVBQUFBO01BQUEsRUFMZ0QsT0FBQSxpQkFBaUI7O0FBQXBELFlBQUEsNkJBQUE7QUFPYixRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUFxRCxrQkFBQUMsa0NBQUEsTUFBQTtBQUNuRCxpQkFBQUEsaUNBQVksS0FBYSxRQUFnQixNQUFjLFNBQWdCO0FBQXZFLGNBQUEsUUFDRSxPQUFBLEtBQUEsTUFDRSxxQ0FBQSxPQUFxQyxLQUFHLElBQUEsRUFBQSxPQUN0QyxVQUFVLFVBQVUsTUFBTSxJQUFFLFVBQUEsRUFBQSxPQUNuQixRQUFNLFVBQUEsRUFBQSxPQUFXLElBQUksQ0FBRSxLQUNuQztBQUNELGdCQUFLLE9BQU87O1FBQ2Q7QUFDRixlQUFBQTtNQUFBLEVBVHFELE9BQUEsaUJBQWlCOztBQUF6RCxZQUFBLGtDQUFBO0FBV2IsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBOEQsa0JBQUFDLDJDQUFBLE1BQUE7QUFDNUQsaUJBQUFBLDBDQUFZLFNBQWU7QUFBM0IsY0FBQSxRQUNFLE9BQUEsS0FBQSxNQUFNLE9BQU8sS0FBQztBQUNkLGdCQUFLLE9BQU87O1FBQ2Q7QUFDRixlQUFBQTtNQUFBLEVBTDhELE9BQUEsaUJBQWlCOztBQUFsRSxZQUFBLDJDQUFBO0FBT2IsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBbUQsa0JBQUFDLGdDQUFBLE1BQUE7QUFDakQsaUJBQUFBLCtCQUFZLEtBQWEsaUJBQXNCO0FBQS9DLGNBQUEsUUFBQTtBQUNFLGNBQU0sVUFBVSxpREFBQSxPQUFpRCxLQUFHLDhFQUFBLEVBQUEsT0FBK0UsS0FBSyxVQUN0SixnQkFBZ0IsT0FBTyxDQUN4QjtrQkFDRCxPQUFBLEtBQUEsTUFBTSxPQUFPLEtBQUM7QUFDZCxnQkFBSyxPQUFPOztRQUNkO0FBQ0YsZUFBQUE7TUFBQSxFQVJtRCxPQUFBLGlCQUFpQjs7QUFBdkQsWUFBQSxnQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCYixRQUFBLFNBQUE7QUFTQSxRQUFNLGNBQWM7QUFFcEIsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBNkMsa0JBQUFDLDBCQUFBLE1BQUE7QUFDM0MsaUJBQUFBLHlCQUFZLGVBQWdDO0FBQTVDLGNBQUEsUUFBQTtBQUNVLGNBQUEsVUFBWSxjQUFhO2tCQUNqQyxPQUFBLEtBQUEsTUFBTSxPQUFPLEtBQUM7QUFDZCxnQkFBSyxPQUFPOztRQUNkO0FBQ0YsZUFBQUE7TUFBQSxFQU42QyxPQUFBLGlCQUFpQjs7QUFBakQsWUFBQSwwQkFBQTtBQVFiLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQWdELGtCQUFBQyw2QkFBQSxNQUFBO0FBQzlDLGlCQUFBQSw0QkFBWSxlQUFnQztBQUE1QyxjQUFBLFFBQUE7QUFDVSxjQUFBLE1BQVEsY0FBYTtBQUM3QixjQUFJLEtBQUs7QUFDUCxvQkFBQSxPQUFBLEtBQUEsTUFDRSx1REFBQSxPQUF1RCxLQUFHLDBEQUFBLEVBQUEsT0FBMkQsV0FBVyxDQUFFLEtBQ25JO2lCQUNJO0FBQ0wsb0JBQUEsT0FBQSxLQUFBLE1BQ0UsZ0dBQUEsT0FBZ0csV0FBVyxDQUFFLEtBQzlHOztBQUVILGdCQUFLLE9BQU87O1FBQ2Q7QUFDRixlQUFBQTtNQUFBLEVBZGdELE9BQUEsaUJBQWlCOztBQUFwRCxZQUFBLDZCQUFBO0FBZ0JiLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQTJDLGtCQUFBQyx3QkFBQSxNQUFBO0FBQ3pDLGlCQUFBQSx1QkFBWSxlQUFnQztBQUE1QyxjQUFBLFFBQUE7QUFDVSxjQUFBLE1BQWlCLGNBQWEsS0FBekIsVUFBWSxjQUFhO0FBQ3RDLGNBQUksS0FBSztBQUNQLG9CQUFBLE9BQUEsS0FBQSxNQUNFLGFBQUEsT0FBYSxLQUFHLDZCQUFBLEVBQUEsT0FBOEIsVUFBVSxVQUFVLEVBQUUsQ0FBRSxLQUN2RTtxQkFDUSxTQUFTO0FBQ2xCLG9CQUFBLE9BQUEsS0FBQSxNQUFNLE9BQU8sS0FBQztpQkFDVDtBQUNMLG9CQUFBLE9BQUEsS0FBQSxJQUFBLEtBQU87O0FBR1QsZ0JBQUssT0FBTzs7UUFDZDtBQUNGLGVBQUFBO01BQUEsRUFmMkMsT0FBQSxpQkFBaUI7O0FBQS9DLFlBQUEsd0JBQUE7QUFpQmIsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBMkMsa0JBQUFDLHdCQUFBLE1BQUE7QUFDekMsaUJBQUFBLHVCQUFZLGVBQWdDO0FBQTVDLGNBQUEsUUFBQTtBQUNVLGNBQUEsTUFBaUIsY0FBYSxLQUF6QixVQUFZLGNBQWE7QUFDdEMsY0FBSSxLQUFLO0FBQ1Asb0JBQUEsT0FBQSxLQUFBLE1BQ0UsYUFBQSxPQUFhLEtBQUcsNkJBQUEsRUFBQSxPQUE4QixVQUFVLFVBQVUsRUFBRSxDQUFFLEtBQ3ZFO3FCQUNRLFNBQVM7QUFDbEIsb0JBQUEsT0FBQSxLQUFBLE1BQU0sT0FBTyxLQUFDO2lCQUNUO0FBQ0wsb0JBQUEsT0FBQSxLQUFBLElBQUEsS0FBTzs7QUFHVCxnQkFBSyxPQUFPOztRQUNkO0FBQ0YsZUFBQUE7TUFBQSxFQWYyQyxPQUFBLGlCQUFpQjs7QUFBL0MsWUFBQSx3QkFBQTtBQWlCYixRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUFpRCxrQkFBQUMsOEJBQUEsTUFBQTtBQUMvQyxpQkFBQUEsNkJBQVksZUFBZ0M7QUFBNUMsY0FBQSxRQUFBO0FBQ1UsY0FBQSxNQUFjLGNBQWEsS0FBdEIsT0FBUyxjQUFhO0FBQ25DLGNBQU0sUUFBUSxNQUNWLHNEQUFBLE9BQXNELEtBQUcsWUFBQSxJQUN6RDtBQUNKLGNBQU0sT0FBTztBQUNiLGNBQU0sY0FBYyxPQUFPLFNBQUEsT0FBUyxJQUFJLElBQUs7a0JBQzdDLE9BQUEsS0FBQSxNQUFNLENBQUMsT0FBTyxNQUFNLFdBQVcsRUFBRSxLQUFLLEdBQUcsRUFBRSxLQUFJLENBQUUsS0FBQztBQUNsRCxnQkFBSyxPQUFPOztRQUNkO0FBQ0YsZUFBQUE7TUFBQSxFQVhpRCxPQUFBLGlCQUFpQjs7QUFBckQsWUFBQSw4QkFBQTtBQWFiLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQWlELGtCQUFBQyw4QkFBQSxNQUFBO0FBQy9DLGlCQUFBQSw2QkFBWSxhQUE4QjtBQUExQyxjQUFBLFFBQUE7QUFDVSxjQUFBLE1BQWlCLFlBQVcsS0FBdkIsVUFBWSxZQUFXO0FBQ3BDLGNBQUksS0FBSztBQUNQLG9CQUFBLE9BQUEsS0FBQSxNQUNFLGFBQUEsT0FBYSxLQUFHLDZCQUFBLEVBQUEsT0FBOEIsVUFBVSxVQUFVLEVBQUUsQ0FBRSxLQUN2RTtxQkFDUSxTQUFTO0FBQ2xCLG9CQUFBLE9BQUEsS0FBQSxNQUFNLE9BQU8sS0FBQztpQkFDVDtBQUNMLG9CQUFBLE9BQUEsS0FBQSxJQUFBLEtBQU87O0FBRVQsZ0JBQUssT0FBTzs7UUFDZDtBQUNGLGVBQUFBO01BQUEsRUFkaUQsT0FBQSxpQkFBaUI7O0FBQXJELFlBQUEsOEJBQUE7QUFnQmIsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBK0Msa0JBQUFDLDRCQUFBLE1BQUE7QUFDN0MsaUJBQUFBLDJCQUFZLGVBQWdDO0FBQTVDLGNBQUEsUUFBQTtBQUNVLGNBQUEsTUFBK0IsY0FBYSxLQUF2QyxTQUEwQixjQUFhLFFBQS9CLE9BQWtCLGNBQWEsTUFBekIsVUFBWSxjQUFhO0FBQ3BELGNBQU0sUUFBUSxNQUNWLGlEQUFBLE9BQWlELEtBQUcsYUFBQSxJQUNwRDtBQUNKLGNBQU0sWUFBWSxTQUFTLFdBQUEsT0FBVyxRQUFNLElBQUEsSUFBTztBQUNuRCxjQUFNLFVBQVUsT0FBTyxTQUFBLE9BQVMsSUFBSSxJQUFLO2tCQUV6QyxPQUFBLEtBQUEsTUFBTSxDQUFDLE9BQU8sU0FBUyxXQUFXLE9BQU8sRUFBRSxLQUFLLEdBQUcsRUFBRSxLQUFJLENBQUUsS0FBQztBQUM1RCxnQkFBSyxPQUFPOztRQUNkO0FBQ0YsZUFBQUE7TUFBQSxFQVorQyxPQUFBLGlCQUFpQjs7QUFBbkQsWUFBQSw0QkFBQTtBQWNOLFFBQU0scUJBQXFCLFNBQUMsbUJBQW9DO0FBQ3JFLGNBQVEsa0JBQWtCLFFBQVE7UUFDaEMsS0FBSztBQUNILGlCQUFPLElBQUksd0JBQXdCLGlCQUFpQjtRQUN0RCxLQUFLO0FBQ0gsaUJBQU8sSUFBSSwyQkFBMkIsaUJBQWlCO1FBQ3pELEtBQUs7QUFDSCxpQkFBTyxJQUFJLHNCQUFzQixpQkFBaUI7UUFDcEQsS0FBSztBQUNILGlCQUFPLElBQUksc0JBQXNCLGlCQUFpQjtRQUNwRCxLQUFLO0FBQ0gsaUJBQU8sSUFBSSw0QkFBNEIsaUJBQWlCO1FBQzFELEtBQUs7QUFDSCxpQkFBTyxJQUFJLDRCQUE0QixpQkFBaUI7UUFDMUQ7QUFDRSxnQkFBTSxJQUFJLDBCQUEwQixpQkFBaUI7O0lBRTNEO0FBakJhLFlBQUEscUJBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEgvQixRQUFBLFNBQUE7QUFFQSxRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUE2QyxrQkFBQUMsMEJBQUEsTUFBQTtBQUMzQyxpQkFBQUEsMkJBQUE7QUFBQSxjQUFBLFFBQ0UsT0FBQSxLQUFBLE1BQ0UsbUhBQW1ILEtBQ3BIO0FBQ0QsZ0JBQUssT0FBTzs7UUFDZDtBQUNGLGVBQUFBO01BQUEsRUFQNkMsT0FBQSxpQkFBaUI7O0FBQWpELFlBQUEsMEJBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGYixRQUFBLFNBQUE7QUFFQSxRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUEyQyxrQkFBQUMsd0JBQUEsTUFBQTtBQUN6QyxpQkFBQUEsdUJBQVksU0FBZTtBQUEzQixjQUFBLFFBQ0UsT0FBQSxLQUFBLE1BQU0sR0FBQSxPQUFHLE9BQU8sQ0FBRSxLQUFDO0FBQ25CLGdCQUFLLE9BQU87O1FBQ2Q7QUFDRixlQUFBQTtNQUFBLEVBTDJDLE9BQUEsaUJBQWlCOztBQUEvQyxZQUFBLHdCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FOLFFBQU0saUJBQWlCLFNBQU8sT0FBb0I7QUFBQSxhQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7QUFDekMscUJBQUEsQ0FBQSxHQUFNLE1BQU0sU0FBUyxLQUFJLENBQUU7O0FBQXJDLHdCQUFVQyxJQUFBLEtBQUE7QUFNZCxrQkFBSTtBQUNJLDhCQUFjLEtBQUssTUFBTSxPQUFPO0FBQ3RDLG9CQUFJLFlBQVksU0FBUztBQUN2Qiw0QkFBVSxZQUFZOzt1QkFFakIsR0FBUDs7QUFJRixxQkFBQSxDQUFBLEdBQU8sT0FBTzs7Ozs7QUFoQkgsWUFBQSxpQkFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGM0IsUUFBQSxVQUFBO0FBQ0EsUUFBQSxTQUFBO0FBQ0EsUUFBQSxZQUFBO0FBT08sUUFBTSxtQkFBbUIsU0FDOUIsR0FDQSxxQkFBeUQ7QUFBQSxhQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7OztvQkFFckQsYUFBYSxTQUFTLEVBQUUsU0FBUztBQUFqQyx1QkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUNGLHFCQUFBLENBQUEsR0FBTyxJQUFJLFVBQUEsd0JBQXVCLENBQUU7O0FBRTdCLHFCQUFBLENBQUEsR0FBTSxvQkFBb0IsQ0FBa0IsQ0FBQzs7QUFBcEQscUJBQUEsQ0FBQSxHQUFPQyxJQUFBLEtBQUEsQ0FBNkM7Ozs7O0FBUDNDLFlBQUEsbUJBQWdCO0FBV3RCLFFBQU0saUJBQWlCLFNBQzVCLEdBQ0EsZUFHb0I7QUFBQSxhQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7OztBQUViLHFCQUFBLENBQUEsSUFBTSxHQUFBLFFBQUEsa0JBQ1gsR0FDQSxTQUFPLGVBQTRCO0FBQUEsdUJBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUNkLCtCQUFBLENBQUEsSUFBTSxHQUFBLFFBQUEsZ0JBQWUsYUFBYSxDQUFDOztBQUFoRCxxQ0FBYSxHQUFBLEtBQUE7QUFDYixxQ0FBYSxjQUFjLFNBQVM7NkJBQzFCO0FBQUEsaUNBQUEsQ0FBQSxHQUFBLENBQUE7QUFDWiwrQkFBQSxDQUFBLEdBQU0sY0FBYyxZQUFZLFVBQVUsQ0FBQzs7QUFBM0Msd0JBQUFBLE1BQUEsR0FBQSxLQUFBOzs7QUFDQSx3QkFBQUEsTUFBQTs7O0FBRkUsa0NBQU9BO0FBSWIsK0JBQUEsQ0FBQSxJQUFPLEdBQUEsT0FBQSxvQkFBbUI7MEJBQ3hCLFFBQVEsY0FBYyxTQUFTOzBCQUMvQixLQUFLLGNBQWMsU0FBUzswQkFDNUI7eUJBQ0QsQ0FBQzs7OztlQUNILENBQ0Y7O0FBZkQscUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FlTjs7Ozs7QUF0QlUsWUFBQSxpQkFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCM0IsUUFBQSxTQUFBO0FBRUEsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBOEMsa0JBQUFDLDJCQUFBLE1BQUE7QUFDNUMsaUJBQUFBLDBCQUNFLGNBQ0EsY0FDQSxVQUF1QjtBQUh6QixjQUFBLFFBQUE7QUFLRSxjQUFNLFlBQVk7QUFDbEIsY0FBSSxTQUFTLFNBQVMsV0FBVztBQUMvQix1QkFBVyxTQUFTLE1BQU0sR0FBRyxTQUFTO0FBQ3RDLHFCQUFTLEtBQUssVUFBQSxPQUFVLGVBQWUsV0FBUyxlQUFBLENBQWU7O2tCQUVqRSxPQUFBLEtBQUEsTUFDRSxHQUFBLE9BQUcsY0FBWSxVQUFBLEVBQUEsT0FDYixlQUFlLGNBQVksc0JBQUEsRUFBQSxPQUNMLFNBQVMsS0FBSyxLQUFNLENBQUMsQ0FBRSxLQUNoRDtBQUNELGdCQUFLLE9BQU87O1FBQ2Q7QUFDRixlQUFBQTtNQUFBLEVBbEI4QyxPQUFBLGlCQUFpQjs7QUFBbEQsWUFBQSwyQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRmIsUUFBQSxXQUFBO0FBQ0UsV0FBQSxlQUFBLFNBQUEsOEJBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxTQUFBO0lBQTBCLEVBQUEsQ0FBQTtBQUMxQixXQUFBLGVBQUEsU0FBQSxtQ0FBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFNBQUE7SUFBK0IsRUFBQSxDQUFBO0FBQy9CLFdBQUEsZUFBQSxTQUFBLDRDQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsU0FBQTtJQUF3QyxFQUFBLENBQUE7QUFDeEMsV0FBQSxlQUFBLFNBQUEsaUNBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxTQUFBO0lBQTZCLEVBQUEsQ0FBQTtBQUUvQixpQkFBQSxnQkFBQSxPQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQVMsV0FBQSxlQUFBLFNBQUEsMkJBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxVQUFBO0lBQXVCLEVBQUEsQ0FBQTtBQUNoQyxRQUFBLGVBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSx5QkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLGFBQUE7SUFBcUIsRUFBQSxDQUFBO0FBQzlCLFFBQUEsVUFBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLGtCQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsUUFBQTtJQUFjLEVBQUEsQ0FBQTtBQUN2QixRQUFBLGFBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSxrQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFdBQUE7SUFBYyxFQUFBLENBQUE7QUFDdkIsUUFBQSxXQUFBO0FBQVMsV0FBQSxlQUFBLFNBQUEsNEJBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxTQUFBO0lBQXdCLEVBQUEsQ0FBQTs7Ozs7Ozs7OztBQ1hqQyxRQUFzQixjQUF0QixNQUFpQzs7QUFBakMsWUFBQSxjQUFBO0FBT2EsWUFBQSxhQUFhO0FBRTFCLFFBQWEsT0FBYixjQUEwQixZQUFXO01BRW5DLFlBQVksR0FBUztBQUNuQixjQUFLO0FBQ0wsWUFBSSxDQUFDLFFBQUEsV0FBVyxLQUFLLENBQUM7QUFBRyxnQkFBTSxJQUFJLE1BQU0sMENBQTBDO0FBQ25GLGFBQUssTUFBTTtNQUNiO01BRUEsV0FBUTtBQUNOLGVBQU8sS0FBSztNQUNkO01BRUEsV0FBUTtBQUNOLGVBQU87TUFDVDtNQUVBLElBQUksUUFBSztBQUNQLGVBQU8sRUFBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEVBQUM7TUFDdkI7O0FBbEJGLFlBQUEsT0FBQTtBQXFCQSxRQUFhLFFBQWIsY0FBMkIsWUFBVztNQUtwQyxZQUFZLE1BQWtDO0FBQzVDLGNBQUs7QUFDTCxhQUFLLFNBQVMsT0FBTyxTQUFTLFdBQVcsQ0FBQyxJQUFJLElBQUk7TUFDcEQ7TUFFQSxXQUFRO0FBQ04sZUFBTyxLQUFLO01BQ2Q7TUFFQSxXQUFRO0FBQ04sWUFBSSxLQUFLLE9BQU8sU0FBUztBQUFHLGlCQUFPO0FBQ25DLGNBQU0sT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUMxQixlQUFPLFNBQVMsTUFBTSxTQUFTO01BQ2pDO01BRUEsSUFBSSxNQUFHOztBQUNMLGdCQUFPQyxNQUFDLEtBQUssVUFBSSxRQUFBQSxRQUFBLFNBQUFBLE1BQVQsS0FBSyxPQUFTLEtBQUssT0FBTyxPQUFPLENBQUMsR0FBVyxNQUFnQixHQUFHLElBQUksS0FBSyxFQUFFO01BQ3JGO01BRUEsSUFBSSxRQUFLOztBQUNQLGdCQUFPQSxNQUFDLEtBQUssWUFBTSxRQUFBQSxRQUFBLFNBQUFBLE1BQVgsS0FBSyxTQUFXLEtBQUssT0FBTyxPQUFPLENBQUMsT0FBa0IsTUFBSztBQUNqRSxjQUFJLGFBQWE7QUFBTSxrQkFBTSxFQUFFLEdBQUcsS0FBSyxNQUFNLEVBQUUsR0FBRyxLQUFLLEtBQUs7QUFDNUQsaUJBQU87UUFDVCxHQUFHLENBQUEsQ0FBRTtNQUNQOztBQTdCRixZQUFBLFFBQUE7QUF3Q2EsWUFBQSxNQUFNLElBQUksTUFBTSxFQUFFO0FBSS9CLGFBQWdCLEVBQUUsU0FBK0IsTUFBZTtBQUM5RCxZQUFNLE9BQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakMsVUFBSSxJQUFJO0FBQ1IsYUFBTyxJQUFJLEtBQUssUUFBUTtBQUN0QixtQkFBVyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQ3hCLGFBQUssS0FBSyxLQUFLLEVBQUUsQ0FBQyxDQUFDOztBQUVyQixhQUFPLElBQUksTUFBTSxJQUFJO0lBQ3ZCO0FBUkEsWUFBQSxJQUFBO0FBVUEsUUFBTSxPQUFPLElBQUksTUFBTSxHQUFHO0FBRTFCLGFBQWdCLElBQUksU0FBK0IsTUFBNEI7QUFDN0UsWUFBTSxPQUFtQixDQUFDLGNBQWMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNoRCxVQUFJLElBQUk7QUFDUixhQUFPLElBQUksS0FBSyxRQUFRO0FBQ3RCLGFBQUssS0FBSyxJQUFJO0FBQ2QsbUJBQVcsTUFBTSxLQUFLLENBQUMsQ0FBQztBQUN4QixhQUFLLEtBQUssTUFBTSxjQUFjLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFFMUMsZUFBUyxJQUFJO0FBQ2IsYUFBTyxJQUFJLE1BQU0sSUFBSTtJQUN2QjtBQVZBLFlBQUEsTUFBQTtBQVlBLGFBQWdCLFdBQVcsTUFBa0IsS0FBdUI7QUFDbEUsVUFBSSxlQUFlO0FBQU8sYUFBSyxLQUFLLEdBQUcsSUFBSSxNQUFNO2VBQ3hDLGVBQWU7QUFBTSxhQUFLLEtBQUssR0FBRzs7QUFDdEMsYUFBSyxLQUFLLFlBQVksR0FBRyxDQUFDO0lBQ2pDO0FBSkEsWUFBQSxhQUFBO0FBTUEsYUFBUyxTQUFTLE1BQWdCO0FBQ2hDLFVBQUksSUFBSTtBQUNSLGFBQU8sSUFBSSxLQUFLLFNBQVMsR0FBRztBQUMxQixZQUFJLEtBQUssQ0FBQyxNQUFNLE1BQU07QUFDcEIsZ0JBQU0sTUFBTSxlQUFlLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsQ0FBQztBQUNuRCxjQUFJLFFBQVEsUUFBVztBQUNyQixpQkFBSyxPQUFPLElBQUksR0FBRyxHQUFHLEdBQUc7QUFDekI7O0FBRUYsZUFBSyxHQUFHLElBQUk7O0FBRWQ7O0lBRUo7QUFFQSxhQUFTLGVBQWUsR0FBYSxHQUFXO0FBQzlDLFVBQUksTUFBTTtBQUFNLGVBQU87QUFDdkIsVUFBSSxNQUFNO0FBQU0sZUFBTztBQUN2QixVQUFJLE9BQU8sS0FBSyxVQUFVO0FBQ3hCLFlBQUksYUFBYSxRQUFRLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTTtBQUFLO0FBQ2xELFlBQUksT0FBTyxLQUFLO0FBQVUsaUJBQU8sR0FBRyxFQUFFLE1BQU0sR0FBRyxFQUFFLElBQUk7QUFDckQsWUFBSSxFQUFFLENBQUMsTUFBTTtBQUFLLGlCQUFPLEVBQUUsTUFBTSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQztBQUNuRDs7QUFFRixVQUFJLE9BQU8sS0FBSyxZQUFZLEVBQUUsQ0FBQyxNQUFNLE9BQU8sRUFBRSxhQUFhO0FBQU8sZUFBTyxJQUFJLElBQUksRUFBRSxNQUFNLENBQUM7QUFDMUY7SUFDRjtBQUVBLGFBQWdCLFVBQVUsSUFBVSxJQUFRO0FBQzFDLGFBQU8sR0FBRyxTQUFRLElBQUssS0FBSyxHQUFHLFNBQVEsSUFBSyxLQUFLLE1BQU0sS0FBSztJQUM5RDtBQUZBLFlBQUEsWUFBQTtBQUtBLGFBQVMsWUFBWSxHQUErQztBQUNsRSxhQUFPLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxhQUFhLE1BQU0sT0FDMUQsSUFDQSxjQUFjLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ3REO0FBRUEsYUFBZ0IsVUFBVSxHQUFVO0FBQ2xDLGFBQU8sSUFBSSxNQUFNLGNBQWMsQ0FBQyxDQUFDO0lBQ25DO0FBRkEsWUFBQSxZQUFBO0FBSUEsYUFBZ0IsY0FBYyxHQUFVO0FBQ3RDLGFBQU8sS0FBSyxVQUFVLENBQUMsRUFDcEIsUUFBUSxXQUFXLFNBQVMsRUFDNUIsUUFBUSxXQUFXLFNBQVM7SUFDakM7QUFKQSxZQUFBLGdCQUFBO0FBTUEsYUFBZ0IsWUFBWSxLQUEyQjtBQUNyRCxhQUFPLE9BQU8sT0FBTyxZQUFZLFFBQUEsV0FBVyxLQUFLLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksS0FBSztJQUN0RjtBQUZBLFlBQUEsY0FBQTtBQUtBLGFBQWdCLGlCQUFpQixLQUEyQjtBQUMxRCxVQUFJLE9BQU8sT0FBTyxZQUFZLFFBQUEsV0FBVyxLQUFLLEdBQUcsR0FBRztBQUNsRCxlQUFPLElBQUksTUFBTSxHQUFHLEtBQUs7O0FBRTNCLFlBQU0sSUFBSSxNQUFNLGlDQUFpQyxvQ0FBb0M7SUFDdkY7QUFMQSxZQUFBLG1CQUFBO0FBT0EsYUFBZ0IsV0FBVyxJQUFVO0FBQ25DLGFBQU8sSUFBSSxNQUFNLEdBQUcsU0FBUSxDQUFFO0lBQ2hDO0FBRkEsWUFBQSxhQUFBOzs7Ozs7Ozs7O0FDcktBLFFBQUEsU0FBQTtBQWVBLFFBQU0sYUFBTixjQUF5QixNQUFLO01BRTVCLFlBQVksTUFBb0I7QUFDOUIsY0FBTSx1QkFBdUIsa0JBQWtCO0FBQy9DLGFBQUssUUFBUSxLQUFLO01BQ3BCOztBQXdCRixRQUFZO0FBQVosS0FBQSxTQUFZQyxpQkFBYztBQUN4QixNQUFBQSxnQkFBQUEsZ0JBQUEsU0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBLE1BQUFBLGdCQUFBQSxnQkFBQSxXQUFBLElBQUEsQ0FBQSxJQUFBO0lBQ0YsR0FIWSxpQkFBQSxRQUFBLG1CQUFBLFFBQUEsaUJBQWMsQ0FBQSxFQUFBO0FBU2IsWUFBQSxXQUFXO01BQ3RCLE9BQU8sSUFBSSxPQUFBLEtBQUssT0FBTztNQUN2QixLQUFLLElBQUksT0FBQSxLQUFLLEtBQUs7TUFDbkIsS0FBSyxJQUFJLE9BQUEsS0FBSyxLQUFLOztBQUdyQixRQUFhLFFBQWIsTUFBa0I7TUFLaEIsWUFBWSxFQUFDLFVBQVUsT0FBTSxJQUFrQixDQUFBLEdBQUU7QUFKOUIsYUFBQSxTQUEyQyxDQUFBO0FBSzVELGFBQUssWUFBWTtBQUNqQixhQUFLLFVBQVU7TUFDakI7TUFFQSxPQUFPLGNBQTJCO0FBQ2hDLGVBQU8sd0JBQXdCLE9BQUEsT0FBTyxlQUFlLEtBQUssS0FBSyxZQUFZO01BQzdFO01BRUEsS0FBSyxRQUFjO0FBQ2pCLGVBQU8sSUFBSSxPQUFBLEtBQUssS0FBSyxTQUFTLE1BQU0sQ0FBQztNQUN2QztNQUVVLFNBQVMsUUFBYztBQUMvQixjQUFNLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxLQUFLLFdBQVcsTUFBTTtBQUN4RCxlQUFPLEdBQUcsU0FBUyxHQUFHO01BQ3hCO01BRVEsV0FBVyxRQUFjOztBQUMvQixjQUFJLE1BQUFDLE1BQUEsS0FBSyxhQUFPLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFLGVBQVMsUUFBQSxPQUFBLFNBQUEsU0FBQSxHQUFFLElBQUksTUFBTSxNQUFNLEtBQUssYUFBYSxDQUFDLEtBQUssVUFBVSxJQUFJLE1BQU0sR0FBSTtBQUMzRixnQkFBTSxJQUFJLE1BQU0sb0JBQW9CLHNDQUFzQzs7QUFFNUUsZUFBUSxLQUFLLE9BQU8sTUFBTSxJQUFJLEVBQUMsUUFBUSxPQUFPLEVBQUM7TUFDakQ7O0FBNUJGLFlBQUEsUUFBQTtBQW9DQSxRQUFhLGlCQUFiLGNBQW9DLE9BQUEsS0FBSTtNQUt0QyxZQUFZLFFBQWdCLFNBQWU7QUFDekMsY0FBTSxPQUFPO0FBQ2IsYUFBSyxTQUFTO01BQ2hCO01BRUEsU0FBUyxPQUFrQixFQUFDLFVBQVUsVUFBUyxHQUFZO0FBQ3pELGFBQUssUUFBUTtBQUNiLGFBQUssYUFBWSxHQUFBLE9BQUEsTUFBSyxJQUFJLE9BQUEsS0FBSyxRQUFRLEtBQUs7TUFDOUM7O0FBYkYsWUFBQSxpQkFBQTtBQW9CQSxRQUFNLFFBQU8sR0FBQSxPQUFBO0FBRWIsUUFBYSxhQUFiLGNBQWdDLE1BQUs7TUFLbkMsWUFBWSxNQUF1QjtBQUNqQyxjQUFNLElBQUk7QUFMTyxhQUFBLFVBQXVCLENBQUE7QUFNeEMsYUFBSyxTQUFTLEtBQUs7QUFDbkIsYUFBSyxPQUFPLEVBQUMsR0FBRyxNQUFNLElBQUksS0FBSyxRQUFRLE9BQU8sT0FBQSxJQUFHO01BQ25EO01BRUEsTUFBRztBQUNELGVBQU8sS0FBSztNQUNkO01BRUEsS0FBSyxRQUFjO0FBQ2pCLGVBQU8sSUFBSSxlQUFlLFFBQVEsS0FBSyxTQUFTLE1BQU0sQ0FBQztNQUN6RDtNQUVBLE1BQU0sY0FBdUMsT0FBZ0I7O0FBQzNELFlBQUksTUFBTSxRQUFRO0FBQVcsZ0JBQU0sSUFBSSxNQUFNLHNDQUFzQztBQUNuRixjQUFNLE9BQU8sS0FBSyxPQUFPLFlBQVk7QUFDckMsY0FBTSxFQUFDLE9BQU0sSUFBSTtBQUNqQixjQUFNLFlBQVdBLE1BQUEsTUFBTSxTQUFHLFFBQUFBLFFBQUEsU0FBQUEsTUFBSSxNQUFNO0FBQ3BDLFlBQUksS0FBSyxLQUFLLFFBQVEsTUFBTTtBQUM1QixZQUFJLElBQUk7QUFDTixnQkFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRO0FBQzdCLGNBQUk7QUFBTyxtQkFBTztlQUNiO0FBQ0wsZUFBSyxLQUFLLFFBQVEsTUFBTSxJQUFJLG9CQUFJLElBQUc7O0FBRXJDLFdBQUcsSUFBSSxVQUFVLElBQUk7QUFFckIsY0FBTSxJQUFJLEtBQUssT0FBTyxNQUFNLE1BQU0sS0FBSyxPQUFPLE1BQU0sSUFBSSxDQUFBO0FBQ3hELGNBQU0sWUFBWSxFQUFFO0FBQ3BCLFVBQUUsU0FBUyxJQUFJLE1BQU07QUFDckIsYUFBSyxTQUFTLE9BQU8sRUFBQyxVQUFVLFFBQVEsVUFBUyxDQUFDO0FBQ2xELGVBQU87TUFDVDtNQUVBLFNBQVMsUUFBZ0IsVUFBaUI7QUFDeEMsY0FBTSxLQUFLLEtBQUssUUFBUSxNQUFNO0FBQzlCLFlBQUksQ0FBQztBQUFJO0FBQ1QsZUFBTyxHQUFHLElBQUksUUFBUTtNQUN4QjtNQUVBLFVBQVUsV0FBaUIsU0FBdUMsS0FBSyxTQUFPO0FBQzVFLGVBQU8sS0FBSyxjQUFjLFFBQVEsQ0FBQyxTQUF3QjtBQUN6RCxjQUFJLEtBQUssY0FBYztBQUFXLGtCQUFNLElBQUksTUFBTSxrQkFBa0Isb0JBQW9CO0FBQ3hGLGtCQUFPLEdBQUEsT0FBQSxLQUFJLFlBQVksS0FBSztRQUM5QixDQUFDO01BQ0g7TUFFQSxVQUNFLFNBQXVDLEtBQUssU0FDNUMsWUFDQSxTQUFpRDtBQUVqRCxlQUFPLEtBQUssY0FDVixRQUNBLENBQUMsU0FBd0I7QUFDdkIsY0FBSSxLQUFLLFVBQVU7QUFBVyxrQkFBTSxJQUFJLE1BQU0sa0JBQWtCLG9CQUFvQjtBQUNwRixpQkFBTyxLQUFLLE1BQU07UUFDcEIsR0FDQSxZQUNBLE9BQU87TUFFWDtNQUVRLGNBQ04sUUFDQSxXQUNBLGFBQThCLENBQUEsR0FDOUIsU0FBaUQ7QUFFakQsWUFBSSxPQUFhLE9BQUE7QUFDakIsbUJBQVcsVUFBVSxRQUFRO0FBQzNCLGdCQUFNLEtBQUssT0FBTyxNQUFNO0FBQ3hCLGNBQUksQ0FBQztBQUFJO0FBQ1QsZ0JBQU0sVUFBVyxXQUFXLE1BQU0sSUFBSSxXQUFXLE1BQU0sS0FBSyxvQkFBSSxJQUFHO0FBQ25FLGFBQUcsUUFBUSxDQUFDLFNBQXdCO0FBQ2xDLGdCQUFJLFFBQVEsSUFBSSxJQUFJO0FBQUc7QUFDdkIsb0JBQVEsSUFBSSxNQUFNLGVBQWUsT0FBTztBQUN4QyxnQkFBSSxJQUFJLFVBQVUsSUFBSTtBQUN0QixnQkFBSSxHQUFHO0FBQ0wsb0JBQU0sTUFBTSxLQUFLLEtBQUssTUFBTSxRQUFBLFNBQVMsTUFBTSxRQUFBLFNBQVM7QUFDcEQsc0JBQU8sR0FBQSxPQUFBLEtBQUksT0FBTyxPQUFPLFVBQVUsS0FBSyxLQUFLLEtBQUs7dUJBQ3hDLElBQUksWUFBTyxRQUFQLFlBQU8sU0FBQSxTQUFQLFFBQVUsSUFBSSxHQUFJO0FBQ2hDLHNCQUFPLEdBQUEsT0FBQSxLQUFJLE9BQU8sSUFBSSxLQUFLLEtBQUs7bUJBQzNCO0FBQ0wsb0JBQU0sSUFBSSxXQUFXLElBQUk7O0FBRTNCLG9CQUFRLElBQUksTUFBTSxlQUFlLFNBQVM7VUFDNUMsQ0FBQzs7QUFFSCxlQUFPO01BQ1Q7O0FBaEdGLFlBQUEsYUFBQTs7Ozs7Ozs7OztBQ3BIQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFVBQUE7QUFFQSxRQUFBLFNBQUE7QUFBUSxXQUFBLGVBQUEsU0FBQSxLQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsT0FBQTtJQUFDLEVBQUEsQ0FBQTtBQUFFLFdBQUEsZUFBQSxTQUFBLE9BQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxPQUFBO0lBQUcsRUFBQSxDQUFBO0FBQUUsV0FBQSxlQUFBLFNBQUEsYUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLE9BQUE7SUFBUyxFQUFBLENBQUE7QUFBRSxXQUFBLGVBQUEsU0FBQSxPQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsT0FBQTtJQUFHLEVBQUEsQ0FBQTtBQUFFLFdBQUEsZUFBQSxTQUFBLGVBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxPQUFBO0lBQVcsRUFBQSxDQUFBO0FBQUUsV0FBQSxlQUFBLFNBQUEsYUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLE9BQUE7SUFBUyxFQUFBLENBQUE7QUFBRSxXQUFBLGVBQUEsU0FBQSxjQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsT0FBQTtJQUFVLEVBQUEsQ0FBQTtBQUFFLFdBQUEsZUFBQSxTQUFBLFFBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxPQUFBO0lBQUksRUFBQSxDQUFBO0FBQ3hFLFFBQUEsVUFBQTtBQUFRLFdBQUEsZUFBQSxTQUFBLFNBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxRQUFBO0lBQUssRUFBQSxDQUFBO0FBQWMsV0FBQSxlQUFBLFNBQUEsY0FBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFFBQUE7SUFBVSxFQUFBLENBQUE7QUFBRSxXQUFBLGVBQUEsU0FBQSxrQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFFBQUE7SUFBYyxFQUFBLENBQUE7QUFBa0IsV0FBQSxlQUFBLFNBQUEsWUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFFBQUE7SUFBUSxFQUFBLENBQUE7QUFRbEUsWUFBQSxZQUFZO01BQ3ZCLElBQUksSUFBSSxPQUFBLE1BQU0sR0FBRztNQUNqQixLQUFLLElBQUksT0FBQSxNQUFNLElBQUk7TUFDbkIsSUFBSSxJQUFJLE9BQUEsTUFBTSxHQUFHO01BQ2pCLEtBQUssSUFBSSxPQUFBLE1BQU0sSUFBSTtNQUNuQixJQUFJLElBQUksT0FBQSxNQUFNLEtBQUs7TUFDbkIsS0FBSyxJQUFJLE9BQUEsTUFBTSxLQUFLO01BQ3BCLEtBQUssSUFBSSxPQUFBLE1BQU0sR0FBRztNQUNsQixJQUFJLElBQUksT0FBQSxNQUFNLElBQUk7TUFDbEIsS0FBSyxJQUFJLE9BQUEsTUFBTSxJQUFJO01BQ25CLEtBQUssSUFBSSxPQUFBLE1BQU0sR0FBRzs7QUFHcEIsUUFBZSxPQUFmLE1BQW1CO01BR2pCLGdCQUFhO0FBQ1gsZUFBTztNQUNUO01BRUEsY0FBYyxRQUFtQixZQUFxQjtBQUNwRCxlQUFPO01BQ1Q7O0FBT0YsUUFBTSxNQUFOLGNBQWtCLEtBQUk7TUFDcEIsWUFBNkIsU0FBZ0MsTUFBb0IsS0FBYztBQUM3RixjQUFLO0FBRHNCLGFBQUEsVUFBQTtBQUFnQyxhQUFBLE9BQUE7QUFBb0IsYUFBQSxNQUFBO01BRWpGO01BRUEsT0FBTyxFQUFDLEtBQUssR0FBRSxHQUFZO0FBQ3pCLGNBQU0sVUFBVSxNQUFNLFFBQUEsU0FBUyxNQUFNLEtBQUs7QUFDMUMsY0FBTSxNQUFNLEtBQUssUUFBUSxTQUFZLEtBQUssTUFBTSxLQUFLO0FBQ3JELGVBQU8sR0FBRyxXQUFXLEtBQUssT0FBTyxTQUFTO01BQzVDO01BRUEsY0FBYyxPQUFrQixXQUFvQjtBQUNsRCxZQUFJLENBQUMsTUFBTSxLQUFLLEtBQUssR0FBRztBQUFHO0FBQzNCLFlBQUksS0FBSztBQUFLLGVBQUssTUFBTSxhQUFhLEtBQUssS0FBSyxPQUFPLFNBQVM7QUFDaEUsZUFBTztNQUNUO01BRUEsSUFBSSxRQUFLO0FBQ1AsZUFBTyxLQUFLLGVBQWUsT0FBQSxjQUFjLEtBQUssSUFBSSxRQUFRLENBQUE7TUFDNUQ7O0FBR0YsUUFBTSxTQUFOLGNBQXFCLEtBQUk7TUFDdkIsWUFBcUIsS0FBa0IsS0FBZ0MsYUFBcUI7QUFDMUYsY0FBSztBQURjLGFBQUEsTUFBQTtBQUFrQixhQUFBLE1BQUE7QUFBZ0MsYUFBQSxjQUFBO01BRXZFO01BRUEsT0FBTyxFQUFDLEdBQUUsR0FBWTtBQUNwQixlQUFPLEdBQUcsS0FBSyxTQUFTLEtBQUssU0FBUztNQUN4QztNQUVBLGNBQWMsT0FBa0IsV0FBb0I7QUFDbEQsWUFBSSxLQUFLLGVBQWUsT0FBQSxRQUFRLENBQUMsTUFBTSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSztBQUFhO0FBQzNFLGFBQUssTUFBTSxhQUFhLEtBQUssS0FBSyxPQUFPLFNBQVM7QUFDbEQsZUFBTztNQUNUO01BRUEsSUFBSSxRQUFLO0FBQ1AsY0FBTSxRQUFRLEtBQUssZUFBZSxPQUFBLE9BQU8sQ0FBQSxJQUFLLEVBQUMsR0FBRyxLQUFLLElBQUksTUFBSztBQUNoRSxlQUFPLGFBQWEsT0FBTyxLQUFLLEdBQUc7TUFDckM7O0FBR0YsUUFBTSxXQUFOLGNBQXVCLE9BQU07TUFDM0IsWUFBWSxLQUE0QixJQUFVLEtBQWUsYUFBcUI7QUFDcEYsY0FBTSxLQUFLLEtBQUssV0FBVztBQURXLGFBQUEsS0FBQTtNQUV4QztNQUVBLE9BQU8sRUFBQyxHQUFFLEdBQVk7QUFDcEIsZUFBTyxHQUFHLEtBQUssT0FBTyxLQUFLLE9BQU8sS0FBSyxTQUFTO01BQ2xEOztBQUdGLFFBQU0sUUFBTixjQUFvQixLQUFJO01BRXRCLFlBQXFCLE9BQVc7QUFDOUIsY0FBSztBQURjLGFBQUEsUUFBQTtBQURaLGFBQUEsUUFBbUIsQ0FBQTtNQUc1QjtNQUVBLE9BQU8sRUFBQyxHQUFFLEdBQVk7QUFDcEIsZUFBTyxHQUFHLEtBQUssV0FBVztNQUM1Qjs7QUFHRixRQUFNLFFBQU4sY0FBb0IsS0FBSTtNQUV0QixZQUFxQixPQUFZO0FBQy9CLGNBQUs7QUFEYyxhQUFBLFFBQUE7QUFEWixhQUFBLFFBQW1CLENBQUE7TUFHNUI7TUFFQSxPQUFPLEVBQUMsR0FBRSxHQUFZO0FBQ3BCLGNBQU0sUUFBUSxLQUFLLFFBQVEsSUFBSSxLQUFLLFVBQVU7QUFDOUMsZUFBTyxRQUFRLFdBQVc7TUFDNUI7O0FBR0YsUUFBTSxRQUFOLGNBQW9CLEtBQUk7TUFDdEIsWUFBcUIsT0FBVztBQUM5QixjQUFLO0FBRGMsYUFBQSxRQUFBO01BRXJCO01BRUEsT0FBTyxFQUFDLEdBQUUsR0FBWTtBQUNwQixlQUFPLFNBQVMsS0FBSyxXQUFXO01BQ2xDO01BRUEsSUFBSSxRQUFLO0FBQ1AsZUFBTyxLQUFLLE1BQU07TUFDcEI7O0FBR0YsUUFBTSxVQUFOLGNBQXNCLEtBQUk7TUFDeEIsWUFBb0IsTUFBYztBQUNoQyxjQUFLO0FBRGEsYUFBQSxPQUFBO01BRXBCO01BRUEsT0FBTyxFQUFDLEdBQUUsR0FBWTtBQUNwQixlQUFPLEdBQUcsS0FBSyxVQUFVO01BQzNCO01BRUEsZ0JBQWE7QUFDWCxlQUFPLEdBQUcsS0FBSyxTQUFTLE9BQU87TUFDakM7TUFFQSxjQUFjLE9BQWtCLFdBQW9CO0FBQ2xELGFBQUssT0FBTyxhQUFhLEtBQUssTUFBTSxPQUFPLFNBQVM7QUFDcEQsZUFBTztNQUNUO01BRUEsSUFBSSxRQUFLO0FBQ1AsZUFBTyxLQUFLLGdCQUFnQixPQUFBLGNBQWMsS0FBSyxLQUFLLFFBQVEsQ0FBQTtNQUM5RDs7QUFHRixRQUFlLGFBQWYsY0FBa0MsS0FBSTtNQUNwQyxZQUFxQixRQUFxQixDQUFBLEdBQUU7QUFDMUMsY0FBSztBQURjLGFBQUEsUUFBQTtNQUVyQjtNQUVBLE9BQU8sTUFBZTtBQUNwQixlQUFPLEtBQUssTUFBTSxPQUFPLENBQUMsTUFBTSxNQUFNLE9BQU8sRUFBRSxPQUFPLElBQUksR0FBRyxFQUFFO01BQ2pFO01BRUEsZ0JBQWE7QUFDWCxjQUFNLEVBQUMsTUFBSyxJQUFJO0FBQ2hCLFlBQUksSUFBSSxNQUFNO0FBQ2QsZUFBTyxLQUFLO0FBQ1YsZ0JBQU0sSUFBSSxNQUFNLENBQUMsRUFBRSxjQUFhO0FBQ2hDLGNBQUksTUFBTSxRQUFRLENBQUM7QUFBRyxrQkFBTSxPQUFPLEdBQUcsR0FBRyxHQUFHLENBQUM7bUJBQ3BDO0FBQUcsa0JBQU0sQ0FBQyxJQUFJOztBQUNsQixrQkFBTSxPQUFPLEdBQUcsQ0FBQzs7QUFFeEIsZUFBTyxNQUFNLFNBQVMsSUFBSSxPQUFPO01BQ25DO01BRUEsY0FBYyxPQUFrQixXQUFvQjtBQUNsRCxjQUFNLEVBQUMsTUFBSyxJQUFJO0FBQ2hCLFlBQUksSUFBSSxNQUFNO0FBQ2QsZUFBTyxLQUFLO0FBRVYsZ0JBQU0sSUFBSSxNQUFNLENBQUM7QUFDakIsY0FBSSxFQUFFLGNBQWMsT0FBTyxTQUFTO0FBQUc7QUFDdkMsd0JBQWMsT0FBTyxFQUFFLEtBQUs7QUFDNUIsZ0JBQU0sT0FBTyxHQUFHLENBQUM7O0FBRW5CLGVBQU8sTUFBTSxTQUFTLElBQUksT0FBTztNQUNuQztNQUVBLElBQUksUUFBSztBQUNQLGVBQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQyxPQUFrQixNQUFNLFNBQVMsT0FBTyxFQUFFLEtBQUssR0FBRyxDQUFBLENBQUU7TUFDaEY7O0FBT0YsUUFBZSxZQUFmLGNBQWlDLFdBQVU7TUFDekMsT0FBTyxNQUFlO0FBQ3BCLGVBQU8sTUFBTSxLQUFLLEtBQUssTUFBTSxPQUFPLElBQUksSUFBSSxNQUFNLEtBQUs7TUFDekQ7O0FBR0YsUUFBTSxPQUFOLGNBQW1CLFdBQVU7O0FBRTdCLFFBQU0sT0FBTixjQUFtQixVQUFTOztBQUNWLFNBQUEsT0FBTztBQUd6QixRQUFNLEtBQU4sY0FBaUIsVUFBUztNQUd4QixZQUFvQixXQUEyQixPQUFtQjtBQUNoRSxjQUFNLEtBQUs7QUFETyxhQUFBLFlBQUE7TUFFcEI7TUFFQSxPQUFPLE1BQWU7QUFDcEIsWUFBSSxPQUFPLE1BQU0sS0FBSyxlQUFlLE1BQU0sT0FBTyxJQUFJO0FBQ3RELFlBQUksS0FBSztBQUFNLGtCQUFRLFVBQVUsS0FBSyxLQUFLLE9BQU8sSUFBSTtBQUN0RCxlQUFPO01BQ1Q7TUFFQSxnQkFBYTtBQUNYLGNBQU0sY0FBYTtBQUNuQixjQUFNLE9BQU8sS0FBSztBQUNsQixZQUFJLFNBQVM7QUFBTSxpQkFBTyxLQUFLO0FBQy9CLFlBQUksSUFBSSxLQUFLO0FBQ2IsWUFBSSxHQUFHO0FBQ0wsZ0JBQU0sS0FBSyxFQUFFLGNBQWE7QUFDMUIsY0FBSSxLQUFLLE9BQU8sTUFBTSxRQUFRLEVBQUUsSUFBSSxJQUFJLEtBQUssRUFBRSxJQUFLOztBQUV0RCxZQUFJLEdBQUc7QUFDTCxjQUFJLFNBQVM7QUFBTyxtQkFBTyxhQUFhLEtBQUssSUFBSSxFQUFFO0FBQ25ELGNBQUksS0FBSyxNQUFNO0FBQVEsbUJBQU87QUFDOUIsaUJBQU8sSUFBSSxHQUFHLElBQUksSUFBSSxHQUFHLGFBQWEsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUs7O0FBRTFELFlBQUksU0FBUyxTQUFTLENBQUMsS0FBSyxNQUFNO0FBQVEsaUJBQU87QUFDakQsZUFBTztNQUNUO01BRUEsY0FBYyxPQUFrQixXQUFvQjs7QUFDbEQsYUFBSyxRQUFPQyxNQUFBLEtBQUssVUFBSSxRQUFBQSxRQUFBLFNBQUEsU0FBQUEsSUFBRSxjQUFjLE9BQU8sU0FBUztBQUNyRCxZQUFJLEVBQUUsTUFBTSxjQUFjLE9BQU8sU0FBUyxLQUFLLEtBQUs7QUFBTztBQUMzRCxhQUFLLFlBQVksYUFBYSxLQUFLLFdBQVcsT0FBTyxTQUFTO0FBQzlELGVBQU87TUFDVDtNQUVBLElBQUksUUFBSztBQUNQLGNBQU0sUUFBUSxNQUFNO0FBQ3BCLHFCQUFhLE9BQU8sS0FBSyxTQUFTO0FBQ2xDLFlBQUksS0FBSztBQUFNLG1CQUFTLE9BQU8sS0FBSyxLQUFLLEtBQUs7QUFDOUMsZUFBTztNQUNUOztBQTFDZ0IsT0FBQSxPQUFPO0FBaUR6QixRQUFlLE1BQWYsY0FBMkIsVUFBUzs7QUFDbEIsUUFBQSxPQUFPO0FBR3pCLFFBQU0sVUFBTixjQUFzQixJQUFHO01BQ3ZCLFlBQW9CLFdBQWU7QUFDakMsY0FBSztBQURhLGFBQUEsWUFBQTtNQUVwQjtNQUVBLE9BQU8sTUFBZTtBQUNwQixlQUFPLE9BQU8sS0FBSyxlQUFlLE1BQU0sT0FBTyxJQUFJO01BQ3JEO01BRUEsY0FBYyxPQUFrQixXQUFvQjtBQUNsRCxZQUFJLENBQUMsTUFBTSxjQUFjLE9BQU8sU0FBUztBQUFHO0FBQzVDLGFBQUssWUFBWSxhQUFhLEtBQUssV0FBVyxPQUFPLFNBQVM7QUFDOUQsZUFBTztNQUNUO01BRUEsSUFBSSxRQUFLO0FBQ1AsZUFBTyxTQUFTLE1BQU0sT0FBTyxLQUFLLFVBQVUsS0FBSztNQUNuRDs7QUFHRixRQUFNLFdBQU4sY0FBdUIsSUFBRztNQUN4QixZQUNtQixTQUNBLE1BQ0EsTUFDQSxJQUFZO0FBRTdCLGNBQUs7QUFMWSxhQUFBLFVBQUE7QUFDQSxhQUFBLE9BQUE7QUFDQSxhQUFBLE9BQUE7QUFDQSxhQUFBLEtBQUE7TUFHbkI7TUFFQSxPQUFPLE1BQWU7QUFDcEIsY0FBTSxVQUFVLEtBQUssTUFBTSxRQUFBLFNBQVMsTUFBTSxLQUFLO0FBQy9DLGNBQU0sRUFBQyxNQUFNLE1BQU0sR0FBRSxJQUFJO0FBQ3pCLGVBQU8sT0FBTyxXQUFXLFFBQVEsU0FBUyxRQUFRLE9BQU8sWUFBWSxNQUFNLE9BQU8sSUFBSTtNQUN4RjtNQUVBLElBQUksUUFBSztBQUNQLGNBQU0sUUFBUSxhQUFhLE1BQU0sT0FBTyxLQUFLLElBQUk7QUFDakQsZUFBTyxhQUFhLE9BQU8sS0FBSyxFQUFFO01BQ3BDOztBQUdGLFFBQU0sVUFBTixjQUFzQixJQUFHO01BQ3ZCLFlBQ21CLE1BQ0EsU0FDQSxNQUNULFVBQWM7QUFFdEIsY0FBSztBQUxZLGFBQUEsT0FBQTtBQUNBLGFBQUEsVUFBQTtBQUNBLGFBQUEsT0FBQTtBQUNULGFBQUEsV0FBQTtNQUdWO01BRUEsT0FBTyxNQUFlO0FBQ3BCLGVBQU8sT0FBTyxLQUFLLFdBQVcsS0FBSyxRQUFRLEtBQUssUUFBUSxLQUFLLGNBQWMsTUFBTSxPQUFPLElBQUk7TUFDOUY7TUFFQSxjQUFjLE9BQWtCLFdBQW9CO0FBQ2xELFlBQUksQ0FBQyxNQUFNLGNBQWMsT0FBTyxTQUFTO0FBQUc7QUFDNUMsYUFBSyxXQUFXLGFBQWEsS0FBSyxVQUFVLE9BQU8sU0FBUztBQUM1RCxlQUFPO01BQ1Q7TUFFQSxJQUFJLFFBQUs7QUFDUCxlQUFPLFNBQVMsTUFBTSxPQUFPLEtBQUssU0FBUyxLQUFLO01BQ2xEOztBQUdGLFFBQU0sT0FBTixjQUFtQixVQUFTO01BRTFCLFlBQW1CLE1BQW1CLE1BQW1CLE9BQWU7QUFDdEUsY0FBSztBQURZLGFBQUEsT0FBQTtBQUFtQixhQUFBLE9BQUE7QUFBbUIsYUFBQSxRQUFBO01BRXpEO01BRUEsT0FBTyxNQUFlO0FBQ3BCLGNBQU0sU0FBUyxLQUFLLFFBQVEsV0FBVztBQUN2QyxlQUFPLEdBQUcsa0JBQWtCLEtBQUssUUFBUSxLQUFLLFVBQVUsTUFBTSxPQUFPLElBQUk7TUFDM0U7O0FBUmdCLFNBQUEsT0FBTztBQVd6QixRQUFNLFNBQU4sY0FBcUIsV0FBVTtNQUc3QixPQUFPLE1BQWU7QUFDcEIsZUFBTyxZQUFZLE1BQU0sT0FBTyxJQUFJO01BQ3RDOztBQUpnQixXQUFBLE9BQU87QUFPekIsUUFBTSxNQUFOLGNBQWtCLFVBQVM7TUFJekIsT0FBTyxNQUFlO0FBQ3BCLFlBQUksT0FBTyxRQUFRLE1BQU0sT0FBTyxJQUFJO0FBQ3BDLFlBQUksS0FBSztBQUFPLGtCQUFRLEtBQUssTUFBTSxPQUFPLElBQUk7QUFDOUMsWUFBSSxLQUFLO0FBQVMsa0JBQVEsS0FBSyxRQUFRLE9BQU8sSUFBSTtBQUNsRCxlQUFPO01BQ1Q7TUFFQSxnQkFBYTs7QUFDWCxjQUFNLGNBQWE7QUFDbkIsU0FBQUEsTUFBQSxLQUFLLFdBQUssUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUUsY0FBYTtBQUN6QixTQUFBLEtBQUEsS0FBSyxhQUFPLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRSxjQUFhO0FBQzNCLGVBQU87TUFDVDtNQUVBLGNBQWMsT0FBa0IsV0FBb0I7O0FBQ2xELGNBQU0sY0FBYyxPQUFPLFNBQVM7QUFDcEMsU0FBQUEsTUFBQSxLQUFLLFdBQUssUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUUsY0FBYyxPQUFPLFNBQVM7QUFDMUMsU0FBQSxLQUFBLEtBQUssYUFBTyxRQUFBLE9BQUEsU0FBQSxTQUFBLEdBQUUsY0FBYyxPQUFPLFNBQVM7QUFDNUMsZUFBTztNQUNUO01BRUEsSUFBSSxRQUFLO0FBQ1AsY0FBTSxRQUFRLE1BQU07QUFDcEIsWUFBSSxLQUFLO0FBQU8sbUJBQVMsT0FBTyxLQUFLLE1BQU0sS0FBSztBQUNoRCxZQUFJLEtBQUs7QUFBUyxtQkFBUyxPQUFPLEtBQUssUUFBUSxLQUFLO0FBQ3BELGVBQU87TUFDVDs7QUFPRixRQUFNLFFBQU4sY0FBb0IsVUFBUztNQUUzQixZQUFxQixPQUFXO0FBQzlCLGNBQUs7QUFEYyxhQUFBLFFBQUE7TUFFckI7TUFFQSxPQUFPLE1BQWU7QUFDcEIsZUFBTyxTQUFTLEtBQUssV0FBVyxNQUFNLE9BQU8sSUFBSTtNQUNuRDs7QUFQZ0IsVUFBQSxPQUFPO0FBVXpCLFFBQU0sVUFBTixjQUFzQixVQUFTO01BRTdCLE9BQU8sTUFBZTtBQUNwQixlQUFPLFlBQVksTUFBTSxPQUFPLElBQUk7TUFDdEM7O0FBSGdCLFlBQUEsT0FBTztBQWlDekIsUUFBYSxVQUFiLE1BQW9CO01BU2xCLFlBQVksVUFBc0IsT0FBdUIsQ0FBQSxHQUFFO0FBTmxELGFBQUEsVUFBMEIsQ0FBQTtBQUVsQixhQUFBLGVBQXlCLENBQUE7QUFDekIsYUFBQSxhQUF3QixDQUFBO0FBSXZDLGFBQUssT0FBTyxFQUFDLEdBQUcsTUFBTSxJQUFJLEtBQUssUUFBUSxPQUFPLEdBQUU7QUFDaEQsYUFBSyxZQUFZO0FBQ2pCLGFBQUssU0FBUyxJQUFJLFFBQUEsTUFBTSxFQUFDLFFBQVEsU0FBUSxDQUFDO0FBQzFDLGFBQUssU0FBUyxDQUFDLElBQUksS0FBSSxDQUFFO01BQzNCO01BRUEsV0FBUTtBQUNOLGVBQU8sS0FBSyxNQUFNLE9BQU8sS0FBSyxJQUFJO01BQ3BDOztNQUdBLEtBQUssUUFBYztBQUNqQixlQUFPLEtBQUssT0FBTyxLQUFLLE1BQU07TUFDaEM7O01BR0EsVUFBVSxRQUFjO0FBQ3RCLGVBQU8sS0FBSyxVQUFVLEtBQUssTUFBTTtNQUNuQzs7TUFHQSxXQUFXLGNBQXVDLE9BQWdCO0FBQ2hFLGNBQU0sT0FBTyxLQUFLLFVBQVUsTUFBTSxjQUFjLEtBQUs7QUFDckQsY0FBTSxLQUFLLEtBQUssUUFBUSxLQUFLLE1BQU0sTUFBTSxLQUFLLFFBQVEsS0FBSyxNQUFNLElBQUksb0JBQUksSUFBRztBQUM1RSxXQUFHLElBQUksSUFBSTtBQUNYLGVBQU87TUFDVDtNQUVBLGNBQWMsUUFBZ0IsVUFBaUI7QUFDN0MsZUFBTyxLQUFLLFVBQVUsU0FBUyxRQUFRLFFBQVE7TUFDakQ7OztNQUlBLFVBQVUsV0FBZTtBQUN2QixlQUFPLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxPQUFPO01BQ3pEO01BRUEsWUFBUztBQUNQLGVBQU8sS0FBSyxVQUFVLFVBQVUsS0FBSyxPQUFPO01BQzlDO01BRVEsS0FDTixTQUNBLGNBQ0EsS0FDQSxVQUFrQjtBQUVsQixjQUFNLE9BQU8sS0FBSyxPQUFPLE9BQU8sWUFBWTtBQUM1QyxZQUFJLFFBQVEsVUFBYTtBQUFVLGVBQUssV0FBVyxLQUFLLEdBQUcsSUFBSTtBQUMvRCxhQUFLLFVBQVUsSUFBSSxJQUFJLFNBQVMsTUFBTSxHQUFHLENBQUM7QUFDMUMsZUFBTztNQUNUOztNQUdBLE1BQU0sY0FBNkIsS0FBZSxXQUFtQjtBQUNuRSxlQUFPLEtBQUssS0FBSyxRQUFBLFNBQVMsT0FBTyxjQUFjLEtBQUssU0FBUztNQUMvRDs7TUFHQSxJQUFJLGNBQTZCLEtBQWdCLFdBQW1CO0FBQ2xFLGVBQU8sS0FBSyxLQUFLLFFBQUEsU0FBUyxLQUFLLGNBQWMsS0FBSyxTQUFTO01BQzdEOztNQUdBLElBQUksY0FBNkIsS0FBZ0IsV0FBbUI7QUFDbEUsZUFBTyxLQUFLLEtBQUssUUFBQSxTQUFTLEtBQUssY0FBYyxLQUFLLFNBQVM7TUFDN0Q7O01BR0EsT0FBTyxLQUFXLEtBQWUsYUFBcUI7QUFDcEQsZUFBTyxLQUFLLFVBQVUsSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUM7TUFDekQ7O01BR0EsSUFBSSxLQUFXLEtBQWE7QUFDMUIsZUFBTyxLQUFLLFVBQVUsSUFBSSxTQUFTLEtBQUssUUFBQSxVQUFVLEtBQUssR0FBRyxDQUFDO01BQzdEOztNQUdBLEtBQUssR0FBbUI7QUFDdEIsWUFBSSxPQUFPLEtBQUs7QUFBWSxZQUFDO2lCQUNwQixNQUFNLE9BQUE7QUFBSyxlQUFLLFVBQVUsSUFBSSxRQUFRLENBQUMsQ0FBQztBQUNqRCxlQUFPO01BQ1Q7O01BR0EsVUFBVSxXQUErQztBQUN2RCxjQUFNLE9BQW1CLENBQUMsR0FBRztBQUM3QixtQkFBVyxDQUFDLEtBQUssS0FBSyxLQUFLLFdBQVc7QUFDcEMsY0FBSSxLQUFLLFNBQVM7QUFBRyxpQkFBSyxLQUFLLEdBQUc7QUFDbEMsZUFBSyxLQUFLLEdBQUc7QUFDYixjQUFJLFFBQVEsU0FBUyxLQUFLLEtBQUssS0FBSztBQUNsQyxpQkFBSyxLQUFLLEdBQUc7QUFDYixhQUFBLEdBQUEsT0FBQSxZQUFXLE1BQU0sS0FBSzs7O0FBRzFCLGFBQUssS0FBSyxHQUFHO0FBQ2IsZUFBTyxJQUFJLE9BQUEsTUFBTSxJQUFJO01BQ3ZCOztNQUdBLEdBQUcsV0FBMkIsVUFBa0IsVUFBZ0I7QUFDOUQsYUFBSyxXQUFXLElBQUksR0FBRyxTQUFTLENBQUM7QUFFakMsWUFBSSxZQUFZLFVBQVU7QUFDeEIsZUFBSyxLQUFLLFFBQVEsRUFBRSxLQUFJLEVBQUcsS0FBSyxRQUFRLEVBQUUsTUFBSzttQkFDdEMsVUFBVTtBQUNuQixlQUFLLEtBQUssUUFBUSxFQUFFLE1BQUs7bUJBQ2hCLFVBQVU7QUFDbkIsZ0JBQU0sSUFBSSxNQUFNLDBDQUEwQzs7QUFFNUQsZUFBTztNQUNUOztNQUdBLE9BQU8sV0FBeUI7QUFDOUIsZUFBTyxLQUFLLFVBQVUsSUFBSSxHQUFHLFNBQVMsQ0FBQztNQUN6Qzs7TUFHQSxPQUFJO0FBQ0YsZUFBTyxLQUFLLFVBQVUsSUFBSSxLQUFJLENBQUU7TUFDbEM7O01BR0EsUUFBSztBQUNILGVBQU8sS0FBSyxjQUFjLElBQUksSUFBSTtNQUNwQztNQUVRLEtBQUssTUFBVyxTQUFlO0FBQ3JDLGFBQUssV0FBVyxJQUFJO0FBQ3BCLFlBQUk7QUFBUyxlQUFLLEtBQUssT0FBTyxFQUFFLE9BQU07QUFDdEMsZUFBTztNQUNUOztNQUdBLElBQUksV0FBaUIsU0FBZTtBQUNsQyxlQUFPLEtBQUssS0FBSyxJQUFJLFFBQVEsU0FBUyxHQUFHLE9BQU87TUFDbEQ7O01BR0EsU0FDRSxjQUNBLE1BQ0EsSUFDQSxTQUNBLFVBQWdCLEtBQUssS0FBSyxNQUFNLFFBQUEsU0FBUyxNQUFNLFFBQUEsU0FBUyxLQUFHO0FBRTNELGNBQU0sT0FBTyxLQUFLLE9BQU8sT0FBTyxZQUFZO0FBQzVDLGVBQU8sS0FBSyxLQUFLLElBQUksU0FBUyxTQUFTLE1BQU0sTUFBTSxFQUFFLEdBQUcsTUFBTSxRQUFRLElBQUksQ0FBQztNQUM3RTs7TUFHQSxNQUNFLGNBQ0EsVUFDQSxTQUNBLFVBQWdCLFFBQUEsU0FBUyxPQUFLO0FBRTlCLGNBQU0sT0FBTyxLQUFLLE9BQU8sT0FBTyxZQUFZO0FBQzVDLFlBQUksS0FBSyxLQUFLLEtBQUs7QUFDakIsZ0JBQU0sTUFBTSxvQkFBb0IsT0FBQSxPQUFPLFdBQVcsS0FBSyxJQUFJLFFBQVEsUUFBUTtBQUMzRSxpQkFBTyxLQUFLLFNBQVMsTUFBTSxJQUFHLEdBQUEsT0FBQSxLQUFJLGNBQWMsQ0FBQyxNQUFLO0FBQ3BELGlCQUFLLElBQUksT0FBTSxHQUFBLE9BQUEsS0FBSSxPQUFPLElBQUk7QUFDOUIsb0JBQVEsSUFBSTtVQUNkLENBQUM7O0FBRUgsZUFBTyxLQUFLLEtBQUssSUFBSSxRQUFRLE1BQU0sU0FBUyxNQUFNLFFBQVEsR0FBRyxNQUFNLFFBQVEsSUFBSSxDQUFDO01BQ2xGOzs7TUFJQSxNQUNFLGNBQ0EsS0FDQSxTQUNBLFVBQWdCLEtBQUssS0FBSyxNQUFNLFFBQUEsU0FBUyxNQUFNLFFBQUEsU0FBUyxPQUFLO0FBRTdELFlBQUksS0FBSyxLQUFLLGVBQWU7QUFDM0IsaUJBQU8sS0FBSyxNQUFNLGVBQWMsR0FBQSxPQUFBLGlCQUFnQixRQUFRLE9BQU87O0FBRWpFLGNBQU0sT0FBTyxLQUFLLE9BQU8sT0FBTyxZQUFZO0FBQzVDLGVBQU8sS0FBSyxLQUFLLElBQUksUUFBUSxNQUFNLFNBQVMsTUFBTSxHQUFHLEdBQUcsTUFBTSxRQUFRLElBQUksQ0FBQztNQUM3RTs7TUFHQSxTQUFNO0FBQ0osZUFBTyxLQUFLLGNBQWMsR0FBRztNQUMvQjs7TUFHQSxNQUFNLE9BQVc7QUFDZixlQUFPLEtBQUssVUFBVSxJQUFJLE1BQU0sS0FBSyxDQUFDO01BQ3hDOztNQUdBLE1BQU0sT0FBWTtBQUNoQixlQUFPLEtBQUssVUFBVSxJQUFJLE1BQU0sS0FBSyxDQUFDO01BQ3hDOztNQUdBLE9BQU8sT0FBdUI7QUFDNUIsY0FBTSxPQUFPLElBQUksT0FBTTtBQUN2QixhQUFLLFdBQVcsSUFBSTtBQUNwQixhQUFLLEtBQUssS0FBSztBQUNmLFlBQUksS0FBSyxNQUFNLFdBQVc7QUFBRyxnQkFBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQ3JGLGVBQU8sS0FBSyxjQUFjLE1BQU07TUFDbEM7O01BR0EsSUFBSSxTQUFnQixXQUErQixhQUFtQjtBQUNwRSxZQUFJLENBQUMsYUFBYSxDQUFDO0FBQWEsZ0JBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUM5RixjQUFNLE9BQU8sSUFBSSxJQUFHO0FBQ3BCLGFBQUssV0FBVyxJQUFJO0FBQ3BCLGFBQUssS0FBSyxPQUFPO0FBQ2pCLFlBQUksV0FBVztBQUNiLGdCQUFNLFFBQVEsS0FBSyxLQUFLLEdBQUc7QUFDM0IsZUFBSyxZQUFZLEtBQUssUUFBUSxJQUFJLE1BQU0sS0FBSztBQUM3QyxvQkFBVSxLQUFLOztBQUVqQixZQUFJLGFBQWE7QUFDZixlQUFLLFlBQVksS0FBSyxVQUFVLElBQUksUUFBTztBQUMzQyxlQUFLLEtBQUssV0FBVzs7QUFFdkIsZUFBTyxLQUFLLGNBQWMsT0FBTyxPQUFPO01BQzFDOztNQUdBLE1BQU0sT0FBVztBQUNmLGVBQU8sS0FBSyxVQUFVLElBQUksTUFBTSxLQUFLLENBQUM7TUFDeEM7O01BR0EsTUFBTSxNQUFjLFdBQWtCO0FBQ3BDLGFBQUssYUFBYSxLQUFLLEtBQUssT0FBTyxNQUFNO0FBQ3pDLFlBQUk7QUFBTSxlQUFLLEtBQUssSUFBSSxFQUFFLFNBQVMsU0FBUztBQUM1QyxlQUFPO01BQ1Q7O01BR0EsU0FBUyxXQUFrQjtBQUN6QixjQUFNLE1BQU0sS0FBSyxhQUFhLElBQUc7QUFDakMsWUFBSSxRQUFRO0FBQVcsZ0JBQU0sSUFBSSxNQUFNLHNDQUFzQztBQUM3RSxjQUFNLFVBQVUsS0FBSyxPQUFPLFNBQVM7QUFDckMsWUFBSSxVQUFVLEtBQU0sY0FBYyxVQUFhLFlBQVksV0FBWTtBQUNyRSxnQkFBTSxJQUFJLE1BQU0sbUNBQW1DLGNBQWMsb0JBQW9COztBQUV2RixhQUFLLE9BQU8sU0FBUztBQUNyQixlQUFPO01BQ1Q7O01BR0EsS0FBSyxNQUFZLE9BQWEsT0FBQSxLQUFLLE9BQWlCLFVBQWdCO0FBQ2xFLGFBQUssV0FBVyxJQUFJLEtBQUssTUFBTSxNQUFNLEtBQUssQ0FBQztBQUMzQyxZQUFJO0FBQVUsZUFBSyxLQUFLLFFBQVEsRUFBRSxRQUFPO0FBQ3pDLGVBQU87TUFDVDs7TUFHQSxVQUFPO0FBQ0wsZUFBTyxLQUFLLGNBQWMsSUFBSTtNQUNoQztNQUVBLFNBQVMsSUFBSSxHQUFDO0FBQ1osZUFBTyxNQUFNLEdBQUc7QUFDZCxlQUFLLE1BQU0sY0FBYTtBQUN4QixlQUFLLE1BQU0sY0FBYyxLQUFLLE1BQU0sT0FBTyxLQUFLLFVBQVU7O01BRTlEO01BRVEsVUFBVSxNQUFjO0FBQzlCLGFBQUssVUFBVSxNQUFNLEtBQUssSUFBSTtBQUM5QixlQUFPO01BQ1Q7TUFFUSxXQUFXLE1BQW9CO0FBQ3JDLGFBQUssVUFBVSxNQUFNLEtBQUssSUFBSTtBQUM5QixhQUFLLE9BQU8sS0FBSyxJQUFJO01BQ3ZCO01BRVEsY0FBYyxJQUFzQixJQUFxQjtBQUMvRCxjQUFNLElBQUksS0FBSztBQUNmLFlBQUksYUFBYSxNQUFPLE1BQU0sYUFBYSxJQUFLO0FBQzlDLGVBQUssT0FBTyxJQUFHO0FBQ2YsaUJBQU87O0FBRVQsY0FBTSxJQUFJLE1BQU0sMEJBQTBCLEtBQUssR0FBRyxHQUFHLFFBQVEsR0FBRyxTQUFTLEdBQUcsT0FBTztNQUNyRjtNQUVRLFVBQVUsTUFBZTtBQUMvQixjQUFNLElBQUksS0FBSztBQUNmLFlBQUksRUFBRSxhQUFhLEtBQUs7QUFDdEIsZ0JBQU0sSUFBSSxNQUFNLDhCQUE4Qjs7QUFFaEQsYUFBSyxZQUFZLEVBQUUsT0FBTztBQUMxQixlQUFPO01BQ1Q7TUFFQSxJQUFZLFFBQUs7QUFDZixlQUFPLEtBQUssT0FBTyxDQUFDO01BQ3RCO01BRUEsSUFBWSxZQUFTO0FBQ25CLGNBQU0sS0FBSyxLQUFLO0FBQ2hCLGVBQU8sR0FBRyxHQUFHLFNBQVMsQ0FBQztNQUN6QjtNQUVBLElBQVksVUFBVSxNQUFnQjtBQUNwQyxjQUFNLEtBQUssS0FBSztBQUNoQixXQUFHLEdBQUcsU0FBUyxDQUFDLElBQUk7TUFDdEI7O0FBalVGLFlBQUEsVUFBQTtBQXdVQSxhQUFTLFNBQVMsT0FBa0IsTUFBZTtBQUNqRCxpQkFBVyxLQUFLO0FBQU0sY0FBTSxDQUFDLEtBQUssTUFBTSxDQUFDLEtBQUssTUFBTSxLQUFLLENBQUMsS0FBSztBQUMvRCxhQUFPO0lBQ1Q7QUFFQSxhQUFTLGFBQWEsT0FBa0IsTUFBYztBQUNwRCxhQUFPLGdCQUFnQixPQUFBLGNBQWMsU0FBUyxPQUFPLEtBQUssS0FBSyxJQUFJO0lBQ3JFO0FBR0EsYUFBUyxhQUFhLE1BQWdCLE9BQWtCLFdBQW9CO0FBQzFFLFVBQUksZ0JBQWdCLE9BQUE7QUFBTSxlQUFPLFlBQVksSUFBSTtBQUNqRCxVQUFJLENBQUMsWUFBWSxJQUFJO0FBQUcsZUFBTztBQUMvQixhQUFPLElBQUksT0FBQSxNQUNULEtBQUssT0FBTyxPQUFPLENBQUMsT0FBbUIsTUFBd0I7QUFDN0QsWUFBSSxhQUFhLE9BQUE7QUFBTSxjQUFJLFlBQVksQ0FBQztBQUN4QyxZQUFJLGFBQWEsT0FBQTtBQUFPLGdCQUFNLEtBQUssR0FBRyxFQUFFLE1BQU07O0FBQ3pDLGdCQUFNLEtBQUssQ0FBQztBQUNqQixlQUFPO01BQ1QsR0FBRyxDQUFBLENBQUUsQ0FBQztBQUdSLGVBQVMsWUFBWSxHQUFPO0FBQzFCLGNBQU0sSUFBSSxVQUFVLEVBQUUsR0FBRztBQUN6QixZQUFJLE1BQU0sVUFBYSxNQUFNLEVBQUUsR0FBRyxNQUFNO0FBQUcsaUJBQU87QUFDbEQsZUFBTyxNQUFNLEVBQUUsR0FBRztBQUNsQixlQUFPO01BQ1Q7QUFFQSxlQUFTLFlBQVksR0FBVztBQUM5QixlQUNFLGFBQWEsT0FBQSxTQUNiLEVBQUUsT0FBTyxLQUNQLENBQUMsTUFBTSxhQUFhLE9BQUEsUUFBUSxNQUFNLEVBQUUsR0FBRyxNQUFNLEtBQUssVUFBVSxFQUFFLEdBQUcsTUFBTSxNQUFTO01BR3RGO0lBQ0Y7QUFFQSxhQUFTLGNBQWMsT0FBa0IsTUFBZTtBQUN0RCxpQkFBVyxLQUFLO0FBQU0sY0FBTSxDQUFDLEtBQUssTUFBTSxDQUFDLEtBQUssTUFBTSxLQUFLLENBQUMsS0FBSztJQUNqRTtBQUdBLGFBQWdCLElBQUksR0FBa0I7QUFDcEMsYUFBTyxPQUFPLEtBQUssYUFBYSxPQUFPLEtBQUssWUFBWSxNQUFNLE9BQU8sQ0FBQyxLQUFJLEdBQUEsT0FBQSxNQUFLLElBQUksQ0FBQztJQUN0RjtBQUZBLFlBQUEsTUFBQTtBQUlBLFFBQU0sVUFBVSxRQUFRLFFBQUEsVUFBVSxHQUFHO0FBR3JDLGFBQWdCLE9BQU8sTUFBWTtBQUNqQyxhQUFPLEtBQUssT0FBTyxPQUFPO0lBQzVCO0FBRkEsWUFBQSxNQUFBO0FBSUEsUUFBTSxTQUFTLFFBQVEsUUFBQSxVQUFVLEVBQUU7QUFHbkMsYUFBZ0IsTUFBTSxNQUFZO0FBQ2hDLGFBQU8sS0FBSyxPQUFPLE1BQU07SUFDM0I7QUFGQSxZQUFBLEtBQUE7QUFNQSxhQUFTLFFBQVEsSUFBUTtBQUN2QixhQUFPLENBQUMsR0FBRyxNQUFPLE1BQU0sT0FBQSxNQUFNLElBQUksTUFBTSxPQUFBLE1BQU0sS0FBSSxHQUFBLE9BQUEsS0FBSSxJQUFJLENBQUMsS0FBSyxNQUFNLElBQUksQ0FBQztJQUM3RTtBQUVBLGFBQVMsSUFBSSxHQUFPO0FBQ2xCLGFBQU8sYUFBYSxPQUFBLE9BQU8sS0FBSSxHQUFBLE9BQUEsTUFBSztJQUN0Qzs7Ozs7Ozs7OztBQzd6QkEsUUFBQSxZQUFBO0FBQ0EsUUFBQSxTQUFBO0FBSUEsYUFBZ0IsT0FBa0MsS0FBUTtBQUN4RCxZQUFNLE9BQTBCLENBQUE7QUFDaEMsaUJBQVcsUUFBUTtBQUFLLGFBQUssSUFBSSxJQUFJO0FBQ3JDLGFBQU87SUFDVDtBQUpBLFlBQUEsU0FBQTtBQU1BLGFBQWdCLGtCQUFrQixJQUFlLFFBQWlCO0FBQ2hFLFVBQUksT0FBTyxVQUFVO0FBQVcsZUFBTztBQUN2QyxVQUFJLE9BQU8sS0FBSyxNQUFNLEVBQUUsV0FBVztBQUFHLGVBQU87QUFDN0Msd0JBQWtCLElBQUksTUFBTTtBQUM1QixhQUFPLENBQUMsZUFBZSxRQUFRLEdBQUcsS0FBSyxNQUFNLEdBQUc7SUFDbEQ7QUFMQSxZQUFBLG9CQUFBO0FBT0EsYUFBZ0Isa0JBQWtCLElBQWUsU0FBb0IsR0FBRyxRQUFNO0FBQzVFLFlBQU0sRUFBQyxNQUFNLE1BQUFDLE1BQUksSUFBSTtBQUNyQixVQUFJLENBQUMsS0FBSztBQUFjO0FBQ3hCLFVBQUksT0FBTyxXQUFXO0FBQVc7QUFDakMsWUFBTSxRQUFRQSxNQUFLLE1BQU07QUFDekIsaUJBQVcsT0FBTyxRQUFRO0FBQ3hCLFlBQUksQ0FBQyxNQUFNLEdBQUc7QUFBRywwQkFBZ0IsSUFBSSxxQkFBcUIsTUFBTTs7SUFFcEU7QUFSQSxZQUFBLG9CQUFBO0FBVUEsYUFBZ0IsZUFDZCxRQUNBLE9BQXlDO0FBRXpDLFVBQUksT0FBTyxVQUFVO0FBQVcsZUFBTyxDQUFDO0FBQ3hDLGlCQUFXLE9BQU87QUFBUSxZQUFJLE1BQU0sR0FBRztBQUFHLGlCQUFPO0FBQ2pELGFBQU87SUFDVDtBQVBBLFlBQUEsaUJBQUE7QUFTQSxhQUFnQixxQkFBcUIsUUFBbUIsT0FBc0I7QUFDNUUsVUFBSSxPQUFPLFVBQVU7QUFBVyxlQUFPLENBQUM7QUFDeEMsaUJBQVcsT0FBTztBQUFRLFlBQUksUUFBUSxVQUFVLE1BQU0sSUFBSSxHQUFHO0FBQUcsaUJBQU87QUFDdkUsYUFBTztJQUNUO0FBSkEsWUFBQSx1QkFBQTtBQU1BLGFBQWdCLGVBQ2QsRUFBQyxjQUFjLFdBQVUsR0FDekIsUUFDQSxTQUNBLE9BQXNCO0FBRXRCLFVBQUksQ0FBQyxPQUFPO0FBQ1YsWUFBSSxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVU7QUFBVyxpQkFBTztBQUNwRSxZQUFJLE9BQU8sVUFBVTtBQUFVLGtCQUFPLEdBQUEsVUFBQSxLQUFJOztBQUU1QyxjQUFPLEdBQUEsVUFBQSxLQUFJLGVBQWUsY0FBYSxHQUFBLFVBQUEsYUFBWSxPQUFPO0lBQzVEO0FBWEEsWUFBQSxpQkFBQTtBQWFBLGFBQWdCLGlCQUFpQixLQUFXO0FBQzFDLGFBQU8sb0JBQW9CLG1CQUFtQixHQUFHLENBQUM7SUFDcEQ7QUFGQSxZQUFBLG1CQUFBO0FBSUEsYUFBZ0IsZUFBZSxLQUFvQjtBQUNqRCxhQUFPLG1CQUFtQixrQkFBa0IsR0FBRyxDQUFDO0lBQ2xEO0FBRkEsWUFBQSxpQkFBQTtBQUlBLGFBQWdCLGtCQUFrQixLQUFvQjtBQUNwRCxVQUFJLE9BQU8sT0FBTztBQUFVLGVBQU8sR0FBRztBQUN0QyxhQUFPLElBQUksUUFBUSxNQUFNLElBQUksRUFBRSxRQUFRLE9BQU8sSUFBSTtJQUNwRDtBQUhBLFlBQUEsb0JBQUE7QUFLQSxhQUFnQixvQkFBb0IsS0FBVztBQUM3QyxhQUFPLElBQUksUUFBUSxPQUFPLEdBQUcsRUFBRSxRQUFRLE9BQU8sR0FBRztJQUNuRDtBQUZBLFlBQUEsc0JBQUE7QUFJQSxhQUFnQixTQUFZLElBQWEsR0FBaUI7QUFDeEQsVUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3JCLG1CQUFXLEtBQUs7QUFBSSxZQUFFLENBQUM7YUFDbEI7QUFDTCxVQUFFLEVBQUU7O0lBRVI7QUFOQSxZQUFBLFdBQUE7QUF3QkEsYUFBUyxtQkFBNEMsRUFDbkQsWUFDQSxhQUNBLGFBQ0EsYUFBWSxHQUNTO0FBQ3JCLGFBQU8sQ0FBQyxLQUFLLE1BQU0sSUFBSSxXQUFVO0FBQy9CLGNBQU0sTUFDSixPQUFPLFNBQ0gsT0FDQSxjQUFjLFVBQUEsUUFDYixnQkFBZ0IsVUFBQSxPQUFPLFdBQVcsS0FBSyxNQUFNLEVBQUUsSUFBSSxZQUFZLEtBQUssTUFBTSxFQUFFLEdBQUcsTUFDaEYsZ0JBQWdCLFVBQUEsUUFDZixZQUFZLEtBQUssSUFBSSxJQUFJLEdBQUcsUUFDN0IsWUFBWSxNQUFNLEVBQUU7QUFDMUIsZUFBTyxXQUFXLFVBQUEsUUFBUSxFQUFFLGVBQWUsVUFBQSxRQUFRLGFBQWEsS0FBSyxHQUFHLElBQUk7TUFDOUU7SUFDRjtBQU9hLFlBQUEsaUJBQWlDO01BQzVDLE9BQU8sbUJBQW1CO1FBQ3hCLFlBQVksQ0FBQyxLQUFLLE1BQU0sT0FDdEIsSUFBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLGtCQUFrQixzQkFBc0IsTUFBSztBQUN0RCxjQUFJLElBQ0YsR0FBQSxVQUFBLEtBQUksaUJBQ0osTUFBTSxJQUFJLE9BQU8sSUFBSSxJQUFJLEdBQ3pCLE1BQU0sSUFBSSxPQUFPLEtBQUksR0FBQSxVQUFBLEtBQUksVUFBVSxFQUFFLE1BQUssR0FBQSxVQUFBLG1CQUFrQixPQUFPLE9BQU8sQ0FBQztRQUUvRSxDQUFDO1FBQ0gsYUFBYSxDQUFDLEtBQUssTUFBTSxPQUN2QixJQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksZUFBZSxNQUFLO0FBQzdCLGNBQUksU0FBUyxNQUFNO0FBQ2pCLGdCQUFJLE9BQU8sSUFBSSxJQUFJO2lCQUNkO0FBQ0wsZ0JBQUksT0FBTyxLQUFJLEdBQUEsVUFBQSxLQUFJLFVBQVU7QUFDN0IseUJBQWEsS0FBSyxJQUFJLElBQUk7O1FBRTlCLENBQUM7UUFDSCxhQUFhLENBQUMsTUFBTSxPQUFRLFNBQVMsT0FBTyxPQUFPLEVBQUMsR0FBRyxNQUFNLEdBQUcsR0FBRTtRQUNsRSxjQUFjO09BQ2Y7TUFDRCxPQUFPLG1CQUFtQjtRQUN4QixZQUFZLENBQUMsS0FBSyxNQUFNLE9BQ3RCLElBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxrQkFBa0Isc0JBQXNCLE1BQ2pELElBQUksT0FBTyxLQUFJLEdBQUEsVUFBQSxLQUFJLDBCQUEwQixRQUFRLFVBQVUsUUFBUSxNQUFNLENBQUM7UUFFbEYsYUFBYSxDQUFDLEtBQUssTUFBTSxPQUN2QixJQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksZUFBZSxNQUN4QixJQUFJLE9BQU8sSUFBSSxTQUFTLE9BQU8sUUFBTyxHQUFBLFVBQUEsS0FBSSxRQUFRLFVBQVUsUUFBUSxNQUFNLENBQUM7UUFFL0UsYUFBYSxDQUFDLE1BQU0sT0FBUSxTQUFTLE9BQU8sT0FBTyxLQUFLLElBQUksTUFBTSxFQUFFO1FBQ3BFLGNBQWMsQ0FBQyxLQUFLLFVBQVUsSUFBSSxJQUFJLFNBQVMsS0FBSztPQUNyRDs7QUFHSCxhQUFnQixxQkFBcUIsS0FBYyxJQUF3QjtBQUN6RSxVQUFJLE9BQU87QUFBTSxlQUFPLElBQUksSUFBSSxTQUFTLElBQUk7QUFDN0MsWUFBTSxRQUFRLElBQUksSUFBSSxVQUFTLEdBQUEsVUFBQSxNQUFLO0FBQ3BDLFVBQUksT0FBTztBQUFXLHFCQUFhLEtBQUssT0FBTyxFQUFFO0FBQ2pELGFBQU87SUFDVDtBQUxBLFlBQUEsdUJBQUE7QUFPQSxhQUFnQixhQUFhLEtBQWMsT0FBYSxJQUEwQjtBQUNoRixhQUFPLEtBQUssRUFBRSxFQUFFLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSxTQUFRLEdBQUEsVUFBQSxhQUFZLENBQUMsS0FBSyxJQUFJLENBQUM7SUFDL0U7QUFGQSxZQUFBLGVBQUE7QUFJQSxRQUFNLFdBQW9DLENBQUE7QUFFMUMsYUFBZ0IsUUFBUSxLQUFjLEdBQWlCO0FBQ3JELGFBQU8sSUFBSSxXQUFXLFFBQVE7UUFDNUIsS0FBSztRQUNMLE1BQU0sU0FBUyxFQUFFLElBQUksTUFBTSxTQUFTLEVBQUUsSUFBSSxJQUFJLElBQUksT0FBQSxNQUFNLEVBQUUsSUFBSTtPQUMvRDtJQUNIO0FBTEEsWUFBQSxVQUFBO0FBT0EsUUFBWTtBQUFaLEtBQUEsU0FBWUMsT0FBSTtBQUNkLE1BQUFBLE1BQUFBLE1BQUEsS0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBLE1BQUFBLE1BQUFBLE1BQUEsS0FBQSxJQUFBLENBQUEsSUFBQTtJQUNGLEdBSFksT0FBQSxRQUFBLFNBQUEsUUFBQSxPQUFJLENBQUEsRUFBQTtBQUtoQixhQUFnQixhQUNkLFVBQ0EsY0FDQSxrQkFBMEI7QUFHMUIsVUFBSSxvQkFBb0IsVUFBQSxNQUFNO0FBQzVCLGNBQU0sV0FBVyxpQkFBaUIsS0FBSztBQUN2QyxlQUFPLG1CQUNILFlBQ0UsR0FBQSxVQUFBLFdBQVUsb0JBQ1YsR0FBQSxVQUFBLFlBQVcsb0JBQ2IsWUFDQSxHQUFBLFVBQUEsV0FBVSxjQUNWLEdBQUEsVUFBQSxXQUFVOztBQUVoQixhQUFPLG9CQUFtQixHQUFBLFVBQUEsYUFBWSxRQUFRLEVBQUUsU0FBUSxJQUFLLE1BQU0sa0JBQWtCLFFBQVE7SUFDL0Y7QUFqQkEsWUFBQSxlQUFBO0FBbUJBLGFBQWdCLGdCQUNkLElBQ0EsS0FDQSxPQUF3QixHQUFHLEtBQUssY0FBWTtBQUU1QyxVQUFJLENBQUM7QUFBTTtBQUNYLFlBQU0sZ0JBQWdCO0FBQ3RCLFVBQUksU0FBUztBQUFNLGNBQU0sSUFBSSxNQUFNLEdBQUc7QUFDdEMsU0FBRyxLQUFLLE9BQU8sS0FBSyxHQUFHO0lBQ3pCO0FBVEEsWUFBQSxrQkFBQTs7Ozs7Ozs7O0FDM01BLFFBQUEsWUFBQTtBQUVBLFFBQU0sUUFBUTs7TUFFWixNQUFNLElBQUksVUFBQSxLQUFLLE1BQU07O01BRXJCLFFBQVEsSUFBSSxVQUFBLEtBQUssUUFBUTtNQUN6QixjQUFjLElBQUksVUFBQSxLQUFLLGNBQWM7TUFDckMsWUFBWSxJQUFJLFVBQUEsS0FBSyxZQUFZO01BQ2pDLG9CQUFvQixJQUFJLFVBQUEsS0FBSyxvQkFBb0I7TUFDakQsVUFBVSxJQUFJLFVBQUEsS0FBSyxVQUFVO01BQzdCLGdCQUFnQixJQUFJLFVBQUEsS0FBSyxnQkFBZ0I7O01BRXpDLFNBQVMsSUFBSSxVQUFBLEtBQUssU0FBUztNQUMzQixRQUFRLElBQUksVUFBQSxLQUFLLFFBQVE7TUFDekIsTUFBTSxJQUFJLFVBQUEsS0FBSyxNQUFNOztNQUVyQixNQUFNLElBQUksVUFBQSxLQUFLLE1BQU07TUFDckIsT0FBTyxJQUFJLFVBQUEsS0FBSyxPQUFPOztNQUV2QixNQUFNLElBQUksVUFBQSxLQUFLLE1BQU07TUFDckIsU0FBUyxJQUFJLFVBQUEsS0FBSyxTQUFTO01BQzNCLFNBQVMsSUFBSSxVQUFBLEtBQUssU0FBUztNQUMzQixVQUFVLElBQUksVUFBQSxLQUFLLFVBQVU7O0FBRy9CLFlBQUEsVUFBZTs7Ozs7Ozs7OztBQ3hCZixRQUFBLFlBQUE7QUFFQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFVBQUE7QUFFYSxZQUFBLGVBQXVDO01BQ2xELFNBQVMsQ0FBQyxFQUFDLFFBQU8sT0FBTSxHQUFBLFVBQUEsa0JBQWlCOztBQUc5QixZQUFBLG9CQUE0QztNQUN2RCxTQUFTLENBQUMsRUFBQyxTQUFTLFdBQVUsTUFDNUIsY0FDSSxHQUFBLFVBQUEsUUFBTyw0QkFBNEIsd0JBQ25DLEdBQUEsVUFBQSxRQUFPOztBQVNmLGFBQWdCLFlBQ2QsS0FDQSxRQUFnQyxRQUFBLGNBQ2hDLFlBQ0EsbUJBQTJCO0FBRTNCLFlBQU0sRUFBQyxHQUFFLElBQUk7QUFDYixZQUFNLEVBQUMsS0FBSyxlQUFlLFVBQVMsSUFBSTtBQUN4QyxZQUFNLFNBQVMsZ0JBQWdCLEtBQUssT0FBTyxVQUFVO0FBQ3JELFVBQUksc0JBQWlCLFFBQWpCLHNCQUFpQixTQUFqQixvQkFBc0IsaUJBQWlCLFdBQVk7QUFDckQsUUFBQUMsVUFBUyxLQUFLLE1BQU07YUFDZjtBQUNMLHFCQUFhLEtBQUksR0FBQSxVQUFBLE1BQUssU0FBUzs7SUFFbkM7QUFkQSxZQUFBLGNBQUE7QUFnQkEsYUFBZ0IsaUJBQ2QsS0FDQSxRQUFnQyxRQUFBLGNBQ2hDLFlBQXVCO0FBRXZCLFlBQU0sRUFBQyxHQUFFLElBQUk7QUFDYixZQUFNLEVBQUMsS0FBSyxlQUFlLFVBQVMsSUFBSTtBQUN4QyxZQUFNLFNBQVMsZ0JBQWdCLEtBQUssT0FBTyxVQUFVO0FBQ3JELE1BQUFBLFVBQVMsS0FBSyxNQUFNO0FBQ3BCLFVBQUksRUFBRSxpQkFBaUIsWUFBWTtBQUNqQyxxQkFBYSxJQUFJLFFBQUEsUUFBRSxPQUFPOztJQUU5QjtBQVpBLFlBQUEsbUJBQUE7QUFjQSxhQUFnQixpQkFBaUIsS0FBYyxXQUFlO0FBQzVELFVBQUksT0FBTyxRQUFBLFFBQUUsUUFBUSxTQUFTO0FBQzlCLFVBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxRQUFBLFFBQUUsb0JBQW9CLE1BQy9CLElBQUksR0FDRixXQUNBLE1BQU0sSUFBSSxRQUFPLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxrQkFBa0IsU0FBUyxHQUNsRCxNQUFNLElBQUksT0FBTyxRQUFBLFFBQUUsU0FBUyxJQUFJLENBQUMsQ0FDbEM7SUFFTDtBQVRBLFlBQUEsbUJBQUE7QUFXQSxhQUFnQixhQUFhLEVBQzNCLEtBQ0EsU0FDQSxhQUNBLE1BQ0EsV0FDQSxHQUFFLEdBQ2M7QUFFaEIsVUFBSSxjQUFjO0FBQVcsY0FBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQ3ZFLFlBQU0sTUFBTSxJQUFJLEtBQUssS0FBSztBQUMxQixVQUFJLFNBQVMsS0FBSyxXQUFXLFFBQUEsUUFBRSxRQUFRLENBQUMsTUFBSztBQUMzQyxZQUFJLE1BQU0sTUFBSyxHQUFBLFVBQUEsS0FBSSxRQUFBLFFBQUUsV0FBVyxJQUFJO0FBQ3BDLFlBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxrQ0FBa0MsTUFDM0MsSUFBSSxRQUFPLEdBQUEsVUFBQSxLQUFJLHFCQUFvQixHQUFBLFVBQUEsV0FBVSxRQUFBLFFBQUUsY0FBYyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBRTdFLFlBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSxtQkFBa0IsR0FBQSxVQUFBLE9BQU0sR0FBRyxpQkFBaUIsU0FBUztBQUNwRSxZQUFJLEdBQUcsS0FBSyxTQUFTO0FBQ25CLGNBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSxjQUFjLFdBQVc7QUFDeEMsY0FBSSxRQUFPLEdBQUEsVUFBQSxLQUFJLFlBQVksSUFBSTs7TUFFbkMsQ0FBQztJQUNIO0FBdEJBLFlBQUEsZUFBQTtBQXdCQSxhQUFTQSxVQUFTLEtBQWMsUUFBWTtBQUMxQyxZQUFNLE1BQU0sSUFBSSxNQUFNLE9BQU8sTUFBTTtBQUNuQyxVQUFJLElBQ0YsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLG9CQUNOLE1BQU0sSUFBSSxPQUFPLFFBQUEsUUFBRSxVQUFTLEdBQUEsVUFBQSxNQUFLLE1BQU0sSUFDdkMsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLGdCQUFnQixNQUFNO0FBRTlCLFVBQUksTUFBSyxHQUFBLFVBQUEsS0FBSSxRQUFBLFFBQUUsVUFBVTtJQUMzQjtBQUVBLGFBQVMsYUFBYSxJQUFlLE1BQVU7QUFDN0MsWUFBTSxFQUFDLEtBQUssY0FBYyxVQUFTLElBQUk7QUFDdkMsVUFBSSxVQUFVLFFBQVE7QUFDcEIsWUFBSSxPQUFNLEdBQUEsVUFBQSxTQUFRLEdBQUcsbUJBQTJCLE9BQU87YUFDbEQ7QUFDTCxZQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksdUJBQXVCLElBQUk7QUFDMUMsWUFBSSxPQUFPLEtBQUs7O0lBRXBCO0FBRUEsUUFBTSxJQUFJO01BQ1IsU0FBUyxJQUFJLFVBQUEsS0FBSyxTQUFTO01BQzNCLFlBQVksSUFBSSxVQUFBLEtBQUssWUFBWTtNQUNqQyxRQUFRLElBQUksVUFBQSxLQUFLLFFBQVE7TUFDekIsY0FBYyxJQUFJLFVBQUEsS0FBSyxjQUFjO01BQ3JDLFNBQVMsSUFBSSxVQUFBLEtBQUssU0FBUztNQUMzQixRQUFRLElBQUksVUFBQSxLQUFLLFFBQVE7TUFDekIsY0FBYyxJQUFJLFVBQUEsS0FBSyxjQUFjOztBQUd2QyxhQUFTLGdCQUNQLEtBQ0EsT0FDQSxZQUF1QjtBQUV2QixZQUFNLEVBQUMsYUFBWSxJQUFJLElBQUk7QUFDM0IsVUFBSSxpQkFBaUI7QUFBTyxnQkFBTyxHQUFBLFVBQUE7QUFDbkMsYUFBTyxZQUFZLEtBQUssT0FBTyxVQUFVO0lBQzNDO0FBRUEsYUFBUyxZQUNQLEtBQ0EsT0FDQSxhQUF5QixDQUFBLEdBQUU7QUFFM0IsWUFBTSxFQUFDLEtBQUssR0FBRSxJQUFJO0FBQ2xCLFlBQU0sWUFBeUM7UUFDN0Msa0JBQWtCLElBQUksVUFBVTtRQUNoQyxnQkFBZ0IsS0FBSyxVQUFVOztBQUVqQyxzQkFBZ0IsS0FBSyxPQUFPLFNBQVM7QUFDckMsYUFBTyxJQUFJLE9BQU8sR0FBRyxTQUFTO0lBQ2hDO0FBRUEsYUFBUyxrQkFBa0IsRUFBQyxVQUFTLEdBQWMsRUFBQyxhQUFZLEdBQWE7QUFDM0UsWUFBTSxXQUFXLGdCQUNiLEdBQUEsVUFBQSxPQUFNLGFBQVksR0FBQSxPQUFBLGNBQWEsY0FBYyxPQUFBLEtBQUssR0FBRyxNQUNyRDtBQUNKLGFBQU8sQ0FBQyxRQUFBLFFBQUUsZUFBYyxHQUFBLFVBQUEsV0FBVSxRQUFBLFFBQUUsY0FBYyxRQUFRLENBQUM7SUFDN0Q7QUFFQSxhQUFTLGdCQUNQLEVBQUMsU0FBUyxJQUFJLEVBQUMsY0FBYSxFQUFDLEdBQzdCLEVBQUMsWUFBWSxhQUFZLEdBQWE7QUFFdEMsVUFBSSxVQUFVLGVBQWUsaUJBQWdCLEdBQUEsVUFBQSxPQUFNLGlCQUFpQjtBQUNwRSxVQUFJLFlBQVk7QUFDZCxtQkFBVSxHQUFBLFVBQUEsT0FBTSxXQUFVLEdBQUEsT0FBQSxjQUFhLFlBQVksT0FBQSxLQUFLLEdBQUc7O0FBRTdELGFBQU8sQ0FBQyxFQUFFLFlBQVksT0FBTztJQUMvQjtBQUVBLGFBQVMsZ0JBQ1AsS0FDQSxFQUFDLFFBQVEsUUFBTyxHQUNoQixXQUFzQztBQUV0QyxZQUFNLEVBQUMsU0FBUyxNQUFNLGFBQWEsR0FBRSxJQUFJO0FBQ3pDLFlBQU0sRUFBQyxNQUFNLGNBQWMsY0FBYyxXQUFVLElBQUk7QUFDdkQsZ0JBQVUsS0FDUixDQUFDLEVBQUUsU0FBUyxPQUFPLEdBQ25CLENBQUMsRUFBRSxRQUFRLE9BQU8sVUFBVSxhQUFhLE9BQU8sR0FBRyxJQUFJLFdBQVUsR0FBQSxVQUFBLE1BQUssQ0FBQztBQUV6RSxVQUFJLEtBQUssVUFBVTtBQUNqQixrQkFBVSxLQUFLLENBQUMsRUFBRSxTQUFTLE9BQU8sV0FBVyxhQUFhLFFBQVEsR0FBRyxJQUFJLE9BQU8sQ0FBQzs7QUFFbkYsVUFBSSxLQUFLLFNBQVM7QUFDaEIsa0JBQVUsS0FDUixDQUFDLEVBQUUsUUFBUSxXQUFXLEdBQ3RCLENBQUMsRUFBRSxlQUFjLEdBQUEsVUFBQSxLQUFJLGVBQWUsWUFBWSxHQUNoRCxDQUFDLFFBQUEsUUFBRSxNQUFNLElBQUksQ0FBQzs7QUFHbEIsVUFBSTtBQUFjLGtCQUFVLEtBQUssQ0FBQyxFQUFFLGNBQWMsWUFBWSxDQUFDO0lBQ2pFOzs7Ozs7Ozs7O0FDckxBLFFBQUEsV0FBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsVUFBQTtBQUVBLFFBQU0sWUFBb0M7TUFDeEMsU0FBUzs7QUFHWCxhQUFnQixxQkFBcUIsSUFBYTtBQUNoRCxZQUFNLEVBQUMsS0FBSyxRQUFRLGFBQVksSUFBSTtBQUNwQyxVQUFJLFdBQVcsT0FBTztBQUNwQix5QkFBaUIsSUFBSSxLQUFLO2lCQUNqQixPQUFPLFVBQVUsWUFBWSxPQUFPLFdBQVcsTUFBTTtBQUM5RCxZQUFJLE9BQU8sUUFBQSxRQUFFLElBQUk7YUFDWjtBQUNMLFlBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSx1QkFBdUIsSUFBSTtBQUMxQyxZQUFJLE9BQU8sSUFBSTs7SUFFbkI7QUFWQSxZQUFBLHVCQUFBO0FBWUEsYUFBZ0Isa0JBQWtCLElBQWUsT0FBVztBQUMxRCxZQUFNLEVBQUMsS0FBSyxPQUFNLElBQUk7QUFDdEIsVUFBSSxXQUFXLE9BQU87QUFDcEIsWUFBSSxJQUFJLE9BQU8sS0FBSztBQUNwQix5QkFBaUIsRUFBRTthQUNkO0FBQ0wsWUFBSSxJQUFJLE9BQU8sSUFBSTs7SUFFdkI7QUFSQSxZQUFBLG9CQUFBO0FBVUEsYUFBUyxpQkFBaUIsSUFBZSxtQkFBMkI7QUFDbEUsWUFBTSxFQUFDLEtBQUssS0FBSSxJQUFJO0FBRXBCLFlBQU0sTUFBdUI7UUFDM0I7UUFDQSxTQUFTO1FBQ1Q7UUFDQSxRQUFRO1FBQ1IsWUFBWTtRQUNaLGFBQWE7UUFDYixRQUFRLENBQUE7UUFDUjs7QUFFRixPQUFBLEdBQUEsU0FBQSxhQUFZLEtBQUssV0FBVyxRQUFXLGlCQUFpQjtJQUMxRDs7Ozs7Ozs7OztBQzVDQSxRQUFNLGFBQWEsQ0FBQyxVQUFVLFVBQVUsV0FBVyxXQUFXLFFBQVEsVUFBVSxPQUFPO0FBSXZGLFFBQU0sWUFBeUIsSUFBSSxJQUFJLFVBQVU7QUFFakQsYUFBZ0IsV0FBVyxHQUFVO0FBQ25DLGFBQU8sT0FBTyxLQUFLLFlBQVksVUFBVSxJQUFJLENBQUM7SUFDaEQ7QUFGQSxZQUFBLGFBQUE7QUEyQkEsYUFBZ0IsV0FBUTtBQUN0QixZQUFNLFNBQXNFO1FBQzFFLFFBQVEsRUFBQyxNQUFNLFVBQVUsT0FBTyxDQUFBLEVBQUU7UUFDbEMsUUFBUSxFQUFDLE1BQU0sVUFBVSxPQUFPLENBQUEsRUFBRTtRQUNsQyxPQUFPLEVBQUMsTUFBTSxTQUFTLE9BQU8sQ0FBQSxFQUFFO1FBQ2hDLFFBQVEsRUFBQyxNQUFNLFVBQVUsT0FBTyxDQUFBLEVBQUU7O0FBRXBDLGFBQU87UUFDTCxPQUFPLEVBQUMsR0FBRyxRQUFRLFNBQVMsTUFBTSxTQUFTLE1BQU0sTUFBTSxLQUFJO1FBQzNELE9BQU8sQ0FBQyxFQUFDLE9BQU8sQ0FBQSxFQUFFLEdBQUcsT0FBTyxRQUFRLE9BQU8sUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNO1FBQzlFLE1BQU0sRUFBQyxPQUFPLENBQUEsRUFBRTtRQUNoQixLQUFLLENBQUE7UUFDTCxVQUFVLENBQUE7O0lBRWQ7QUFkQSxZQUFBLFdBQUE7Ozs7Ozs7Ozs7QUMvQkEsYUFBZ0Isc0JBQ2QsRUFBQyxRQUFRLE1BQUFDLE1BQUksR0FDYixNQUFjO0FBRWQsWUFBTSxRQUFRQSxNQUFLLE1BQU0sTUFBTSxJQUFJO0FBQ25DLGFBQU8sU0FBUyxVQUFVLFFBQVEsZUFBZSxRQUFRLEtBQUs7SUFDaEU7QUFOQSxZQUFBLHdCQUFBO0FBUUEsYUFBZ0IsZUFBZSxRQUF5QixPQUFnQjtBQUN0RSxhQUFPLE1BQU0sTUFBTSxLQUFLLENBQUMsU0FBUyxjQUFjLFFBQVEsSUFBSSxDQUFDO0lBQy9EO0FBRkEsWUFBQSxpQkFBQTtBQUlBLGFBQWdCLGNBQWMsUUFBeUIsTUFBVTs7QUFDL0QsYUFDRSxPQUFPLEtBQUssT0FBTyxNQUFNLFlBQ3pCQyxNQUFBLEtBQUssV0FBVyxnQkFBVSxRQUFBQSxRQUFBLFNBQUEsU0FBQUEsSUFBRSxLQUFLLENBQUMsUUFBUSxPQUFPLEdBQUcsTUFBTSxNQUFTO0lBRXZFO0FBTEEsWUFBQSxnQkFBQTs7Ozs7Ozs7OztBQ1RBLFFBQUEsVUFBQTtBQUNBLFFBQUEsa0JBQUE7QUFDQSxRQUFBLFdBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFFQSxRQUFZO0FBQVosS0FBQSxTQUFZQyxXQUFRO0FBQ2xCLE1BQUFBLFVBQUFBLFVBQUEsU0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBLE1BQUFBLFVBQUFBLFVBQUEsT0FBQSxJQUFBLENBQUEsSUFBQTtJQUNGLEdBSFksV0FBQSxRQUFBLGFBQUEsUUFBQSxXQUFRLENBQUEsRUFBQTtBQUtwQixhQUFnQixlQUFlLFFBQXVCO0FBQ3BELFlBQU0sUUFBUSxhQUFhLE9BQU8sSUFBSTtBQUN0QyxZQUFNLFVBQVUsTUFBTSxTQUFTLE1BQU07QUFDckMsVUFBSSxTQUFTO0FBQ1gsWUFBSSxPQUFPLGFBQWE7QUFBTyxnQkFBTSxJQUFJLE1BQU0sd0NBQXdDO2FBQ2xGO0FBQ0wsWUFBSSxDQUFDLE1BQU0sVUFBVSxPQUFPLGFBQWEsUUFBVztBQUNsRCxnQkFBTSxJQUFJLE1BQU0sMENBQTBDOztBQUU1RCxZQUFJLE9BQU8sYUFBYTtBQUFNLGdCQUFNLEtBQUssTUFBTTs7QUFFakQsYUFBTztJQUNUO0FBWkEsWUFBQSxpQkFBQTtBQWNBLGFBQWdCLGFBQWEsSUFBdUI7QUFDbEQsWUFBTSxRQUFtQixNQUFNLFFBQVEsRUFBRSxJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFBO0FBQzlELFVBQUksTUFBTSxNQUFNLFFBQUEsVUFBVTtBQUFHLGVBQU87QUFDcEMsWUFBTSxJQUFJLE1BQU0sMENBQTBDLE1BQU0sS0FBSyxHQUFHLENBQUM7SUFDM0U7QUFKQSxZQUFBLGVBQUE7QUFNQSxhQUFnQix1QkFBdUIsSUFBa0IsT0FBaUI7QUFDeEUsWUFBTSxFQUFDLEtBQUssTUFBTSxLQUFJLElBQUk7QUFDMUIsWUFBTSxXQUFXLGNBQWMsT0FBTyxLQUFLLFdBQVc7QUFDdEQsWUFBTSxhQUNKLE1BQU0sU0FBUyxLQUNmLEVBQUUsU0FBUyxXQUFXLEtBQUssTUFBTSxXQUFXLE1BQUssR0FBQSxnQkFBQSx1QkFBc0IsSUFBSSxNQUFNLENBQUMsQ0FBQztBQUNyRixVQUFJLFlBQVk7QUFDZCxjQUFNLFlBQVksZUFBZSxPQUFPLE1BQU0sS0FBSyxlQUFlLFNBQVMsS0FBSztBQUNoRixZQUFJLEdBQUcsV0FBVyxNQUFLO0FBQ3JCLGNBQUksU0FBUztBQUFRLHVCQUFXLElBQUksT0FBTyxRQUFROztBQUM5Qyw0QkFBZ0IsRUFBRTtRQUN6QixDQUFDOztBQUVILGFBQU87SUFDVDtBQWRBLFlBQUEseUJBQUE7QUFnQkEsUUFBTSxZQUEyQixvQkFBSSxJQUFJLENBQUMsVUFBVSxVQUFVLFdBQVcsV0FBVyxNQUFNLENBQUM7QUFDM0YsYUFBUyxjQUFjLE9BQW1CLGFBQStCO0FBQ3ZFLGFBQU8sY0FDSCxNQUFNLE9BQU8sQ0FBQyxNQUFNLFVBQVUsSUFBSSxDQUFDLEtBQU0sZ0JBQWdCLFdBQVcsTUFBTSxPQUFRLElBQ2xGLENBQUE7SUFDTjtBQUVBLGFBQVMsV0FBVyxJQUFrQixPQUFtQixVQUFvQjtBQUMzRSxZQUFNLEVBQUMsS0FBSyxNQUFNLEtBQUksSUFBSTtBQUMxQixZQUFNLFdBQVcsSUFBSSxJQUFJLGFBQVksR0FBQSxVQUFBLFlBQVcsTUFBTTtBQUN0RCxZQUFNLFVBQVUsSUFBSSxJQUFJLFlBQVcsR0FBQSxVQUFBLGFBQVk7QUFDL0MsVUFBSSxLQUFLLGdCQUFnQixTQUFTO0FBQ2hDLFlBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSx5Q0FBeUMsWUFBWSxvQkFBb0IsTUFDbEYsSUFDRyxPQUFPLE9BQU0sR0FBQSxVQUFBLEtBQUksU0FBUyxFQUMxQixPQUFPLFdBQVUsR0FBQSxVQUFBLFlBQVcsTUFBTSxFQUNsQyxHQUFHLGVBQWUsT0FBTyxNQUFNLEtBQUssYUFBYSxHQUFHLE1BQU0sSUFBSSxPQUFPLFNBQVMsSUFBSSxDQUFDLENBQUM7O0FBRzNGLFVBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSx1QkFBdUI7QUFDbEMsaUJBQVcsS0FBSyxVQUFVO0FBQ3hCLFlBQUksVUFBVSxJQUFJLENBQUMsS0FBTSxNQUFNLFdBQVcsS0FBSyxnQkFBZ0IsU0FBVTtBQUN2RSw2QkFBbUIsQ0FBQzs7O0FBR3hCLFVBQUksS0FBSTtBQUNSLHNCQUFnQixFQUFFO0FBQ2xCLFVBQUksTUFBSztBQUVULFVBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSx5QkFBeUIsTUFBSztBQUN2QyxZQUFJLE9BQU8sTUFBTSxPQUFPO0FBQ3hCLHlCQUFpQixJQUFJLE9BQU87TUFDOUIsQ0FBQztBQUVELGVBQVMsbUJBQW1CLEdBQVM7QUFDbkMsZ0JBQVEsR0FBRztVQUNULEtBQUs7QUFDSCxnQkFDRyxRQUFPLEdBQUEsVUFBQSxLQUFJLDJCQUEyQix1QkFBdUIsRUFDN0QsT0FBTyxVQUFTLEdBQUEsVUFBQSxVQUFTLE1BQU0sRUFDL0IsUUFBTyxHQUFBLFVBQUEsS0FBSSxlQUFlLEVBQzFCLE9BQU8sVUFBUyxHQUFBLFVBQUEsTUFBSztBQUN4QjtVQUNGLEtBQUs7QUFDSCxnQkFDRyxRQUNDLEdBQUEsVUFBQSxLQUFJLDRCQUE0QjtvQkFDeEIsMkJBQTJCLFdBQVcsWUFBWSxPQUFPLEVBRWxFLE9BQU8sVUFBUyxHQUFBLFVBQUEsTUFBSyxNQUFNO0FBQzlCO1VBQ0YsS0FBSztBQUNILGdCQUNHLFFBQ0MsR0FBQSxVQUFBLEtBQUksNkJBQTZCO29CQUN6Qiw0QkFBNEIsV0FBVyxZQUFZLGFBQWEsWUFBWSxFQUVyRixPQUFPLFVBQVMsR0FBQSxVQUFBLE1BQUssTUFBTTtBQUM5QjtVQUNGLEtBQUs7QUFDSCxnQkFDRyxRQUFPLEdBQUEsVUFBQSxLQUFJLHVCQUF1QixpQkFBaUIsZUFBZSxFQUNsRSxPQUFPLFNBQVMsS0FBSyxFQUNyQixRQUFPLEdBQUEsVUFBQSxLQUFJLHNCQUFzQixZQUFZLEVBQzdDLE9BQU8sU0FBUyxJQUFJO0FBQ3ZCO1VBQ0YsS0FBSztBQUNILGdCQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksa0JBQWtCLGlCQUFpQixnQkFBZ0I7QUFDbEUsZ0JBQUksT0FBTyxTQUFTLElBQUk7QUFDeEI7VUFFRixLQUFLO0FBQ0gsZ0JBQ0csUUFDQyxHQUFBLFVBQUEsS0FBSSw0QkFBNEI7bUJBQ3pCLDZCQUE2QixlQUFlLEVBRXBELE9BQU8sVUFBUyxHQUFBLFVBQUEsTUFBSyxPQUFPOztNQUVyQztJQUNGO0FBRUEsYUFBUyxpQkFBaUIsRUFBQyxLQUFLLFlBQVksbUJBQWtCLEdBQWlCLE1BQVU7QUFFdkYsVUFBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLDRCQUE0QixNQUNyQyxJQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksY0FBYyx1QkFBdUIsSUFBSSxDQUFDO0lBRTdEO0FBRUEsYUFBZ0IsY0FDZCxVQUNBLE1BQ0EsWUFDQSxVQUFVLFNBQVMsU0FBTztBQUUxQixZQUFNLEtBQUssWUFBWSxTQUFTLFVBQVUsVUFBQSxVQUFVLEtBQUssVUFBQSxVQUFVO0FBQ25FLFVBQUk7QUFDSixjQUFRLFVBQVU7UUFDaEIsS0FBSztBQUNILGtCQUFPLEdBQUEsVUFBQSxLQUFJLFFBQVE7UUFDckIsS0FBSztBQUNILGtCQUFPLEdBQUEsVUFBQSxtQkFBa0I7QUFDekI7UUFDRixLQUFLO0FBQ0gsa0JBQU8sR0FBQSxVQUFBLEtBQUksa0JBQWtCLHNDQUFzQztBQUNuRTtRQUNGLEtBQUs7QUFDSCxpQkFBTyxTQUFRLEdBQUEsVUFBQSxPQUFNLHVCQUF1QixPQUFPO0FBQ25EO1FBQ0YsS0FBSztBQUNILGlCQUFPLFFBQU87QUFDZDtRQUNGO0FBQ0Usa0JBQU8sR0FBQSxVQUFBLFlBQVcsUUFBUSxNQUFNOztBQUVwQyxhQUFPLFlBQVksU0FBUyxVQUFVLFFBQU8sR0FBQSxVQUFBLEtBQUksSUFBSTtBQUVyRCxlQUFTLFFBQVEsUUFBYyxVQUFBLEtBQUc7QUFDaEMsZ0JBQU8sR0FBQSxVQUFBLE1BQUksR0FBQSxVQUFBLFlBQVcsb0JBQW9CLE9BQU8sY0FBYSxHQUFBLFVBQUEsY0FBYSxVQUFVLFVBQUEsR0FBRztNQUMxRjtJQUNGO0FBL0JBLFlBQUEsZ0JBQUE7QUFpQ0EsYUFBZ0IsZUFDZCxXQUNBLE1BQ0EsWUFDQSxTQUFrQjtBQUVsQixVQUFJLFVBQVUsV0FBVyxHQUFHO0FBQzFCLGVBQU8sY0FBYyxVQUFVLENBQUMsR0FBRyxNQUFNLFlBQVksT0FBTzs7QUFFOUQsVUFBSTtBQUNKLFlBQU0sU0FBUSxHQUFBLE9BQUEsUUFBTyxTQUFTO0FBQzlCLFVBQUksTUFBTSxTQUFTLE1BQU0sUUFBUTtBQUMvQixjQUFNLFVBQVMsR0FBQSxVQUFBLFlBQVc7QUFDMUIsZUFBTyxNQUFNLE9BQU8sVUFBUyxHQUFBLFVBQUEsTUFBSyxXQUFXO0FBQzdDLGVBQU8sTUFBTTtBQUNiLGVBQU8sTUFBTTtBQUNiLGVBQU8sTUFBTTthQUNSO0FBQ0wsZUFBTyxVQUFBOztBQUVULFVBQUksTUFBTTtBQUFRLGVBQU8sTUFBTTtBQUMvQixpQkFBVyxLQUFLO0FBQU8sZ0JBQU8sR0FBQSxVQUFBLEtBQUksTUFBTSxjQUFjLEdBQWUsTUFBTSxZQUFZLE9BQU8sQ0FBQztBQUMvRixhQUFPO0lBQ1Q7QUF2QkEsWUFBQSxpQkFBQTtBQTJCQSxRQUFNLFlBQW9DO01BQ3hDLFNBQVMsQ0FBQyxFQUFDLE9BQU0sTUFBTSxXQUFXO01BQ2xDLFFBQVEsQ0FBQyxFQUFDLFFBQVEsWUFBVyxNQUMzQixPQUFPLFVBQVUsWUFBVyxHQUFBLFVBQUEsWUFBVyxhQUFZLEdBQUEsVUFBQSxZQUFXOztBQUdsRSxhQUFnQixnQkFBZ0IsSUFBZ0I7QUFDOUMsWUFBTSxNQUFNLG9CQUFvQixFQUFFO0FBQ2xDLE9BQUEsR0FBQSxTQUFBLGFBQVksS0FBSyxTQUFTO0lBQzVCO0FBSEEsWUFBQSxrQkFBQTtBQUtBLGFBQVMsb0JBQW9CLElBQWdCO0FBQzNDLFlBQU0sRUFBQyxLQUFLLE1BQU0sT0FBTSxJQUFJO0FBQzVCLFlBQU0sY0FBYSxHQUFBLE9BQUEsZ0JBQWUsSUFBSSxRQUFRLE1BQU07QUFDcEQsYUFBTztRQUNMO1FBQ0EsU0FBUztRQUNUO1FBQ0EsUUFBUSxPQUFPO1FBQ2Y7UUFDQSxhQUFhO1FBQ2IsY0FBYztRQUNkLFFBQVEsQ0FBQTtRQUNSOztJQUVKOzs7Ozs7Ozs7O0FDbk9BLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQUVBLGFBQWdCLGVBQWUsSUFBa0IsSUFBVztBQUMxRCxZQUFNLEVBQUMsWUFBWSxNQUFLLElBQUksR0FBRztBQUMvQixVQUFJLE9BQU8sWUFBWSxZQUFZO0FBQ2pDLG1CQUFXLE9BQU8sWUFBWTtBQUM1Qix3QkFBYyxJQUFJLEtBQUssV0FBVyxHQUFHLEVBQUUsT0FBTzs7aUJBRXZDLE9BQU8sV0FBVyxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ2pELGNBQU0sUUFBUSxDQUFDLEtBQUssTUFBYyxjQUFjLElBQUksR0FBRyxJQUFJLE9BQU8sQ0FBQzs7SUFFdkU7QUFUQSxZQUFBLGlCQUFBO0FBV0EsYUFBUyxjQUFjLElBQWtCLE1BQXVCLGNBQXFCO0FBQ25GLFlBQU0sRUFBQyxLQUFLLGVBQWUsTUFBTSxLQUFJLElBQUk7QUFDekMsVUFBSSxpQkFBaUI7QUFBVztBQUNoQyxZQUFNLGFBQVksR0FBQSxVQUFBLEtBQUksUUFBTyxHQUFBLFVBQUEsYUFBWSxJQUFJO0FBQzdDLFVBQUksZUFBZTtBQUNqQixTQUFBLEdBQUEsT0FBQSxpQkFBZ0IsSUFBSSwyQkFBMkIsV0FBVztBQUMxRDs7QUFHRixVQUFJLGFBQVksR0FBQSxVQUFBLEtBQUk7QUFDcEIsVUFBSSxLQUFLLGdCQUFnQixTQUFTO0FBQ2hDLHFCQUFZLEdBQUEsVUFBQSxLQUFJLGdCQUFnQix5QkFBeUI7O0FBSTNELFVBQUksR0FBRyxZQUFXLEdBQUEsVUFBQSxLQUFJLGdCQUFlLEdBQUEsVUFBQSxXQUFVLFlBQVksR0FBRztJQUNoRTs7Ozs7Ozs7OztBQzVCQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxhQUFnQix1QkFBdUIsS0FBaUIsTUFBWTtBQUNsRSxZQUFNLEVBQUMsS0FBSyxNQUFNLEdBQUUsSUFBSTtBQUN4QixVQUFJLEdBQUcsaUJBQWlCLEtBQUssTUFBTSxNQUFNLEdBQUcsS0FBSyxhQUFhLEdBQUcsTUFBSztBQUNwRSxZQUFJLFVBQVUsRUFBQyxrQkFBaUIsR0FBQSxVQUFBLEtBQUksT0FBTSxHQUFHLElBQUk7QUFDakQsWUFBSSxNQUFLO01BQ1gsQ0FBQztJQUNIO0FBTkEsWUFBQSx5QkFBQTtBQVFBLGFBQWdCLGlCQUNkLEVBQUMsS0FBSyxNQUFNLElBQUksRUFBQyxLQUFJLEVBQUMsR0FDdEIsWUFDQSxTQUFhO0FBRWIsY0FBTyxHQUFBLFVBQUEsSUFDTCxHQUFHLFdBQVcsSUFBSSxDQUFDLFVBQ2pCLEdBQUEsVUFBQSxLQUFJLGlCQUFpQixLQUFLLE1BQU0sTUFBTSxLQUFLLGFBQWEsSUFBRyxHQUFBLFVBQUEsS0FBSSxhQUFhLE1BQU0sQ0FBQyxDQUNwRjtJQUVMO0FBVkEsWUFBQSxtQkFBQTtBQVlBLGFBQWdCLGtCQUFrQixLQUFpQixTQUFhO0FBQzlELFVBQUksVUFBVSxFQUFDLGlCQUFpQixRQUFPLEdBQUcsSUFBSTtBQUM5QyxVQUFJLE1BQUs7SUFDWDtBQUhBLFlBQUEsb0JBQUE7QUFLQSxhQUFnQixZQUFZLEtBQVk7QUFDdEMsYUFBTyxJQUFJLFdBQVcsUUFBUTs7UUFFNUIsS0FBSyxPQUFPLFVBQVU7UUFDdEIsT0FBTSxHQUFBLFVBQUE7T0FDUDtJQUNIO0FBTkEsWUFBQSxjQUFBO0FBUUEsYUFBZ0IsY0FBYyxLQUFjLE1BQVksVUFBdUI7QUFDN0UsY0FBTyxHQUFBLFVBQUEsS0FBSSxZQUFZLEdBQUcsVUFBVSxTQUFTO0lBQy9DO0FBRkEsWUFBQSxnQkFBQTtBQUlBLGFBQWdCLGVBQ2QsS0FDQSxNQUNBLFVBQ0EsZUFBdUI7QUFFdkIsWUFBTSxRQUFPLEdBQUEsVUFBQSxLQUFJLFFBQU8sR0FBQSxVQUFBLGFBQVksUUFBUTtBQUM1QyxhQUFPLGlCQUFnQixHQUFBLFVBQUEsS0FBSSxXQUFXLGNBQWMsS0FBSyxNQUFNLFFBQVEsTUFBTTtJQUMvRTtBQVJBLFlBQUEsaUJBQUE7QUFVQSxhQUFnQixpQkFDZCxLQUNBLE1BQ0EsVUFDQSxlQUF1QjtBQUV2QixZQUFNLFFBQU8sR0FBQSxVQUFBLEtBQUksUUFBTyxHQUFBLFVBQUEsYUFBWSxRQUFRO0FBQzVDLGFBQU8saUJBQWdCLEdBQUEsVUFBQSxJQUFHLE9BQU0sR0FBQSxVQUFBLEtBQUksY0FBYyxLQUFLLE1BQU0sUUFBUSxDQUFDLENBQUMsSUFBSTtJQUM3RTtBQVJBLFlBQUEsbUJBQUE7QUFVQSxhQUFnQixvQkFBb0IsV0FBcUI7QUFDdkQsYUFBTyxZQUFZLE9BQU8sS0FBSyxTQUFTLEVBQUUsT0FBTyxDQUFDLE1BQU0sTUFBTSxXQUFXLElBQUksQ0FBQTtJQUMvRTtBQUZBLFlBQUEsc0JBQUE7QUFJQSxhQUFnQixpQkFBaUIsSUFBZSxXQUFvQjtBQUNsRSxhQUFPLG9CQUFvQixTQUFTLEVBQUUsT0FDcEMsQ0FBQyxNQUFNLEVBQUMsR0FBQSxPQUFBLG1CQUFrQixJQUFJLFVBQVUsQ0FBQyxDQUFjLENBQUM7SUFFNUQ7QUFKQSxZQUFBLG1CQUFBO0FBTUEsYUFBZ0IsaUJBQ2QsRUFBQyxZQUFZLE1BQU0sSUFBSSxFQUFDLEtBQUssY0FBYyxZQUFZLFVBQVMsR0FBRyxHQUFFLEdBQ3JFLE1BQ0EsU0FDQSxZQUFvQjtBQUVwQixZQUFNLGdCQUFnQixjQUFhLEdBQUEsVUFBQSxLQUFJLGVBQWUsU0FBUyxlQUFlLGVBQWU7QUFDN0YsWUFBTSxTQUFrQztRQUN0QyxDQUFDLFFBQUEsUUFBRSxlQUFjLEdBQUEsVUFBQSxXQUFVLFFBQUEsUUFBRSxjQUFjLFNBQVMsQ0FBQztRQUNyRCxDQUFDLFFBQUEsUUFBRSxZQUFZLEdBQUcsVUFBVTtRQUM1QixDQUFDLFFBQUEsUUFBRSxvQkFBb0IsR0FBRyxrQkFBa0I7UUFDNUMsQ0FBQyxRQUFBLFFBQUUsVUFBVSxRQUFBLFFBQUUsUUFBUTs7QUFFekIsVUFBSSxHQUFHLEtBQUs7QUFBWSxlQUFPLEtBQUssQ0FBQyxRQUFBLFFBQUUsZ0JBQWdCLFFBQUEsUUFBRSxjQUFjLENBQUM7QUFDeEUsWUFBTSxRQUFPLEdBQUEsVUFBQSxLQUFJLGtCQUFrQixJQUFJLE9BQU8sR0FBRyxNQUFNO0FBQ3ZELGFBQU8sWUFBWSxVQUFBLE9BQU0sR0FBQSxVQUFBLEtBQUksYUFBYSxZQUFZLFdBQVUsR0FBQSxVQUFBLEtBQUksUUFBUTtJQUM5RTtBQWhCQSxZQUFBLG1CQUFBO0FBa0JBLFFBQU0sYUFBWSxHQUFBLFVBQUE7QUFFbEIsYUFBZ0IsV0FBVyxFQUFDLEtBQUssSUFBSSxFQUFDLEtBQUksRUFBQyxHQUFlLFNBQWU7QUFDdkUsWUFBTSxJQUFJLEtBQUssZ0JBQWdCLE1BQU07QUFDckMsWUFBTSxFQUFDLE9BQU0sSUFBSSxLQUFLO0FBQ3RCLFlBQU0sS0FBSyxPQUFPLFNBQVMsQ0FBQztBQUU1QixhQUFPLElBQUksV0FBVyxXQUFXO1FBQy9CLEtBQUssR0FBRyxTQUFRO1FBQ2hCLEtBQUs7UUFDTCxPQUFNLEdBQUEsVUFBQSxLQUFJLE9BQU8sU0FBUyxlQUFlLGFBQVksR0FBQSxPQUFBLFNBQVEsS0FBSyxNQUFNLEtBQUssWUFBWTtPQUMxRjtJQUNIO0FBVkEsWUFBQSxhQUFBO0FBWUEsYUFBZ0IsY0FBYyxLQUFlO0FBQzNDLFlBQU0sRUFBQyxLQUFLLE1BQU0sU0FBUyxHQUFFLElBQUk7QUFDakMsWUFBTSxRQUFRLElBQUksS0FBSyxPQUFPO0FBQzlCLFVBQUksR0FBRyxXQUFXO0FBQ2hCLGNBQU0sV0FBVyxJQUFJLElBQUksU0FBUyxJQUFJO0FBQ3RDLHNCQUFjLE1BQU0sSUFBSSxPQUFPLFVBQVUsS0FBSyxDQUFDO0FBQy9DLGVBQU87O0FBRVQsVUFBSSxJQUFJLE9BQU8sSUFBSTtBQUNuQixvQkFBYyxNQUFNLElBQUksTUFBSyxDQUFFO0FBQy9CLGFBQU87QUFFUCxlQUFTLGNBQWMsVUFBb0I7QUFDekMsY0FBTSxNQUFNLElBQUksTUFBTSxRQUFPLEdBQUEsVUFBQSxLQUFJLGFBQWE7QUFDOUMsWUFBSSxTQUFTLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBSztBQUM5QixjQUFJLFVBQ0Y7WUFDRTtZQUNBLFVBQVU7WUFDVixjQUFjLE9BQUEsS0FBSzthQUVyQixLQUFLO0FBRVAsY0FBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLEtBQUssR0FBRyxRQUFRO1FBQzdCLENBQUM7TUFDSDtJQUNGO0FBMUJBLFlBQUEsZ0JBQUE7QUE0QkEsYUFBZ0IsY0FBYyxLQUFlO0FBQzNDLFlBQU0sRUFBQyxLQUFLLFFBQVEsU0FBUyxHQUFFLElBQUk7QUFFbkMsVUFBSSxDQUFDLE1BQU0sUUFBUSxNQUFNO0FBQUcsY0FBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQ3RFLFlBQU0sY0FBYyxPQUFPLEtBQUssQ0FBQyxTQUFtQixHQUFBLE9BQUEsbUJBQWtCLElBQUksR0FBRyxDQUFDO0FBQzlFLFVBQUksZUFBZSxDQUFDLEdBQUcsS0FBSztBQUFhO0FBRXpDLFlBQU0sUUFBUSxJQUFJLElBQUksU0FBUyxLQUFLO0FBQ3BDLFlBQU0sV0FBVyxJQUFJLEtBQUssUUFBUTtBQUVsQyxVQUFJLE1BQU0sTUFDUixPQUFPLFFBQVEsQ0FBQyxNQUFpQixNQUFhO0FBQzVDLGNBQU0sU0FBUyxJQUFJLFVBQ2pCO1VBQ0U7VUFDQSxZQUFZO1VBQ1osZUFBZTtXQUVqQixRQUFRO0FBRVYsWUFBSSxPQUFPLFFBQU8sR0FBQSxVQUFBLEtBQUksWUFBWSxVQUFVO0FBQzVDLGNBQU0sU0FBUyxJQUFJLG9CQUFvQixRQUFRLFFBQVE7QUFHdkQsWUFBSSxDQUFDO0FBQVEsY0FBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLEtBQUssQ0FBQztNQUNoQyxDQUFDLENBQUM7QUFHSixVQUFJLE9BQ0YsT0FDQSxNQUFNLElBQUksTUFBSyxHQUNmLE1BQU0sSUFBSSxNQUFNLElBQUksQ0FBQztJQUV6QjtBQWpDQSxZQUFBLGdCQUFBOzs7Ozs7Ozs7O0FDNUhBLFFBQUEsWUFBQTtBQUNBLFFBQUEsVUFBQTtBQUVBLFFBQUEsU0FBQTtBQUNBLFFBQUEsV0FBQTtBQUlBLGFBQWdCLGlCQUFpQixLQUFpQixLQUEyQjtBQUMzRSxZQUFNLEVBQUMsS0FBSyxTQUFTLFFBQVEsY0FBYyxHQUFFLElBQUk7QUFDakQsWUFBTSxjQUFjLElBQUksTUFBTSxLQUFLLEdBQUcsTUFBTSxRQUFRLGNBQWMsRUFBRTtBQUNwRSxZQUFNLFlBQVksV0FBVyxLQUFLLFNBQVMsV0FBVztBQUN0RCxVQUFJLEdBQUcsS0FBSyxtQkFBbUI7QUFBTyxXQUFHLEtBQUssZUFBZSxhQUFhLElBQUk7QUFFOUUsWUFBTSxRQUFRLElBQUksS0FBSyxPQUFPO0FBQzlCLFVBQUksVUFDRjtRQUNFLFFBQVE7UUFDUixZQUFZLFVBQUE7UUFDWixlQUFlLEdBQUcsR0FBRyxpQkFBaUI7UUFDdEMsY0FBYztRQUNkLGVBQWU7U0FFakIsS0FBSztBQUVQLFVBQUksS0FBSyxPQUFPLE1BQU0sSUFBSSxNQUFNLElBQUksQ0FBQztJQUN2QztBQWxCQSxZQUFBLG1CQUFBO0FBb0JBLGFBQWdCLGdCQUFnQixLQUFpQixLQUEwQjs7QUFDekUsWUFBTSxFQUFDLEtBQUssU0FBUyxRQUFRLGNBQWMsT0FBTyxHQUFFLElBQUk7QUFDeEQsd0JBQWtCLElBQUksR0FBRztBQUN6QixZQUFNLFdBQ0osQ0FBQyxTQUFTLElBQUksVUFBVSxJQUFJLFFBQVEsS0FBSyxHQUFHLE1BQU0sUUFBUSxjQUFjLEVBQUUsSUFBSSxJQUFJO0FBQ3BGLFlBQU0sY0FBYyxXQUFXLEtBQUssU0FBUyxRQUFRO0FBQ3JELFlBQU0sUUFBUSxJQUFJLElBQUksT0FBTztBQUM3QixVQUFJLFdBQVcsT0FBTyxlQUFlO0FBQ3JDLFVBQUksSUFBR0MsTUFBQSxJQUFJLFdBQUssUUFBQUEsUUFBQSxTQUFBQSxNQUFJLEtBQUs7QUFFekIsZUFBUyxrQkFBZTtBQUN0QixZQUFJLElBQUksV0FBVyxPQUFPO0FBQ3hCLHNCQUFXO0FBQ1gsY0FBSSxJQUFJO0FBQVcsdUJBQVcsR0FBRztBQUNqQyxxQkFBVyxNQUFNLElBQUksTUFBSyxDQUFFO2VBQ3ZCO0FBQ0wsZ0JBQU0sV0FBVyxJQUFJLFFBQVEsY0FBYSxJQUFLLGFBQVk7QUFDM0QsY0FBSSxJQUFJO0FBQVcsdUJBQVcsR0FBRztBQUNqQyxxQkFBVyxNQUFNLFFBQVEsS0FBSyxRQUFRLENBQUM7O01BRTNDO0FBRUEsZUFBUyxnQkFBYTtBQUNwQixjQUFNLFdBQVcsSUFBSSxJQUFJLFlBQVksSUFBSTtBQUN6QyxZQUFJLElBQ0YsTUFBTSxhQUFZLEdBQUEsVUFBQSxVQUFTLEdBQzNCLENBQUMsTUFDQyxJQUFJLE9BQU8sT0FBTyxLQUFLLEVBQUUsSUFDdkIsR0FBQSxVQUFBLEtBQUksZ0JBQWdCLEdBQUcsbUJBQ3ZCLE1BQU0sSUFBSSxPQUFPLFdBQVUsR0FBQSxVQUFBLEtBQUksVUFBVSxHQUN6QyxNQUFNLElBQUksTUFBTSxDQUFDLENBQUMsQ0FDbkI7QUFFTCxlQUFPO01BQ1Q7QUFFQSxlQUFTLGVBQVk7QUFDbkIsY0FBTSxnQkFBZSxHQUFBLFVBQUEsS0FBSTtBQUN6QixZQUFJLE9BQU8sY0FBYyxJQUFJO0FBQzdCLG9CQUFZLFVBQUEsR0FBRztBQUNmLGVBQU87TUFDVDtBQUVBLGVBQVMsWUFBWSxTQUFlLElBQUksU0FBUSxHQUFBLFVBQUEsYUFBWSxVQUFBLEtBQUc7QUFDN0QsY0FBTSxVQUFVLEdBQUcsS0FBSyxjQUFjLFFBQUEsUUFBRSxPQUFPLFFBQUEsUUFBRTtBQUNqRCxjQUFNLGFBQWEsRUFBRyxhQUFhLE9BQU8sQ0FBQyxTQUFVLElBQUksV0FBVztBQUNwRSxZQUFJLE9BQ0YsUUFDQSxHQUFBLFVBQUEsS0FBSSxVQUFTLEdBQUEsT0FBQSxrQkFBaUIsS0FBSyxhQUFhLFNBQVMsVUFBVSxLQUNuRSxJQUFJLFNBQVM7TUFFakI7QUFFQSxlQUFTLFdBQVcsUUFBa0I7O0FBQ3BDLFlBQUksSUFBRyxHQUFBLFVBQUEsTUFBSUEsTUFBQSxJQUFJLFdBQUssUUFBQUEsUUFBQSxTQUFBQSxNQUFJLEtBQUssR0FBRyxNQUFNO01BQ3hDO0lBQ0Y7QUF4REEsWUFBQSxrQkFBQTtBQTBEQSxhQUFTLFdBQVcsS0FBZTtBQUNqQyxZQUFNLEVBQUMsS0FBSyxNQUFNLEdBQUUsSUFBSTtBQUN4QixVQUFJLEdBQUcsR0FBRyxZQUFZLE1BQU0sSUFBSSxPQUFPLE9BQU0sR0FBQSxVQUFBLEtBQUksR0FBRyxjQUFjLEdBQUcscUJBQXFCLENBQUM7SUFDN0Y7QUFFQSxhQUFTLFFBQVEsS0FBaUIsTUFBVTtBQUMxQyxZQUFNLEVBQUMsSUFBRyxJQUFJO0FBQ2QsVUFBSSxJQUNGLEdBQUEsVUFBQSxtQkFBa0IsU0FDbEIsTUFBSztBQUNILFlBQ0csT0FBTyxRQUFBLFFBQUUsVUFBUyxHQUFBLFVBQUEsS0FBSSxRQUFBLFFBQUUsc0JBQXNCLFVBQVUsUUFBQSxRQUFFLGtCQUFrQixPQUFPLEVBQ25GLE9BQU8sUUFBQSxRQUFFLFNBQVEsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLGdCQUFnQjtBQUMxQyxTQUFBLEdBQUEsU0FBQSxjQUFhLEdBQUc7TUFDbEIsR0FDQSxNQUFNLElBQUksTUFBSyxDQUFFO0lBRXJCO0FBRUEsYUFBUyxrQkFBa0IsRUFBQyxVQUFTLEdBQWlCLEtBQTBCO0FBQzlFLFVBQUksSUFBSSxTQUFTLENBQUMsVUFBVTtBQUFRLGNBQU0sSUFBSSxNQUFNLDhCQUE4QjtJQUNwRjtBQUVBLGFBQVMsV0FBVyxLQUFjLFNBQWlCLFFBQWlDO0FBQ2xGLFVBQUksV0FBVztBQUFXLGNBQU0sSUFBSSxNQUFNLFlBQVksNEJBQTRCO0FBQ2xGLGFBQU8sSUFBSSxXQUNULFdBQ0EsT0FBTyxVQUFVLGFBQWEsRUFBQyxLQUFLLE9BQU0sSUFBSSxFQUFDLEtBQUssUUFBUSxPQUFNLEdBQUEsVUFBQSxXQUFVLE1BQU0sRUFBQyxDQUFDO0lBRXhGO0FBRUEsYUFBZ0IsZ0JBQ2QsUUFDQSxZQUNBLGlCQUFpQixPQUFLO0FBR3RCLGFBQ0UsQ0FBQyxXQUFXLFVBQ1osV0FBVyxLQUFLLENBQUMsT0FDZixPQUFPLFVBQ0gsTUFBTSxRQUFRLE1BQU0sSUFDcEIsT0FBTyxXQUNQLFVBQVUsT0FBTyxVQUFVLFlBQVksQ0FBQyxNQUFNLFFBQVEsTUFBTSxJQUM1RCxPQUFPLFVBQVUsTUFBTyxrQkFBa0IsT0FBTyxVQUFVLFdBQVk7SUFHakY7QUFoQkEsWUFBQSxrQkFBQTtBQWtCQSxhQUFnQixxQkFDZCxFQUFDLFFBQVEsTUFBTSxNQUFBQyxPQUFNLGNBQWEsR0FDbEMsS0FDQSxTQUFlO0FBR2YsVUFBSSxNQUFNLFFBQVEsSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLFFBQVEsU0FBUyxPQUFPLElBQUksSUFBSSxZQUFZLFNBQVM7QUFDekYsY0FBTSxJQUFJLE1BQU0sMEJBQTBCOztBQUc1QyxZQUFNLE9BQU8sSUFBSTtBQUNqQixVQUFJLFNBQUksUUFBSixTQUFJLFNBQUEsU0FBSixLQUFNLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxVQUFVLGVBQWUsS0FBSyxRQUFRLEdBQUcsQ0FBQyxHQUFHO0FBQzNFLGNBQU0sSUFBSSxNQUFNLDJDQUEyQyxZQUFZLEtBQUssS0FBSyxHQUFHLEdBQUc7O0FBR3pGLFVBQUksSUFBSSxnQkFBZ0I7QUFDdEIsY0FBTSxRQUFRLElBQUksZUFBZSxPQUFPLE9BQU8sQ0FBQztBQUNoRCxZQUFJLENBQUMsT0FBTztBQUNWLGdCQUFNLE1BQ0osWUFBWSxzQ0FBc0MscUJBQ2xEQSxNQUFLLFdBQVcsSUFBSSxlQUFlLE1BQU07QUFDM0MsY0FBSSxLQUFLLG1CQUFtQjtBQUFPLFlBQUFBLE1BQUssT0FBTyxNQUFNLEdBQUc7O0FBQ25ELGtCQUFNLElBQUksTUFBTSxHQUFHOzs7SUFHOUI7QUF6QkEsWUFBQSx1QkFBQTs7Ozs7Ozs7OztBQy9JQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUE2Q0EsYUFBZ0IsYUFDZCxJQUNBLEVBQUMsU0FBUyxZQUFZLFFBQVEsWUFBWSxlQUFlLGFBQVksR0FBZ0I7QUFFckYsVUFBSSxZQUFZLFVBQWEsV0FBVyxRQUFXO0FBQ2pELGNBQU0sSUFBSSxNQUFNLHNEQUFzRDs7QUFHeEUsVUFBSSxZQUFZLFFBQVc7QUFDekIsY0FBTSxNQUFNLEdBQUcsT0FBTyxPQUFPO0FBQzdCLGVBQU8sZUFBZSxTQUNsQjtVQUNFLFFBQVE7VUFDUixhQUFZLEdBQUEsVUFBQSxLQUFJLEdBQUcsY0FBYSxHQUFBLFVBQUEsYUFBWSxPQUFPO1VBQ25ELGVBQWUsR0FBRyxHQUFHLGlCQUFpQjtZQUV4QztVQUNFLFFBQVEsSUFBSSxVQUFVO1VBQ3RCLGFBQVksR0FBQSxVQUFBLEtBQUksR0FBRyxjQUFhLEdBQUEsVUFBQSxhQUFZLE9BQU8sS0FBSSxHQUFBLFVBQUEsYUFBWSxVQUFVO1VBQzdFLGVBQWUsR0FBRyxHQUFHLGlCQUFpQixZQUFXLEdBQUEsT0FBQSxnQkFBZSxVQUFVOzs7QUFJbEYsVUFBSSxXQUFXLFFBQVc7QUFDeEIsWUFBSSxlQUFlLFVBQWEsa0JBQWtCLFVBQWEsaUJBQWlCLFFBQVc7QUFDekYsZ0JBQU0sSUFBSSxNQUFNLDZFQUE2RTs7QUFFL0YsZUFBTztVQUNMO1VBQ0E7VUFDQTtVQUNBOzs7QUFJSixZQUFNLElBQUksTUFBTSw2Q0FBNkM7SUFDL0Q7QUFwQ0EsWUFBQSxlQUFBO0FBc0NBLGFBQWdCLG9CQUNkLFdBQ0EsSUFDQSxFQUFDLFVBQVUsY0FBYyxRQUFRLE1BQU0sV0FBVyxhQUFZLEdBQWdCO0FBRTlFLFVBQUksU0FBUyxVQUFhLGFBQWEsUUFBVztBQUNoRCxjQUFNLElBQUksTUFBTSxxREFBcUQ7O0FBR3ZFLFlBQU0sRUFBQyxJQUFHLElBQUk7QUFFZCxVQUFJLGFBQWEsUUFBVztBQUMxQixjQUFNLEVBQUMsV0FBVyxhQUFhLEtBQUksSUFBSTtBQUN2QyxjQUFNLFdBQVcsSUFBSSxJQUFJLFNBQVEsR0FBQSxVQUFBLEtBQUksR0FBRyxRQUFPLEdBQUEsVUFBQSxhQUFZLFFBQVEsS0FBSyxJQUFJO0FBQzVFLHlCQUFpQixRQUFRO0FBQ3pCLGtCQUFVLGFBQVksR0FBQSxVQUFBLE9BQU0sYUFBWSxHQUFBLE9BQUEsY0FBYSxVQUFVLFFBQVEsS0FBSyxnQkFBZ0I7QUFDNUYsa0JBQVUsc0JBQXFCLEdBQUEsVUFBQSxLQUFJO0FBQ25DLGtCQUFVLGNBQWMsQ0FBQyxHQUFHLGFBQWEsVUFBVSxrQkFBa0I7O0FBR3ZFLFVBQUksU0FBUyxRQUFXO0FBQ3RCLGNBQU0sV0FBVyxnQkFBZ0IsVUFBQSxPQUFPLE9BQU8sSUFBSSxJQUFJLFFBQVEsTUFBTSxJQUFJO0FBQ3pFLHlCQUFpQixRQUFRO0FBQ3pCLFlBQUksaUJBQWlCO0FBQVcsb0JBQVUsZUFBZTs7QUFJM0QsVUFBSTtBQUFXLGtCQUFVLFlBQVk7QUFFckMsZUFBUyxpQkFBaUIsV0FBZTtBQUN2QyxrQkFBVSxPQUFPO0FBQ2pCLGtCQUFVLFlBQVksR0FBRyxZQUFZO0FBQ3JDLGtCQUFVLFlBQVksQ0FBQTtBQUN0QixXQUFHLG9CQUFvQixvQkFBSSxJQUFHO0FBQzlCLGtCQUFVLGFBQWEsR0FBRztBQUMxQixrQkFBVSxZQUFZLENBQUMsR0FBRyxHQUFHLFdBQVcsU0FBUztNQUNuRDtJQUNGO0FBckNBLFlBQUEsc0JBQUE7QUF1Q0EsYUFBZ0Isb0JBQ2QsV0FDQSxFQUFDLGtCQUFrQixhQUFhLGVBQWUsY0FBYyxVQUFTLEdBQWdCO0FBRXRGLFVBQUksa0JBQWtCO0FBQVcsa0JBQVUsZ0JBQWdCO0FBQzNELFVBQUksaUJBQWlCO0FBQVcsa0JBQVUsZUFBZTtBQUN6RCxVQUFJLGNBQWM7QUFBVyxrQkFBVSxZQUFZO0FBQ25ELGdCQUFVLG1CQUFtQjtBQUM3QixnQkFBVSxjQUFjO0lBQzFCO0FBVEEsWUFBQSxzQkFBQTs7Ozs7QUM3SEE7QUFBQSxtREFBQUMsU0FBQTtBQUFBO0FBTUEsSUFBQUEsUUFBTyxVQUFVLFNBQVMsTUFBTSxHQUFHLEdBQUc7QUFDcEMsVUFBSSxNQUFNO0FBQUcsZUFBTztBQUVwQixVQUFJLEtBQUssS0FBSyxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVTtBQUMxRCxZQUFJLEVBQUUsZ0JBQWdCLEVBQUU7QUFBYSxpQkFBTztBQUU1QyxZQUFJLFFBQVEsR0FBRztBQUNmLFlBQUksTUFBTSxRQUFRLENBQUMsR0FBRztBQUNwQixtQkFBUyxFQUFFO0FBQ1gsY0FBSSxVQUFVLEVBQUU7QUFBUSxtQkFBTztBQUMvQixlQUFLLElBQUksUUFBUSxRQUFRO0FBQ3ZCLGdCQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUFHLHFCQUFPO0FBQ2pDLGlCQUFPO0FBQUEsUUFDVDtBQUlBLFlBQUksRUFBRSxnQkFBZ0I7QUFBUSxpQkFBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQzVFLFlBQUksRUFBRSxZQUFZLE9BQU8sVUFBVTtBQUFTLGlCQUFPLEVBQUUsUUFBUSxNQUFNLEVBQUUsUUFBUTtBQUM3RSxZQUFJLEVBQUUsYUFBYSxPQUFPLFVBQVU7QUFBVSxpQkFBTyxFQUFFLFNBQVMsTUFBTSxFQUFFLFNBQVM7QUFFakYsZUFBTyxPQUFPLEtBQUssQ0FBQztBQUNwQixpQkFBUyxLQUFLO0FBQ2QsWUFBSSxXQUFXLE9BQU8sS0FBSyxDQUFDLEVBQUU7QUFBUSxpQkFBTztBQUU3QyxhQUFLLElBQUksUUFBUSxRQUFRO0FBQ3ZCLGNBQUksQ0FBQyxPQUFPLFVBQVUsZUFBZSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFBRyxtQkFBTztBQUVoRSxhQUFLLElBQUksUUFBUSxRQUFRLEtBQUk7QUFDM0IsY0FBSSxNQUFNLEtBQUssQ0FBQztBQUVoQixjQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUFHLG1CQUFPO0FBQUEsUUFDckM7QUFFQSxlQUFPO0FBQUEsTUFDVDtBQUdBLGFBQU8sTUFBSSxLQUFLLE1BQUk7QUFBQSxJQUN0QjtBQUFBO0FBQUE7OztBQzdDQTtBQUFBLGlHQUFBQyxTQUFBO0FBQUE7QUFFQSxRQUFJLFdBQVdBLFFBQU8sVUFBVSxTQUFVLFFBQVEsTUFBTSxJQUFJO0FBRTFELFVBQUksT0FBTyxRQUFRLFlBQVk7QUFDN0IsYUFBSztBQUNMLGVBQU8sQ0FBQztBQUFBLE1BQ1Y7QUFFQSxXQUFLLEtBQUssTUFBTTtBQUNoQixVQUFJLE1BQU8sT0FBTyxNQUFNLGFBQWMsS0FBSyxHQUFHLE9BQU8sV0FBVztBQUFBLE1BQUM7QUFDakUsVUFBSSxPQUFPLEdBQUcsUUFBUSxXQUFXO0FBQUEsTUFBQztBQUVsQyxnQkFBVSxNQUFNLEtBQUssTUFBTSxRQUFRLElBQUksTUFBTTtBQUFBLElBQy9DO0FBR0EsYUFBUyxXQUFXO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsT0FBTztBQUFBLE1BQ1AsVUFBVTtBQUFBLE1BQ1Ysc0JBQXNCO0FBQUEsTUFDdEIsZUFBZTtBQUFBLE1BQ2YsS0FBSztBQUFBLE1BQ0wsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLElBQ1I7QUFFQSxhQUFTLGdCQUFnQjtBQUFBLE1BQ3ZCLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxnQkFBZ0I7QUFBQSxNQUN2QixPQUFPO0FBQUEsTUFDUCxhQUFhO0FBQUEsTUFDYixZQUFZO0FBQUEsTUFDWixtQkFBbUI7QUFBQSxNQUNuQixjQUFjO0FBQUEsSUFDaEI7QUFFQSxhQUFTLGVBQWU7QUFBQSxNQUN0QixTQUFTO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxrQkFBa0I7QUFBQSxNQUNsQixrQkFBa0I7QUFBQSxNQUNsQixZQUFZO0FBQUEsTUFDWixXQUFXO0FBQUEsTUFDWCxXQUFXO0FBQUEsTUFDWCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsTUFDYixlQUFlO0FBQUEsTUFDZixlQUFlO0FBQUEsSUFDakI7QUFHQSxhQUFTLFVBQVUsTUFBTSxLQUFLLE1BQU0sUUFBUSxTQUFTLFlBQVksZUFBZSxlQUFlLGNBQWMsVUFBVTtBQUNySCxVQUFJLFVBQVUsT0FBTyxVQUFVLFlBQVksQ0FBQyxNQUFNLFFBQVEsTUFBTSxHQUFHO0FBQ2pFLFlBQUksUUFBUSxTQUFTLFlBQVksZUFBZSxlQUFlLGNBQWMsUUFBUTtBQUNyRixpQkFBUyxPQUFPLFFBQVE7QUFDdEIsY0FBSSxNQUFNLE9BQU8sR0FBRztBQUNwQixjQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDdEIsZ0JBQUksT0FBTyxTQUFTLGVBQWU7QUFDakMsdUJBQVMsSUFBRSxHQUFHLElBQUUsSUFBSSxRQUFRO0FBQzFCLDBCQUFVLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQyxHQUFHLFVBQVUsTUFBTSxNQUFNLE1BQU0sR0FBRyxZQUFZLFNBQVMsS0FBSyxRQUFRLENBQUM7QUFBQSxZQUN6RztBQUFBLFVBQ0YsV0FBVyxPQUFPLFNBQVMsZUFBZTtBQUN4QyxnQkFBSSxPQUFPLE9BQU8sT0FBTyxVQUFVO0FBQ2pDLHVCQUFTLFFBQVE7QUFDZiwwQkFBVSxNQUFNLEtBQUssTUFBTSxJQUFJLElBQUksR0FBRyxVQUFVLE1BQU0sTUFBTSxNQUFNLGNBQWMsSUFBSSxHQUFHLFlBQVksU0FBUyxLQUFLLFFBQVEsSUFBSTtBQUFBLFlBQ2pJO0FBQUEsVUFDRixXQUFXLE9BQU8sU0FBUyxZQUFhLEtBQUssV0FBVyxFQUFFLE9BQU8sU0FBUyxlQUFnQjtBQUN4RixzQkFBVSxNQUFNLEtBQUssTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLFlBQVksU0FBUyxLQUFLLE1BQU07QUFBQSxVQUN2RjtBQUFBLFFBQ0Y7QUFDQSxhQUFLLFFBQVEsU0FBUyxZQUFZLGVBQWUsZUFBZSxjQUFjLFFBQVE7QUFBQSxNQUN4RjtBQUFBLElBQ0Y7QUFHQSxhQUFTLGNBQWMsS0FBSztBQUMxQixhQUFPLElBQUksUUFBUSxNQUFNLElBQUksRUFBRSxRQUFRLE9BQU8sSUFBSTtBQUFBLElBQ3BEO0FBQUE7QUFBQTs7Ozs7Ozs7QUN6RkEsUUFBQSxTQUFBO0FBQ0EsUUFBQSxRQUFBO0FBQ0EsUUFBQSxXQUFBO0FBTUEsUUFBTSxpQkFBaUIsb0JBQUksSUFBSTtNQUM3QjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtLQUNEO0FBRUQsYUFBZ0IsVUFBVSxRQUFtQixRQUEwQixNQUFJO0FBQ3pFLFVBQUksT0FBTyxVQUFVO0FBQVcsZUFBTztBQUN2QyxVQUFJLFVBQVU7QUFBTSxlQUFPLENBQUMsT0FBTyxNQUFNO0FBQ3pDLFVBQUksQ0FBQztBQUFPLGVBQU87QUFDbkIsYUFBTyxVQUFVLE1BQU0sS0FBSztJQUM5QjtBQUxBLFlBQUEsWUFBQTtBQU9BLFFBQU0sZUFBZSxvQkFBSSxJQUFJO01BQzNCO01BQ0E7TUFDQTtNQUNBO01BQ0E7S0FDRDtBQUVELGFBQVMsT0FBTyxRQUF1QjtBQUNyQyxpQkFBVyxPQUFPLFFBQVE7QUFDeEIsWUFBSSxhQUFhLElBQUksR0FBRztBQUFHLGlCQUFPO0FBQ2xDLGNBQU0sTUFBTSxPQUFPLEdBQUc7QUFDdEIsWUFBSSxNQUFNLFFBQVEsR0FBRyxLQUFLLElBQUksS0FBSyxNQUFNO0FBQUcsaUJBQU87QUFDbkQsWUFBSSxPQUFPLE9BQU8sWUFBWSxPQUFPLEdBQUc7QUFBRyxpQkFBTzs7QUFFcEQsYUFBTztJQUNUO0FBRUEsYUFBUyxVQUFVLFFBQXVCO0FBQ3hDLFVBQUksUUFBUTtBQUNaLGlCQUFXLE9BQU8sUUFBUTtBQUN4QixZQUFJLFFBQVE7QUFBUSxpQkFBTztBQUMzQjtBQUNBLFlBQUksZUFBZSxJQUFJLEdBQUc7QUFBRztBQUM3QixZQUFJLE9BQU8sT0FBTyxHQUFHLEtBQUssVUFBVTtBQUNsQyxXQUFBLEdBQUEsT0FBQSxVQUFTLE9BQU8sR0FBRyxHQUFHLENBQUMsUUFBUyxTQUFTLFVBQVUsR0FBRyxDQUFFOztBQUUxRCxZQUFJLFVBQVU7QUFBVSxpQkFBTzs7QUFFakMsYUFBTztJQUNUO0FBRUEsYUFBZ0IsWUFBWSxVQUF1QixLQUFLLElBQUksV0FBbUI7QUFDN0UsVUFBSSxjQUFjO0FBQU8sYUFBSyxZQUFZLEVBQUU7QUFDNUMsWUFBTSxJQUFJLFNBQVMsTUFBTSxFQUFFO0FBQzNCLGFBQU8sYUFBYSxVQUFVLENBQUM7SUFDakM7QUFKQSxZQUFBLGNBQUE7QUFNQSxhQUFnQixhQUFhLFVBQXVCLEdBQWdCO0FBQ2xFLFlBQU0sYUFBYSxTQUFTLFVBQVUsQ0FBQztBQUN2QyxhQUFPLFdBQVcsTUFBTSxHQUFHLEVBQUUsQ0FBQyxJQUFJO0lBQ3BDO0FBSEEsWUFBQSxlQUFBO0FBS0EsUUFBTSxzQkFBc0I7QUFDNUIsYUFBZ0IsWUFBWSxJQUFzQjtBQUNoRCxhQUFPLEtBQUssR0FBRyxRQUFRLHFCQUFxQixFQUFFLElBQUk7SUFDcEQ7QUFGQSxZQUFBLGNBQUE7QUFJQSxhQUFnQixXQUFXLFVBQXVCLFFBQWdCLElBQVU7QUFDMUUsV0FBSyxZQUFZLEVBQUU7QUFDbkIsYUFBTyxTQUFTLFFBQVEsUUFBUSxFQUFFO0lBQ3BDO0FBSEEsWUFBQSxhQUFBO0FBS0EsUUFBTSxTQUFTO0FBRWYsYUFBZ0IsY0FBeUIsUUFBbUIsUUFBYztBQUN4RSxVQUFJLE9BQU8sVUFBVTtBQUFXLGVBQU8sQ0FBQTtBQUN2QyxZQUFNLEVBQUMsVUFBVSxZQUFXLElBQUksS0FBSztBQUNyQyxZQUFNLFFBQVEsWUFBWSxPQUFPLFFBQVEsS0FBSyxNQUFNO0FBQ3BELFlBQU0sVUFBMEMsRUFBQyxJQUFJLE1BQUs7QUFDMUQsWUFBTSxhQUFhLFlBQVksYUFBYSxPQUFPLEtBQUs7QUFDeEQsWUFBTSxZQUF1QixDQUFBO0FBQzdCLFlBQU0sYUFBMEIsb0JBQUksSUFBRztBQUV2QyxlQUFTLFFBQVEsRUFBQyxTQUFTLEtBQUksR0FBRyxDQUFDLEtBQUssU0FBUyxHQUFHLGtCQUFpQjtBQUNuRSxZQUFJLGtCQUFrQjtBQUFXO0FBQ2pDLGNBQU0sV0FBVyxhQUFhO0FBQzlCLFlBQUlDLFVBQVMsUUFBUSxhQUFhO0FBQ2xDLFlBQUksT0FBTyxJQUFJLFFBQVEsS0FBSztBQUFVLFVBQUFBLFVBQVMsT0FBTyxLQUFLLE1BQU0sSUFBSSxRQUFRLENBQUM7QUFDOUUsa0JBQVUsS0FBSyxNQUFNLElBQUksT0FBTztBQUNoQyxrQkFBVSxLQUFLLE1BQU0sSUFBSSxjQUFjO0FBQ3ZDLGdCQUFRLE9BQU8sSUFBSUE7QUFFbkIsaUJBQVMsT0FBa0IsS0FBVztBQUVwQyxnQkFBTSxXQUFXLEtBQUssS0FBSyxZQUFZO0FBQ3ZDLGdCQUFNLFlBQVlBLFVBQVMsU0FBU0EsU0FBUSxHQUFHLElBQUksR0FBRztBQUN0RCxjQUFJLFdBQVcsSUFBSSxHQUFHO0FBQUcsa0JBQU0sU0FBUyxHQUFHO0FBQzNDLHFCQUFXLElBQUksR0FBRztBQUNsQixjQUFJLFdBQVcsS0FBSyxLQUFLLEdBQUc7QUFDNUIsY0FBSSxPQUFPLFlBQVk7QUFBVSx1QkFBVyxLQUFLLEtBQUssUUFBUTtBQUM5RCxjQUFJLE9BQU8sWUFBWSxVQUFVO0FBQy9CLDZCQUFpQixLQUFLLFNBQVMsUUFBUSxHQUFHO3FCQUNqQyxRQUFRLFlBQVksUUFBUSxHQUFHO0FBQ3hDLGdCQUFJLElBQUksQ0FBQyxNQUFNLEtBQUs7QUFDbEIsK0JBQWlCLEtBQUssVUFBVSxHQUFHLEdBQUcsR0FBRztBQUN6Qyx3QkFBVSxHQUFHLElBQUk7bUJBQ1o7QUFDTCxtQkFBSyxLQUFLLEdBQUcsSUFBSTs7O0FBR3JCLGlCQUFPO1FBQ1Q7QUFFQSxpQkFBUyxVQUFxQixRQUFlO0FBQzNDLGNBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0IsZ0JBQUksQ0FBQyxPQUFPLEtBQUssTUFBTTtBQUFHLG9CQUFNLElBQUksTUFBTSxtQkFBbUIsU0FBUztBQUN0RSxtQkFBTyxLQUFLLE1BQU0sSUFBSSxRQUFROztRQUVsQztNQUNGLENBQUM7QUFFRCxhQUFPO0FBRVAsZUFBUyxpQkFBaUIsTUFBaUIsTUFBNkIsS0FBVztBQUNqRixZQUFJLFNBQVMsVUFBYSxDQUFDLE1BQU0sTUFBTSxJQUFJO0FBQUcsZ0JBQU0sU0FBUyxHQUFHO01BQ2xFO0FBRUEsZUFBUyxTQUFTLEtBQVc7QUFDM0IsZUFBTyxJQUFJLE1BQU0sY0FBYyx1Q0FBdUM7TUFDeEU7SUFDRjtBQXhEQSxZQUFBLGdCQUFBOzs7Ozs7Ozs7O0FDbkZBLFFBQUEsZUFBQTtBQUNBLFFBQUEsYUFBQTtBQUNBLFFBQUEsa0JBQUE7QUFDQSxRQUFBLGFBQUE7QUFDQSxRQUFBLGFBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFTQSxRQUFBLFdBQUE7QUFTQSxhQUFnQixxQkFBcUIsSUFBYTtBQUNoRCxVQUFJLFlBQVksRUFBRSxHQUFHO0FBQ25CLHNCQUFjLEVBQUU7QUFDaEIsWUFBSSxrQkFBa0IsRUFBRSxHQUFHO0FBQ3pCLDJCQUFpQixFQUFFO0FBQ25COzs7QUFHSix1QkFBaUIsSUFBSSxPQUFNLEdBQUEsYUFBQSxzQkFBcUIsRUFBRSxDQUFDO0lBQ3JEO0FBVEEsWUFBQSx1QkFBQTtBQVdBLGFBQVMsaUJBQ1AsRUFBQyxLQUFLLGNBQWMsUUFBUSxXQUFXLEtBQUksR0FDM0MsTUFBVztBQUVYLFVBQUksS0FBSyxLQUFLLEtBQUs7QUFDakIsWUFBSSxLQUFLLGVBQWMsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLFNBQVMsUUFBQSxRQUFFLFVBQVUsVUFBVSxRQUFRLE1BQUs7QUFDdkUsY0FBSSxNQUFLLEdBQUEsVUFBQSxtQkFBa0IsY0FBYyxRQUFRLElBQUksR0FBRztBQUN4RCwrQkFBcUIsS0FBSyxJQUFJO0FBQzlCLGNBQUksS0FBSyxJQUFJO1FBQ2YsQ0FBQzthQUNJO0FBQ0wsWUFBSSxLQUFLLGVBQWMsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLFNBQVMsa0JBQWtCLElBQUksS0FBSyxVQUFVLFFBQVEsTUFDakYsSUFBSSxLQUFLLGNBQWMsUUFBUSxJQUFJLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQzs7SUFHdEQ7QUFFQSxhQUFTLGtCQUFrQixNQUFxQjtBQUM5QyxjQUFPLEdBQUEsVUFBQSxNQUFLLFFBQUEsUUFBRSxvQkFBb0IsUUFBQSxRQUFFLGVBQWUsUUFBQSxRQUFFLHVCQUF1QixRQUFBLFFBQUUsWUFDNUUsUUFBQSxRQUFFLE9BQ0QsS0FBSyxjQUFhLEdBQUEsVUFBQSxPQUFNLFFBQUEsUUFBRSxzQkFBc0IsVUFBQTtJQUNyRDtBQUVBLGFBQVMscUJBQXFCLEtBQWMsTUFBcUI7QUFDL0QsVUFBSSxHQUNGLFFBQUEsUUFBRSxRQUNGLE1BQUs7QUFDSCxZQUFJLElBQUksUUFBQSxRQUFFLGVBQWMsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLFVBQVUsUUFBQSxRQUFFLGNBQWM7QUFDeEQsWUFBSSxJQUFJLFFBQUEsUUFBRSxhQUFZLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxVQUFVLFFBQUEsUUFBRSxZQUFZO0FBQ3BELFlBQUksSUFBSSxRQUFBLFFBQUUscUJBQW9CLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxVQUFVLFFBQUEsUUFBRSxvQkFBb0I7QUFDcEUsWUFBSSxJQUFJLFFBQUEsUUFBRSxXQUFVLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxVQUFVLFFBQUEsUUFBRSxVQUFVO0FBQ2hELFlBQUksS0FBSztBQUFZLGNBQUksSUFBSSxRQUFBLFFBQUUsaUJBQWdCLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxVQUFVLFFBQUEsUUFBRSxnQkFBZ0I7TUFDbkYsR0FDQSxNQUFLO0FBQ0gsWUFBSSxJQUFJLFFBQUEsUUFBRSxlQUFjLEdBQUEsVUFBQSxNQUFLO0FBQzdCLFlBQUksSUFBSSxRQUFBLFFBQUUsYUFBWSxHQUFBLFVBQUEsYUFBWTtBQUNsQyxZQUFJLElBQUksUUFBQSxRQUFFLHFCQUFvQixHQUFBLFVBQUEsYUFBWTtBQUMxQyxZQUFJLElBQUksUUFBQSxRQUFFLFVBQVUsUUFBQSxRQUFFLElBQUk7QUFDMUIsWUFBSSxLQUFLO0FBQVksY0FBSSxJQUFJLFFBQUEsUUFBRSxpQkFBZ0IsR0FBQSxVQUFBLE1BQUs7TUFDdEQsQ0FBQztJQUVMO0FBRUEsYUFBUyxpQkFBaUIsSUFBZ0I7QUFDeEMsWUFBTSxFQUFDLFFBQVEsTUFBTSxJQUFHLElBQUk7QUFDNUIsdUJBQWlCLElBQUksTUFBSztBQUN4QixZQUFJLEtBQUssWUFBWSxPQUFPO0FBQVUseUJBQWUsRUFBRTtBQUN2RCx1QkFBZSxFQUFFO0FBQ2pCLFlBQUksSUFBSSxRQUFBLFFBQUUsU0FBUyxJQUFJO0FBQ3ZCLFlBQUksSUFBSSxRQUFBLFFBQUUsUUFBUSxDQUFDO0FBQ25CLFlBQUksS0FBSztBQUFhLHlCQUFlLEVBQUU7QUFDdkMsd0JBQWdCLEVBQUU7QUFDbEIsc0JBQWMsRUFBRTtNQUNsQixDQUFDO0FBQ0Q7SUFDRjtBQUVBLGFBQVMsZUFBZSxJQUFnQjtBQUV0QyxZQUFNLEVBQUMsS0FBSyxhQUFZLElBQUk7QUFDNUIsU0FBRyxZQUFZLElBQUksTUFBTSxjQUFhLEdBQUEsVUFBQSxLQUFJLHdCQUF3QjtBQUNsRSxVQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksR0FBRywwQkFBMEIsTUFBTSxJQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksR0FBRyxvQkFBbUIsR0FBQSxVQUFBLGFBQVksQ0FBQztBQUNoRyxVQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksR0FBRywwQkFBMEIsTUFBTSxJQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksR0FBRyxvQkFBbUIsR0FBQSxVQUFBLGFBQVksQ0FBQztJQUNsRztBQUVBLGFBQVMsY0FBYyxRQUFtQixNQUFxQjtBQUM3RCxZQUFNLFFBQVEsT0FBTyxVQUFVLFlBQVksT0FBTyxLQUFLLFFBQVE7QUFDL0QsYUFBTyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFXLEdBQUEsVUFBQSxtQkFBa0IsYUFBYSxVQUFBO0lBQzNGO0FBR0EsYUFBUyxjQUFjLElBQWUsT0FBVztBQUMvQyxVQUFJLFlBQVksRUFBRSxHQUFHO0FBQ25CLHNCQUFjLEVBQUU7QUFDaEIsWUFBSSxrQkFBa0IsRUFBRSxHQUFHO0FBQ3pCLDJCQUFpQixJQUFJLEtBQUs7QUFDMUI7OztBQUdKLE9BQUEsR0FBQSxhQUFBLG1CQUFrQixJQUFJLEtBQUs7SUFDN0I7QUFFQSxhQUFTLGtCQUFrQixFQUFDLFFBQVEsTUFBQUMsTUFBSSxHQUFZO0FBQ2xELFVBQUksT0FBTyxVQUFVO0FBQVcsZUFBTyxDQUFDO0FBQ3hDLGlCQUFXLE9BQU87QUFBUSxZQUFJQSxNQUFLLE1BQU0sSUFBSSxHQUFHO0FBQUcsaUJBQU87QUFDMUQsYUFBTztJQUNUO0FBRUEsYUFBUyxZQUFZLElBQWE7QUFDaEMsYUFBTyxPQUFPLEdBQUcsVUFBVTtJQUM3QjtBQUVBLGFBQVMsaUJBQWlCLElBQWtCLE9BQVc7QUFDckQsWUFBTSxFQUFDLFFBQVEsS0FBSyxLQUFJLElBQUk7QUFDNUIsVUFBSSxLQUFLLFlBQVksT0FBTztBQUFVLHVCQUFlLEVBQUU7QUFDdkQsb0JBQWMsRUFBRTtBQUNoQix1QkFBaUIsRUFBRTtBQUNuQixZQUFNLFlBQVksSUFBSSxNQUFNLFNBQVMsUUFBQSxRQUFFLE1BQU07QUFDN0Msc0JBQWdCLElBQUksU0FBUztBQUU3QixVQUFJLElBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSxpQkFBaUIsUUFBQSxRQUFFLFFBQVE7SUFDaEQ7QUFFQSxhQUFTLGNBQWMsSUFBZ0I7QUFDckMsT0FBQSxHQUFBLE9BQUEsbUJBQWtCLEVBQUU7QUFDcEIsMkJBQXFCLEVBQUU7SUFDekI7QUFFQSxhQUFTLGdCQUFnQixJQUFrQixXQUFnQjtBQUN6RCxVQUFJLEdBQUcsS0FBSztBQUFLLGVBQU8sZUFBZSxJQUFJLENBQUEsR0FBSSxPQUFPLFNBQVM7QUFDL0QsWUFBTSxTQUFRLEdBQUEsV0FBQSxnQkFBZSxHQUFHLE1BQU07QUFDdEMsWUFBTSxnQkFBZSxHQUFBLFdBQUEsd0JBQXVCLElBQUksS0FBSztBQUNyRCxxQkFBZSxJQUFJLE9BQU8sQ0FBQyxjQUFjLFNBQVM7SUFDcEQ7QUFFQSxhQUFTLHFCQUFxQixJQUFnQjtBQUM1QyxZQUFNLEVBQUMsUUFBUSxlQUFlLE1BQU0sTUFBQUEsTUFBSSxJQUFJO0FBQzVDLFVBQUksT0FBTyxRQUFRLEtBQUssMEJBQXlCLEdBQUEsT0FBQSxzQkFBcUIsUUFBUUEsTUFBSyxLQUFLLEdBQUc7QUFDekYsUUFBQUEsTUFBSyxPQUFPLEtBQUssNkNBQTZDLGdCQUFnQjs7SUFFbEY7QUFFQSxhQUFTLGVBQWUsSUFBZ0I7QUFDdEMsWUFBTSxFQUFDLFFBQVEsS0FBSSxJQUFJO0FBQ3ZCLFVBQUksT0FBTyxZQUFZLFVBQWEsS0FBSyxlQUFlLEtBQUssY0FBYztBQUN6RSxTQUFBLEdBQUEsT0FBQSxpQkFBZ0IsSUFBSSx1Q0FBdUM7O0lBRS9EO0FBRUEsYUFBUyxjQUFjLElBQWdCO0FBQ3JDLFlBQU0sUUFBUSxHQUFHLE9BQU8sR0FBRyxLQUFLLFFBQVE7QUFDeEMsVUFBSTtBQUFPLFdBQUcsVUFBUyxHQUFBLFVBQUEsWUFBVyxHQUFHLEtBQUssYUFBYSxHQUFHLFFBQVEsS0FBSztJQUN6RTtBQUVBLGFBQVMsaUJBQWlCLElBQWdCO0FBQ3hDLFVBQUksR0FBRyxPQUFPLFVBQVUsQ0FBQyxHQUFHLFVBQVU7QUFBUSxjQUFNLElBQUksTUFBTSw2QkFBNkI7SUFDN0Y7QUFFQSxhQUFTLGVBQWUsRUFBQyxLQUFLLFdBQVcsUUFBUSxlQUFlLEtBQUksR0FBZTtBQUNqRixZQUFNLE1BQU0sT0FBTztBQUNuQixVQUFJLEtBQUssYUFBYSxNQUFNO0FBQzFCLFlBQUksTUFBSyxHQUFBLFVBQUEsS0FBSSxRQUFBLFFBQUUsbUJBQW1CLE1BQU07aUJBQy9CLE9BQU8sS0FBSyxZQUFZLFlBQVk7QUFDN0MsY0FBTSxjQUFhLEdBQUEsVUFBQSxPQUFNO0FBQ3pCLGNBQU0sV0FBVyxJQUFJLFdBQVcsUUFBUSxFQUFDLEtBQUssVUFBVSxLQUFJLENBQUM7QUFDN0QsWUFBSSxNQUFLLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxzQkFBc0IsUUFBUSxlQUFlLGtCQUFrQjs7SUFFbEY7QUFFQSxhQUFTLGNBQWMsSUFBYTtBQUNsQyxZQUFNLEVBQUMsS0FBSyxXQUFXLGNBQWMsaUJBQWlCLEtBQUksSUFBSTtBQUM5RCxVQUFJLFVBQVUsUUFBUTtBQUVwQixZQUFJLElBQ0YsR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLGdCQUNOLE1BQU0sSUFBSSxPQUFPLFFBQUEsUUFBRSxJQUFJLEdBQ3ZCLE1BQU0sSUFBSSxPQUFNLEdBQUEsVUFBQSxTQUFRLG1CQUEyQixRQUFBLFFBQUUsVUFBVSxDQUFDO2FBRTdEO0FBQ0wsWUFBSSxRQUFPLEdBQUEsVUFBQSxLQUFJLHVCQUF1QixRQUFBLFFBQUUsT0FBTztBQUMvQyxZQUFJLEtBQUs7QUFBYSwwQkFBZ0IsRUFBRTtBQUN4QyxZQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksUUFBQSxRQUFFLGNBQWM7O0lBRW5DO0FBRUEsYUFBUyxnQkFBZ0IsRUFBQyxLQUFLLFdBQVcsT0FBTyxNQUFLLEdBQVk7QUFDaEUsVUFBSSxpQkFBaUIsVUFBQTtBQUFNLFlBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSxtQkFBbUIsS0FBSztBQUNsRSxVQUFJLGlCQUFpQixVQUFBO0FBQU0sWUFBSSxRQUFPLEdBQUEsVUFBQSxLQUFJLG1CQUFtQixLQUFLO0lBQ3BFO0FBRUEsYUFBUyxlQUNQLElBQ0EsT0FDQSxZQUNBLFdBQWdCO0FBRWhCLFlBQU0sRUFBQyxLQUFLLFFBQVEsTUFBTSxXQUFXLE1BQU0sTUFBQUEsTUFBSSxJQUFJO0FBQ25ELFlBQU0sRUFBQyxNQUFLLElBQUlBO0FBQ2hCLFVBQUksT0FBTyxTQUFTLEtBQUsseUJBQXlCLEVBQUMsR0FBQSxPQUFBLHNCQUFxQixRQUFRLEtBQUssSUFBSTtBQUN2RixZQUFJLE1BQU0sTUFBTSxZQUFZLElBQUksUUFBUyxNQUFNLElBQUksS0FBYyxVQUFVLENBQUM7QUFDNUU7O0FBRUYsVUFBSSxDQUFDLEtBQUs7QUFBSyx5QkFBaUIsSUFBSSxLQUFLO0FBQ3pDLFVBQUksTUFBTSxNQUFLO0FBQ2IsbUJBQVcsU0FBUyxNQUFNO0FBQU8sd0JBQWMsS0FBSztBQUNwRCxzQkFBYyxNQUFNLElBQUk7TUFDMUIsQ0FBQztBQUVELGVBQVMsY0FBYyxPQUFnQjtBQUNyQyxZQUFJLEVBQUMsR0FBQSxnQkFBQSxnQkFBZSxRQUFRLEtBQUs7QUFBRztBQUNwQyxZQUFJLE1BQU0sTUFBTTtBQUNkLGNBQUksSUFBRyxHQUFBLFdBQUEsZUFBYyxNQUFNLE1BQU0sTUFBTSxLQUFLLGFBQWEsQ0FBQztBQUMxRCwwQkFBZ0IsSUFBSSxLQUFLO0FBQ3pCLGNBQUksTUFBTSxXQUFXLEtBQUssTUFBTSxDQUFDLE1BQU0sTUFBTSxRQUFRLFlBQVk7QUFDL0QsZ0JBQUksS0FBSTtBQUNSLGFBQUEsR0FBQSxXQUFBLGlCQUFnQixFQUFFOztBQUVwQixjQUFJLE1BQUs7ZUFDSjtBQUNMLDBCQUFnQixJQUFJLEtBQUs7O0FBRzNCLFlBQUksQ0FBQztBQUFXLGNBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxRQUFBLFFBQUUsY0FBYyxhQUFhLEdBQUc7TUFDN0Q7SUFDRjtBQUVBLGFBQVMsZ0JBQWdCLElBQWtCLE9BQWdCO0FBQ3pELFlBQU0sRUFDSixLQUNBLFFBQ0EsTUFBTSxFQUFDLFlBQVcsRUFBQyxJQUNqQjtBQUNKLFVBQUk7QUFBYSxTQUFBLEdBQUEsV0FBQSxnQkFBZSxJQUFJLE1BQU0sSUFBSTtBQUM5QyxVQUFJLE1BQU0sTUFBSztBQUNiLG1CQUFXLFFBQVEsTUFBTSxPQUFPO0FBQzlCLGVBQUksR0FBQSxnQkFBQSxlQUFjLFFBQVEsSUFBSSxHQUFHO0FBQy9CLHdCQUFZLElBQUksS0FBSyxTQUFTLEtBQUssWUFBWSxNQUFNLElBQUk7OztNQUcvRCxDQUFDO0lBQ0g7QUFFQSxhQUFTLGlCQUFpQixJQUFrQixPQUFpQjtBQUMzRCxVQUFJLEdBQUcsVUFBVSxRQUFRLENBQUMsR0FBRyxLQUFLO0FBQWE7QUFDL0Msd0JBQWtCLElBQUksS0FBSztBQUMzQixVQUFJLENBQUMsR0FBRyxLQUFLO0FBQWlCLDJCQUFtQixJQUFJLEtBQUs7QUFDMUQsd0JBQWtCLElBQUksR0FBRyxTQUFTO0lBQ3BDO0FBRUEsYUFBUyxrQkFBa0IsSUFBa0IsT0FBaUI7QUFDNUQsVUFBSSxDQUFDLE1BQU07QUFBUTtBQUNuQixVQUFJLENBQUMsR0FBRyxVQUFVLFFBQVE7QUFDeEIsV0FBRyxZQUFZO0FBQ2Y7O0FBRUYsWUFBTSxRQUFRLENBQUMsTUFBSztBQUNsQixZQUFJLENBQUMsYUFBYSxHQUFHLFdBQVcsQ0FBQyxHQUFHO0FBQ2xDLDJCQUFpQixJQUFJLFNBQVMsOEJBQThCLEdBQUcsVUFBVSxLQUFLLEdBQUcsSUFBSTs7TUFFekYsQ0FBQztBQUNELHdCQUFrQixJQUFJLEtBQUs7SUFDN0I7QUFFQSxhQUFTLG1CQUFtQixJQUFrQixJQUFjO0FBQzFELFVBQUksR0FBRyxTQUFTLEtBQUssRUFBRSxHQUFHLFdBQVcsS0FBSyxHQUFHLFNBQVMsTUFBTSxJQUFJO0FBQzlELHlCQUFpQixJQUFJLGlEQUFpRDs7SUFFMUU7QUFFQSxhQUFTLGtCQUFrQixJQUFrQixJQUFjO0FBQ3pELFlBQU0sUUFBUSxHQUFHLEtBQUssTUFBTTtBQUM1QixpQkFBVyxXQUFXLE9BQU87QUFDM0IsY0FBTSxPQUFPLE1BQU0sT0FBTztBQUMxQixZQUFJLE9BQU8sUUFBUSxhQUFZLEdBQUEsZ0JBQUEsZUFBYyxHQUFHLFFBQVEsSUFBSSxHQUFHO0FBQzdELGdCQUFNLEVBQUMsS0FBSSxJQUFJLEtBQUs7QUFDcEIsY0FBSSxLQUFLLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQyxNQUFNLGtCQUFrQixJQUFJLENBQUMsQ0FBQyxHQUFHO0FBQzlELDZCQUFpQixJQUFJLGlCQUFpQixLQUFLLEtBQUssR0FBRyxtQkFBbUIsVUFBVTs7OztJQUl4RjtBQUVBLGFBQVMsa0JBQWtCLE9BQW1CLE1BQWM7QUFDMUQsYUFBTyxNQUFNLFNBQVMsSUFBSSxLQUFNLFNBQVMsWUFBWSxNQUFNLFNBQVMsU0FBUztJQUMvRTtBQUVBLGFBQVMsYUFBYSxJQUFnQixHQUFXO0FBQy9DLGFBQU8sR0FBRyxTQUFTLENBQUMsS0FBTSxNQUFNLGFBQWEsR0FBRyxTQUFTLFFBQVE7SUFDbkU7QUFFQSxhQUFTLGtCQUFrQixJQUFrQixXQUFxQjtBQUNoRSxZQUFNLEtBQWlCLENBQUE7QUFDdkIsaUJBQVcsS0FBSyxHQUFHLFdBQVc7QUFDNUIsWUFBSSxhQUFhLFdBQVcsQ0FBQztBQUFHLGFBQUcsS0FBSyxDQUFDO2lCQUNoQyxVQUFVLFNBQVMsU0FBUyxLQUFLLE1BQU07QUFBVSxhQUFHLEtBQUssU0FBUzs7QUFFN0UsU0FBRyxZQUFZO0lBQ2pCO0FBRUEsYUFBUyxpQkFBaUIsSUFBa0IsS0FBVztBQUNyRCxZQUFNLGFBQWEsR0FBRyxVQUFVLFNBQVMsR0FBRztBQUM1QyxhQUFPLFFBQVE7QUFDZixPQUFBLEdBQUEsT0FBQSxpQkFBZ0IsSUFBSSxLQUFLLEdBQUcsS0FBSyxXQUFXO0lBQzlDO0FBRUEsUUFBYSxhQUFiLE1BQXVCO01BaUJyQixZQUFZLElBQWtCLEtBQTZCLFNBQWU7QUFDeEUsU0FBQSxHQUFBLFVBQUEsc0JBQXFCLElBQUksS0FBSyxPQUFPO0FBQ3JDLGFBQUssTUFBTSxHQUFHO0FBQ2QsYUFBSyxZQUFZLEdBQUc7QUFDcEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxPQUFPLEdBQUc7QUFDZixhQUFLLFNBQVMsR0FBRyxPQUFPLE9BQU87QUFDL0IsYUFBSyxRQUFRLElBQUksU0FBUyxHQUFHLEtBQUssU0FBUyxLQUFLLFVBQVUsS0FBSyxPQUFPO0FBQ3RFLGFBQUssZUFBYyxHQUFBLE9BQUEsZ0JBQWUsSUFBSSxLQUFLLFFBQVEsU0FBUyxLQUFLLEtBQUs7QUFDdEUsYUFBSyxhQUFhLElBQUk7QUFDdEIsYUFBSyxlQUFlLEdBQUc7QUFDdkIsYUFBSyxTQUFTLENBQUE7QUFDZCxhQUFLLEtBQUs7QUFDVixhQUFLLE1BQU07QUFFWCxZQUFJLEtBQUssT0FBTztBQUNkLGVBQUssYUFBYSxHQUFHLElBQUksTUFBTSxXQUFXLFFBQVEsS0FBSyxPQUFPLEVBQUUsQ0FBQztlQUM1RDtBQUNMLGVBQUssYUFBYSxLQUFLO0FBQ3ZCLGNBQUksRUFBQyxHQUFBLFVBQUEsaUJBQWdCLEtBQUssUUFBUSxJQUFJLFlBQVksSUFBSSxjQUFjLEdBQUc7QUFDckUsa0JBQU0sSUFBSSxNQUFNLEdBQUcseUJBQXlCLEtBQUssVUFBVSxJQUFJLFVBQVUsR0FBRzs7O0FBSWhGLFlBQUksVUFBVSxNQUFNLElBQUksY0FBYyxJQUFJLFdBQVcsT0FBTztBQUMxRCxlQUFLLFlBQVksR0FBRyxJQUFJLE1BQU0sU0FBUyxRQUFBLFFBQUUsTUFBTTs7TUFFbkQ7TUFFQSxPQUFPLFdBQWlCLGVBQTRCLFlBQXVCO0FBQ3pFLGFBQUssWUFBVyxHQUFBLFVBQUEsS0FBSSxTQUFTLEdBQUcsZUFBZSxVQUFVO01BQzNEO01BRUEsV0FBVyxXQUFpQixlQUE0QixZQUF1QjtBQUM3RSxhQUFLLElBQUksR0FBRyxTQUFTO0FBQ3JCLFlBQUk7QUFBWSxxQkFBVTs7QUFDckIsZUFBSyxNQUFLO0FBQ2YsWUFBSSxlQUFlO0FBQ2pCLGVBQUssSUFBSSxLQUFJO0FBQ2Isd0JBQWE7QUFDYixjQUFJLEtBQUs7QUFBVyxpQkFBSyxJQUFJLE1BQUs7ZUFDN0I7QUFDTCxjQUFJLEtBQUs7QUFBVyxpQkFBSyxJQUFJLE1BQUs7O0FBQzdCLGlCQUFLLElBQUksS0FBSTs7TUFFdEI7TUFFQSxLQUFLLFdBQWlCLFlBQXVCO0FBQzNDLGFBQUssWUFBVyxHQUFBLFVBQUEsS0FBSSxTQUFTLEdBQUcsUUFBVyxVQUFVO01BQ3ZEO01BRUEsS0FBSyxXQUFnQjtBQUNuQixZQUFJLGNBQWMsUUFBVztBQUMzQixlQUFLLE1BQUs7QUFDVixjQUFJLENBQUMsS0FBSztBQUFXLGlCQUFLLElBQUksR0FBRyxLQUFLO0FBQ3RDOztBQUVGLGFBQUssSUFBSSxHQUFHLFNBQVM7QUFDckIsYUFBSyxNQUFLO0FBQ1YsWUFBSSxLQUFLO0FBQVcsZUFBSyxJQUFJLE1BQUs7O0FBQzdCLGVBQUssSUFBSSxLQUFJO01BQ3BCO01BRUEsVUFBVSxXQUFlO0FBQ3ZCLFlBQUksQ0FBQyxLQUFLO0FBQU8saUJBQU8sS0FBSyxLQUFLLFNBQVM7QUFDM0MsY0FBTSxFQUFDLFdBQVUsSUFBSTtBQUNyQixhQUFLLE1BQUssR0FBQSxVQUFBLEtBQUksaUNBQWdDLEdBQUEsVUFBQSxJQUFHLEtBQUssYUFBWSxHQUFJLFNBQVMsSUFBSTtNQUNyRjtNQUVBLE1BQU0sUUFBa0IsYUFBZ0MsWUFBdUI7QUFDN0UsWUFBSSxhQUFhO0FBQ2YsZUFBSyxVQUFVLFdBQVc7QUFDMUIsZUFBSyxPQUFPLFFBQVEsVUFBVTtBQUM5QixlQUFLLFVBQVUsQ0FBQSxDQUFFO0FBQ2pCOztBQUVGLGFBQUssT0FBTyxRQUFRLFVBQVU7TUFDaEM7TUFFUSxPQUFPLFFBQWtCLFlBQXVCO0FBQ3REO0FBQUMsU0FBQyxTQUFTLFNBQUEsbUJBQW1CLFNBQUEsYUFBYSxNQUFNLEtBQUssSUFBSSxPQUFPLFVBQVU7TUFDN0U7TUFFQSxhQUFVO0FBQ1IsU0FBQSxHQUFBLFNBQUEsYUFBWSxNQUFNLEtBQUssSUFBSSxjQUFjLFNBQUEsaUJBQWlCO01BQzVEO01BRUEsUUFBSztBQUNILFlBQUksS0FBSyxjQUFjO0FBQVcsZ0JBQU0sSUFBSSxNQUFNLHlDQUF5QztBQUMzRixTQUFBLEdBQUEsU0FBQSxrQkFBaUIsS0FBSyxLQUFLLEtBQUssU0FBUztNQUMzQztNQUVBLEdBQUcsTUFBb0I7QUFDckIsWUFBSSxDQUFDLEtBQUs7QUFBVyxlQUFLLElBQUksR0FBRyxJQUFJO01BQ3ZDO01BRUEsVUFBVSxLQUF1QixRQUFhO0FBQzVDLFlBQUk7QUFBUSxpQkFBTyxPQUFPLEtBQUssUUFBUSxHQUFHOztBQUNyQyxlQUFLLFNBQVM7TUFDckI7TUFFQSxXQUFXLE9BQWEsV0FBdUIsYUFBbUIsVUFBQSxLQUFHO0FBQ25FLGFBQUssSUFBSSxNQUFNLE1BQUs7QUFDbEIsZUFBSyxXQUFXLE9BQU8sVUFBVTtBQUNqQyxvQkFBUztRQUNYLENBQUM7TUFDSDtNQUVBLFdBQVcsUUFBYyxVQUFBLEtBQUssYUFBbUIsVUFBQSxLQUFHO0FBQ2xELFlBQUksQ0FBQyxLQUFLO0FBQU87QUFDakIsY0FBTSxFQUFDLEtBQUssWUFBWSxZQUFZLElBQUcsSUFBSTtBQUMzQyxZQUFJLElBQUcsR0FBQSxVQUFBLEtBQUcsR0FBQSxVQUFBLEtBQUksNEJBQTRCLFVBQVUsQ0FBQztBQUNyRCxZQUFJLFVBQVUsVUFBQTtBQUFLLGNBQUksT0FBTyxPQUFPLElBQUk7QUFDekMsWUFBSSxXQUFXLFVBQVUsSUFBSSxnQkFBZ0I7QUFDM0MsY0FBSSxPQUFPLEtBQUssYUFBWSxDQUFFO0FBQzlCLGVBQUssV0FBVTtBQUNmLGNBQUksVUFBVSxVQUFBO0FBQUssZ0JBQUksT0FBTyxPQUFPLEtBQUs7O0FBRTVDLFlBQUksS0FBSTtNQUNWO01BRUEsZUFBWTtBQUNWLGNBQU0sRUFBQyxLQUFLLFlBQVksWUFBWSxLQUFLLEdBQUUsSUFBSTtBQUMvQyxnQkFBTyxHQUFBLFVBQUEsSUFBRyxlQUFjLEdBQUksbUJBQWtCLENBQUU7QUFFaEQsaUJBQVMsaUJBQWM7QUFDckIsY0FBSSxXQUFXLFFBQVE7QUFFckIsZ0JBQUksRUFBRSxzQkFBc0IsVUFBQTtBQUFPLG9CQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDN0Usa0JBQU0sS0FBSyxNQUFNLFFBQVEsVUFBVSxJQUFJLGFBQWEsQ0FBQyxVQUFVO0FBQy9ELG9CQUFPLEdBQUEsVUFBQSxNQUFJLEdBQUEsV0FBQSxnQkFBZSxJQUFJLFlBQVksR0FBRyxLQUFLLGVBQWUsV0FBQSxTQUFTLEtBQUs7O0FBRWpGLGlCQUFPLFVBQUE7UUFDVDtBQUVBLGlCQUFTLHFCQUFrQjtBQUN6QixjQUFJLElBQUksZ0JBQWdCO0FBQ3RCLGtCQUFNLG9CQUFvQixJQUFJLFdBQVcsaUJBQWlCLEVBQUMsS0FBSyxJQUFJLGVBQWMsQ0FBQztBQUNuRixvQkFBTyxHQUFBLFVBQUEsTUFBSyxxQkFBcUI7O0FBRW5DLGlCQUFPLFVBQUE7UUFDVDtNQUNGO01BRUEsVUFBVSxNQUFxQixPQUFXO0FBQ3hDLGNBQU0sYUFBWSxHQUFBLFlBQUEsY0FBYSxLQUFLLElBQUksSUFBSTtBQUM1QyxTQUFBLEdBQUEsWUFBQSxxQkFBb0IsV0FBVyxLQUFLLElBQUksSUFBSTtBQUM1QyxTQUFBLEdBQUEsWUFBQSxxQkFBb0IsV0FBVyxJQUFJO0FBQ25DLGNBQU0sY0FBYyxFQUFDLEdBQUcsS0FBSyxJQUFJLEdBQUcsV0FBVyxPQUFPLFFBQVcsT0FBTyxPQUFTO0FBQ2pGLHNCQUFjLGFBQWEsS0FBSztBQUNoQyxlQUFPO01BQ1Q7TUFFQSxlQUFlLFdBQXNCLFFBQW9CO0FBQ3ZELGNBQU0sRUFBQyxJQUFJLElBQUcsSUFBSTtBQUNsQixZQUFJLENBQUMsR0FBRyxLQUFLO0FBQWE7QUFDMUIsWUFBSSxHQUFHLFVBQVUsUUFBUSxVQUFVLFVBQVUsUUFBVztBQUN0RCxhQUFHLFFBQVEsT0FBQSxlQUFlLE1BQU0sS0FBSyxVQUFVLE9BQU8sR0FBRyxPQUFPLE1BQU07O0FBRXhFLFlBQUksR0FBRyxVQUFVLFFBQVEsVUFBVSxVQUFVLFFBQVc7QUFDdEQsYUFBRyxRQUFRLE9BQUEsZUFBZSxNQUFNLEtBQUssVUFBVSxPQUFPLEdBQUcsT0FBTyxNQUFNOztNQUUxRTtNQUVBLG9CQUFvQixXQUFzQixPQUFXO0FBQ25ELGNBQU0sRUFBQyxJQUFJLElBQUcsSUFBSTtBQUNsQixZQUFJLEdBQUcsS0FBSyxnQkFBZ0IsR0FBRyxVQUFVLFFBQVEsR0FBRyxVQUFVLE9BQU87QUFDbkUsY0FBSSxHQUFHLE9BQU8sTUFBTSxLQUFLLGVBQWUsV0FBVyxVQUFBLElBQUksQ0FBQztBQUN4RCxpQkFBTzs7TUFFWDs7QUEzTEYsWUFBQSxhQUFBO0FBOExBLGFBQVMsWUFDUCxJQUNBLFNBQ0EsS0FDQSxVQUFtQjtBQUVuQixZQUFNLE1BQU0sSUFBSSxXQUFXLElBQUksS0FBSyxPQUFPO0FBQzNDLFVBQUksVUFBVSxLQUFLO0FBQ2pCLFlBQUksS0FBSyxLQUFLLFFBQVE7aUJBQ2IsSUFBSSxTQUFTLElBQUksVUFBVTtBQUNwQyxTQUFBLEdBQUEsVUFBQSxpQkFBZ0IsS0FBSyxHQUFHO2lCQUNmLFdBQVcsS0FBSztBQUN6QixTQUFBLEdBQUEsVUFBQSxrQkFBaUIsS0FBSyxHQUFHO2lCQUNoQixJQUFJLFdBQVcsSUFBSSxVQUFVO0FBQ3RDLFNBQUEsR0FBQSxVQUFBLGlCQUFnQixLQUFLLEdBQUc7O0lBRTVCO0FBRUEsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sd0JBQXdCO0FBQzlCLGFBQWdCLFFBQ2QsT0FDQSxFQUFDLFdBQVcsV0FBVyxZQUFXLEdBQVk7QUFFOUMsVUFBSTtBQUNKLFVBQUk7QUFDSixVQUFJLFVBQVU7QUFBSSxlQUFPLFFBQUEsUUFBRTtBQUMzQixVQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUs7QUFDcEIsWUFBSSxDQUFDLGFBQWEsS0FBSyxLQUFLO0FBQUcsZ0JBQU0sSUFBSSxNQUFNLHlCQUF5QixPQUFPO0FBQy9FLHNCQUFjO0FBQ2QsZUFBTyxRQUFBLFFBQUU7YUFDSjtBQUNMLGNBQU0sVUFBVSxzQkFBc0IsS0FBSyxLQUFLO0FBQ2hELFlBQUksQ0FBQztBQUFTLGdCQUFNLElBQUksTUFBTSx5QkFBeUIsT0FBTztBQUM5RCxjQUFNLEtBQWEsQ0FBQyxRQUFRLENBQUM7QUFDN0Isc0JBQWMsUUFBUSxDQUFDO0FBQ3ZCLFlBQUksZ0JBQWdCLEtBQUs7QUFDdkIsY0FBSSxNQUFNO0FBQVcsa0JBQU0sSUFBSSxNQUFNLFNBQVMsa0JBQWtCLEVBQUUsQ0FBQztBQUNuRSxpQkFBTyxZQUFZLFlBQVksRUFBRTs7QUFFbkMsWUFBSSxLQUFLO0FBQVcsZ0JBQU0sSUFBSSxNQUFNLFNBQVMsUUFBUSxFQUFFLENBQUM7QUFDeEQsZUFBTyxVQUFVLFlBQVksRUFBRTtBQUMvQixZQUFJLENBQUM7QUFBYSxpQkFBTzs7QUFHM0IsVUFBSSxPQUFPO0FBQ1gsWUFBTSxXQUFXLFlBQVksTUFBTSxHQUFHO0FBQ3RDLGlCQUFXLFdBQVcsVUFBVTtBQUM5QixZQUFJLFNBQVM7QUFDWCxrQkFBTyxHQUFBLFVBQUEsS0FBSSxRQUFPLEdBQUEsVUFBQSxjQUFZLEdBQUEsT0FBQSxxQkFBb0IsT0FBTyxDQUFDO0FBQzFELGtCQUFPLEdBQUEsVUFBQSxLQUFJLFdBQVc7OztBQUcxQixhQUFPO0FBRVAsZUFBUyxTQUFTLGFBQXFCLElBQVU7QUFDL0MsZUFBTyxpQkFBaUIsZUFBZSxrQ0FBa0M7TUFDM0U7SUFDRjtBQXRDQSxZQUFBLFVBQUE7Ozs7Ozs7OztBQzdoQkEsUUFBcUIsa0JBQXJCLGNBQTZDLE1BQUs7TUFLaEQsWUFBWSxRQUE4QjtBQUN4QyxjQUFNLG1CQUFtQjtBQUN6QixhQUFLLFNBQVM7QUFDZCxhQUFLLE1BQU0sS0FBSyxhQUFhO01BQy9COztBQVRGLFlBQUEsVUFBQTs7Ozs7Ozs7O0FDRkEsUUFBQSxZQUFBO0FBR0EsUUFBcUIsa0JBQXJCLGNBQTZDLE1BQUs7TUFJaEQsWUFBWSxVQUF1QixRQUFnQixLQUFhLEtBQVk7QUFDMUUsY0FBTSxPQUFPLDJCQUEyQixlQUFlLFFBQVE7QUFDL0QsYUFBSyxjQUFhLEdBQUEsVUFBQSxZQUFXLFVBQVUsUUFBUSxHQUFHO0FBQ2xELGFBQUssaUJBQWdCLEdBQUEsVUFBQSxjQUFZLEdBQUEsVUFBQSxhQUFZLFVBQVUsS0FBSyxVQUFVLENBQUM7TUFDekU7O0FBUkYsWUFBQSxVQUFBOzs7Ozs7Ozs7O0FDT0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxxQkFBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQUNBLFFBQUEsYUFBQTtBQTBEQSxRQUFhLFlBQWIsTUFBc0I7TUFrQnBCLFlBQVksS0FBa0I7O0FBVHJCLGFBQUEsT0FBbUIsQ0FBQTtBQUNuQixhQUFBLGlCQUEyQyxDQUFBO0FBU2xELFlBQUk7QUFDSixZQUFJLE9BQU8sSUFBSSxVQUFVO0FBQVUsbUJBQVMsSUFBSTtBQUNoRCxhQUFLLFNBQVMsSUFBSTtBQUNsQixhQUFLLFdBQVcsSUFBSTtBQUNwQixhQUFLLE9BQU8sSUFBSSxRQUFRO0FBQ3hCLGFBQUssVUFBU0MsTUFBQSxJQUFJLFlBQU0sUUFBQUEsUUFBQSxTQUFBQSxPQUFJLEdBQUEsVUFBQSxhQUFZLFdBQU0sUUFBTixXQUFNLFNBQUEsU0FBTixPQUFTLElBQUksWUFBWSxLQUFLLENBQUM7QUFDdkUsYUFBSyxhQUFhLElBQUk7QUFDdEIsYUFBSyxZQUFZLElBQUk7QUFDckIsYUFBSyxPQUFPLElBQUk7QUFDaEIsYUFBSyxTQUFTLFdBQU0sUUFBTixXQUFNLFNBQUEsU0FBTixPQUFRO0FBQ3RCLGFBQUssT0FBTyxDQUFBO01BQ2Q7O0FBOUJGLFlBQUEsWUFBQTtBQXFDQSxhQUFnQixjQUF5QixLQUFjO0FBRXJELFlBQU0sT0FBTyxtQkFBbUIsS0FBSyxNQUFNLEdBQUc7QUFDOUMsVUFBSTtBQUFNLGVBQU87QUFDakIsWUFBTSxVQUFTLEdBQUEsVUFBQSxhQUFZLEtBQUssS0FBSyxhQUFhLElBQUksS0FBSyxNQUFNO0FBQ2pFLFlBQU0sRUFBQyxLQUFLLE1BQUssSUFBSSxLQUFLLEtBQUs7QUFDL0IsWUFBTSxFQUFDLGNBQWEsSUFBSSxLQUFLO0FBQzdCLFlBQU0sTUFBTSxJQUFJLFVBQUEsUUFBUSxLQUFLLE9BQU8sRUFBQyxLQUFLLE9BQU8sY0FBYSxDQUFDO0FBQy9ELFVBQUk7QUFDSixVQUFJLElBQUksUUFBUTtBQUNkLDJCQUFtQixJQUFJLFdBQVcsU0FBUztVQUN6QyxLQUFLLG1CQUFBO1VBQ0wsT0FBTSxHQUFBLFVBQUE7U0FDUDs7QUFHSCxZQUFNLGVBQWUsSUFBSSxVQUFVLFVBQVU7QUFDN0MsVUFBSSxlQUFlO0FBRW5CLFlBQU0sWUFBdUI7UUFDM0I7UUFDQSxXQUFXLEtBQUssS0FBSztRQUNyQixNQUFNLFFBQUEsUUFBRTtRQUNSLFlBQVksUUFBQSxRQUFFO1FBQ2Qsb0JBQW9CLFFBQUEsUUFBRTtRQUN0QixXQUFXLENBQUMsUUFBQSxRQUFFLElBQUk7UUFDbEIsYUFBYSxDQUFDLFVBQUEsR0FBRztRQUNqQixXQUFXO1FBQ1gsV0FBVyxDQUFBO1FBQ1gsbUJBQW1CLG9CQUFJLElBQUc7UUFDMUIsY0FBYyxJQUFJLFdBQ2hCLFVBQ0EsS0FBSyxLQUFLLEtBQUssV0FBVyxPQUN0QixFQUFDLEtBQUssSUFBSSxRQUFRLE9BQU0sR0FBQSxVQUFBLFdBQVUsSUFBSSxNQUFNLEVBQUMsSUFDN0MsRUFBQyxLQUFLLElBQUksT0FBTSxDQUFDO1FBRXZCO1FBQ0EsaUJBQWlCO1FBQ2pCLFFBQVEsSUFBSTtRQUNaLFdBQVc7UUFDWDtRQUNBLFFBQVEsSUFBSSxVQUFVO1FBQ3RCLFlBQVksVUFBQTtRQUNaLGVBQWUsSUFBSSxlQUFlLEtBQUssS0FBSyxNQUFNLEtBQUs7UUFDdkQsWUFBVyxHQUFBLFVBQUE7UUFDWCxNQUFNLEtBQUs7UUFDWCxNQUFNOztBQUdSLFVBQUk7QUFDSixVQUFJO0FBQ0YsYUFBSyxjQUFjLElBQUksR0FBRztBQUMxQixTQUFBLEdBQUEsV0FBQSxzQkFBcUIsU0FBUztBQUM5QixZQUFJLFNBQVMsS0FBSyxLQUFLLEtBQUssUUFBUTtBQUVwQyxjQUFNLGVBQWUsSUFBSSxTQUFRO0FBQ2pDLHFCQUFhLEdBQUcsSUFBSSxVQUFVLFFBQUEsUUFBRSxLQUFLLFdBQVc7QUFFaEQsWUFBSSxLQUFLLEtBQUssS0FBSztBQUFTLHVCQUFhLEtBQUssS0FBSyxLQUFLLFFBQVEsWUFBWSxHQUFHO0FBRS9FLGNBQU0sZUFBZSxJQUFJLFNBQVMsR0FBRyxRQUFBLFFBQUUsUUFBUSxHQUFHLFFBQUEsUUFBRSxTQUFTLFVBQVU7QUFDdkUsY0FBTSxXQUFnQyxhQUFhLE1BQU0sS0FBSyxNQUFNLElBQUcsQ0FBRTtBQUN6RSxhQUFLLE1BQU0sTUFBTSxjQUFjLEVBQUMsS0FBSyxTQUFRLENBQUM7QUFFOUMsaUJBQVMsU0FBUztBQUNsQixpQkFBUyxTQUFTLElBQUk7QUFDdEIsaUJBQVMsWUFBWTtBQUNyQixZQUFJLElBQUk7QUFBUyxtQkFBbUMsU0FBUztBQUM3RCxZQUFJLEtBQUssS0FBSyxLQUFLLFdBQVcsTUFBTTtBQUNsQyxtQkFBUyxTQUFTLEVBQUMsY0FBYyxjQUFjLGFBQWEsSUFBSSxRQUFPOztBQUV6RSxZQUFJLEtBQUssS0FBSyxhQUFhO0FBQ3pCLGdCQUFNLEVBQUMsT0FBTyxNQUFLLElBQUk7QUFDdkIsbUJBQVMsWUFBWTtZQUNuQixPQUFPLGlCQUFpQixVQUFBLE9BQU8sU0FBWTtZQUMzQyxPQUFPLGlCQUFpQixVQUFBLE9BQU8sU0FBWTtZQUMzQyxjQUFjLGlCQUFpQixVQUFBO1lBQy9CLGNBQWMsaUJBQWlCLFVBQUE7O0FBRWpDLGNBQUksU0FBUztBQUFRLHFCQUFTLE9BQU8sYUFBWSxHQUFBLFVBQUEsV0FBVSxTQUFTLFNBQVM7O0FBRS9FLFlBQUksV0FBVztBQUNmLGVBQU87ZUFDQSxHQUFQO0FBQ0EsZUFBTyxJQUFJO0FBQ1gsZUFBTyxJQUFJO0FBQ1gsWUFBSTtBQUFZLGVBQUssT0FBTyxNQUFNLDBDQUEwQyxVQUFVO0FBRXRGLGNBQU07O0FBRU4sYUFBSyxjQUFjLE9BQU8sR0FBRzs7SUFFakM7QUE1RkEsWUFBQSxnQkFBQTtBQThGQSxhQUFnQixXQUVkLE1BQ0EsUUFDQSxLQUFXOztBQUVYLGFBQU0sR0FBQSxVQUFBLFlBQVcsS0FBSyxLQUFLLGFBQWEsUUFBUSxHQUFHO0FBQ25ELFlBQU0sWUFBWSxLQUFLLEtBQUssR0FBRztBQUMvQixVQUFJO0FBQVcsZUFBTztBQUV0QixVQUFJLE9BQU8sUUFBUSxLQUFLLE1BQU0sTUFBTSxHQUFHO0FBQ3ZDLFVBQUksU0FBUyxRQUFXO0FBQ3RCLGNBQU0sVUFBU0EsTUFBQSxLQUFLLGVBQVMsUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUcsR0FBRztBQUNuQyxjQUFNLEVBQUMsU0FBUSxJQUFJLEtBQUs7QUFDeEIsWUFBSTtBQUFRLGlCQUFPLElBQUksVUFBVSxFQUFDLFFBQVEsVUFBVSxNQUFNLE9BQU0sQ0FBQzs7QUFHbkUsVUFBSSxTQUFTO0FBQVc7QUFDeEIsYUFBUSxLQUFLLEtBQUssR0FBRyxJQUFJLGdCQUFnQixLQUFLLE1BQU0sSUFBSTtJQUMxRDtBQW5CQSxZQUFBLGFBQUE7QUFxQkEsYUFBUyxnQkFBMkIsS0FBYztBQUNoRCxXQUFJLEdBQUEsVUFBQSxXQUFVLElBQUksUUFBUSxLQUFLLEtBQUssVUFBVTtBQUFHLGVBQU8sSUFBSTtBQUM1RCxhQUFPLElBQUksV0FBVyxNQUFNLGNBQWMsS0FBSyxNQUFNLEdBQUc7SUFDMUQ7QUFHQSxhQUFnQixtQkFBOEIsUUFBaUI7QUFDN0QsaUJBQVcsT0FBTyxLQUFLLGVBQWU7QUFDcEMsWUFBSSxjQUFjLEtBQUssTUFBTTtBQUFHLGlCQUFPOztJQUUzQztBQUpBLFlBQUEscUJBQUE7QUFNQSxhQUFTLGNBQWMsSUFBZSxJQUFhO0FBQ2pELGFBQU8sR0FBRyxXQUFXLEdBQUcsVUFBVSxHQUFHLFNBQVMsR0FBRyxRQUFRLEdBQUcsV0FBVyxHQUFHO0lBQzVFO0FBSUEsYUFBUyxRQUVQLE1BQ0E7QUFFQSxVQUFJO0FBQ0osYUFBTyxRQUFRLE1BQU0sS0FBSyxLQUFLLEdBQUcsTUFBTTtBQUFVLGNBQU07QUFDeEQsYUFBTyxPQUFPLEtBQUssUUFBUSxHQUFHLEtBQUssY0FBYyxLQUFLLE1BQU0sTUFBTSxHQUFHO0lBQ3ZFO0FBR0EsYUFBZ0IsY0FFZCxNQUNBO0FBRUEsWUFBTSxJQUFJLEtBQUssS0FBSyxZQUFZLE1BQU0sR0FBRztBQUN6QyxZQUFNLFdBQVUsR0FBQSxVQUFBLGNBQWEsS0FBSyxLQUFLLGFBQWEsQ0FBQztBQUNyRCxVQUFJLFVBQVMsR0FBQSxVQUFBLGFBQVksS0FBSyxLQUFLLGFBQWEsS0FBSyxRQUFRLE1BQVM7QUFFdEUsVUFBSSxPQUFPLEtBQUssS0FBSyxNQUFNLEVBQUUsU0FBUyxLQUFLLFlBQVksUUFBUTtBQUM3RCxlQUFPLGVBQWUsS0FBSyxNQUFNLEdBQUcsSUFBSTs7QUFHMUMsWUFBTSxNQUFLLEdBQUEsVUFBQSxhQUFZLE9BQU87QUFDOUIsWUFBTSxXQUFXLEtBQUssS0FBSyxFQUFFLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDakQsVUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixjQUFNLE1BQU0sY0FBYyxLQUFLLE1BQU0sTUFBTSxRQUFRO0FBQ25ELFlBQUksUUFBTyxRQUFHLFFBQUgsUUFBRyxTQUFBLFNBQUgsSUFBSyxZQUFXO0FBQVU7QUFDckMsZUFBTyxlQUFlLEtBQUssTUFBTSxHQUFHLEdBQUc7O0FBR3pDLFVBQUksUUFBTyxhQUFRLFFBQVIsYUFBUSxTQUFBLFNBQVIsU0FBVSxZQUFXO0FBQVU7QUFDMUMsVUFBSSxDQUFDLFNBQVM7QUFBVSxzQkFBYyxLQUFLLE1BQU0sUUFBUTtBQUN6RCxVQUFJLFFBQU8sR0FBQSxVQUFBLGFBQVksR0FBRyxHQUFHO0FBQzNCLGNBQU0sRUFBQyxPQUFNLElBQUk7QUFDakIsY0FBTSxFQUFDLFNBQVEsSUFBSSxLQUFLO0FBQ3hCLGNBQU0sUUFBUSxPQUFPLFFBQVE7QUFDN0IsWUFBSTtBQUFPLG9CQUFTLEdBQUEsVUFBQSxZQUFXLEtBQUssS0FBSyxhQUFhLFFBQVEsS0FBSztBQUNuRSxlQUFPLElBQUksVUFBVSxFQUFDLFFBQVEsVUFBVSxNQUFNLE9BQU0sQ0FBQzs7QUFFdkQsYUFBTyxlQUFlLEtBQUssTUFBTSxHQUFHLFFBQVE7SUFDOUM7QUEvQkEsWUFBQSxnQkFBQTtBQWlDQSxRQUFNLHVCQUF1QixvQkFBSSxJQUFJO01BQ25DO01BQ0E7TUFDQTtNQUNBO01BQ0E7S0FDRDtBQUVELGFBQVMsZUFFUCxXQUNBLEVBQUMsUUFBUSxRQUFRLEtBQUksR0FBWTs7QUFFakMsWUFBSUEsTUFBQSxVQUFVLGNBQVEsUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUcsQ0FBQyxPQUFNO0FBQUs7QUFDckMsaUJBQVcsUUFBUSxVQUFVLFNBQVMsTUFBTSxDQUFDLEVBQUUsTUFBTSxHQUFHLEdBQUc7QUFDekQsWUFBSSxPQUFPLFdBQVc7QUFBVztBQUNqQyxjQUFNLGFBQWEsUUFBTyxHQUFBLE9BQUEsa0JBQWlCLElBQUksQ0FBQztBQUNoRCxZQUFJLGVBQWU7QUFBVztBQUM5QixpQkFBUztBQUVULGNBQU0sUUFBUSxPQUFPLFdBQVcsWUFBWSxPQUFPLEtBQUssS0FBSyxRQUFRO0FBQ3JFLFlBQUksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLEtBQUssT0FBTztBQUM1QyxvQkFBUyxHQUFBLFVBQUEsWUFBVyxLQUFLLEtBQUssYUFBYSxRQUFRLEtBQUs7OztBQUc1RCxVQUFJO0FBQ0osVUFBSSxPQUFPLFVBQVUsYUFBYSxPQUFPLFFBQVEsRUFBQyxHQUFBLE9BQUEsc0JBQXFCLFFBQVEsS0FBSyxLQUFLLEdBQUc7QUFDMUYsY0FBTSxRQUFPLEdBQUEsVUFBQSxZQUFXLEtBQUssS0FBSyxhQUFhLFFBQVEsT0FBTyxJQUFJO0FBQ2xFLGNBQU0sY0FBYyxLQUFLLE1BQU0sTUFBTSxJQUFJOztBQUkzQyxZQUFNLEVBQUMsU0FBUSxJQUFJLEtBQUs7QUFDeEIsWUFBTSxPQUFPLElBQUksVUFBVSxFQUFDLFFBQVEsVUFBVSxNQUFNLE9BQU0sQ0FBQztBQUMzRCxVQUFJLElBQUksV0FBVyxJQUFJLEtBQUs7QUFBUSxlQUFPO0FBQzNDLGFBQU87SUFDVDs7Ozs7QUNuVUE7QUFBQSwyRkFBQUMsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxNQUNFLEtBQU87QUFBQSxNQUNQLGFBQWU7QUFBQSxNQUNmLE1BQVE7QUFBQSxNQUNSLFVBQVksQ0FBQyxPQUFPO0FBQUEsTUFDcEIsWUFBYztBQUFBLFFBQ1osT0FBUztBQUFBLFVBQ1AsTUFBUTtBQUFBLFVBQ1IsT0FBUyxDQUFDLEVBQUMsUUFBVSx3QkFBdUIsR0FBRyxFQUFDLFFBQVUsZUFBYyxDQUFDO0FBQUEsUUFDM0U7QUFBQSxNQUNGO0FBQUEsTUFDQSxzQkFBd0I7QUFBQSxJQUMxQjtBQUFBO0FBQUE7Ozs7Ozs7OztBYVpBLGVBQUFDLFFBQUE7MENBQXlCQyxPQUF6QixNQUFBLElBQUEsR0FBQSxPQUFBLEdBQUEsT0FBQSxNQUFBLFFBQUE7ZUFBQSxJQUFBLElBQUEsVUFBQSxJQUFBOztZQUNLQSxLQUFLQyxTQUFTLEdBQUc7ZUFDZixDQUFMLElBQVVELEtBQUssQ0FBTCxFQUFRRSxNQUFNLEdBQUcsRUFBakI7Y0FDSkMsS0FBS0gsS0FBS0MsU0FBUzttQkFDaEJHLElBQUksR0FBR0EsSUFBSUQsSUFBSSxFQUFFQyxHQUFHO2lCQUN2QkEsQ0FBTCxJQUFVSixLQUFLSSxDQUFMLEVBQVFGLE1BQU0sR0FBRyxFQUFqQjs7ZUFFTkMsRUFBTCxJQUFXSCxLQUFLRyxFQUFMLEVBQVNELE1BQU0sQ0FBZjtpQkFDSkYsS0FBS0ssS0FBSyxFQUFWO2VBQ0Q7aUJBQ0NMLEtBQUssQ0FBTDs7O0FBSVQsZUFBQU0sT0FBdUJDLEtBQXZCO2VBQ1EsUUFBUUEsTUFBTTs7QUFHdEIsZUFBQUMsT0FBdUJDLEdBQXZCO2VBQ1FBLE1BQU1DLFNBQVksY0FBZUQsTUFBTSxPQUFPLFNBQVNFLE9BQU9DLFVBQVVDLFNBQVNDLEtBQUtMLENBQS9CLEVBQWtDTSxNQUFNLEdBQXhDLEVBQTZDQyxJQUE3QyxFQUFtREQsTUFBTSxHQUF6RCxFQUE4REUsTUFBOUQsRUFBc0VDLFlBQXRFOztBQUcvRCxlQUFBQyxZQUE0QlosS0FBNUI7ZUFDUUEsSUFBSVksWUFBSjs7QUFHUixlQUFBQyxRQUF3QkMsS0FBeEI7ZUFDUUEsUUFBUVgsVUFBYVcsUUFBUSxPQUFRQSxlQUFlQyxRQUFRRCxNQUFPLE9BQU9BLElBQUlwQixXQUFXLFlBQVlvQixJQUFJTixTQUFTTSxJQUFJRSxlQUFlRixJQUFJUCxPQUFPLENBQUNPLEdBQUQsSUFBUUMsTUFBTVYsVUFBVVYsTUFBTVksS0FBS08sR0FBM0IsSUFBb0MsQ0FBQTs7QUFJcE0sZUFBQUcsT0FBdUJDLFFBQWdCQyxRQUF2QztZQUNPTCxNQUFNSTtZQUNSQyxRQUFRO21CQUNBQyxPQUFPRCxRQUFRO2dCQUNyQkMsR0FBSixJQUFXRCxPQUFPQyxHQUFQOzs7ZUFHTk47O0FEbkNSLGVBQUFPLFVBQTBCQyxRQUExQjtZQUVFQyxVQUFVLFlBQ1ZDLE1BQU0sV0FDTkMsVUFBVSxTQUNWQyxXQUFXLFdBQ1hDLFlBQVduQyxNQUFNaUMsU0FBUyxVQUFmLFVBQ0osV0FDUEcsT0FBTyxXQUNQQyxnQkFBZTlCLE9BQU9BLE9BQU8sWUFBWTRCLFlBQVcsTUFBTUEsWUFBV0EsWUFBVyxNQUFNQSxZQUFXQSxTQUEzRSxJQUF1RixNQUFNNUIsT0FBTyxnQkFBZ0I0QixZQUFXLE1BQU1BLFlBQVdBLFNBQW5ELElBQStELE1BQU01QixPQUFPLE1BQU00QixZQUFXQSxTQUF4QixDQUF6SyxrQkFDQSwyQkFDZkcsZUFBZSx1Q0FDZkMsYUFBYXZDLE1BQU13QyxjQUFjRixZQUFwQixHQUNiRyxZQUFZWCxTQUFRLGdGQUFnRixtQkFDdkZBLFNBQVEsc0JBQXNCLHNCQUM1QjlCLE1BQU0rQixTQUFTRSxTQUFTLGtCQUFrQlEsU0FBMUMsR0FDZkMsVUFBVW5DLE9BQU93QixVQUFVL0IsTUFBTStCLFNBQVNFLFNBQVMsYUFBeEIsSUFBeUMsR0FBMUQsR0FDVlUsWUFBWXBDLE9BQU9BLE9BQU84QixnQkFBZSxNQUFNckMsTUFBTTRDLGVBQWNOLGNBQWMsT0FBbEMsQ0FBNUIsSUFBMEUsR0FBakYsR0FDWk8sYUFBYXRDLE9BQU9BLE9BQU8sU0FBUCxJQUFvQixNQUFNQSxPQUFPLFdBQVcwQixPQUFsQixJQUE2QixNQUFNMUIsT0FBTyxNQUFNMEIsVUFBVUEsT0FBdkIsSUFBa0MsTUFBTTFCLE9BQU8sVUFBVTBCLE9BQWpCLElBQTRCLE1BQU1BLE9BQTlJLEdBQ2JhLHFCQUFxQnZDLE9BQU9BLE9BQU8sU0FBUCxJQUFvQixNQUFNQSxPQUFPLFdBQVcwQixPQUFsQixJQUE2QixNQUFNMUIsT0FBTyxNQUFNMEIsVUFBVUEsT0FBdkIsSUFBa0MsTUFBTTFCLE9BQU8sWUFBWTBCLE9BQW5CLElBQThCLFVBQVVBLE9BQXBKLGtCQUNOMUIsT0FBT3VDLHFCQUFxQixRQUFRQSxxQkFBcUIsUUFBUUEscUJBQXFCLFFBQVFBLGtCQUE5RixHQUNmQyxPQUFPeEMsT0FBTzRCLFlBQVcsT0FBbEIsR0FDUGEsUUFBUXpDLE9BQU9BLE9BQU93QyxPQUFPLFFBQVFBLElBQXRCLElBQThCLE1BQU1FLFlBQTNDLEdBQ1JDLGdCQUFnQjNDLE9BQW1FQSxPQUFPd0MsT0FBTyxLQUFkLElBQXVCLFFBQVFDLEtBQWxHLG1CQUNBekMsT0FBd0QsV0FBV0EsT0FBT3dDLE9BQU8sS0FBZCxJQUF1QixRQUFRQyxLQUFsRyxtQkFDQXpDLE9BQU9BLE9BQXdDd0MsSUFBeEMsSUFBZ0QsWUFBWXhDLE9BQU93QyxPQUFPLEtBQWQsSUFBdUIsUUFBUUMsS0FBbEcsbUJBQ0F6QyxPQUFPQSxPQUFPQSxPQUFPd0MsT0FBTyxLQUFkLElBQXVCLFVBQVVBLElBQXhDLElBQWdELFlBQVl4QyxPQUFPd0MsT0FBTyxLQUFkLElBQXVCLFFBQVFDLEtBQWxHLG1CQUNBekMsT0FBT0EsT0FBT0EsT0FBT3dDLE9BQU8sS0FBZCxJQUF1QixVQUFVQSxJQUF4QyxJQUFnRCxZQUFZeEMsT0FBT3dDLE9BQU8sS0FBZCxJQUF1QixRQUFRQyxLQUFsRyxtQkFDQXpDLE9BQU9BLE9BQU9BLE9BQU93QyxPQUFPLEtBQWQsSUFBdUIsVUFBVUEsSUFBeEMsSUFBZ0QsWUFBbUJBLE9BQU8sUUFBaUJDLEtBQWxHLG1CQUNBekMsT0FBT0EsT0FBT0EsT0FBT3dDLE9BQU8sS0FBZCxJQUF1QixVQUFVQSxJQUF4QyxJQUFnRCxZQUEyQ0MsS0FBbEcsbUJBQ0F6QyxPQUFPQSxPQUFPQSxPQUFPd0MsT0FBTyxLQUFkLElBQXVCLFVBQVVBLElBQXhDLElBQWdELFlBQTJDQSxJQUFsRyxtQkFDQXhDLE9BQU9BLE9BQU9BLE9BQU93QyxPQUFPLEtBQWQsSUFBdUIsVUFBVUEsSUFBeEMsSUFBZ0QsU0FBdkQsa0JBQ0R4QyxPQUFPLENBQUMyQyxlQUFlQyxlQUFlQyxlQUFlQyxlQUFlQyxlQUFlQyxlQUFlQyxlQUFlQyxlQUFlQyxhQUF6SCxFQUF3SXBELEtBQUssR0FBN0ksQ0FBUCxHQUNmcUQsVUFBVXBELE9BQU9BLE9BQU9xQyxnQkFBZSxNQUFNUCxhQUE1QixJQUE0QyxHQUFuRCxnQkFDRzlCLE9BQU9xRCxlQUFlLFVBQVVELE9BQWhDLHdCQUNRcEQsT0FBT3FELGVBQWVyRCxPQUFPLGlCQUFpQjRCLFlBQVcsTUFBbkMsSUFBNkN3QixPQUFuRSxnQkFDUnBELE9BQU8sU0FBUzRCLFlBQVcsU0FBU25DLE1BQU00QyxlQUFjTixjQUFjLE9BQWxDLElBQTZDLEdBQWpGLEdBQ2J1QixjQUFjdEQsT0FBTyxRQUFRQSxPQUFPdUQscUJBQXFCLE1BQU1GLGVBQWUsTUFBTUcsVUFBdkQsSUFBcUUsS0FBcEYsZUFDRnhELE9BQU9BLE9BQU84QixnQkFBZSxNQUFNckMsTUFBTTRDLGVBQWNOLFlBQXBCLENBQTVCLElBQWlFLEdBQXhFLEdBQ1owQixRQUFRekQsT0FBT3NELGNBQWMsTUFBTVosZUFBZSxRQUFRZ0IsWUFBWSxPQUFZQSxTQUExRSxHQUNSQyxRQUFRM0QsT0FBTzBCLFVBQVUsR0FBakIsR0FDUmtDLGFBQWE1RCxPQUFPQSxPQUFPb0MsWUFBWSxHQUFuQixJQUEwQixNQUFNcUIsUUFBUXpELE9BQU8sUUFBUTJELEtBQWYsSUFBd0IsR0FBdkUsR0FDYkUsU0FBUzdELE9BQU84QixnQkFBZSxNQUFNckMsTUFBTTRDLGVBQWNOLGNBQWMsVUFBbEMsQ0FBNUIsR0FDVCtCLFdBQVc5RCxPQUFPNkQsU0FBUyxHQUFoQixHQUNYRSxjQUFjL0QsT0FBTzZELFNBQVMsR0FBaEIsR0FDZEcsaUJBQWlCaEUsT0FBT0EsT0FBTzhCLGdCQUFlLE1BQU1yQyxNQUFNNEMsZUFBY04sY0FBYyxPQUFsQyxDQUE1QixJQUEwRSxHQUFqRixHQUNqQmtDLGdCQUFnQmpFLE9BQU9BLE9BQU8sUUFBUThELFFBQWYsSUFBMkIsR0FBbEMsR0FDaEJJLGlCQUFpQmxFLE9BQU8sUUFBUUEsT0FBTytELGNBQWNFLGFBQXJCLElBQXNDLEdBQXJELG9CQUNBakUsT0FBT2dFLGlCQUFpQkMsYUFBeEIsb0JBQ0FqRSxPQUFPK0QsY0FBY0UsYUFBckIsaUJBQ0gsUUFBUUosU0FBUyxLQUMvQk0sUUFBUW5FLE9BQU9pRSxnQkFBZ0IsTUFBTUMsaUJBQWlCLE1BQU1FLGlCQUFpQixNQUFNQyxpQkFBaUIsTUFBTUMsV0FBbEcsR0FDUkMsU0FBU3ZFLE9BQU9BLE9BQU82RCxTQUFTLE1BQU1wRSxNQUFNLFlBQVkrRSxVQUFsQixDQUF0QixJQUF1RCxHQUE5RCxHQUNUQyxZQUFZekUsT0FBT0EsT0FBTzZELFNBQVMsV0FBaEIsSUFBK0IsR0FBdEMsR0FDWmEsYUFBYTFFLE9BQU9BLE9BQU8sV0FBVzRELGFBQWFLLGFBQS9CLElBQWdELE1BQU1DLGlCQUFpQixNQUFNRyxpQkFBaUIsTUFBTUMsV0FBM0csR0FDYkssT0FBTzNFLE9BQU9tQyxVQUFVLFFBQVF1QyxhQUFhMUUsT0FBTyxRQUFRdUUsTUFBZixJQUF5QixNQUFNdkUsT0FBTyxRQUFReUUsU0FBZixJQUE0QixHQUFqRyxHQUNQRyxpQkFBaUI1RSxPQUFPQSxPQUFPLFdBQVc0RCxhQUFhSyxhQUEvQixJQUFnRCxNQUFNQyxpQkFBaUIsTUFBTUUsaUJBQWlCLE1BQU1FLFdBQTNHLEdBQ2pCTyxZQUFZN0UsT0FBTzRFLGlCQUFpQjVFLE9BQU8sUUFBUXVFLE1BQWYsSUFBeUIsTUFBTXZFLE9BQU8sUUFBUXlFLFNBQWYsSUFBNEIsR0FBbkYsR0FDWkssaUJBQWlCOUUsT0FBTzJFLE9BQU8sTUFBTUUsU0FBcEIsR0FDakJFLGdCQUFnQi9FLE9BQU9tQyxVQUFVLFFBQVF1QyxhQUFhMUUsT0FBTyxRQUFRdUUsTUFBZixJQUF5QixHQUEvRCxHQUVoQlMsZUFBZSxPQUFPN0MsVUFBVSxTQUFTbkMsT0FBT0EsT0FBTyxZQUFZQSxPQUFPLE1BQU1vQyxZQUFZLElBQXpCLElBQWlDLE9BQU9xQixRQUFRLE1BQU16RCxPQUFPLFNBQVMyRCxRQUFRLEdBQXhCLElBQStCLElBQXhHLElBQWdILE9BQU9NLGdCQUFnQixNQUFNQyxpQkFBaUIsTUFBTUcsaUJBQWlCLE1BQU1DLGNBQWMsR0FBaE4sSUFBdU50RSxPQUFPLFNBQVN1RSxTQUFTLEdBQXpCLElBQWdDLE1BQU12RSxPQUFPLFNBQVN5RSxZQUFZLEdBQTVCLElBQW1DLE1BQ3pVUSxnQkFBZ0IsV0FBV2pGLE9BQU9BLE9BQU8sWUFBWUEsT0FBTyxNQUFNb0MsWUFBWSxJQUF6QixJQUFpQyxPQUFPcUIsUUFBUSxNQUFNekQsT0FBTyxTQUFTMkQsUUFBUSxHQUF4QixJQUErQixJQUF4RyxJQUFnSCxPQUFPTSxnQkFBZ0IsTUFBTUMsaUJBQWlCLE1BQU1FLGlCQUFpQixNQUFNRSxjQUFjLEdBQWhOLElBQXVOdEUsT0FBTyxTQUFTdUUsU0FBUyxHQUF6QixJQUFnQyxNQUFNdkUsT0FBTyxTQUFTeUUsWUFBWSxHQUE1QixJQUFtQyxNQUMzVFMsZ0JBQWdCLE9BQU8vQyxVQUFVLFNBQVNuQyxPQUFPQSxPQUFPLFlBQVlBLE9BQU8sTUFBTW9DLFlBQVksSUFBekIsSUFBaUMsT0FBT3FCLFFBQVEsTUFBTXpELE9BQU8sU0FBUzJELFFBQVEsR0FBeEIsSUFBK0IsSUFBeEcsSUFBZ0gsT0FBT00sZ0JBQWdCLE1BQU1DLGlCQUFpQixNQUFNRyxpQkFBaUIsTUFBTUMsY0FBYyxHQUFoTixJQUF1TnRFLE9BQU8sU0FBU3VFLFNBQVMsR0FBekIsSUFBZ0MsTUFDalNZLGVBQWUsTUFBTW5GLE9BQU8sU0FBU3lFLFlBQVksR0FBNUIsSUFBbUMsTUFDeERXLGlCQUFpQixNQUFNcEYsT0FBTyxNQUFNb0MsWUFBWSxJQUF6QixJQUFpQyxPQUFPcUIsUUFBUSxNQUFNekQsT0FBTyxTQUFTMkQsUUFBUSxHQUF4QixJQUErQjtlQUd0RztzQkFDTyxJQUFJMEIsT0FBTzVGLE1BQU0sT0FBTytCLFNBQVNFLFNBQVMsYUFBL0IsR0FBK0MsR0FBMUQ7d0JBQ0UsSUFBSTJELE9BQU81RixNQUFNLGFBQWE0QyxlQUFjTixZQUFqQyxHQUFnRCxHQUEzRDtvQkFDSixJQUFJc0QsT0FBTzVGLE1BQU0sbUJBQW1CNEMsZUFBY04sWUFBdkMsR0FBc0QsR0FBakU7b0JBQ0EsSUFBSXNELE9BQU81RixNQUFNLG1CQUFtQjRDLGVBQWNOLFlBQXZDLEdBQXNELEdBQWpFOzZCQUNTLElBQUlzRCxPQUFPNUYsTUFBTSxnQkFBZ0I0QyxlQUFjTixZQUFwQyxHQUFtRCxHQUE5RDtxQkFDUixJQUFJc0QsT0FBTzVGLE1BQU0sVUFBVTRDLGVBQWNOLGNBQWMsa0JBQWtCeUMsVUFBOUQsR0FBMkUsR0FBdEY7d0JBQ0csSUFBSWEsT0FBTzVGLE1BQU0sVUFBVTRDLGVBQWNOLGNBQWMsZ0JBQTVDLEdBQStELEdBQTFFO2tCQUNOLElBQUlzRCxPQUFPNUYsTUFBTSxPQUFPNEMsZUFBY04sWUFBM0IsR0FBMEMsR0FBckQ7c0JBQ0ksSUFBSXNELE9BQU9oRCxlQUFjLEdBQXpCO3VCQUNDLElBQUlnRCxPQUFPNUYsTUFBTSxVQUFVNEMsZUFBY0wsVUFBOUIsR0FBMkMsR0FBdEQ7dUJBQ0EsSUFBSXFELE9BQU92RCxlQUFjLEdBQXpCO3VCQUNBLElBQUl1RCxPQUFPLE9BQU8zQyxlQUFlLElBQWpDO3VCQUNBLElBQUkyQyxPQUFPLFdBQVdoQyxlQUFlLE1BQU1yRCxPQUFPQSxPQUFPLGlCQUFpQjRCLFlBQVcsTUFBbkMsSUFBNkMsTUFBTXdCLFVBQVUsR0FBcEUsSUFBMkUsUUFBdEg7Ozs7QUFJaEIsVUFBQSxlQUFlOUIsVUFBVSxLQUFWO0FEckZmLFVBQUEsZUFBZUEsVUFBVSxJQUFWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FEQWYsVUFBTWdFLFNBQVM7QUFHZixVQUFNQyxPQUFPO0FBQ2IsVUFBTUMsT0FBTztBQUNiLFVBQU1DLE9BQU87QUFDYixVQUFNQyxPQUFPO0FBQ2IsVUFBTUMsT0FBTztBQUNiLFVBQU1DLGNBQWM7QUFDcEIsVUFBTUMsV0FBVztBQUNqQixVQUFNQyxZQUFZO0FBR2xCLFVBQU1DLGdCQUFnQjtBQUN0QixVQUFNQyxnQkFBZ0I7QUFDdEIsVUFBTUMsa0JBQWtCO0FBR3hCLFVBQU1DLFNBQVM7b0JBQ0Y7cUJBQ0M7eUJBQ0k7O0FBSWxCLFVBQU1DLGdCQUFnQlosT0FBT0M7QUFDN0IsVUFBTVksUUFBUUMsS0FBS0Q7QUFDbkIsVUFBTUUscUJBQXFCQyxPQUFPQztBQVVsQyxlQUFTQyxRQUFNQyxNQUFNO2NBQ2QsSUFBSUMsV0FBV1QsT0FBT1EsSUFBUCxDQUFmOztBQVdQLGVBQVNFLElBQUlDLE9BQU9DLElBQUk7WUFDakJDLFNBQVMsQ0FBQTtZQUNYcEgsU0FBU2tILE1BQU1sSDtlQUNaQSxVQUFVO2lCQUNUQSxNQUFQLElBQWlCbUgsR0FBR0QsTUFBTWxILE1BQU4sQ0FBSDs7ZUFFWG9IOztBQWFSLGVBQVNDLFVBQVVDLFFBQVFILElBQUk7WUFDeEJJLFFBQVFELE9BQU94RyxNQUFNLEdBQWI7WUFDVnNHLFNBQVM7WUFDVEcsTUFBTXZILFNBQVMsR0FBRzttQkFHWnVILE1BQU0sQ0FBTixJQUFXO21CQUNYQSxNQUFNLENBQU47O2lCQUdERCxPQUFPRSxRQUFRbEIsaUJBQWlCLEdBQWhDO1lBQ0htQixTQUFTSCxPQUFPeEcsTUFBTSxHQUFiO1lBQ1Q0RyxVQUFVVCxJQUFJUSxRQUFRTixFQUFaLEVBQWdCL0csS0FBSyxHQUFyQjtlQUNUZ0gsU0FBU007O0FBZ0JqQixlQUFTQyxXQUFXTCxRQUFRO1lBQ3JCTSxTQUFTLENBQUE7WUFDWEMsVUFBVTtZQUNSN0gsU0FBU3NILE9BQU90SDtlQUNmNkgsVUFBVTdILFFBQVE7Y0FDbEI4SCxRQUFRUixPQUFPUyxXQUFXRixTQUFsQjtjQUNWQyxTQUFTLFNBQVVBLFNBQVMsU0FBVUQsVUFBVTdILFFBQVE7Z0JBRXJEZ0ksUUFBUVYsT0FBT1MsV0FBV0YsU0FBbEI7aUJBQ1RHLFFBQVEsVUFBVyxPQUFRO3FCQUN4QkMsT0FBT0gsUUFBUSxTQUFVLE9BQU9FLFFBQVEsUUFBUyxLQUF4RDttQkFDTTtxQkFHQ0MsS0FBS0gsS0FBWjs7O2lCQUdLO21CQUNDRyxLQUFLSCxLQUFaOzs7ZUFHS0Y7O0FBV1IsVUFBTU0sYUFBYSxTQUFiQSxZQUFhLE9BQUE7ZUFBU3RCLE9BQU91QixjQUFQLE1BQUEsUUFBQSxrQkFBd0JqQixLQUF4QixDQUFBOztBQVc1QixVQUFNa0IsZUFBZSxTQUFmQSxjQUF3QkMsV0FBVztZQUNwQ0EsWUFBWSxLQUFPLElBQU07aUJBQ3JCQSxZQUFZOztZQUVoQkEsWUFBWSxLQUFPLElBQU07aUJBQ3JCQSxZQUFZOztZQUVoQkEsWUFBWSxLQUFPLElBQU07aUJBQ3JCQSxZQUFZOztlQUViekM7O0FBY1IsVUFBTTBDLGVBQWUsU0FBZkEsY0FBd0JDLE9BQU9DLE1BQU07ZUFHbkNELFFBQVEsS0FBSyxNQUFNQSxRQUFRLFFBQVFDLFFBQVEsTUFBTTs7QUFRekQsVUFBTUMsUUFBUSxTQUFSQSxPQUFpQkMsT0FBT0MsV0FBV0MsV0FBVztZQUMvQ0MsSUFBSTtnQkFDQUQsWUFBWW5DLE1BQU1pQyxRQUFRMUMsSUFBZCxJQUFzQjBDLFNBQVM7aUJBQzFDakMsTUFBTWlDLFFBQVFDLFNBQWQ7Ozs7VUFDcUJELFFBQVFsQyxnQkFBZ0JWLFFBQVE7VUFBRytDLEtBQUtqRDtVQUFNO2tCQUNuRWEsTUFBTWlDLFFBQVFsQyxhQUFkOztlQUVGQyxNQUFNb0MsS0FBS3JDLGdCQUFnQixLQUFLa0MsU0FBU0EsUUFBUTNDLEtBQWpEOztBQVVSLFVBQU0rQyxTQUFTLFNBQVRBLFFBQWtCQyxPQUFPO1lBRXhCbkIsU0FBUyxDQUFBO1lBQ1RvQixjQUFjRCxNQUFNL0k7WUFDdEJpSixJQUFJO1lBQ0pDLElBQUloRDtZQUNKaUQsT0FBT2xEO1lBTVBtRCxRQUFRTCxNQUFNTSxZQUFZbEQsU0FBbEI7WUFDUmlELFFBQVEsR0FBRztrQkFDTjs7aUJBR0FFLElBQUksR0FBR0EsSUFBSUYsT0FBTyxFQUFFRSxHQUFHO2NBRTNCUCxNQUFNaEIsV0FBV3VCLENBQWpCLEtBQXVCLEtBQU07b0JBQzFCLFdBQU47O2lCQUVNckIsS0FBS2MsTUFBTWhCLFdBQVd1QixDQUFqQixDQUFaOztpQkFNUUMsUUFBUUgsUUFBUSxJQUFJQSxRQUFRLElBQUksR0FBR0csUUFBUVAsZUFBd0M7Y0FPdkZRLE9BQU9QOztnQkFDRlEsSUFBSSxHQUFHWixJQUFJakQ7OztZQUEwQmlELEtBQUtqRDtZQUFNO2dCQUVwRDJELFNBQVNQLGFBQWE7c0JBQ25CLGVBQU47O2dCQUdLVCxRQUFRSCxhQUFhVyxNQUFNaEIsV0FBV3dCLE9BQWpCLENBQWI7Z0JBRVZoQixTQUFTM0MsUUFBUTJDLFFBQVE5QixPQUFPZCxTQUFTc0QsS0FBS1EsQ0FBckIsR0FBeUI7c0JBQy9DLFVBQU47O2lCQUdJbEIsUUFBUWtCO2dCQUNQQyxJQUFJYixLQUFLTSxPQUFPdEQsT0FBUWdELEtBQUtNLE9BQU9yRCxPQUFPQSxPQUFPK0MsSUFBSU07Z0JBRXhEWixRQUFRbUIsR0FBRzs7O2dCQUlUQyxhQUFhL0QsT0FBTzhEO2dCQUN0QkQsSUFBSWhELE1BQU1kLFNBQVNnRSxVQUFmLEdBQTRCO3NCQUM3QixVQUFOOztpQkFHSUE7O2NBSUFDLE1BQU1oQyxPQUFPNUgsU0FBUztpQkFDckJ5SSxNQUFNUSxJQUFJTyxNQUFNSSxLQUFLSixRQUFRLENBQTdCO2NBSUgvQyxNQUFNd0MsSUFBSVcsR0FBVixJQUFpQmpFLFNBQVN1RCxHQUFHO29CQUMxQixVQUFOOztlQUdJekMsTUFBTXdDLElBQUlXLEdBQVY7ZUFDQUE7aUJBR0VDLE9BQU9aLEtBQUssR0FBR0MsQ0FBdEI7O2VBSU10QyxPQUFPdUIsY0FBUCxNQUFBLFFBQXdCUCxNQUF4Qjs7QUFVUixVQUFNa0MsU0FBUyxTQUFUQSxRQUFrQmYsT0FBTztZQUN4Qm5CLFNBQVMsQ0FBQTtnQkFHUEQsV0FBV29CLEtBQVg7WUFHSkMsY0FBY0QsTUFBTS9JO1lBR3BCa0osSUFBSWhEO1lBQ0p3QyxRQUFRO1lBQ1JTLE9BQU9sRDs7Ozs7K0JBR2dCOEMsTUFBM0IsT0FBQSxRQUFBLEVBQUEsR0FBQSxPQUFBLEVBQUEsNkJBQUEsUUFBQSxVQUFBLEtBQUEsR0FBQSxPQUFBLDRCQUFBLE1BQWtDO2dCQUF2QmdCLGlCQUF1QixNQUFBO2dCQUM3QkEsaUJBQWUsS0FBTTtxQkFDakI5QixLQUFLdEIsbUJBQW1Cb0QsY0FBbkIsQ0FBWjs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFJRUMsY0FBY3BDLE9BQU81SDtZQUNyQmlLLGlCQUFpQkQ7WUFNakJBLGFBQWE7aUJBQ1QvQixLQUFLOUIsU0FBWjs7ZUFJTThELGlCQUFpQmpCLGFBQWE7Y0FJaENrQixJQUFJdkU7Ozs7O2tDQUNtQm9ELE1BQTNCLE9BQUEsUUFBQSxFQUFBLEdBQUEsUUFBQSxFQUFBLDhCQUFBLFNBQUEsV0FBQSxLQUFBLEdBQUEsT0FBQSw2QkFBQSxNQUFrQztrQkFBdkJnQixlQUF1QixPQUFBO2tCQUM3QkEsZ0JBQWdCYixLQUFLYSxlQUFlRyxHQUFHO29CQUN0Q0g7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBTUFJLHdCQUF3QkYsaUJBQWlCO2NBQzNDQyxJQUFJaEIsSUFBSXpDLE9BQU9kLFNBQVMrQyxTQUFTeUIscUJBQXpCLEdBQWlEO29CQUN0RCxVQUFOOztvQkFHU0QsSUFBSWhCLEtBQUtpQjtjQUNmRDs7Ozs7a0NBRXVCbkIsTUFBM0IsT0FBQSxRQUFBLEVBQUEsR0FBQSxRQUFBLEVBQUEsOEJBQUEsU0FBQSxXQUFBLEtBQUEsR0FBQSxPQUFBLDZCQUFBLE1BQWtDO2tCQUF2QmdCLGdCQUF1QixPQUFBO2tCQUM3QkEsZ0JBQWViLEtBQUssRUFBRVIsUUFBUS9DLFFBQVE7d0JBQ25DLFVBQU47O2tCQUVHb0UsaUJBQWdCYixHQUFHO29CQUVsQmtCLElBQUkxQjs7c0JBQ0NHLElBQUlqRDs7O2tCQUEwQmlELEtBQUtqRDtrQkFBTTtzQkFDM0M4RCxJQUFJYixLQUFLTSxPQUFPdEQsT0FBUWdELEtBQUtNLE9BQU9yRCxPQUFPQSxPQUFPK0MsSUFBSU07c0JBQ3hEaUIsSUFBSVYsR0FBRzs7O3NCQUdMVyxVQUFVRCxJQUFJVjtzQkFDZEMsYUFBYS9ELE9BQU84RDt5QkFDbkJ6QixLQUNOdEIsbUJBQW1CMkIsYUFBYW9CLElBQUlXLFVBQVVWLFlBQVksQ0FBdkMsQ0FBbkIsQ0FERDtzQkFHSWxELE1BQU00RCxVQUFVVixVQUFoQjs7dUJBR0UxQixLQUFLdEIsbUJBQW1CMkIsYUFBYThCLEdBQUcsQ0FBaEIsQ0FBbkIsQ0FBWjt1QkFDTzNCLE1BQU1DLE9BQU95Qix1QkFBdUJGLGtCQUFrQkQsV0FBdEQ7d0JBQ0M7a0JBQ05DOzs7Ozs7Ozs7Ozs7Ozs7OztZQUlGdkI7WUFDQVE7O2VBR0l0QixPQUFPeEgsS0FBSyxFQUFaOztBQWNSLFVBQU1rSyxZQUFZLFNBQVpBLFdBQXFCdkIsT0FBTztlQUMxQjFCLFVBQVUwQixPQUFPLFNBQVN6QixRQUFRO2lCQUNqQ2xCLGNBQWNtRSxLQUFLakQsTUFBbkIsSUFDSndCLE9BQU94QixPQUFPckgsTUFBTSxDQUFiLEVBQWdCZ0IsWUFBaEIsQ0FBUCxJQUNBcUc7U0FIRzs7QUFrQlIsVUFBTWtELFVBQVUsU0FBVkEsU0FBbUJ6QixPQUFPO2VBQ3hCMUIsVUFBVTBCLE9BQU8sU0FBU3pCLFFBQVE7aUJBQ2pDakIsY0FBY2tFLEtBQUtqRCxNQUFuQixJQUNKLFNBQVN3QyxPQUFPeEMsTUFBUCxJQUNUQTtTQUhHOztBQVVSLFVBQU1tRCxXQUFXOzs7Ozs7bUJBTUw7Ozs7Ozs7O2dCQVFIO29CQUNHOUM7b0JBQ0FPOztrQkFFRFk7a0JBQ0FnQjttQkFDQ1U7cUJBQ0VGOztBRDVWUCxVQUFNSSxVQUE2QyxDQUFBO0FBRTFELGVBQUFDLFdBQTJCQyxLQUEzQjtZQUNPQyxJQUFJRCxJQUFJN0MsV0FBVyxDQUFmO1lBQ04rQyxJQUFBQTtZQUVBRCxJQUFJO0FBQUlDLGNBQUksT0FBT0QsRUFBRWpLLFNBQVMsRUFBWCxFQUFlTSxZQUFmO2lCQUNkMkosSUFBSTtBQUFLQyxjQUFJLE1BQU1ELEVBQUVqSyxTQUFTLEVBQVgsRUFBZU0sWUFBZjtpQkFDbkIySixJQUFJO0FBQU1DLGNBQUksT0FBUUQsS0FBSyxJQUFLLEtBQUtqSyxTQUFTLEVBQTFCLEVBQThCTSxZQUE5QixJQUE4QyxPQUFRMkosSUFBSSxLQUFNLEtBQUtqSyxTQUFTLEVBQTFCLEVBQThCTSxZQUE5Qjs7QUFDNUU0SixjQUFJLE9BQVFELEtBQUssS0FBTSxLQUFLakssU0FBUyxFQUEzQixFQUErQk0sWUFBL0IsSUFBK0MsT0FBUzJKLEtBQUssSUFBSyxLQUFNLEtBQUtqSyxTQUFTLEVBQWpDLEVBQXFDTSxZQUFyQyxJQUFxRCxPQUFRMkosSUFBSSxLQUFNLEtBQUtqSyxTQUFTLEVBQTFCLEVBQThCTSxZQUE5QjtlQUV4SDRKOztBQUdSLGVBQUFDLFlBQTRCekssS0FBNUI7WUFDSzBLLFNBQVM7WUFDVC9CLElBQUk7WUFDRmdDLEtBQUszSyxJQUFJTjtlQUVSaUosSUFBSWdDLElBQUk7Y0FDUkosSUFBSUssU0FBUzVLLElBQUk2SyxPQUFPbEMsSUFBSSxHQUFHLENBQWxCLEdBQXNCLEVBQS9CO2NBRU40QixJQUFJLEtBQUs7c0JBQ0ZqRSxPQUFPQyxhQUFhZ0UsQ0FBcEI7aUJBQ0w7cUJBRUdBLEtBQUssT0FBT0EsSUFBSSxLQUFLO2dCQUN4QkksS0FBS2hDLEtBQU0sR0FBRztrQkFDWm1DLEtBQUtGLFNBQVM1SyxJQUFJNkssT0FBT2xDLElBQUksR0FBRyxDQUFsQixHQUFzQixFQUEvQjt3QkFDRHJDLE9BQU9DLGNBQWVnRSxJQUFJLE9BQU8sSUFBTU8sS0FBSyxFQUE1QzttQkFDSjt3QkFDSTlLLElBQUk2SyxPQUFPbEMsR0FBRyxDQUFkOztpQkFFTjtxQkFFRzRCLEtBQUssS0FBSztnQkFDYkksS0FBS2hDLEtBQU0sR0FBRztrQkFDWm1DLEtBQUtGLFNBQVM1SyxJQUFJNkssT0FBT2xDLElBQUksR0FBRyxDQUFsQixHQUFzQixFQUEvQjtrQkFDTG9DLEtBQUtILFNBQVM1SyxJQUFJNkssT0FBT2xDLElBQUksR0FBRyxDQUFsQixHQUFzQixFQUEvQjt3QkFDRHJDLE9BQU9DLGNBQWVnRSxJQUFJLE9BQU8sTUFBUU8sS0FBSyxPQUFPLElBQU1DLEtBQUssRUFBaEU7bUJBQ0o7d0JBQ0kvSyxJQUFJNkssT0FBT2xDLEdBQUcsQ0FBZDs7aUJBRU47aUJBRUQ7c0JBQ00zSSxJQUFJNkssT0FBT2xDLEdBQUcsQ0FBZDtpQkFDTDs7O2VBSUErQjs7QUFHUixlQUFBTSw0QkFBcUNDLFlBQTBCQyxVQUEvRDtpQkFDQUMsa0JBQTJCbkwsS0FBM0I7Y0FDUW9MLFNBQVNYLFlBQVl6SyxHQUFaO2lCQUNQLENBQUNvTCxPQUFPQyxNQUFNSCxTQUFTSSxVQUF0QixJQUFvQ3RMLE1BQU1vTDs7WUFHaERILFdBQVdNO0FBQVFOLHFCQUFXTSxTQUFTakYsT0FBTzJFLFdBQVdNLE1BQWxCLEVBQTBCckUsUUFBUWdFLFNBQVNNLGFBQWFMLGlCQUF4RCxFQUEwRXhLLFlBQTFFLEVBQXdGdUcsUUFBUWdFLFNBQVNPLFlBQVksRUFBckg7WUFDdkNSLFdBQVdTLGFBQWF2TDtBQUFXOEsscUJBQVdTLFdBQVdwRixPQUFPMkUsV0FBV1MsUUFBbEIsRUFBNEJ4RSxRQUFRZ0UsU0FBU00sYUFBYUwsaUJBQTFELEVBQTRFakUsUUFBUWdFLFNBQVNTLGNBQWN0QixVQUEzRyxFQUF1SG5ELFFBQVFnRSxTQUFTTSxhQUFhNUssV0FBcko7WUFDekRxSyxXQUFXVyxTQUFTekw7QUFBVzhLLHFCQUFXVyxPQUFPdEYsT0FBTzJFLFdBQVdXLElBQWxCLEVBQXdCMUUsUUFBUWdFLFNBQVNNLGFBQWFMLGlCQUF0RCxFQUF3RXhLLFlBQXhFLEVBQXNGdUcsUUFBUWdFLFNBQVNXLFVBQVV4QixVQUFqSCxFQUE2SG5ELFFBQVFnRSxTQUFTTSxhQUFhNUssV0FBM0o7WUFDakRxSyxXQUFXYSxTQUFTM0w7QUFBVzhLLHFCQUFXYSxPQUFPeEYsT0FBTzJFLFdBQVdhLElBQWxCLEVBQXdCNUUsUUFBUWdFLFNBQVNNLGFBQWFMLGlCQUF0RCxFQUF3RWpFLFFBQVMrRCxXQUFXTSxTQUFTTCxTQUFTYSxXQUFXYixTQUFTYyxtQkFBb0IzQixVQUF0SixFQUFrS25ELFFBQVFnRSxTQUFTTSxhQUFhNUssV0FBaE07WUFDakRxSyxXQUFXZ0IsVUFBVTlMO0FBQVc4SyxxQkFBV2dCLFFBQVEzRixPQUFPMkUsV0FBV2dCLEtBQWxCLEVBQXlCL0UsUUFBUWdFLFNBQVNNLGFBQWFMLGlCQUF2RCxFQUF5RWpFLFFBQVFnRSxTQUFTZ0IsV0FBVzdCLFVBQXJHLEVBQWlIbkQsUUFBUWdFLFNBQVNNLGFBQWE1SyxXQUEvSTtZQUNuRHFLLFdBQVdrQixhQUFhaE07QUFBVzhLLHFCQUFXa0IsV0FBVzdGLE9BQU8yRSxXQUFXa0IsUUFBbEIsRUFBNEJqRixRQUFRZ0UsU0FBU00sYUFBYUwsaUJBQTFELEVBQTRFakUsUUFBUWdFLFNBQVNrQixjQUFjL0IsVUFBM0csRUFBdUhuRCxRQUFRZ0UsU0FBU00sYUFBYTVLLFdBQXJKO2VBRXREcUs7O0FBR1IsZUFBQW9CLG1CQUE0QnJNLEtBQTVCO2VBQ1FBLElBQUlrSCxRQUFRLFdBQVcsSUFBdkIsS0FBZ0M7O0FBR3hDLGVBQUFvRixlQUF3QlYsTUFBYVYsVUFBckM7WUFDT3FCLFVBQVVYLEtBQUtQLE1BQU1ILFNBQVNzQixXQUFwQixLQUFvQyxDQUFBO3FDQUNoQ0QsU0FGckIsQ0FBQSxHQUVVRSxVQUZWLFNBQUEsQ0FBQTtZQUlLQSxTQUFTO2lCQUNMQSxRQUFRak0sTUFBTSxHQUFkLEVBQW1CbUcsSUFBSTBGLGtCQUF2QixFQUEyQ3ZNLEtBQUssR0FBaEQ7ZUFDRDtpQkFDQzhMOzs7QUFJVCxlQUFBYyxlQUF3QmQsTUFBYVYsVUFBckM7WUFDT3FCLFVBQVVYLEtBQUtQLE1BQU1ILFNBQVN5QixXQUFwQixLQUFvQyxDQUFBO3NDQUMxQkosU0FGM0IsQ0FBQSxHQUVVRSxVQUZWLFVBQUEsQ0FBQSxHQUVtQkcsT0FGbkIsVUFBQSxDQUFBO1lBSUtILFNBQVM7c0NBQ1VBLFFBQVE5TCxZQUFSLEVBQXNCSCxNQUFNLElBQTVCLEVBQWtDcU0sUUFBbEMscUVBQWZDLE9BREssdUJBQUEsQ0FBQSxHQUNDQyxRQURELHVCQUFBLENBQUE7Y0FFTkMsY0FBY0QsUUFBUUEsTUFBTXZNLE1BQU0sR0FBWixFQUFpQm1HLElBQUkwRixrQkFBckIsSUFBMkMsQ0FBQTtjQUNqRVksYUFBYUgsS0FBS3RNLE1BQU0sR0FBWCxFQUFnQm1HLElBQUkwRixrQkFBcEI7Y0FDYmEseUJBQXlCaEMsU0FBU3NCLFlBQVl2QyxLQUFLZ0QsV0FBV0EsV0FBV3ZOLFNBQVMsQ0FBL0IsQ0FBMUI7Y0FDekJ5TixhQUFhRCx5QkFBeUIsSUFBSTtjQUMxQ0Usa0JBQWtCSCxXQUFXdk4sU0FBU3lOO2NBQ3RDRSxTQUFTdE0sTUFBY29NLFVBQWQ7bUJBRU50TixJQUFJLEdBQUdBLElBQUlzTixZQUFZLEVBQUV0TixHQUFHO21CQUM3QkEsQ0FBUCxJQUFZbU4sWUFBWW5OLENBQVosS0FBa0JvTixXQUFXRyxrQkFBa0J2TixDQUE3QixLQUFtQzs7Y0FHOURxTix3QkFBd0I7bUJBQ3BCQyxhQUFhLENBQXBCLElBQXlCYixlQUFlZSxPQUFPRixhQUFhLENBQXBCLEdBQXdCakMsUUFBdkM7O2NBR3BCb0MsZ0JBQWdCRCxPQUFPRSxPQUE0QyxTQUFDQyxLQUFLQyxPQUFPeEUsT0FBeEY7Z0JBQ08sQ0FBQ3dFLFNBQVNBLFVBQVUsS0FBSztrQkFDdEJDLGNBQWNGLElBQUlBLElBQUk5TixTQUFTLENBQWpCO2tCQUNoQmdPLGVBQWVBLFlBQVl6RSxRQUFReUUsWUFBWWhPLFdBQVd1SixPQUFPOzRCQUN4RHZKO3FCQUNOO29CQUNGaUksS0FBSyxFQUFFc0IsT0FBT3ZKLFFBQVMsRUFBbEIsQ0FBVDs7O21CQUdLOE47YUFDTCxDQUFBLENBVm1CO2NBWWhCRyxvQkFBb0JMLGNBQWNNLEtBQUssU0FBQ0MsR0FBR0MsR0FBSjttQkFBVUEsRUFBRXBPLFNBQVNtTyxFQUFFbk87V0FBMUMsRUFBa0QsQ0FBbEQ7Y0FFdEJxTyxVQUFBQTtjQUNBSixxQkFBcUJBLGtCQUFrQmpPLFNBQVMsR0FBRztnQkFDaERzTyxXQUFXWCxPQUFPMU4sTUFBTSxHQUFHZ08sa0JBQWtCMUUsS0FBbEM7Z0JBQ1hnRixVQUFVWixPQUFPMU4sTUFBTWdPLGtCQUFrQjFFLFFBQVEwRSxrQkFBa0JqTyxNQUF6RDtzQkFDTnNPLFNBQVNsTyxLQUFLLEdBQWQsSUFBcUIsT0FBT21PLFFBQVFuTyxLQUFLLEdBQWI7aUJBQ2hDO3NCQUNJdU4sT0FBT3ZOLEtBQUssR0FBWjs7Y0FHUDhNLE1BQU07dUJBQ0UsTUFBTUE7O2lCQUdYbUI7ZUFDRDtpQkFDQ25DOzs7QUFJVCxVQUFNc0MsWUFBWTtBQUNsQixVQUFNQyx3QkFBNEMsR0FBSTlDLE1BQU0sT0FBWCxFQUFxQixDQUFyQixNQUE0QmxMO0FBRTdFLGVBQUFpTyxNQUFzQkMsV0FBdEI7WUFBd0NDLFVBQXhDLFVBQUEsU0FBQSxLQUFBLFVBQUEsQ0FBQSxNQUFBLFNBQUEsVUFBQSxDQUFBLElBQTZELENBQUE7WUFDdERyRCxhQUEyQixDQUFBO1lBQzNCQyxXQUFZb0QsUUFBUUMsUUFBUSxRQUFRQyxlQUFlQztZQUVyREgsUUFBUUksY0FBYztBQUFVTCx1QkFBYUMsUUFBUS9DLFNBQVMrQyxRQUFRL0MsU0FBUyxNQUFNLE1BQU0sT0FBTzhDO1lBRWhHOUIsVUFBVThCLFVBQVVoRCxNQUFNNkMsU0FBaEI7WUFFWjNCLFNBQVM7Y0FDUjRCLHVCQUF1Qjt1QkFFZjVDLFNBQVNnQixRQUFRLENBQVI7dUJBQ1RiLFdBQVdhLFFBQVEsQ0FBUjt1QkFDWFgsT0FBT1csUUFBUSxDQUFSO3VCQUNQb0MsT0FBTy9ELFNBQVMyQixRQUFRLENBQVIsR0FBWSxFQUFyQjt1QkFDUFQsT0FBT1MsUUFBUSxDQUFSLEtBQWM7dUJBQ3JCTixRQUFRTSxRQUFRLENBQVI7dUJBQ1JKLFdBQVdJLFFBQVEsQ0FBUjtnQkFHbEJxQyxNQUFNM0QsV0FBVzBELElBQWpCLEdBQXdCO3lCQUNoQkEsT0FBT3BDLFFBQVEsQ0FBUjs7aUJBRWI7dUJBRUtoQixTQUFTZ0IsUUFBUSxDQUFSLEtBQWNwTTt1QkFDdkJ1TCxXQUFZMkMsVUFBVVEsUUFBUSxHQUFsQixNQUEyQixLQUFLdEMsUUFBUSxDQUFSLElBQWFwTTt1QkFDekR5TCxPQUFReUMsVUFBVVEsUUFBUSxJQUFsQixNQUE0QixLQUFLdEMsUUFBUSxDQUFSLElBQWFwTTt1QkFDdER3TyxPQUFPL0QsU0FBUzJCLFFBQVEsQ0FBUixHQUFZLEVBQXJCO3VCQUNQVCxPQUFPUyxRQUFRLENBQVIsS0FBYzt1QkFDckJOLFFBQVNvQyxVQUFVUSxRQUFRLEdBQWxCLE1BQTJCLEtBQUt0QyxRQUFRLENBQVIsSUFBYXBNO3VCQUN0RGdNLFdBQVlrQyxVQUFVUSxRQUFRLEdBQWxCLE1BQTJCLEtBQUt0QyxRQUFRLENBQVIsSUFBYXBNO2dCQUdoRXlPLE1BQU0zRCxXQUFXMEQsSUFBakIsR0FBd0I7eUJBQ2hCQSxPQUFRTixVQUFVaEQsTUFBTSwrQkFBaEIsSUFBbURrQixRQUFRLENBQVIsSUFBYXBNOzs7Y0FJakY4SyxXQUFXVyxNQUFNO3VCQUVUQSxPQUFPYyxlQUFlSixlQUFlckIsV0FBV1csTUFBTVYsUUFBaEMsR0FBMkNBLFFBQTFEOztjQUlmRCxXQUFXTSxXQUFXcEwsVUFBYThLLFdBQVdTLGFBQWF2TCxVQUFhOEssV0FBV1csU0FBU3pMLFVBQWE4SyxXQUFXMEQsU0FBU3hPLFVBQWEsQ0FBQzhLLFdBQVdhLFFBQVFiLFdBQVdnQixVQUFVOUwsUUFBVzt1QkFDdEx1TyxZQUFZO3FCQUNiekQsV0FBV00sV0FBV3BMLFFBQVc7dUJBQ2hDdU8sWUFBWTtxQkFDYnpELFdBQVdrQixhQUFhaE0sUUFBVzt1QkFDbEN1TyxZQUFZO2lCQUNqQjt1QkFDS0EsWUFBWTs7Y0FJcEJKLFFBQVFJLGFBQWFKLFFBQVFJLGNBQWMsWUFBWUosUUFBUUksY0FBY3pELFdBQVd5RCxXQUFXO3VCQUMzRmxJLFFBQVF5RSxXQUFXekUsU0FBUyxrQkFBa0I4SCxRQUFRSSxZQUFZOztjQUl4RUksZ0JBQWdCMUUsU0FBU2tFLFFBQVEvQyxVQUFVTixXQUFXTSxVQUFVLElBQUk1SyxZQUE1QyxDQUFSO2NBR2xCLENBQUMyTixRQUFRUyxtQkFBbUIsQ0FBQ0QsaUJBQWlCLENBQUNBLGNBQWNDLGlCQUFpQjtnQkFFN0U5RCxXQUFXVyxTQUFTMEMsUUFBUVUsY0FBZUYsaUJBQWlCQSxjQUFjRSxhQUFjO2tCQUV2RjsyQkFDUXBELE9BQU96QixTQUFTRCxRQUFRZSxXQUFXVyxLQUFLMUUsUUFBUWdFLFNBQVNNLGFBQWFmLFdBQTlDLEVBQTJEOUosWUFBM0QsQ0FBakI7dUJBQ1Y2SixHQUFQOzJCQUNVaEUsUUFBUXlFLFdBQVd6RSxTQUFTLG9FQUFvRWdFOzs7d0NBSWpGUyxZQUFZd0QsWUFBeEM7aUJBQ007d0NBRXNCeEQsWUFBWUMsUUFBeEM7O2NBSUc0RCxpQkFBaUJBLGNBQWNWLE9BQU87MEJBQzNCQSxNQUFNbkQsWUFBWXFELE9BQWhDOztlQUVLO3FCQUNLOUgsUUFBUXlFLFdBQVd6RSxTQUFTOztlQUdqQ3lFOztBQUdSLGVBQUFnRSxvQkFBNkJoRSxZQUEwQnFELFNBQXZEO1lBQ09wRCxXQUFZb0QsUUFBUUMsUUFBUSxRQUFRQyxlQUFlQztZQUNuRFMsWUFBMEIsQ0FBQTtZQUU1QmpFLFdBQVdTLGFBQWF2TCxRQUFXO29CQUM1QndILEtBQUtzRCxXQUFXUyxRQUExQjtvQkFDVS9ELEtBQUssR0FBZjs7WUFHR3NELFdBQVdXLFNBQVN6TCxRQUFXO29CQUV4QndILEtBQUsrRSxlQUFlSixlQUFlaEcsT0FBTzJFLFdBQVdXLElBQWxCLEdBQXlCVixRQUF4QyxHQUFtREEsUUFBbEUsRUFBNEVoRSxRQUFRZ0UsU0FBU3lCLGFBQWEsU0FBQ3dDLEdBQUdDLElBQUlDLElBQVI7bUJBQWUsTUFBTUQsTUFBTUMsS0FBSyxRQUFRQSxLQUFLLE1BQU07V0FBN0osQ0FBZjs7WUFHRyxPQUFPcEUsV0FBVzBELFNBQVMsWUFBWSxPQUFPMUQsV0FBVzBELFNBQVMsVUFBVTtvQkFDckVoSCxLQUFLLEdBQWY7b0JBQ1VBLEtBQUtyQixPQUFPMkUsV0FBVzBELElBQWxCLENBQWY7O2VBR01PLFVBQVV4UCxTQUFTd1AsVUFBVXBQLEtBQUssRUFBZixJQUFxQks7O0FBR2hELFVBQU1tUCxPQUFPO0FBQ2IsVUFBTUMsT0FBTztBQUNiLFVBQU1DLE9BQU87QUFFYixVQUFNQyxPQUFPO0FBRWIsZUFBQUMsa0JBQWtDakgsT0FBbEM7WUFDT25CLFNBQXVCLENBQUE7ZUFFdEJtQixNQUFNL0ksUUFBUTtjQUNoQitJLE1BQU00QyxNQUFNaUUsSUFBWixHQUFtQjtvQkFDZDdHLE1BQU12QixRQUFRb0ksTUFBTSxFQUFwQjtxQkFDRTdHLE1BQU00QyxNQUFNa0UsSUFBWixHQUFtQjtvQkFDckI5RyxNQUFNdkIsUUFBUXFJLE1BQU0sR0FBcEI7cUJBQ0U5RyxNQUFNNEMsTUFBTW1FLElBQVosR0FBbUI7b0JBQ3JCL0csTUFBTXZCLFFBQVFzSSxNQUFNLEdBQXBCO21CQUNEL08sSUFBUDtxQkFDVWdJLFVBQVUsT0FBT0EsVUFBVSxNQUFNO29CQUNuQztpQkFDRjtnQkFDQWtILEtBQUtsSCxNQUFNNEMsTUFBTW9FLElBQVo7Z0JBQ1BFLElBQUk7a0JBQ0RDLElBQUlELEdBQUcsQ0FBSDtzQkFDRmxILE1BQU05SSxNQUFNaVEsRUFBRWxRLE1BQWQ7cUJBQ0RpSSxLQUFLaUksQ0FBWjttQkFDTTtvQkFDQSxJQUFJQyxNQUFNLGtDQUFWOzs7O2VBS0Z2SSxPQUFPeEgsS0FBSyxFQUFaOztBQUdSLGVBQUFnUSxVQUEwQjdFLFlBQTFCO1lBQW9EcUQsVUFBcEQsVUFBQSxTQUFBLEtBQUEsVUFBQSxDQUFBLE1BQUEsU0FBQSxVQUFBLENBQUEsSUFBeUUsQ0FBQTtZQUNsRXBELFdBQVlvRCxRQUFRQyxNQUFNQyxlQUFlQztZQUN6Q1MsWUFBMEIsQ0FBQTtZQUcxQkosZ0JBQWdCMUUsU0FBU2tFLFFBQVEvQyxVQUFVTixXQUFXTSxVQUFVLElBQUk1SyxZQUE1QyxDQUFSO1lBR2xCbU8saUJBQWlCQSxjQUFjZ0I7QUFBV2hCLHdCQUFjZ0IsVUFBVTdFLFlBQVlxRCxPQUFwQztZQUUxQ3JELFdBQVdXLE1BQU07Y0FFaEJWLFNBQVN5QixZQUFZMUMsS0FBS2dCLFdBQVdXLElBQXJDLEdBQTRDO1VBQUEsV0FLdkMwQyxRQUFRVSxjQUFlRixpQkFBaUJBLGNBQWNFLFlBQWE7Z0JBRXZFO3lCQUNRcEQsT0FBUSxDQUFDMEMsUUFBUUMsTUFBTXBFLFNBQVNELFFBQVFlLFdBQVdXLEtBQUsxRSxRQUFRZ0UsU0FBU00sYUFBYWYsV0FBOUMsRUFBMkQ5SixZQUEzRCxDQUFqQixJQUE2RndKLFNBQVNILFVBQVVpQixXQUFXVyxJQUE5QjtxQkFDdkhwQixHQUFQO3lCQUNVaEUsUUFBUXlFLFdBQVd6RSxTQUFTLGlEQUFpRCxDQUFDOEgsUUFBUUMsTUFBTSxVQUFVLGFBQWEsb0JBQW9CL0Q7Ozs7b0NBTXpIUyxZQUFZQyxRQUF4QztZQUVJb0QsUUFBUUksY0FBYyxZQUFZekQsV0FBV00sUUFBUTtvQkFDOUM1RCxLQUFLc0QsV0FBV00sTUFBMUI7b0JBQ1U1RCxLQUFLLEdBQWY7O1lBR0tvSSxZQUFZZCxvQkFBb0JoRSxZQUFZcUQsT0FBaEM7WUFDZHlCLGNBQWM1UCxRQUFXO2NBQ3hCbU8sUUFBUUksY0FBYyxVQUFVO3NCQUN6Qi9HLEtBQUssSUFBZjs7b0JBR1NBLEtBQUtvSSxTQUFmO2NBRUk5RSxXQUFXYSxRQUFRYixXQUFXYSxLQUFLa0UsT0FBTyxDQUF2QixNQUE4QixLQUFLO3NCQUMvQ3JJLEtBQUssR0FBZjs7O1lBSUVzRCxXQUFXYSxTQUFTM0wsUUFBVztjQUM5QnlQLElBQUkzRSxXQUFXYTtjQUVmLENBQUN3QyxRQUFRMkIsaUJBQWlCLENBQUNuQixpQkFBaUIsQ0FBQ0EsY0FBY21CLGVBQWU7Z0JBQ3pFUCxrQkFBa0JFLENBQWxCOztjQUdERyxjQUFjNVAsUUFBVztnQkFDeEJ5UCxFQUFFMUksUUFBUSxTQUFTLE1BQW5COztvQkFHS1MsS0FBS2lJLENBQWY7O1lBR0czRSxXQUFXZ0IsVUFBVTlMLFFBQVc7b0JBQ3pCd0gsS0FBSyxHQUFmO29CQUNVQSxLQUFLc0QsV0FBV2dCLEtBQTFCOztZQUdHaEIsV0FBV2tCLGFBQWFoTSxRQUFXO29CQUM1QndILEtBQUssR0FBZjtvQkFDVUEsS0FBS3NELFdBQVdrQixRQUExQjs7ZUFHTStDLFVBQVVwUCxLQUFLLEVBQWY7O0FBR1IsZUFBQW9RLGtCQUFrQzVLLE9BQW9CNkssVUFBdEQ7WUFBOEU3QixVQUE5RSxVQUFBLFNBQUEsS0FBQSxVQUFBLENBQUEsTUFBQSxTQUFBLFVBQUEsQ0FBQSxJQUFtRyxDQUFBO1lBQUk4QixvQkFBdkcsVUFBQSxDQUFBO1lBQ09sUCxTQUF1QixDQUFBO1lBRXpCLENBQUNrUCxtQkFBbUI7a0JBQ2hCaEMsTUFBTTBCLFVBQVV4SyxPQUFNZ0osT0FBaEIsR0FBMEJBLE9BQWhDO3FCQUNJRixNQUFNMEIsVUFBVUssVUFBVTdCLE9BQXBCLEdBQThCQSxPQUFwQzs7a0JBRUZBLFdBQVcsQ0FBQTtZQUVqQixDQUFDQSxRQUFRK0IsWUFBWUYsU0FBUzVFLFFBQVE7aUJBQ2xDQSxTQUFTNEUsU0FBUzVFO2lCQUVsQkcsV0FBV3lFLFNBQVN6RTtpQkFDcEJFLE9BQU91RSxTQUFTdkU7aUJBQ2hCK0MsT0FBT3dCLFNBQVN4QjtpQkFDaEI3QyxPQUFPNEQsa0JBQWtCUyxTQUFTckUsUUFBUSxFQUFuQztpQkFDUEcsUUFBUWtFLFNBQVNsRTtlQUNsQjtjQUNGa0UsU0FBU3pFLGFBQWF2TCxVQUFhZ1EsU0FBU3ZFLFNBQVN6TCxVQUFhZ1EsU0FBU3hCLFNBQVN4TyxRQUFXO21CQUUzRnVMLFdBQVd5RSxTQUFTekU7bUJBQ3BCRSxPQUFPdUUsU0FBU3ZFO21CQUNoQitDLE9BQU93QixTQUFTeEI7bUJBQ2hCN0MsT0FBTzRELGtCQUFrQlMsU0FBU3JFLFFBQVEsRUFBbkM7bUJBQ1BHLFFBQVFrRSxTQUFTbEU7aUJBQ2xCO2dCQUNGLENBQUNrRSxTQUFTckUsTUFBTTtxQkFDWkEsT0FBT3hHLE1BQUt3RztrQkFDZnFFLFNBQVNsRSxVQUFVOUwsUUFBVzt1QkFDMUI4TCxRQUFRa0UsU0FBU2xFO3FCQUNsQjt1QkFDQ0EsUUFBUTNHLE1BQUsyRzs7bUJBRWY7a0JBQ0ZrRSxTQUFTckUsS0FBS2tFLE9BQU8sQ0FBckIsTUFBNEIsS0FBSzt1QkFDN0JsRSxPQUFPNEQsa0JBQWtCUyxTQUFTckUsSUFBM0I7cUJBQ1I7cUJBQ0R4RyxNQUFLb0csYUFBYXZMLFVBQWFtRixNQUFLc0csU0FBU3pMLFVBQWFtRixNQUFLcUosU0FBU3hPLFdBQWMsQ0FBQ21GLE1BQUt3RyxNQUFNO3lCQUMvRkEsT0FBTyxNQUFNcUUsU0FBU3JFOzJCQUNuQixDQUFDeEcsTUFBS3dHLE1BQU07eUJBQ2ZBLE9BQU9xRSxTQUFTckU7dUJBQ2pCO3lCQUNDQSxPQUFPeEcsTUFBS3dHLEtBQUtuTSxNQUFNLEdBQUcyRixNQUFLd0csS0FBSy9DLFlBQVksR0FBdEIsSUFBNkIsQ0FBaEQsSUFBcURvSCxTQUFTckU7O3VCQUV0RUEsT0FBTzRELGtCQUFrQnhPLE9BQU80SyxJQUF6Qjs7cUJBRVJHLFFBQVFrRSxTQUFTbEU7O21CQUdsQlAsV0FBV3BHLE1BQUtvRzttQkFDaEJFLE9BQU90RyxNQUFLc0c7bUJBQ1orQyxPQUFPckosTUFBS3FKOztpQkFFYnBELFNBQVNqRyxNQUFLaUc7O2VBR2ZZLFdBQVdnRSxTQUFTaEU7ZUFFcEJqTDs7QUFHUixlQUFBb1AsUUFBd0JDLFNBQWdCQyxhQUFvQmxDLFNBQTVEO1lBQ09tQyxvQkFBb0J4UCxPQUFPLEVBQUVzSyxRQUFTLE9BQVgsR0FBcUIrQyxPQUE1QjtlQUNuQndCLFVBQVVJLGtCQUFrQjlCLE1BQU1tQyxTQUFTRSxpQkFBZixHQUFtQ3JDLE1BQU1vQyxhQUFhQyxpQkFBbkIsR0FBdUNBLG1CQUFtQixJQUEvRyxHQUFzSEEsaUJBQWhJOztBQUtSLGVBQUFDLFVBQTBCQyxLQUFTckMsU0FBbkM7WUFDSyxPQUFPcUMsUUFBUSxVQUFVO2dCQUN0QmIsVUFBVTFCLE1BQU11QyxLQUFLckMsT0FBWCxHQUFxQkEsT0FBL0I7bUJBQ0lyTyxPQUFPMFEsR0FBUCxNQUFnQixVQUFVO2dCQUM5QnZDLE1BQU0wQixVQUF5QmEsS0FBS3JDLE9BQTlCLEdBQXdDQSxPQUE5Qzs7ZUFHQXFDOztBQUtSLGVBQUFDLE1BQXNCQyxNQUFVQyxNQUFVeEMsU0FBMUM7WUFDSyxPQUFPdUMsU0FBUyxVQUFVO2lCQUN0QmYsVUFBVTFCLE1BQU15QyxNQUFNdkMsT0FBWixHQUFzQkEsT0FBaEM7bUJBQ0dyTyxPQUFPNFEsSUFBUCxNQUFpQixVQUFVO2lCQUM5QmYsVUFBeUJlLE1BQU12QyxPQUEvQjs7WUFHSixPQUFPd0MsU0FBUyxVQUFVO2lCQUN0QmhCLFVBQVUxQixNQUFNMEMsTUFBTXhDLE9BQVosR0FBc0JBLE9BQWhDO21CQUNHck8sT0FBTzZRLElBQVAsTUFBaUIsVUFBVTtpQkFDOUJoQixVQUF5QmdCLE1BQU14QyxPQUEvQjs7ZUFHRHVDLFNBQVNDOztBQUdqQixlQUFBQyxnQkFBZ0MvUSxLQUFZc08sU0FBNUM7ZUFDUXRPLE9BQU9BLElBQUlNLFNBQUosRUFBZTRHLFFBQVMsQ0FBQ29ILFdBQVcsQ0FBQ0EsUUFBUUMsTUFBTUUsYUFBYXVDLFNBQVN4QyxhQUFhd0MsUUFBUzNHLFVBQS9GOztBQUdmLGVBQUE0RyxrQkFBa0NqUixLQUFZc08sU0FBOUM7ZUFDUXRPLE9BQU9BLElBQUlNLFNBQUosRUFBZTRHLFFBQVMsQ0FBQ29ILFdBQVcsQ0FBQ0EsUUFBUUMsTUFBTUUsYUFBYWpELGNBQWNnRCxhQUFhaEQsYUFBY2YsV0FBekc7O0FEeGlCZixVQUFNeUcsVUFBMkI7Z0JBQ3ZCO29CQUVJO2VBRUwsU0FBQTlDLE9BQVVuRCxZQUEwQnFELFNBQTdDO2NBRU0sQ0FBQ3JELFdBQVdXLE1BQU07dUJBQ1ZwRixRQUFReUUsV0FBV3pFLFNBQVM7O2lCQUdqQ3lFOzttQkFHSSxTQUFBNkUsV0FBVTdFLFlBQTBCcUQsU0FBakQ7Y0FDUTZDLFNBQVM3SyxPQUFPMkUsV0FBV00sTUFBbEIsRUFBMEI1SyxZQUExQixNQUE0QztjQUd2RHNLLFdBQVcwRCxVQUFVd0MsU0FBUyxNQUFNLE9BQU9sRyxXQUFXMEQsU0FBUyxJQUFJO3VCQUMzREEsT0FBT3hPOztjQUlmLENBQUM4SyxXQUFXYSxNQUFNO3VCQUNWQSxPQUFPOztpQkFPWmI7OztBRDlCVCxVQUFNaUcsWUFBMkI7Z0JBQ3ZCO29CQUNJRSxRQUFLcEM7ZUFDVm9DLFFBQUtoRDttQkFDRGdELFFBQUt0Qjs7QURBbEIsZUFBQXVCLFNBQWtCQyxjQUFsQjtlQUNRLE9BQU9BLGFBQWFILFdBQVcsWUFBWUcsYUFBYUgsU0FBUzdLLE9BQU9nTCxhQUFhL0YsTUFBcEIsRUFBNEI1SyxZQUE1QixNQUE4Qzs7QUFJdkgsVUFBTXVRLFlBQTJCO2dCQUN2QjtvQkFFSTtlQUVMLFNBQUE5QyxPQUFVbkQsWUFBMEJxRCxTQUE3QztjQUNRZ0QsZUFBZXJHO3VCQUdSa0csU0FBU0UsU0FBU0MsWUFBVDt1QkFHVEMsZ0JBQWdCRCxhQUFheEYsUUFBUSxRQUFRd0YsYUFBYXJGLFFBQVEsTUFBTXFGLGFBQWFyRixRQUFRO3VCQUM3RkgsT0FBTzNMO3VCQUNQOEwsUUFBUTlMO2lCQUVkbVI7O21CQUdJLFNBQUF4QixXQUFVd0IsY0FBMkJoRCxTQUFsRDtjQUVNZ0QsYUFBYTNDLFVBQVUwQyxTQUFTQyxZQUFULElBQXlCLE1BQU0sT0FBT0EsYUFBYTNDLFNBQVMsSUFBSTt5QkFDN0VBLE9BQU94Tzs7Y0FJakIsT0FBT21SLGFBQWFILFdBQVcsV0FBVzt5QkFDaEM1RixTQUFVK0YsYUFBYUgsU0FBUyxRQUFRO3lCQUN4Q0EsU0FBU2hSOztjQUluQm1SLGFBQWFDLGNBQWM7d0NBQ1JELGFBQWFDLGFBQWEvUSxNQUFNLEdBQWhDLHFFQUFmc0wsT0FEdUIsdUJBQUEsQ0FBQSxHQUNqQkcsUUFEaUIsdUJBQUEsQ0FBQTt5QkFFakJILE9BQVFBLFFBQVFBLFNBQVMsTUFBTUEsT0FBTzNMO3lCQUN0QzhMLFFBQVFBO3lCQUNSc0YsZUFBZXBSOzt1QkFJaEJnTSxXQUFXaE07aUJBRWpCbVI7OztBRG5EVCxVQUFNSixZQUEyQjtnQkFDdkI7b0JBQ0lNLFVBQUd4QztlQUNSd0MsVUFBR3BEO21CQUNDb0QsVUFBRzFCOztBRFNoQixVQUFNMkIsSUFBa0IsQ0FBQTtBQUN4QixVQUFNblEsUUFBUTtBQUdkLFVBQU1jLGVBQWUsNEJBQTRCZCxRQUFRLDhFQUE4RSxNQUFNO0FBQzdJLFVBQU1LLFdBQVc7QUFDakIsVUFBTUUsZUFBZTlCLE9BQU9BLE9BQU8sWUFBWTRCLFdBQVcsTUFBTUEsV0FBV0EsV0FBVyxNQUFNQSxXQUFXQSxRQUEzRSxJQUF1RixNQUFNNUIsT0FBTyxnQkFBZ0I0QixXQUFXLE1BQU1BLFdBQVdBLFFBQW5ELElBQStELE1BQU01QixPQUFPLE1BQU00QixXQUFXQSxRQUF4QixDQUF6SztBQWFyQixVQUFNK1AsVUFBVTtBQUNoQixVQUFNQyxVQUFVO0FBQ2hCLFVBQU1DLFVBQVVwUyxNQUFNbVMsU0FBUyxXQUFmO0FBUWhCLFVBQU1FLGdCQUFnQjtBQWF0QixVQUFNdkcsYUFBYSxJQUFJbEcsT0FBT2hELGNBQWMsR0FBekI7QUFDbkIsVUFBTW9KLGNBQWMsSUFBSXBHLE9BQU92RCxjQUFjLEdBQXpCO0FBQ3BCLFVBQU1pUSxpQkFBaUIsSUFBSTFNLE9BQU81RixNQUFNLE9BQU9rUyxTQUFTLFNBQVMsU0FBU0UsT0FBeEMsR0FBa0QsR0FBN0Q7QUFFdkIsVUFBTUcsYUFBYSxJQUFJM00sT0FBTzVGLE1BQU0sT0FBTzRDLGNBQWN5UCxhQUEzQixHQUEyQyxHQUF0RDtBQUNuQixVQUFNRyxjQUFjRDtBQUlwQixlQUFBNUcsaUJBQTBCbkwsS0FBMUI7WUFDT29MLFNBQVNYLFlBQVl6SyxHQUFaO2VBQ1AsQ0FBQ29MLE9BQU9DLE1BQU1DLFVBQWIsSUFBMkJ0TCxNQUFNb0w7O0FBRzNDLFVBQU04RixZQUE4QztnQkFDMUM7ZUFFRCxTQUFBLFNBQVVqRyxZQUEwQnFELFNBQTdDO2NBQ1EyRCxtQkFBbUJoSDtjQUNuQmlILEtBQUtELGlCQUFpQkMsS0FBTUQsaUJBQWlCbkcsT0FBT21HLGlCQUFpQm5HLEtBQUt0TCxNQUFNLEdBQTVCLElBQW1DLENBQUE7MkJBQzVFc0wsT0FBTzNMO2NBRXBCOFIsaUJBQWlCaEcsT0FBTztnQkFDdkJrRyxpQkFBaUI7Z0JBQ2ZDLFVBQXdCLENBQUE7Z0JBQ3hCQyxVQUFVSixpQkFBaUJoRyxNQUFNekwsTUFBTSxHQUE3QjtxQkFFUFgsSUFBSSxHQUFHRCxLQUFLeVMsUUFBUTNTLFFBQVFHLElBQUlELElBQUksRUFBRUMsR0FBRztrQkFDM0N5UyxTQUFTRCxRQUFReFMsQ0FBUixFQUFXVyxNQUFNLEdBQWpCO3NCQUVQOFIsT0FBTyxDQUFQLEdBQVI7cUJBQ007c0JBQ0VDLFVBQVVELE9BQU8sQ0FBUCxFQUFVOVIsTUFBTSxHQUFoQjsyQkFDUFgsS0FBSSxHQUFHRCxNQUFLMlMsUUFBUTdTLFFBQVFHLEtBQUlELEtBQUksRUFBRUMsSUFBRzt1QkFDOUM4SCxLQUFLNEssUUFBUTFTLEVBQVIsQ0FBUjs7O3FCQUdHO21DQUNhMlMsVUFBVXZCLGtCQUFrQnFCLE9BQU8sQ0FBUCxHQUFXaEUsT0FBN0I7O3FCQUV2QjttQ0FDYW1FLE9BQU94QixrQkFBa0JxQixPQUFPLENBQVAsR0FBV2hFLE9BQTdCOzs7bUNBR1A7MEJBQ1QyQyxrQkFBa0JxQixPQUFPLENBQVAsR0FBV2hFLE9BQTdCLENBQVIsSUFBaUQyQyxrQkFBa0JxQixPQUFPLENBQVAsR0FBV2hFLE9BQTdCOzs7O2dCQUtoRDZEO0FBQWdCRiwrQkFBaUJHLFVBQVVBOzsyQkFHL0JuRyxRQUFROUw7bUJBRWhCTixNQUFJLEdBQUdELE9BQUtzUyxHQUFHeFMsUUFBUUcsTUFBSUQsTUFBSSxFQUFFQyxLQUFHO2dCQUN0QzZTLE9BQU9SLEdBQUdyUyxHQUFILEVBQU1XLE1BQU0sR0FBWjtpQkFFUixDQUFMLElBQVV5USxrQkFBa0J5QixLQUFLLENBQUwsQ0FBbEI7Z0JBRU4sQ0FBQ3BFLFFBQVFTLGdCQUFnQjtrQkFFeEI7cUJBQ0UsQ0FBTCxJQUFVNUUsU0FBU0QsUUFBUStHLGtCQUFrQnlCLEtBQUssQ0FBTCxHQUFTcEUsT0FBM0IsRUFBb0MzTixZQUFwQyxDQUFqQjt1QkFDRjZKLEdBQVA7aUNBQ2dCaEUsUUFBUXlMLGlCQUFpQnpMLFNBQVMsNkVBQTZFZ0U7O21CQUUzSDttQkFDRCxDQUFMLElBQVV5RyxrQkFBa0J5QixLQUFLLENBQUwsR0FBU3BFLE9BQTNCLEVBQW9DM04sWUFBcEM7O2VBR1JkLEdBQUgsSUFBUTZTLEtBQUs1UyxLQUFLLEdBQVY7O2lCQUdGbVM7O21CQUdJLFNBQUEsYUFBVUEsa0JBQW1DM0QsU0FBMUQ7Y0FDUXJELGFBQWFnSDtjQUNiQyxLQUFLclIsUUFBUW9SLGlCQUFpQkMsRUFBekI7Y0FDUEEsSUFBSTtxQkFDRXJTLElBQUksR0FBR0QsS0FBS3NTLEdBQUd4UyxRQUFRRyxJQUFJRCxJQUFJLEVBQUVDLEdBQUc7a0JBQ3RDOFMsU0FBU3JNLE9BQU80TCxHQUFHclMsQ0FBSCxDQUFQO2tCQUNUK1MsUUFBUUQsT0FBTzVKLFlBQVksR0FBbkI7a0JBQ1I4SixZQUFhRixPQUFPaFQsTUFBTSxHQUFHaVQsS0FBaEIsRUFBd0IxTCxRQUFRc0UsYUFBYUwsZ0JBQTlDLEVBQWdFakUsUUFBUXNFLGFBQWE1SyxXQUFyRixFQUFrR3NHLFFBQVE0SyxnQkFBZ0J6SCxVQUExSDtrQkFDZHlJLFNBQVNILE9BQU9oVCxNQUFNaVQsUUFBUSxDQUFyQjtrQkFHVDt5QkFDTyxDQUFDdEUsUUFBUUMsTUFBTXBFLFNBQVNELFFBQVErRyxrQkFBa0I2QixRQUFReEUsT0FBMUIsRUFBbUMzTixZQUFuQyxDQUFqQixJQUFxRXdKLFNBQVNILFVBQVU4SSxNQUFuQjt1QkFDdEZ0SSxHQUFQOzJCQUNVaEUsUUFBUXlFLFdBQVd6RSxTQUFTLDBEQUEwRCxDQUFDOEgsUUFBUUMsTUFBTSxVQUFVLGFBQWEsb0JBQW9CL0Q7O2lCQUd6SjNLLENBQUgsSUFBUWdULFlBQVksTUFBTUM7O3VCQUdoQmhILE9BQU9vRyxHQUFHcFMsS0FBSyxHQUFSOztjQUdic1MsVUFBVUgsaUJBQWlCRyxVQUFVSCxpQkFBaUJHLFdBQVcsQ0FBQTtjQUVuRUgsaUJBQWlCTztBQUFTSixvQkFBUSxTQUFSLElBQXFCSCxpQkFBaUJPO2NBQ2hFUCxpQkFBaUJRO0FBQU1MLG9CQUFRLE1BQVIsSUFBa0JILGlCQUFpQlE7Y0FFeERwRixTQUFTLENBQUE7bUJBQ0owRixRQUFRWCxTQUFTO2dCQUN2QkEsUUFBUVcsSUFBUixNQUFrQnRCLEVBQUVzQixJQUFGLEdBQVM7cUJBQ3ZCcEwsS0FDTm9MLEtBQUs3TCxRQUFRc0UsYUFBYUwsZ0JBQTFCLEVBQTRDakUsUUFBUXNFLGFBQWE1SyxXQUFqRSxFQUE4RXNHLFFBQVE2SyxZQUFZMUgsVUFBbEcsSUFDQSxNQUNBK0gsUUFBUVcsSUFBUixFQUFjN0wsUUFBUXNFLGFBQWFMLGdCQUFuQyxFQUFxRGpFLFFBQVFzRSxhQUFhNUssV0FBMUUsRUFBdUZzRyxRQUFROEssYUFBYTNILFVBQTVHLENBSEQ7OztjQU9FZ0QsT0FBTzNOLFFBQVE7dUJBQ1B1TSxRQUFRb0IsT0FBT3ZOLEtBQUssR0FBWjs7aUJBR2JtTDs7O0FEL0pULFVBQU0rSCxZQUFZO0FBSWxCLFVBQU05QixZQUFxRDtnQkFDakQ7ZUFFRCxTQUFBLFNBQVVqRyxZQUEwQnFELFNBQTdDO2NBQ1EvQixVQUFVdEIsV0FBV2EsUUFBUWIsV0FBV2EsS0FBS1QsTUFBTTJILFNBQXRCO2NBQy9CQyxnQkFBZ0JoSTtjQUVoQnNCLFNBQVM7Z0JBQ05oQixTQUFTK0MsUUFBUS9DLFVBQVUwSCxjQUFjMUgsVUFBVTtnQkFDbkQySCxNQUFNM0csUUFBUSxDQUFSLEVBQVc1TCxZQUFYO2dCQUNOd1MsTUFBTTVHLFFBQVEsQ0FBUjtnQkFDTjZHLFlBQWU3SCxTQUFmLE9BQXlCK0MsUUFBUTRFLE9BQU9BO2dCQUN4Q3BFLGdCQUFnQjFFLFFBQVFnSixTQUFSOzBCQUVSRixNQUFNQTswQkFDTkMsTUFBTUE7MEJBQ05ySCxPQUFPM0w7Z0JBRWpCMk8sZUFBZTs4QkFDRkEsY0FBY1YsTUFBTTZFLGVBQWUzRSxPQUFuQzs7aUJBRVg7MEJBQ1E5SCxRQUFReU0sY0FBY3pNLFNBQVM7O2lCQUd2Q3lNOzttQkFHSSxTQUFBLGFBQVVBLGVBQTZCM0UsU0FBcEQ7Y0FDUS9DLFNBQVMrQyxRQUFRL0MsVUFBVTBILGNBQWMxSCxVQUFVO2NBQ25EMkgsTUFBTUQsY0FBY0M7Y0FDcEJFLFlBQWU3SCxTQUFmLE9BQXlCK0MsUUFBUTRFLE9BQU9BO2NBQ3hDcEUsZ0JBQWdCMUUsUUFBUWdKLFNBQVI7Y0FFbEJ0RSxlQUFlOzRCQUNGQSxjQUFjZ0IsVUFBVW1ELGVBQWUzRSxPQUF2Qzs7Y0FHWCtFLGdCQUFnQko7Y0FDaEJFLE1BQU1GLGNBQWNFO3dCQUNackgsUUFBVW9ILE9BQU81RSxRQUFRNEUsT0FBdkMsTUFBOENDO2lCQUV2Q0U7OztBRHhEVCxVQUFNQyxPQUFPO0FBSWIsVUFBTXBDLFlBQXNFO2dCQUNsRTtlQUVELFNBQUE5QyxPQUFVNkUsZUFBNkIzRSxTQUFoRDtjQUNRaUYsaUJBQWlCTjt5QkFDUk8sT0FBT0QsZUFBZUo7eUJBQ3RCQSxNQUFNaFQ7Y0FFakIsQ0FBQ21PLFFBQVErQixhQUFhLENBQUNrRCxlQUFlQyxRQUFRLENBQUNELGVBQWVDLEtBQUtuSSxNQUFNaUksSUFBMUIsSUFBa0M7MkJBQ3JFOU0sUUFBUStNLGVBQWUvTSxTQUFTOztpQkFHekMrTTs7bUJBR0ksU0FBQXpELFdBQVV5RCxnQkFBK0JqRixTQUF0RDtjQUNRMkUsZ0JBQWdCTTt3QkFFUkosT0FBT0ksZUFBZUMsUUFBUSxJQUFJN1MsWUFBNUI7aUJBQ2JzUzs7O0FENUJUN0ksY0FBUWdILFFBQUs3RixNQUFiLElBQXVCNkY7QUFHdkJoSCxjQUFRcUosVUFBTWxJLE1BQWQsSUFBd0JrSTtBQUd4QnJKLGNBQVFvSCxVQUFHakcsTUFBWCxJQUFxQmlHO0FBR3JCcEgsY0FBUXNKLFVBQUluSSxNQUFaLElBQXNCbUk7QUFHdEJ0SixjQUFRdUosVUFBT3BJLE1BQWYsSUFBeUJvSTtBQUd6QnZKLGNBQVF3SixVQUFJckksTUFBWixJQUFzQnFJO0FBR3RCeEosY0FBUW9KLFVBQUtqSSxNQUFiLElBQXVCaUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FhckJ2QixRQUFBLE1BQUE7QUFHRSxRQUFZLE9BQU87QUFFckIsWUFBQSxVQUFlOzs7Ozs7Ozs7O0FDdUJmLFFBQUEsYUFBQTtBQUFRLFdBQUEsZUFBQSxTQUFBLGNBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxXQUFBO0lBQVUsRUFBQSxDQUFBO0FBS2xCLFFBQUEsWUFBQTtBQUFRLFdBQUEsZUFBQSxTQUFBLEtBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxVQUFBO0lBQUMsRUFBQSxDQUFBO0FBQUUsV0FBQSxlQUFBLFNBQUEsT0FBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFVBQUE7SUFBRyxFQUFBLENBQUE7QUFBRSxXQUFBLGVBQUEsU0FBQSxhQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsVUFBQTtJQUFTLEVBQUEsQ0FBQTtBQUFFLFdBQUEsZUFBQSxTQUFBLE9BQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxVQUFBO0lBQUcsRUFBQSxDQUFBO0FBQUUsV0FBQSxlQUFBLFNBQUEsUUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFVBQUE7SUFBSSxFQUFBLENBQUE7QUFBUSxXQUFBLGVBQUEsU0FBQSxXQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsVUFBQTtJQUFPLEVBQUEsQ0FBQTtBQXNCbkQsUUFBQSxxQkFBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsYUFBQTtBQUNBLFFBQUEsU0FBQTtBQUNBLFFBQUEsaUJBQUE7QUFFQSxRQUFBLFFBQUE7QUFFQSxRQUFNLGdCQUE4QixDQUFDLEtBQUssVUFBVSxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQ3pFLGtCQUFjLE9BQU87QUFFckIsUUFBTSxzQkFBeUMsQ0FBQyxvQkFBb0IsZUFBZSxhQUFhO0FBQ2hHLFFBQU0sa0JBQWtCLG9CQUFJLElBQUk7TUFDOUI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7S0FDRDtBQXlHRCxRQUFNLGlCQUE4QztNQUNsRCxlQUFlO01BQ2YsUUFBUTtNQUNSLFVBQVU7TUFDVixjQUFjO01BQ2QsWUFBWTtNQUNaLGFBQWE7TUFDYixhQUFhO01BQ2IsWUFBWTtNQUNaLGdCQUFnQjtNQUNoQixnQkFBZ0I7TUFDaEIsYUFBYTtNQUNiLGdCQUFnQjtNQUNoQixPQUFPO01BQ1AsV0FBVztNQUNYLFdBQVc7O0FBR2IsUUFBTSxvQkFBb0Q7TUFDeEQsdUJBQXVCO01BQ3ZCLGtCQUFrQjtNQUNsQixTQUFTOztBQTBCWCxRQUFNLGlCQUFpQjtBQUd2QixhQUFTLGdCQUFnQixHQUFVOztBQUNqQyxZQUFNLElBQUksRUFBRTtBQUNaLFlBQU0sU0FBUUssTUFBQSxFQUFFLFVBQUksUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUU7QUFDdEIsWUFBTSxXQUFXLFVBQVUsUUFBUSxVQUFVLFNBQVksSUFBSSxTQUFTO0FBQ3RFLFlBQU0sVUFBUyxNQUFBLEtBQUEsRUFBRSxVQUFJLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRSxZQUFNLFFBQUEsT0FBQSxTQUFBLEtBQUk7QUFDakMsWUFBTSxlQUFjLEtBQUEsRUFBRSxpQkFBVyxRQUFBLE9BQUEsU0FBQSxLQUFJLE1BQUE7QUFDckMsYUFBTztRQUNMLGVBQWMsTUFBQSxLQUFBLEVBQUUsa0JBQVksUUFBQSxPQUFBLFNBQUEsS0FBSSxPQUFDLFFBQUEsT0FBQSxTQUFBLEtBQUk7UUFDckMsZ0JBQWUsTUFBQSxLQUFBLEVBQUUsbUJBQWEsUUFBQSxPQUFBLFNBQUEsS0FBSSxPQUFDLFFBQUEsT0FBQSxTQUFBLEtBQUk7UUFDdkMsY0FBYSxNQUFBLEtBQUEsRUFBRSxpQkFBVyxRQUFBLE9BQUEsU0FBQSxLQUFJLE9BQUMsUUFBQSxPQUFBLFNBQUEsS0FBSTtRQUNuQyxlQUFjLE1BQUEsS0FBQSxFQUFFLGtCQUFZLFFBQUEsT0FBQSxTQUFBLEtBQUksT0FBQyxRQUFBLE9BQUEsU0FBQSxLQUFJO1FBQ3JDLGlCQUFnQixNQUFBLEtBQUEsRUFBRSxvQkFBYyxRQUFBLE9BQUEsU0FBQSxLQUFJLE9BQUMsUUFBQSxPQUFBLFNBQUEsS0FBSTtRQUN6QyxNQUFNLEVBQUUsT0FBTyxFQUFDLEdBQUcsRUFBRSxNQUFNLFVBQVUsT0FBTSxJQUFJLEVBQUMsVUFBVSxPQUFNO1FBQ2hFLGVBQWMsS0FBQSxFQUFFLGtCQUFZLFFBQUEsT0FBQSxTQUFBLEtBQUk7UUFDaEMsV0FBVSxLQUFBLEVBQUUsY0FBUSxRQUFBLE9BQUEsU0FBQSxLQUFJO1FBQ3hCLE9BQU0sS0FBQSxFQUFFLFVBQUksUUFBQSxPQUFBLFNBQUEsS0FBSTtRQUNoQixXQUFVLEtBQUEsRUFBRSxjQUFRLFFBQUEsT0FBQSxTQUFBLEtBQUk7UUFDeEIsYUFBWSxLQUFBLEVBQUUsZ0JBQVUsUUFBQSxPQUFBLFNBQUEsS0FBSTtRQUM1QixXQUFVLEtBQUEsRUFBRSxjQUFRLFFBQUEsT0FBQSxTQUFBLEtBQUk7UUFDeEIsZ0JBQWUsS0FBQSxFQUFFLG1CQUFhLFFBQUEsT0FBQSxTQUFBLEtBQUk7UUFDbEMsaUJBQWdCLEtBQUEsRUFBRSxvQkFBYyxRQUFBLE9BQUEsU0FBQSxLQUFJO1FBQ3BDLGtCQUFpQixLQUFBLEVBQUUscUJBQWUsUUFBQSxPQUFBLFNBQUEsS0FBSTtRQUN0QyxnQkFBZSxLQUFBLEVBQUUsbUJBQWEsUUFBQSxPQUFBLFNBQUEsS0FBSTtRQUNsQyxhQUFZLEtBQUEsRUFBRSxnQkFBVSxRQUFBLE9BQUEsU0FBQSxLQUFJO1FBQzVCOztJQUVKO0FBUUEsUUFBcUIsTUFBckIsTUFBd0I7TUFrQnRCLFlBQVksT0FBZ0IsQ0FBQSxHQUFFO0FBWnJCLGFBQUEsVUFBeUMsQ0FBQTtBQUN6QyxhQUFBLE9BQStDLENBQUE7QUFDL0MsYUFBQSxVQUE0QyxDQUFBO0FBRTVDLGFBQUEsZ0JBQWdDLG9CQUFJLElBQUc7QUFDL0IsYUFBQSxXQUF5RCxDQUFBO0FBQ3pELGFBQUEsU0FBb0Msb0JBQUksSUFBRztBQU8xRCxlQUFPLEtBQUssT0FBTyxFQUFDLEdBQUcsTUFBTSxHQUFHLGdCQUFnQixJQUFJLEVBQUM7QUFDckQsY0FBTSxFQUFDLEtBQUssTUFBSyxJQUFJLEtBQUssS0FBSztBQUUvQixhQUFLLFFBQVEsSUFBSSxVQUFBLFdBQVcsRUFBQyxPQUFPLENBQUEsR0FBSSxVQUFVLGlCQUFpQixLQUFLLE1BQUssQ0FBQztBQUM5RSxhQUFLLFNBQVMsVUFBVSxLQUFLLE1BQU07QUFDbkMsY0FBTSxZQUFZLEtBQUs7QUFDdkIsYUFBSyxrQkFBa0I7QUFFdkIsYUFBSyxTQUFRLEdBQUEsUUFBQSxVQUFRO0FBQ3JCLHFCQUFhLEtBQUssTUFBTSxnQkFBZ0IsTUFBTSxlQUFlO0FBQzdELHFCQUFhLEtBQUssTUFBTSxtQkFBbUIsTUFBTSxjQUFjLE1BQU07QUFDckUsYUFBSyxZQUFZLHFCQUFxQixLQUFLLElBQUk7QUFFL0MsWUFBSSxLQUFLO0FBQVMsNEJBQWtCLEtBQUssSUFBSTtBQUM3QyxhQUFLLGlCQUFnQjtBQUNyQixhQUFLLHNCQUFxQjtBQUMxQixZQUFJLEtBQUs7QUFBVSw2QkFBbUIsS0FBSyxNQUFNLEtBQUssUUFBUTtBQUM5RCxZQUFJLE9BQU8sS0FBSyxRQUFRO0FBQVUsZUFBSyxjQUFjLEtBQUssSUFBSTtBQUM5RCwwQkFBa0IsS0FBSyxJQUFJO0FBQzNCLGFBQUssa0JBQWtCO01BQ3pCO01BRUEsbUJBQWdCO0FBQ2QsYUFBSyxXQUFXLFFBQVE7TUFDMUI7TUFFQSx3QkFBcUI7QUFDbkIsY0FBTSxFQUFDLE9BQU8sTUFBTSxTQUFRLElBQUksS0FBSztBQUNyQyxZQUFJLGlCQUErQjtBQUNuQyxZQUFJLGFBQWEsTUFBTTtBQUNyQiwyQkFBaUIsRUFBQyxHQUFHLGVBQWM7QUFDbkMseUJBQWUsS0FBSyxlQUFlO0FBQ25DLGlCQUFPLGVBQWU7O0FBRXhCLFlBQUksUUFBUTtBQUFPLGVBQUssY0FBYyxnQkFBZ0IsZUFBZSxRQUFRLEdBQUcsS0FBSztNQUN2RjtNQUVBLGNBQVc7QUFDVCxjQUFNLEVBQUMsTUFBTSxTQUFRLElBQUksS0FBSztBQUM5QixlQUFRLEtBQUssS0FBSyxjQUFjLE9BQU8sUUFBUSxXQUFXLEtBQUssUUFBUSxLQUFLLE9BQU87TUFDckY7TUFrQkEsU0FDRSxjQUNBO0FBRUEsWUFBSTtBQUNKLFlBQUksT0FBTyxnQkFBZ0IsVUFBVTtBQUNuQyxjQUFJLEtBQUssVUFBYSxZQUFZO0FBQ2xDLGNBQUksQ0FBQztBQUFHLGtCQUFNLElBQUksTUFBTSw4QkFBOEIsZUFBZTtlQUNoRTtBQUNMLGNBQUksS0FBSyxRQUFXLFlBQVk7O0FBR2xDLGNBQU0sUUFBUSxFQUFFLElBQUk7QUFDcEIsWUFBSSxFQUFFLFlBQVk7QUFBSSxlQUFLLFNBQVMsRUFBRTtBQUN0QyxlQUFPO01BQ1Q7TUFnQkEsUUFBcUIsUUFBbUIsT0FBZTtBQUNyRCxjQUFNLE1BQU0sS0FBSyxXQUFXLFFBQVEsS0FBSztBQUN6QyxlQUFRLElBQUksWUFBWSxLQUFLLGtCQUFrQixHQUFHO01BQ3BEO01BbUJBLGFBQ0UsUUFDQSxNQUFjO0FBRWQsWUFBSSxPQUFPLEtBQUssS0FBSyxjQUFjLFlBQVk7QUFDN0MsZ0JBQU0sSUFBSSxNQUFNLHlDQUF5Qzs7QUFFM0QsY0FBTSxFQUFDLFdBQVUsSUFBSSxLQUFLO0FBQzFCLGVBQU8sZ0JBQWdCLEtBQUssTUFBTSxRQUFRLElBQUk7QUFFOUMsdUJBQWUsZ0JBRWIsU0FDQSxPQUFlO0FBRWYsZ0JBQU0sZUFBZSxLQUFLLE1BQU0sUUFBUSxPQUFPO0FBQy9DLGdCQUFNLE1BQU0sS0FBSyxXQUFXLFNBQVMsS0FBSztBQUMxQyxpQkFBTyxJQUFJLFlBQVksY0FBYyxLQUFLLE1BQU0sR0FBRztRQUNyRDtBQUVBLHVCQUFlLGVBQTBCLE1BQWE7QUFDcEQsY0FBSSxRQUFRLENBQUMsS0FBSyxVQUFVLElBQUksR0FBRztBQUNqQyxrQkFBTSxnQkFBZ0IsS0FBSyxNQUFNLEVBQUMsS0FBSSxHQUFHLElBQUk7O1FBRWpEO0FBRUEsdUJBQWUsY0FBeUIsS0FBYztBQUNwRCxjQUFJO0FBQ0YsbUJBQU8sS0FBSyxrQkFBa0IsR0FBRzttQkFDMUIsR0FBUDtBQUNBLGdCQUFJLEVBQUUsYUFBYSxZQUFBO0FBQWtCLG9CQUFNO0FBQzNDLHdCQUFZLEtBQUssTUFBTSxDQUFDO0FBQ3hCLGtCQUFNLGtCQUFrQixLQUFLLE1BQU0sRUFBRSxhQUFhO0FBQ2xELG1CQUFPLGNBQWMsS0FBSyxNQUFNLEdBQUc7O1FBRXZDO0FBRUEsaUJBQVMsWUFBdUIsRUFBQyxlQUFlLEtBQUssV0FBVSxHQUFrQjtBQUMvRSxjQUFJLEtBQUssS0FBSyxHQUFHLEdBQUc7QUFDbEIsa0JBQU0sSUFBSSxNQUFNLGFBQWEscUJBQXFCLCtCQUErQjs7UUFFckY7QUFFQSx1QkFBZSxrQkFBNkIsS0FBVztBQUNyRCxnQkFBTSxVQUFVLE1BQU0sWUFBWSxLQUFLLE1BQU0sR0FBRztBQUNoRCxjQUFJLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBRyxrQkFBTSxlQUFlLEtBQUssTUFBTSxRQUFRLE9BQU87QUFDcEUsY0FBSSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUcsaUJBQUssVUFBVSxTQUFTLEtBQUssSUFBSTtRQUN4RDtBQUVBLHVCQUFlLFlBQXVCLEtBQVc7QUFDL0MsZ0JBQU0sSUFBSSxLQUFLLFNBQVMsR0FBRztBQUMzQixjQUFJO0FBQUcsbUJBQU87QUFDZCxjQUFJO0FBQ0YsbUJBQU8sT0FBTyxLQUFLLFNBQVMsR0FBRyxJQUFJLFdBQVcsR0FBRzs7QUFFakQsbUJBQU8sS0FBSyxTQUFTLEdBQUc7O1FBRTVCO01BQ0Y7O01BR0EsVUFDRSxRQUNBLEtBQ0EsT0FDQSxrQkFBa0IsS0FBSyxLQUFLO0FBRTVCLFlBQUksTUFBTSxRQUFRLE1BQU0sR0FBRztBQUN6QixxQkFBVyxPQUFPO0FBQVEsaUJBQUssVUFBVSxLQUFLLFFBQVcsT0FBTyxlQUFlO0FBQy9FLGlCQUFPOztBQUVULFlBQUk7QUFDSixZQUFJLE9BQU8sV0FBVyxVQUFVO0FBQzlCLGdCQUFNLEVBQUMsU0FBUSxJQUFJLEtBQUs7QUFDeEIsZUFBSyxPQUFPLFFBQVE7QUFDcEIsY0FBSSxPQUFPLFVBQWEsT0FBTyxNQUFNLFVBQVU7QUFDN0Msa0JBQU0sSUFBSSxNQUFNLFVBQVUseUJBQXlCOzs7QUFHdkQsZUFBTSxHQUFBLFVBQUEsYUFBWSxPQUFPLEVBQUU7QUFDM0IsYUFBSyxhQUFhLEdBQUc7QUFDckIsYUFBSyxRQUFRLEdBQUcsSUFBSSxLQUFLLFdBQVcsUUFBUSxPQUFPLEtBQUssaUJBQWlCLElBQUk7QUFDN0UsZUFBTztNQUNUOzs7TUFJQSxjQUNFLFFBQ0EsS0FDQSxrQkFBa0IsS0FBSyxLQUFLO0FBRTVCLGFBQUssVUFBVSxRQUFRLEtBQUssTUFBTSxlQUFlO0FBQ2pELGVBQU87TUFDVDs7TUFHQSxlQUFlLFFBQW1CLGlCQUF5QjtBQUN6RCxZQUFJLE9BQU8sVUFBVTtBQUFXLGlCQUFPO0FBQ3ZDLFlBQUk7QUFDSixrQkFBVSxPQUFPO0FBQ2pCLFlBQUksWUFBWSxVQUFhLE9BQU8sV0FBVyxVQUFVO0FBQ3ZELGdCQUFNLElBQUksTUFBTSwwQkFBMEI7O0FBRTVDLGtCQUFVLFdBQVcsS0FBSyxLQUFLLGVBQWUsS0FBSyxZQUFXO0FBQzlELFlBQUksQ0FBQyxTQUFTO0FBQ1osZUFBSyxPQUFPLEtBQUssMkJBQTJCO0FBQzVDLGVBQUssU0FBUztBQUNkLGlCQUFPOztBQUVULGNBQU0sUUFBUSxLQUFLLFNBQVMsU0FBUyxNQUFNO0FBQzNDLFlBQUksQ0FBQyxTQUFTLGlCQUFpQjtBQUM3QixnQkFBTSxVQUFVLHdCQUF3QixLQUFLLFdBQVU7QUFDdkQsY0FBSSxLQUFLLEtBQUssbUJBQW1CO0FBQU8saUJBQUssT0FBTyxNQUFNLE9BQU87O0FBQzVELGtCQUFNLElBQUksTUFBTSxPQUFPOztBQUU5QixlQUFPO01BQ1Q7OztNQUlBLFVBQXVCLFFBQWM7QUFDbkMsWUFBSTtBQUNKLGVBQU8sUUFBUSxNQUFNLFVBQVUsS0FBSyxNQUFNLE1BQU0sTUFBTTtBQUFVLG1CQUFTO0FBQ3pFLFlBQUksUUFBUSxRQUFXO0FBQ3JCLGdCQUFNLEVBQUMsU0FBUSxJQUFJLEtBQUs7QUFDeEIsZ0JBQU0sT0FBTyxJQUFJLFVBQUEsVUFBVSxFQUFDLFFBQVEsQ0FBQSxHQUFJLFNBQVEsQ0FBQztBQUNqRCxnQkFBTSxVQUFBLGNBQWMsS0FBSyxNQUFNLE1BQU0sTUFBTTtBQUMzQyxjQUFJLENBQUM7QUFBSztBQUNWLGVBQUssS0FBSyxNQUFNLElBQUk7O0FBRXRCLGVBQVEsSUFBSSxZQUFZLEtBQUssa0JBQWtCLEdBQUc7TUFDcEQ7Ozs7O01BTUEsYUFBYSxjQUEwQztBQUNyRCxZQUFJLHdCQUF3QixRQUFRO0FBQ2xDLGVBQUssa0JBQWtCLEtBQUssU0FBUyxZQUFZO0FBQ2pELGVBQUssa0JBQWtCLEtBQUssTUFBTSxZQUFZO0FBQzlDLGlCQUFPOztBQUVULGdCQUFRLE9BQU8sY0FBYztVQUMzQixLQUFLO0FBQ0gsaUJBQUssa0JBQWtCLEtBQUssT0FBTztBQUNuQyxpQkFBSyxrQkFBa0IsS0FBSyxJQUFJO0FBQ2hDLGlCQUFLLE9BQU8sTUFBSztBQUNqQixtQkFBTztVQUNULEtBQUssVUFBVTtBQUNiLGtCQUFNLE1BQU0sVUFBVSxLQUFLLE1BQU0sWUFBWTtBQUM3QyxnQkFBSSxPQUFPLE9BQU87QUFBVSxtQkFBSyxPQUFPLE9BQU8sSUFBSSxNQUFNO0FBQ3pELG1CQUFPLEtBQUssUUFBUSxZQUFZO0FBQ2hDLG1CQUFPLEtBQUssS0FBSyxZQUFZO0FBQzdCLG1CQUFPOztVQUVULEtBQUssVUFBVTtBQUNiLGtCQUFNLFdBQVc7QUFDakIsaUJBQUssT0FBTyxPQUFPLFFBQVE7QUFDM0IsZ0JBQUksS0FBSyxhQUFhLEtBQUssS0FBSyxRQUFRO0FBQ3hDLGdCQUFJLElBQUk7QUFDTixvQkFBSyxHQUFBLFVBQUEsYUFBWSxFQUFFO0FBQ25CLHFCQUFPLEtBQUssUUFBUSxFQUFFO0FBQ3RCLHFCQUFPLEtBQUssS0FBSyxFQUFFOztBQUVyQixtQkFBTzs7VUFFVDtBQUNFLGtCQUFNLElBQUksTUFBTSxxQ0FBcUM7O01BRTNEOztNQUdBLGNBQWMsYUFBdUI7QUFDbkMsbUJBQVcsT0FBTztBQUFhLGVBQUssV0FBVyxHQUFHO0FBQ2xELGVBQU87TUFDVDtNQUVBLFdBQ0UsVUFDQTtBQUVBLFlBQUk7QUFDSixZQUFJLE9BQU8sWUFBWSxVQUFVO0FBQy9CLG9CQUFVO0FBQ1YsY0FBSSxPQUFPLE9BQU8sVUFBVTtBQUMxQixpQkFBSyxPQUFPLEtBQUssMERBQTBEO0FBQzNFLGdCQUFJLFVBQVU7O21CQUVQLE9BQU8sWUFBWSxZQUFZLFFBQVEsUUFBVztBQUMzRCxnQkFBTTtBQUNOLG9CQUFVLElBQUk7QUFDZCxjQUFJLE1BQU0sUUFBUSxPQUFPLEtBQUssQ0FBQyxRQUFRLFFBQVE7QUFDN0Msa0JBQU0sSUFBSSxNQUFNLHdEQUF3RDs7ZUFFckU7QUFDTCxnQkFBTSxJQUFJLE1BQU0sZ0NBQWdDOztBQUdsRCxxQkFBYSxLQUFLLE1BQU0sU0FBUyxHQUFHO0FBQ3BDLFlBQUksQ0FBQyxLQUFLO0FBQ1IsV0FBQSxHQUFBLE9BQUEsVUFBUyxTQUFTLENBQUMsUUFBUSxRQUFRLEtBQUssTUFBTSxHQUFHLENBQUM7QUFDbEQsaUJBQU87O0FBRVQsMEJBQWtCLEtBQUssTUFBTSxHQUFHO0FBQ2hDLGNBQU0sYUFBcUM7VUFDekMsR0FBRztVQUNILE9BQU0sR0FBQSxXQUFBLGNBQWEsSUFBSSxJQUFJO1VBQzNCLGFBQVksR0FBQSxXQUFBLGNBQWEsSUFBSSxVQUFVOztBQUV6QyxTQUFBLEdBQUEsT0FBQSxVQUNFLFNBQ0EsV0FBVyxLQUFLLFdBQVcsSUFDdkIsQ0FBQyxNQUFNLFFBQVEsS0FBSyxNQUFNLEdBQUcsVUFBVSxJQUN2QyxDQUFDLE1BQU0sV0FBVyxLQUFLLFFBQVEsQ0FBQyxNQUFNLFFBQVEsS0FBSyxNQUFNLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztBQUVqRixlQUFPO01BQ1Q7TUFFQSxXQUFXLFNBQWU7QUFDeEIsY0FBTSxPQUFPLEtBQUssTUFBTSxJQUFJLE9BQU87QUFDbkMsZUFBTyxPQUFPLFFBQVEsV0FBVyxLQUFLLGFBQWEsQ0FBQyxDQUFDO01BQ3ZEOztNQUdBLGNBQWMsU0FBZTtBQUUzQixjQUFNLEVBQUMsTUFBSyxJQUFJO0FBQ2hCLGVBQU8sTUFBTSxTQUFTLE9BQU87QUFDN0IsZUFBTyxNQUFNLElBQUksT0FBTztBQUN4QixtQkFBVyxTQUFTLE1BQU0sT0FBTztBQUMvQixnQkFBTSxJQUFJLE1BQU0sTUFBTSxVQUFVLENBQUMsU0FBUyxLQUFLLFlBQVksT0FBTztBQUNsRSxjQUFJLEtBQUs7QUFBRyxrQkFBTSxNQUFNLE9BQU8sR0FBRyxDQUFDOztBQUVyQyxlQUFPO01BQ1Q7O01BR0EsVUFBVSxNQUFjLFFBQWM7QUFDcEMsWUFBSSxPQUFPLFVBQVU7QUFBVSxtQkFBUyxJQUFJLE9BQU8sTUFBTTtBQUN6RCxhQUFLLFFBQVEsSUFBSSxJQUFJO0FBQ3JCLGVBQU87TUFDVDtNQUVBLFdBQ0UsU0FBMkMsS0FBSyxRQUNoRCxFQUFDLFlBQVksTUFBTSxVQUFVLE9BQU0sSUFBdUIsQ0FBQTtBQUUxRCxZQUFJLENBQUMsVUFBVSxPQUFPLFdBQVc7QUFBRyxpQkFBTztBQUMzQyxlQUFPLE9BQ0osSUFBSSxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxFQUNyRCxPQUFPLENBQUMsTUFBTSxRQUFRLE9BQU8sWUFBWSxHQUFHO01BQ2pEO01BRUEsZ0JBQWdCLFlBQTZCLHNCQUE4QjtBQUN6RSxjQUFNLFFBQVEsS0FBSyxNQUFNO0FBQ3pCLHFCQUFhLEtBQUssTUFBTSxLQUFLLFVBQVUsVUFBVSxDQUFDO0FBQ2xELG1CQUFXLGVBQWUsc0JBQXNCO0FBQzlDLGdCQUFNLFdBQVcsWUFBWSxNQUFNLEdBQUcsRUFBRSxNQUFNLENBQUM7QUFDL0MsY0FBSSxXQUFXO0FBQ2YscUJBQVcsT0FBTztBQUFVLHVCQUFXLFNBQVMsR0FBRztBQUVuRCxxQkFBVyxPQUFPLE9BQU87QUFDdkIsa0JBQU0sT0FBTyxNQUFNLEdBQUc7QUFDdEIsZ0JBQUksT0FBTyxRQUFRO0FBQVU7QUFDN0Isa0JBQU0sRUFBQyxNQUFLLElBQUksS0FBSztBQUNyQixrQkFBTSxTQUFTLFNBQVMsR0FBRztBQUMzQixnQkFBSSxTQUFTO0FBQVEsdUJBQVMsR0FBRyxJQUFJLGFBQWEsTUFBTTs7O0FBSTVELGVBQU87TUFDVDtNQUVRLGtCQUFrQixTQUFpRCxPQUFjO0FBQ3ZGLG1CQUFXLFVBQVUsU0FBUztBQUM1QixnQkFBTSxNQUFNLFFBQVEsTUFBTTtBQUMxQixjQUFJLENBQUMsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQ2hDLGdCQUFJLE9BQU8sT0FBTyxVQUFVO0FBQzFCLHFCQUFPLFFBQVEsTUFBTTt1QkFDWixPQUFPLENBQUMsSUFBSSxNQUFNO0FBQzNCLG1CQUFLLE9BQU8sT0FBTyxJQUFJLE1BQU07QUFDN0IscUJBQU8sUUFBUSxNQUFNOzs7O01BSTdCO01BRUEsV0FDRSxRQUNBLE1BQ0EsUUFDQSxpQkFBaUIsS0FBSyxLQUFLLGdCQUMzQixZQUFZLEtBQUssS0FBSyxlQUFhO0FBRW5DLFlBQUk7QUFDSixjQUFNLEVBQUMsU0FBUSxJQUFJLEtBQUs7QUFDeEIsWUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixlQUFLLE9BQU8sUUFBUTtlQUNmO0FBQ0wsY0FBSSxLQUFLLEtBQUs7QUFBSyxrQkFBTSxJQUFJLE1BQU0sdUJBQXVCO21CQUNqRCxPQUFPLFVBQVU7QUFBVyxrQkFBTSxJQUFJLE1BQU0sa0NBQWtDOztBQUV6RixZQUFJLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTTtBQUNoQyxZQUFJLFFBQVE7QUFBVyxpQkFBTztBQUU5QixrQkFBUyxHQUFBLFVBQUEsYUFBWSxNQUFNLE1BQU07QUFDakMsY0FBTSxZQUFZLFVBQUEsY0FBYyxLQUFLLE1BQU0sUUFBUSxNQUFNO0FBQ3pELGNBQU0sSUFBSSxVQUFBLFVBQVUsRUFBQyxRQUFRLFVBQVUsTUFBTSxRQUFRLFVBQVMsQ0FBQztBQUMvRCxhQUFLLE9BQU8sSUFBSSxJQUFJLFFBQVEsR0FBRztBQUMvQixZQUFJLGFBQWEsQ0FBQyxPQUFPLFdBQVcsR0FBRyxHQUFHO0FBRXhDLGNBQUk7QUFBUSxpQkFBSyxhQUFhLE1BQU07QUFDcEMsZUFBSyxLQUFLLE1BQU0sSUFBSTs7QUFFdEIsWUFBSTtBQUFnQixlQUFLLGVBQWUsUUFBUSxJQUFJO0FBQ3BELGVBQU87TUFDVDtNQUVRLGFBQWEsSUFBVTtBQUM3QixZQUFJLEtBQUssUUFBUSxFQUFFLEtBQUssS0FBSyxLQUFLLEVBQUUsR0FBRztBQUNyQyxnQkFBTSxJQUFJLE1BQU0sMEJBQTBCLG9CQUFvQjs7TUFFbEU7TUFFUSxrQkFBa0IsS0FBYztBQUN0QyxZQUFJLElBQUk7QUFBTSxlQUFLLG1CQUFtQixHQUFHOztBQUNwQyxvQkFBQSxjQUFjLEtBQUssTUFBTSxHQUFHO0FBR2pDLFlBQUksQ0FBQyxJQUFJO0FBQVUsZ0JBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUM3RCxlQUFPLElBQUk7TUFDYjtNQUVRLG1CQUFtQixLQUFjO0FBQ3ZDLGNBQU0sY0FBYyxLQUFLO0FBQ3pCLGFBQUssT0FBTyxLQUFLO0FBQ2pCLFlBQUk7QUFDRixvQkFBQSxjQUFjLEtBQUssTUFBTSxHQUFHOztBQUU1QixlQUFLLE9BQU87O01BRWhCOztBQXpkRixZQUFBLFVBQUE7QUFlUyxRQUFBLGtCQUFrQixtQkFBQTtBQUNsQixRQUFBLGtCQUFrQixZQUFBO0FBaWQzQixhQUFTLGFBRVAsV0FDQSxTQUNBLEtBQ0EsTUFBd0IsU0FBTztBQUUvQixpQkFBVyxPQUFPLFdBQVc7QUFDM0IsY0FBTSxNQUFNO0FBQ1osWUFBSSxPQUFPO0FBQVMsZUFBSyxPQUFPLEdBQUcsRUFBRSxHQUFHLGVBQWUsUUFBUSxVQUFVLEdBQUcsR0FBRzs7SUFFbkY7QUFFQSxhQUFTLFVBQXFCLFFBQWM7QUFDMUMsZ0JBQVMsR0FBQSxVQUFBLGFBQVksTUFBTTtBQUMzQixhQUFPLEtBQUssUUFBUSxNQUFNLEtBQUssS0FBSyxLQUFLLE1BQU07SUFDakQ7QUFFQSxhQUFTLG9CQUFpQjtBQUN4QixZQUFNLGNBQWMsS0FBSyxLQUFLO0FBQzlCLFVBQUksQ0FBQztBQUFhO0FBQ2xCLFVBQUksTUFBTSxRQUFRLFdBQVc7QUFBRyxhQUFLLFVBQVUsV0FBVzs7QUFDckQsbUJBQVcsT0FBTztBQUFhLGVBQUssVUFBVSxZQUFZLEdBQUcsR0FBZ0IsR0FBRztJQUN2RjtBQUVBLGFBQVMsb0JBQWlCO0FBQ3hCLGlCQUFXLFFBQVEsS0FBSyxLQUFLLFNBQVM7QUFDcEMsY0FBTSxTQUFTLEtBQUssS0FBSyxRQUFRLElBQUk7QUFDckMsWUFBSTtBQUFRLGVBQUssVUFBVSxNQUFNLE1BQU07O0lBRTNDO0FBRUEsYUFBUyxtQkFFUCxNQUFzRDtBQUV0RCxVQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDdkIsYUFBSyxjQUFjLElBQUk7QUFDdkI7O0FBRUYsV0FBSyxPQUFPLEtBQUssa0RBQWtEO0FBQ25FLGlCQUFXLFdBQVcsTUFBTTtBQUMxQixjQUFNLE1BQU0sS0FBSyxPQUFPO0FBQ3hCLFlBQUksQ0FBQyxJQUFJO0FBQVMsY0FBSSxVQUFVO0FBQ2hDLGFBQUssV0FBVyxHQUFHOztJQUV2QjtBQUVBLGFBQVMsdUJBQW9CO0FBQzNCLFlBQU0sV0FBVyxFQUFDLEdBQUcsS0FBSyxLQUFJO0FBQzlCLGlCQUFXLE9BQU87QUFBcUIsZUFBTyxTQUFTLEdBQUc7QUFDMUQsYUFBTztJQUNUO0FBRUEsUUFBTSxTQUFTLEVBQUMsTUFBRztJQUFJLEdBQUcsT0FBSTtJQUFJLEdBQUcsUUFBSztJQUFJLEVBQUM7QUFFL0MsYUFBUyxVQUFVLFFBQWdDO0FBQ2pELFVBQUksV0FBVztBQUFPLGVBQU87QUFDN0IsVUFBSSxXQUFXO0FBQVcsZUFBTztBQUNqQyxVQUFJLE9BQU8sT0FBTyxPQUFPLFFBQVEsT0FBTztBQUFPLGVBQU87QUFDdEQsWUFBTSxJQUFJLE1BQU0sbURBQW1EO0lBQ3JFO0FBRUEsUUFBTSxlQUFlO0FBRXJCLGFBQVMsYUFBd0IsU0FBNEIsS0FBdUI7QUFDbEYsWUFBTSxFQUFDLE1BQUssSUFBSTtBQUNoQixPQUFBLEdBQUEsT0FBQSxVQUFTLFNBQVMsQ0FBQyxRQUFPO0FBQ3hCLFlBQUksTUFBTSxTQUFTLEdBQUc7QUFBRyxnQkFBTSxJQUFJLE1BQU0sV0FBVyx3QkFBd0I7QUFDNUUsWUFBSSxDQUFDLGFBQWEsS0FBSyxHQUFHO0FBQUcsZ0JBQU0sSUFBSSxNQUFNLFdBQVcsc0JBQXNCO01BQ2hGLENBQUM7QUFDRCxVQUFJLENBQUM7QUFBSztBQUNWLFVBQUksSUFBSSxTQUFTLEVBQUUsVUFBVSxPQUFPLGNBQWMsTUFBTTtBQUN0RCxjQUFNLElBQUksTUFBTSx1REFBdUQ7O0lBRTNFO0FBRUEsYUFBUyxRQUVQLFNBQ0EsWUFDQSxVQUFtQjs7QUFFbkIsWUFBTSxPQUFPLGVBQVUsUUFBVixlQUFVLFNBQUEsU0FBVixXQUFZO0FBQ3pCLFVBQUksWUFBWTtBQUFNLGNBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUNuRixZQUFNLEVBQUMsTUFBSyxJQUFJO0FBQ2hCLFVBQUksWUFBWSxPQUFPLE1BQU0sT0FBTyxNQUFNLE1BQU0sS0FBSyxDQUFDLEVBQUMsTUFBTSxFQUFDLE1BQU0sTUFBTSxRQUFRO0FBQ2xGLFVBQUksQ0FBQyxXQUFXO0FBQ2Qsb0JBQVksRUFBQyxNQUFNLFVBQVUsT0FBTyxDQUFBLEVBQUU7QUFDdEMsY0FBTSxNQUFNLEtBQUssU0FBUzs7QUFFNUIsWUFBTSxTQUFTLE9BQU8sSUFBSTtBQUMxQixVQUFJLENBQUM7QUFBWTtBQUVqQixZQUFNLE9BQWE7UUFDakI7UUFDQSxZQUFZO1VBQ1YsR0FBRztVQUNILE9BQU0sR0FBQSxXQUFBLGNBQWEsV0FBVyxJQUFJO1VBQ2xDLGFBQVksR0FBQSxXQUFBLGNBQWEsV0FBVyxVQUFVOzs7QUFHbEQsVUFBSSxXQUFXO0FBQVEsc0JBQWMsS0FBSyxNQUFNLFdBQVcsTUFBTSxXQUFXLE1BQU07O0FBQzdFLGtCQUFVLE1BQU0sS0FBSyxJQUFJO0FBQzlCLFlBQU0sSUFBSSxPQUFPLElBQUk7QUFDckIsT0FBQUEsTUFBQSxXQUFXLGdCQUFVLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFLFFBQVEsQ0FBQyxRQUFRLEtBQUssV0FBVyxHQUFHLENBQUM7SUFDOUQ7QUFFQSxhQUFTLGNBQXlCLFdBQXNCLE1BQVksUUFBYztBQUNoRixZQUFNLElBQUksVUFBVSxNQUFNLFVBQVUsQ0FBQyxVQUFVLE1BQU0sWUFBWSxNQUFNO0FBQ3ZFLFVBQUksS0FBSyxHQUFHO0FBQ1Ysa0JBQVUsTUFBTSxPQUFPLEdBQUcsR0FBRyxJQUFJO2FBQzVCO0FBQ0wsa0JBQVUsTUFBTSxLQUFLLElBQUk7QUFDekIsYUFBSyxPQUFPLEtBQUssUUFBUSx1QkFBdUI7O0lBRXBEO0FBRUEsYUFBUyxrQkFBNkIsS0FBc0I7QUFDMUQsVUFBSSxFQUFDLFdBQVUsSUFBSTtBQUNuQixVQUFJLGVBQWU7QUFBVztBQUM5QixVQUFJLElBQUksU0FBUyxLQUFLLEtBQUs7QUFBTyxxQkFBYSxhQUFhLFVBQVU7QUFDdEUsVUFBSSxpQkFBaUIsS0FBSyxRQUFRLFlBQVksSUFBSTtJQUNwRDtBQUVBLFFBQU0sV0FBVztNQUNmLE1BQU07O0FBR1IsYUFBUyxhQUFhLFFBQWlCO0FBQ3JDLGFBQU8sRUFBQyxPQUFPLENBQUMsUUFBUSxRQUFRLEVBQUM7SUFDbkM7Ozs7Ozs7OztBQ3AzQkEsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsT0FBSTtBQUNGLGNBQU0sSUFBSSxNQUFNLHNEQUFzRDtNQUN4RTs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7Ozs7QUNQZixRQUFBLGNBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFFQSxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxZQUFZO01BQ1osS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxLQUFLLFFBQVEsTUFBTSxHQUFFLElBQUk7QUFDaEMsY0FBTSxFQUFDLFFBQVEsV0FBVyxLQUFLLGNBQWMsTUFBTSxNQUFBQyxNQUFJLElBQUk7QUFDM0QsY0FBTSxFQUFDLEtBQUksSUFBSTtBQUNmLGFBQUssU0FBUyxPQUFPLFNBQVMsU0FBUyxXQUFXLEtBQUs7QUFBUSxpQkFBTyxZQUFXO0FBQ2pGLGNBQU0sV0FBVyxVQUFBLFdBQVcsS0FBS0EsT0FBTSxNQUFNLFFBQVEsSUFBSTtBQUN6RCxZQUFJLGFBQWE7QUFBVyxnQkFBTSxJQUFJLFlBQUEsUUFBZ0IsR0FBRyxLQUFLLGFBQWEsUUFBUSxJQUFJO0FBQ3ZGLFlBQUksb0JBQW9CLFVBQUE7QUFBVyxpQkFBTyxhQUFhLFFBQVE7QUFDL0QsZUFBTyxnQkFBZ0IsUUFBUTtBQUUvQixpQkFBUyxjQUFXO0FBQ2xCLGNBQUksUUFBUTtBQUFNLG1CQUFPLFFBQVEsS0FBSyxjQUFjLEtBQUssSUFBSSxNQUFNO0FBQ25FLGdCQUFNLFdBQVcsSUFBSSxXQUFXLFFBQVEsRUFBQyxLQUFLLEtBQUksQ0FBQztBQUNuRCxpQkFBTyxRQUFRLE1BQUssR0FBQSxVQUFBLEtBQUkscUJBQXFCLE1BQU0sS0FBSyxNQUFNO1FBQ2hFO0FBRUEsaUJBQVMsYUFBYSxLQUFjO0FBQ2xDLGdCQUFNLElBQUksWUFBWSxLQUFLLEdBQUc7QUFDOUIsa0JBQVEsS0FBSyxHQUFHLEtBQUssSUFBSSxNQUFNO1FBQ2pDO0FBRUEsaUJBQVMsZ0JBQWdCLEtBQWM7QUFDckMsZ0JBQU0sVUFBVSxJQUFJLFdBQ2xCLFVBQ0EsS0FBSyxLQUFLLFdBQVcsT0FBTyxFQUFDLEtBQUssS0FBSyxPQUFNLEdBQUEsVUFBQSxXQUFVLEdBQUcsRUFBQyxJQUFJLEVBQUMsS0FBSyxJQUFHLENBQUM7QUFFM0UsZ0JBQU0sUUFBUSxJQUFJLEtBQUssT0FBTztBQUM5QixnQkFBTSxTQUFTLElBQUksVUFDakI7WUFDRSxRQUFRO1lBQ1IsV0FBVyxDQUFBO1lBQ1gsWUFBWSxVQUFBO1lBQ1osY0FBYztZQUNkLGVBQWU7YUFFakIsS0FBSztBQUVQLGNBQUksZUFBZSxNQUFNO0FBQ3pCLGNBQUksR0FBRyxLQUFLO1FBQ2Q7TUFDRjs7QUFHRixhQUFnQixZQUFZLEtBQWlCLEtBQWM7QUFDekQsWUFBTSxFQUFDLElBQUcsSUFBSTtBQUNkLGFBQU8sSUFBSSxXQUNQLElBQUksV0FBVyxZQUFZLEVBQUMsS0FBSyxJQUFJLFNBQVEsQ0FBQyxLQUM5QyxHQUFBLFVBQUEsS0FBSSxJQUFJLFdBQVcsV0FBVyxFQUFDLEtBQUssSUFBRyxDQUFDO0lBQzlDO0FBTEEsWUFBQSxjQUFBO0FBT0EsYUFBZ0IsUUFBUSxLQUFpQixHQUFTLEtBQWlCLFFBQWdCO0FBQ2pGLFlBQU0sRUFBQyxLQUFLLEdBQUUsSUFBSTtBQUNsQixZQUFNLEVBQUMsV0FBVyxXQUFXLEtBQUssS0FBSSxJQUFJO0FBQzFDLFlBQU0sVUFBVSxLQUFLLGNBQWMsUUFBQSxRQUFFLE9BQU8sVUFBQTtBQUM1QyxVQUFJO0FBQVEscUJBQVk7O0FBQ25CLG9CQUFXO0FBRWhCLGVBQVMsZUFBWTtBQUNuQixZQUFJLENBQUMsSUFBSTtBQUFRLGdCQUFNLElBQUksTUFBTSx3Q0FBd0M7QUFDekUsY0FBTSxRQUFRLElBQUksSUFBSSxPQUFPO0FBQzdCLFlBQUksSUFDRixNQUFLO0FBQ0gsY0FBSSxNQUFLLEdBQUEsVUFBQSxZQUFVLEdBQUEsT0FBQSxrQkFBaUIsS0FBSyxHQUFHLE9BQU8sR0FBRztBQUN0RCwyQkFBaUIsQ0FBQztBQUNsQixjQUFJLENBQUM7QUFBVyxnQkFBSSxPQUFPLE9BQU8sSUFBSTtRQUN4QyxHQUNBLENBQUMsTUFBSztBQUNKLGNBQUksSUFBRyxHQUFBLFVBQUEsT0FBTSxnQkFBZ0IsR0FBRyxvQkFBNEIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDO0FBQzlFLHdCQUFjLENBQUM7QUFDZixjQUFJLENBQUM7QUFBVyxnQkFBSSxPQUFPLE9BQU8sS0FBSztRQUN6QyxDQUFDO0FBRUgsWUFBSSxHQUFHLEtBQUs7TUFDZDtBQUVBLGVBQVMsY0FBVztBQUNsQixZQUFJLFFBQ0YsR0FBQSxPQUFBLGtCQUFpQixLQUFLLEdBQUcsT0FBTyxHQUNoQyxNQUFNLGlCQUFpQixDQUFDLEdBQ3hCLE1BQU0sY0FBYyxDQUFDLENBQUM7TUFFMUI7QUFFQSxlQUFTLGNBQWMsUUFBWTtBQUNqQyxjQUFNLFFBQU8sR0FBQSxVQUFBLEtBQUk7QUFDakIsWUFBSSxPQUFPLFFBQUEsUUFBRSxVQUFTLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxzQkFBc0IsVUFBVSxRQUFBLFFBQUUsa0JBQWtCLE9BQU87QUFDdkYsWUFBSSxPQUFPLFFBQUEsUUFBRSxTQUFRLEdBQUEsVUFBQSxLQUFJLFFBQUEsUUFBRSxnQkFBZ0I7TUFDN0M7QUFFQSxlQUFTLGlCQUFpQixRQUFZOztBQUNwQyxZQUFJLENBQUMsR0FBRyxLQUFLO0FBQWE7QUFDMUIsY0FBTSxnQkFBZUMsTUFBQSxRQUFHLFFBQUgsUUFBRyxTQUFBLFNBQUgsSUFBSyxjQUFRLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFO0FBRXBDLFlBQUksR0FBRyxVQUFVLE1BQU07QUFDckIsY0FBSSxnQkFBZ0IsQ0FBQyxhQUFhLGNBQWM7QUFDOUMsZ0JBQUksYUFBYSxVQUFVLFFBQVc7QUFDcEMsaUJBQUcsUUFBUSxPQUFBLGVBQWUsTUFBTSxLQUFLLGFBQWEsT0FBTyxHQUFHLEtBQUs7O2lCQUU5RDtBQUNMLGtCQUFNLFFBQVEsSUFBSSxJQUFJLFVBQVMsR0FBQSxVQUFBLEtBQUksd0JBQXdCO0FBQzNELGVBQUcsUUFBUSxPQUFBLGVBQWUsTUFBTSxLQUFLLE9BQU8sR0FBRyxPQUFPLFVBQUEsSUFBSTs7O0FBRzlELFlBQUksR0FBRyxVQUFVLE1BQU07QUFDckIsY0FBSSxnQkFBZ0IsQ0FBQyxhQUFhLGNBQWM7QUFDOUMsZ0JBQUksYUFBYSxVQUFVLFFBQVc7QUFDcEMsaUJBQUcsUUFBUSxPQUFBLGVBQWUsTUFBTSxLQUFLLGFBQWEsT0FBTyxHQUFHLEtBQUs7O2lCQUU5RDtBQUNMLGtCQUFNLFFBQVEsSUFBSSxJQUFJLFVBQVMsR0FBQSxVQUFBLEtBQUksd0JBQXdCO0FBQzNELGVBQUcsUUFBUSxPQUFBLGVBQWUsTUFBTSxLQUFLLE9BQU8sR0FBRyxPQUFPLFVBQUEsSUFBSTs7O01BR2hFO0lBQ0Y7QUFoRUEsWUFBQSxVQUFBO0FBa0VBLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDL0hmLFFBQUEsT0FBQTtBQUNBLFFBQUEsUUFBQTtBQUVBLFFBQU0sT0FBbUI7TUFDdkI7TUFDQTtNQUNBO01BQ0E7TUFDQSxFQUFDLFNBQVMsV0FBVTtNQUNwQjtNQUNBLEtBQUE7TUFDQSxNQUFBOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDYmYsUUFBQSxZQUFBO0FBRUEsUUFBTSxNQUFNLFVBQUE7QUFNWixRQUFNLE9BQWdFO01BQ3BFLFNBQVMsRUFBQyxPQUFPLE1BQU0sSUFBSSxJQUFJLEtBQUssTUFBTSxJQUFJLEdBQUU7TUFDaEQsU0FBUyxFQUFDLE9BQU8sTUFBTSxJQUFJLElBQUksS0FBSyxNQUFNLElBQUksR0FBRTtNQUNoRCxrQkFBa0IsRUFBQyxPQUFPLEtBQUssSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUc7TUFDeEQsa0JBQWtCLEVBQUMsT0FBTyxLQUFLLElBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFHOztBQVMxRCxRQUFNLFFBQWdDO01BQ3BDLFNBQVMsQ0FBQyxFQUFDLFNBQVMsV0FBVSxPQUFNLEdBQUEsVUFBQSxlQUFjLEtBQUssT0FBYyxFQUFFLFNBQVM7TUFDaEYsUUFBUSxDQUFDLEVBQUMsU0FBUyxXQUFVLE9BQzNCLEdBQUEsVUFBQSxrQkFBaUIsS0FBSyxPQUFjLEVBQUUsaUJBQWlCOztBQUczRCxRQUFNLE1BQTZCO01BQ2pDLFNBQVMsT0FBTyxLQUFLLElBQUk7TUFDekIsTUFBTTtNQUNOLFlBQVk7TUFDWixPQUFPO01BQ1A7TUFDQSxLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLFNBQVMsTUFBTSxXQUFVLElBQUk7QUFDcEMsWUFBSSxXQUFVLEdBQUEsVUFBQSxLQUFJLFFBQVEsS0FBSyxPQUFjLEVBQUUsUUFBUSx1QkFBdUIsT0FBTztNQUN2Rjs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7OztBQ3ZDZixRQUFBLFlBQUE7QUFRQSxRQUFNLFFBQWdDO01BQ3BDLFNBQVMsQ0FBQyxFQUFDLFdBQVUsT0FBTSxHQUFBLFVBQUEsMkJBQTBCO01BQ3JELFFBQVEsQ0FBQyxFQUFDLFdBQVUsT0FBTSxHQUFBLFVBQUEsa0JBQWlCOztBQUc3QyxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWTtNQUNaLE9BQU87TUFDUDtNQUNBLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsS0FBSyxNQUFNLFlBQVksR0FBRSxJQUFJO0FBRXBDLGNBQU0sT0FBTyxHQUFHLEtBQUs7QUFDckIsY0FBTSxNQUFNLElBQUksSUFBSSxLQUFLO0FBQ3pCLGNBQU0sVUFBVSxRQUNaLEdBQUEsVUFBQSx5QkFBd0IsVUFBVSxhQUFhLFVBQy9DLEdBQUEsVUFBQSxLQUFJLG9CQUFvQjtBQUM1QixZQUFJLFdBQVUsR0FBQSxVQUFBLE1BQUssd0JBQXdCLFNBQVMsUUFBUSxlQUFlLFdBQVc7TUFDeEY7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUMvQmYsYUFBd0IsV0FBVyxLQUFXO0FBQzVDLFlBQU0sTUFBTSxJQUFJO0FBQ2hCLFVBQUksU0FBUztBQUNiLFVBQUksTUFBTTtBQUNWLFVBQUk7QUFDSixhQUFPLE1BQU0sS0FBSztBQUNoQjtBQUNBLGdCQUFRLElBQUksV0FBVyxLQUFLO0FBQzVCLFlBQUksU0FBUyxTQUFVLFNBQVMsU0FBVSxNQUFNLEtBQUs7QUFFbkQsa0JBQVEsSUFBSSxXQUFXLEdBQUc7QUFDMUIsZUFBSyxRQUFRLFdBQVk7QUFBUTs7O0FBR3JDLGFBQU87SUFDVDtBQWZBLFlBQUEsVUFBQTtBQWlCQSxlQUFXLE9BQU87Ozs7Ozs7OztBQ2pCbEIsUUFBQSxZQUFBO0FBQ0EsUUFBQSxTQUFBO0FBQ0EsUUFBQSxlQUFBO0FBRUEsUUFBTSxRQUFnQztNQUNwQyxRQUFRLEVBQUMsU0FBUyxXQUFVLEdBQUM7QUFDM0IsY0FBTSxPQUFPLFlBQVksY0FBYyxTQUFTO0FBQ2hELGdCQUFPLEdBQUEsVUFBQSxxQkFBb0IsYUFBYTtNQUMxQztNQUNBLFFBQVEsQ0FBQyxFQUFDLFdBQVUsT0FBTSxHQUFBLFVBQUEsYUFBWTs7QUFHeEMsUUFBTSxNQUE2QjtNQUNqQyxTQUFTLENBQUMsYUFBYSxXQUFXO01BQ2xDLE1BQU07TUFDTixZQUFZO01BQ1osT0FBTztNQUNQO01BQ0EsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxTQUFTLE1BQU0sWUFBWSxHQUFFLElBQUk7QUFDeEMsY0FBTSxLQUFLLFlBQVksY0FBYyxVQUFBLFVBQVUsS0FBSyxVQUFBLFVBQVU7QUFDOUQsY0FBTSxNQUNKLEdBQUcsS0FBSyxZQUFZLFNBQVEsR0FBQSxVQUFBLEtBQUksaUJBQWdCLEdBQUEsVUFBQSxNQUFJLEdBQUEsT0FBQSxTQUFRLElBQUksS0FBSyxhQUFBLE9BQVUsS0FBSztBQUN0RixZQUFJLFdBQVUsR0FBQSxVQUFBLEtBQUksT0FBTyxNQUFNLFlBQVk7TUFDN0M7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUMzQmYsUUFBQSxTQUFBO0FBQ0EsUUFBQSxZQUFBO0FBSUEsUUFBTSxRQUFnQztNQUNwQyxTQUFTLENBQUMsRUFBQyxXQUFVLE9BQU0sR0FBQSxVQUFBLDJCQUEwQjtNQUNyRCxRQUFRLENBQUMsRUFBQyxXQUFVLE9BQU0sR0FBQSxVQUFBLGVBQWM7O0FBRzFDLFFBQU0sTUFBNkI7TUFDakMsU0FBUztNQUNULE1BQU07TUFDTixZQUFZO01BQ1osT0FBTztNQUNQO01BQ0EsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxNQUFNLE9BQU8sUUFBUSxZQUFZLEdBQUUsSUFBSTtBQUU5QyxjQUFNLElBQUksR0FBRyxLQUFLLGdCQUFnQixNQUFNO0FBQ3hDLGNBQU0sU0FBUyxTQUFRLEdBQUEsVUFBQSxpQkFBZ0IsZUFBZSxTQUFRLEdBQUEsT0FBQSxZQUFXLEtBQUssTUFBTTtBQUNwRixZQUFJLFdBQVUsR0FBQSxVQUFBLE1BQUssZUFBZSxPQUFPO01BQzNDOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDekJmLFFBQUEsWUFBQTtBQUVBLFFBQU0sUUFBZ0M7TUFDcEMsUUFBUSxFQUFDLFNBQVMsV0FBVSxHQUFDO0FBQzNCLGNBQU0sT0FBTyxZQUFZLGtCQUFrQixTQUFTO0FBQ3BELGdCQUFPLEdBQUEsVUFBQSxxQkFBb0IsYUFBYTtNQUMxQztNQUNBLFFBQVEsQ0FBQyxFQUFDLFdBQVUsT0FBTSxHQUFBLFVBQUEsYUFBWTs7QUFHeEMsUUFBTSxNQUE2QjtNQUNqQyxTQUFTLENBQUMsaUJBQWlCLGVBQWU7TUFDMUMsTUFBTTtNQUNOLFlBQVk7TUFDWixPQUFPO01BQ1A7TUFDQSxLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLFNBQVMsTUFBTSxXQUFVLElBQUk7QUFDcEMsY0FBTSxLQUFLLFlBQVksa0JBQWtCLFVBQUEsVUFBVSxLQUFLLFVBQUEsVUFBVTtBQUNsRSxZQUFJLFdBQVUsR0FBQSxVQUFBLGlCQUFnQixnQkFBZ0IsTUFBTSxZQUFZO01BQ2xFOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDdkJmLFFBQUEsU0FBQTtBQU9BLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQVFBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUyxDQUFDLEVBQUMsUUFBUSxFQUFDLGdCQUFlLEVBQUMsT0FBTSxHQUFBLFVBQUEsb0NBQW1DO01BQzdFLFFBQVEsQ0FBQyxFQUFDLFFBQVEsRUFBQyxnQkFBZSxFQUFDLE9BQU0sR0FBQSxVQUFBLHVCQUFzQjs7QUFHakUsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsTUFBTTtNQUNOLFlBQVk7TUFDWixPQUFPO01BQ1A7TUFDQSxLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLEtBQUssUUFBUSxZQUFZLE1BQU0sT0FBTyxHQUFFLElBQUk7QUFDbkQsY0FBTSxFQUFDLEtBQUksSUFBSTtBQUNmLFlBQUksQ0FBQyxTQUFTLE9BQU8sV0FBVztBQUFHO0FBQ25DLGNBQU0sVUFBVSxPQUFPLFVBQVUsS0FBSztBQUN0QyxZQUFJLEdBQUc7QUFBVyx3QkFBYTs7QUFDMUIsMEJBQWU7QUFFcEIsWUFBSSxLQUFLLGdCQUFnQjtBQUN2QixnQkFBTSxRQUFRLElBQUksYUFBYTtBQUMvQixnQkFBTSxFQUFDLGtCQUFpQixJQUFJLElBQUk7QUFDaEMscUJBQVcsZUFBZSxRQUFRO0FBQ2hDLGlCQUFJLFVBQUssUUFBTCxVQUFLLFNBQUEsU0FBTCxNQUFRLFdBQVcsT0FBTSxVQUFhLENBQUMsa0JBQWtCLElBQUksV0FBVyxHQUFHO0FBQzdFLG9CQUFNLGFBQWEsR0FBRyxVQUFVLFNBQVMsR0FBRztBQUM1QyxvQkFBTSxNQUFNLHNCQUFzQixtQ0FBbUM7QUFDckUsZUFBQSxHQUFBLE9BQUEsaUJBQWdCLElBQUksS0FBSyxHQUFHLEtBQUssY0FBYzs7OztBQUtyRCxpQkFBUyxnQkFBYTtBQUNwQixjQUFJLFdBQVcsT0FBTztBQUNwQixnQkFBSSxXQUFXLFVBQUEsS0FBSyxlQUFlO2lCQUM5QjtBQUNMLHVCQUFXLFFBQVEsUUFBUTtBQUN6QixlQUFBLEdBQUEsT0FBQSx3QkFBdUIsS0FBSyxJQUFJOzs7UUFHdEM7QUFFQSxpQkFBUyxrQkFBZTtBQUN0QixnQkFBTSxVQUFVLElBQUksSUFBSSxTQUFTO0FBQ2pDLGNBQUksV0FBVyxPQUFPO0FBQ3BCLGtCQUFNLFFBQVEsSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUNuQyxnQkFBSSxXQUFXLE9BQU8sTUFBTSxpQkFBaUIsU0FBUyxLQUFLLENBQUM7QUFDNUQsZ0JBQUksR0FBRyxLQUFLO2lCQUNQO0FBQ0wsZ0JBQUksSUFBRyxHQUFBLE9BQUEsa0JBQWlCLEtBQUssUUFBUSxPQUFPLENBQUM7QUFDN0MsYUFBQSxHQUFBLE9BQUEsbUJBQWtCLEtBQUssT0FBTztBQUM5QixnQkFBSSxLQUFJOztRQUVaO0FBRUEsaUJBQVMsa0JBQWU7QUFDdEIsY0FBSSxNQUFNLFFBQVEsWUFBb0IsQ0FBQyxTQUFRO0FBQzdDLGdCQUFJLFVBQVUsRUFBQyxpQkFBaUIsS0FBSSxDQUFDO0FBQ3JDLGdCQUFJLElBQUcsR0FBQSxPQUFBLGtCQUFpQixLQUFLLE1BQU0sTUFBTSxLQUFLLGFBQWEsR0FBRyxNQUFNLElBQUksTUFBSyxDQUFFO1VBQ2pGLENBQUM7UUFDSDtBQUVBLGlCQUFTLGlCQUFpQixTQUFlLE9BQVc7QUFDbEQsY0FBSSxVQUFVLEVBQUMsaUJBQWlCLFFBQU8sQ0FBQztBQUN4QyxjQUFJLE1BQ0YsU0FDQSxZQUNBLE1BQUs7QUFDSCxnQkFBSSxPQUFPLFFBQU8sR0FBQSxPQUFBLGdCQUFlLEtBQUssTUFBTSxTQUFTLEtBQUssYUFBYSxDQUFDO0FBQ3hFLGdCQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksS0FBSyxHQUFHLE1BQUs7QUFDdEIsa0JBQUksTUFBSztBQUNULGtCQUFJLE1BQUs7WUFDWCxDQUFDO1VBQ0gsR0FDQSxVQUFBLEdBQUc7UUFFUDtNQUNGOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDL0ZmLFFBQUEsWUFBQTtBQUVBLFFBQU0sUUFBZ0M7TUFDcEMsUUFBUSxFQUFDLFNBQVMsV0FBVSxHQUFDO0FBQzNCLGNBQU0sT0FBTyxZQUFZLGFBQWEsU0FBUztBQUMvQyxnQkFBTyxHQUFBLFVBQUEscUJBQW9CLGFBQWE7TUFDMUM7TUFDQSxRQUFRLENBQUMsRUFBQyxXQUFVLE9BQU0sR0FBQSxVQUFBLGFBQVk7O0FBR3hDLFFBQU0sTUFBNkI7TUFDakMsU0FBUyxDQUFDLFlBQVksVUFBVTtNQUNoQyxNQUFNO01BQ04sWUFBWTtNQUNaLE9BQU87TUFDUDtNQUNBLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsU0FBUyxNQUFNLFdBQVUsSUFBSTtBQUNwQyxjQUFNLEtBQUssWUFBWSxhQUFhLFVBQUEsVUFBVSxLQUFLLFVBQUEsVUFBVTtBQUM3RCxZQUFJLFdBQVUsR0FBQSxVQUFBLEtBQUksZUFBZSxNQUFNLFlBQVk7TUFDckQ7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUN4QmYsUUFBQSxRQUFBO0FBR0UsVUFBZ0IsT0FBTztBQUV6QixZQUFBLFVBQWU7Ozs7Ozs7OztBQ0pmLFFBQUEsYUFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQUNBLFFBQUEsVUFBQTtBQVFBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUyxDQUFDLEVBQUMsUUFBUSxFQUFDLEdBQUcsRUFBQyxFQUFDLE9BQ3ZCLEdBQUEsVUFBQSwrQ0FBOEMsU0FBUztNQUN6RCxRQUFRLENBQUMsRUFBQyxRQUFRLEVBQUMsR0FBRyxFQUFDLEVBQUMsT0FBTSxHQUFBLFVBQUEsU0FBUSxTQUFTOztBQUdqRCxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWTtNQUNaLE9BQU87TUFDUDtNQUNBLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsS0FBSyxNQUFNLE9BQU8sUUFBUSxjQUFjLFlBQVksR0FBRSxJQUFJO0FBQ2pFLFlBQUksQ0FBQyxTQUFTLENBQUM7QUFBUTtBQUN2QixjQUFNLFFBQVEsSUFBSSxJQUFJLE9BQU87QUFDN0IsY0FBTSxZQUFZLGFBQWEsU0FBUSxHQUFBLFdBQUEsZ0JBQWUsYUFBYSxLQUFLLElBQUksQ0FBQTtBQUM1RSxZQUFJLFdBQVcsT0FBTyxzQkFBcUIsR0FBQSxVQUFBLEtBQUksc0JBQXNCO0FBQ3JFLFlBQUksR0FBRyxLQUFLO0FBRVosaUJBQVMsc0JBQW1CO0FBQzFCLGdCQUFNLElBQUksSUFBSSxJQUFJLE1BQUssR0FBQSxVQUFBLEtBQUksYUFBYTtBQUN4QyxnQkFBTSxJQUFJLElBQUksSUFBSSxHQUFHO0FBQ3JCLGNBQUksVUFBVSxFQUFDLEdBQUcsRUFBQyxDQUFDO0FBQ3BCLGNBQUksT0FBTyxPQUFPLElBQUk7QUFDdEIsY0FBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLFNBQVMsT0FBTyxZQUFXLElBQUssUUFBUSxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFO0FBRUEsaUJBQVMsY0FBVztBQUNsQixpQkFBTyxVQUFVLFNBQVMsS0FBSyxDQUFDLFVBQVUsS0FBSyxDQUFDLE1BQU0sTUFBTSxZQUFZLE1BQU0sT0FBTztRQUN2RjtBQUVBLGlCQUFTLE1BQU0sR0FBUyxHQUFPO0FBQzdCLGdCQUFNLE9BQU8sSUFBSSxLQUFLLE1BQU07QUFDNUIsZ0JBQU0sYUFBWSxHQUFBLFdBQUEsZ0JBQWUsV0FBVyxNQUFNLEdBQUcsS0FBSyxlQUFlLFdBQUEsU0FBUyxLQUFLO0FBQ3ZGLGdCQUFNLFVBQVUsSUFBSSxNQUFNLFlBQVcsR0FBQSxVQUFBLE1BQUs7QUFDMUMsY0FBSSxLQUFJLEdBQUEsVUFBQSxNQUFLLFFBQVEsTUFBSztBQUN4QixnQkFBSSxJQUFJLE9BQU0sR0FBQSxVQUFBLEtBQUksUUFBUSxJQUFJO0FBQzlCLGdCQUFJLEdBQUcsWUFBVyxHQUFBLFVBQUEsWUFBVztBQUM3QixnQkFBSSxVQUFVLFNBQVM7QUFBRyxrQkFBSSxJQUFHLEdBQUEsVUFBQSxZQUFXLHFCQUFvQixHQUFBLFVBQUEsS0FBSSxhQUFhO0FBQ2pGLGdCQUNHLElBQUcsR0FBQSxVQUFBLFlBQVcsV0FBVyxxQkFBcUIsTUFBSztBQUNsRCxrQkFBSSxPQUFPLElBQUcsR0FBQSxVQUFBLEtBQUksV0FBVyxPQUFPO0FBQ3BDLGtCQUFJLE1BQUs7QUFDVCxrQkFBSSxPQUFPLE9BQU8sS0FBSyxFQUFFLE1BQUs7WUFDaEMsQ0FBQyxFQUNBLE1BQUssR0FBQSxVQUFBLEtBQUksV0FBVyxXQUFXLEdBQUc7VUFDdkMsQ0FBQztRQUNIO0FBRUEsaUJBQVMsT0FBTyxHQUFTLEdBQU87QUFDOUIsZ0JBQU0sT0FBTSxHQUFBLE9BQUEsU0FBUSxLQUFLLFFBQUEsT0FBSztBQUM5QixnQkFBTSxRQUFRLElBQUksS0FBSyxPQUFPO0FBQzlCLGNBQUksTUFBTSxLQUFLLEVBQUUsS0FBSSxHQUFBLFVBQUEsTUFBSyxRQUFRLE1BQ2hDLElBQUksS0FBSSxHQUFBLFVBQUEsS0FBSSxPQUFPLE1BQU0sUUFBUSxNQUMvQixJQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksT0FBTyxRQUFRLE9BQU8sUUFBUSxPQUFPLE1BQUs7QUFDbkQsZ0JBQUksTUFBSztBQUNULGdCQUFJLE9BQU8sT0FBTyxLQUFLLEVBQUUsTUFBTSxLQUFLO1VBQ3RDLENBQUMsQ0FBQyxDQUNIO1FBRUw7TUFDRjs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7OztBQzVFZixRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFVBQUE7QUFJQSxRQUFNLFFBQWdDO01BQ3BDLFNBQVM7TUFDVCxRQUFRLENBQUMsRUFBQyxXQUFVLE9BQU0sR0FBQSxVQUFBLG9CQUFtQjs7QUFHL0MsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsT0FBTztNQUNQO01BQ0EsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxLQUFLLE1BQU0sT0FBTyxZQUFZLE9BQU0sSUFBSTtBQUMvQyxZQUFJLFNBQVUsVUFBVSxPQUFPLFVBQVUsVUFBVztBQUNsRCxjQUFJLFdBQVUsR0FBQSxVQUFBLE9BQUssR0FBQSxPQUFBLFNBQVEsS0FBSyxRQUFBLE9BQUssS0FBSyxTQUFTLGFBQWE7ZUFDM0Q7QUFDTCxjQUFJLE1BQUssR0FBQSxVQUFBLEtBQUksY0FBYyxNQUFNOztNQUVyQzs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7OztBQ3pCZixRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFVBQUE7QUFJQSxRQUFNLFFBQWdDO01BQ3BDLFNBQVM7TUFDVCxRQUFRLENBQUMsRUFBQyxXQUFVLE9BQU0sR0FBQSxVQUFBLHFCQUFvQjs7QUFHaEQsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsWUFBWTtNQUNaLE9BQU87TUFDUDtNQUNBLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsS0FBSyxNQUFNLE9BQU8sUUFBUSxZQUFZLEdBQUUsSUFBSTtBQUNuRCxZQUFJLENBQUMsU0FBUyxPQUFPLFdBQVc7QUFBRyxnQkFBTSxJQUFJLE1BQU0sZ0NBQWdDO0FBQ25GLGNBQU0sVUFBVSxPQUFPLFVBQVUsR0FBRyxLQUFLO0FBQ3pDLFlBQUk7QUFDSixjQUFNLFNBQVMsTUFBYSxRQUFHLFFBQUgsUUFBRyxTQUFILE1BQUEsT0FBUSxHQUFBLE9BQUEsU0FBUSxLQUFLLFFBQUEsT0FBSztBQUV0RCxZQUFJO0FBQ0osWUFBSSxXQUFXLE9BQU87QUFDcEIsa0JBQVEsSUFBSSxJQUFJLE9BQU87QUFDdkIsY0FBSSxXQUFXLE9BQU8sUUFBUTtlQUN6QjtBQUVMLGNBQUksQ0FBQyxNQUFNLFFBQVEsTUFBTTtBQUFHLGtCQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDdEUsZ0JBQU0sVUFBVSxJQUFJLE1BQU0sV0FBVyxVQUFVO0FBQy9DLG1CQUFRLEdBQUEsVUFBQSxJQUFHLEdBQUcsT0FBTyxJQUFJLENBQUMsSUFBYSxNQUFjLFVBQVUsU0FBUyxDQUFDLENBQUMsQ0FBQzs7QUFFN0UsWUFBSSxLQUFLLEtBQUs7QUFFZCxpQkFBUyxXQUFRO0FBQ2YsY0FBSSxPQUFPLE9BQU8sS0FBSztBQUN2QixjQUFJLE1BQU0sS0FBSyxZQUFvQixDQUFDLE1BQ2xDLElBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxPQUFNLEtBQU0sU0FBUyxNQUFNLE1BQU0sSUFBSSxPQUFPLE9BQU8sSUFBSSxFQUFFLE1BQUssQ0FBRSxDQUFDO1FBRWhGO0FBRUEsaUJBQVMsVUFBVSxTQUFlLEdBQVM7QUFDekMsZ0JBQU0sTUFBTSxPQUFPLENBQUM7QUFDcEIsaUJBQU8sT0FBTyxRQUFRLFlBQVksUUFBUSxRQUN0QyxHQUFBLFVBQUEsS0FBSSxPQUFNLEtBQU0sU0FBUyxXQUFXLFNBQ3BDLEdBQUEsVUFBQSxLQUFJLFlBQVk7UUFDdEI7TUFDRjs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7OztBQ3BEZixRQUFBLGdCQUFBO0FBQ0EsUUFBQSxlQUFBO0FBQ0EsUUFBQSxnQkFBQTtBQUNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsb0JBQUE7QUFDQSxRQUFBLGFBQUE7QUFDQSxRQUFBLGVBQUE7QUFDQSxRQUFBLGdCQUFBO0FBQ0EsUUFBQSxVQUFBO0FBQ0EsUUFBQSxTQUFBO0FBRUEsUUFBTSxhQUF5Qjs7TUFFN0IsY0FBQTtNQUNBLGFBQUE7O01BRUEsY0FBQTtNQUNBLFVBQUE7O01BRUEsa0JBQUE7TUFDQSxXQUFBOztNQUVBLGFBQUE7TUFDQSxjQUFBOztNQUVBLEVBQUMsU0FBUyxRQUFRLFlBQVksQ0FBQyxVQUFVLE9BQU8sRUFBQztNQUNqRCxFQUFDLFNBQVMsWUFBWSxZQUFZLFVBQVM7TUFDM0MsUUFBQTtNQUNBLE9BQUE7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7O0FDekJmLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQUlBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUyxDQUFDLEVBQUMsUUFBUSxFQUFDLElBQUcsRUFBQyxPQUFNLEdBQUEsVUFBQSwrQkFBOEI7TUFDNUQsUUFBUSxDQUFDLEVBQUMsUUFBUSxFQUFDLElBQUcsRUFBQyxPQUFNLEdBQUEsVUFBQSxhQUFZOztBQUczQyxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWSxDQUFDLFdBQVcsUUFBUTtNQUNoQyxRQUFRO01BQ1I7TUFDQSxLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLGNBQWMsR0FBRSxJQUFJO0FBQzNCLGNBQU0sRUFBQyxNQUFLLElBQUk7QUFDaEIsWUFBSSxDQUFDLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDekIsV0FBQSxHQUFBLE9BQUEsaUJBQWdCLElBQUksc0VBQXNFO0FBQzFGOztBQUVGLGdDQUF3QixLQUFLLEtBQUs7TUFDcEM7O0FBR0YsYUFBZ0Isd0JBQXdCLEtBQWlCLE9BQWtCO0FBQ3pFLFlBQU0sRUFBQyxLQUFLLFFBQVEsTUFBTSxTQUFTLEdBQUUsSUFBSTtBQUN6QyxTQUFHLFFBQVE7QUFDWCxZQUFNLE1BQU0sSUFBSSxNQUFNLFFBQU8sR0FBQSxVQUFBLEtBQUksYUFBYTtBQUM5QyxVQUFJLFdBQVcsT0FBTztBQUNwQixZQUFJLFVBQVUsRUFBQyxLQUFLLE1BQU0sT0FBTSxDQUFDO0FBQ2pDLFlBQUksTUFBSyxHQUFBLFVBQUEsS0FBSSxVQUFVLE1BQU0sUUFBUTtpQkFDNUIsT0FBTyxVQUFVLFlBQVksRUFBQyxHQUFBLE9BQUEsbUJBQWtCLElBQUksTUFBTSxHQUFHO0FBQ3RFLGNBQU0sUUFBUSxJQUFJLElBQUksVUFBUyxHQUFBLFVBQUEsS0FBSSxVQUFVLE1BQU0sUUFBUTtBQUMzRCxZQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksS0FBSyxHQUFHLE1BQU0sY0FBYyxLQUFLLENBQUM7QUFDN0MsWUFBSSxHQUFHLEtBQUs7O0FBR2QsZUFBUyxjQUFjLE9BQVc7QUFDaEMsWUFBSSxTQUFTLEtBQUssTUFBTSxRQUFRLEtBQUssQ0FBQyxNQUFLO0FBQ3pDLGNBQUksVUFBVSxFQUFDLFNBQVMsVUFBVSxHQUFHLGNBQWMsT0FBQSxLQUFLLElBQUcsR0FBRyxLQUFLO0FBQ25FLGNBQUksQ0FBQyxHQUFHO0FBQVcsZ0JBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxLQUFLLEdBQUcsTUFBTSxJQUFJLE1BQUssQ0FBRTtRQUN6RCxDQUFDO01BQ0g7SUFDRjtBQW5CQSxZQUFBLDBCQUFBO0FBcUJBLFlBQUEsVUFBZTs7Ozs7Ozs7OztBQ3JEZixRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxRQUFBLFNBQUE7QUFFQSxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWSxDQUFDLFVBQVUsU0FBUyxTQUFTO01BQ3pDLFFBQVE7TUFDUixLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLFFBQVEsR0FBRSxJQUFJO0FBQ3JCLFlBQUksTUFBTSxRQUFRLE1BQU07QUFBRyxpQkFBTyxjQUFjLEtBQUssbUJBQW1CLE1BQU07QUFDOUUsV0FBRyxRQUFRO0FBQ1gsYUFBSSxHQUFBLE9BQUEsbUJBQWtCLElBQUksTUFBTTtBQUFHO0FBQ25DLFlBQUksSUFBRyxHQUFBLE9BQUEsZUFBYyxHQUFHLENBQUM7TUFDM0I7O0FBR0YsYUFBZ0IsY0FDZCxLQUNBLFlBQ0EsU0FBc0IsSUFBSSxRQUFNO0FBRWhDLFlBQU0sRUFBQyxLQUFLLGNBQWMsTUFBTSxTQUFTLEdBQUUsSUFBSTtBQUMvQyx1QkFBaUIsWUFBWTtBQUM3QixVQUFJLEdBQUcsS0FBSyxlQUFlLE9BQU8sVUFBVSxHQUFHLFVBQVUsTUFBTTtBQUM3RCxXQUFHLFFBQVEsT0FBQSxlQUFlLE1BQU0sS0FBSyxPQUFPLFFBQVEsR0FBRyxLQUFLOztBQUU5RCxZQUFNLFFBQVEsSUFBSSxLQUFLLE9BQU87QUFDOUIsWUFBTSxNQUFNLElBQUksTUFBTSxRQUFPLEdBQUEsVUFBQSxLQUFJLGFBQWE7QUFDOUMsYUFBTyxRQUFRLENBQUMsS0FBZ0IsTUFBYTtBQUMzQyxhQUFJLEdBQUEsT0FBQSxtQkFBa0IsSUFBSSxHQUFHO0FBQUc7QUFDaEMsWUFBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLFNBQVMsS0FBSyxNQUN2QixJQUFJLFVBQ0Y7VUFDRTtVQUNBLFlBQVk7VUFDWixVQUFVO1dBRVosS0FBSyxDQUNOO0FBRUgsWUFBSSxHQUFHLEtBQUs7TUFDZCxDQUFDO0FBRUQsZUFBUyxpQkFBaUIsS0FBb0I7QUFDNUMsY0FBTSxFQUFDLE1BQU0sY0FBYSxJQUFJO0FBQzlCLGNBQU0sSUFBSSxPQUFPO0FBQ2pCLGNBQU0sWUFBWSxNQUFNLElBQUksYUFBYSxNQUFNLElBQUksWUFBWSxJQUFJLFVBQVUsTUFBTTtBQUNuRixZQUFJLEtBQUssZ0JBQWdCLENBQUMsV0FBVztBQUNuQyxnQkFBTSxNQUFNLElBQUksZUFBZSxxQ0FBcUMsc0RBQXNEO0FBQzFILFdBQUEsR0FBQSxPQUFBLGlCQUFnQixJQUFJLEtBQUssS0FBSyxZQUFZOztNQUU5QztJQUNGO0FBcENBLFlBQUEsZ0JBQUE7QUFzQ0EsWUFBQSxVQUFlOzs7Ozs7Ozs7QUN6RGYsUUFBQSxVQUFBO0FBRUEsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsTUFBTTtNQUNOLFlBQVksQ0FBQyxPQUFPO01BQ3BCLFFBQVE7TUFDUixNQUFNLENBQUMsU0FBUSxHQUFBLFFBQUEsZUFBYyxLQUFLLE9BQU87O0FBRzNDLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDSmYsUUFBQSxZQUFBO0FBQ0EsUUFBQSxTQUFBO0FBQ0EsUUFBQSxTQUFBO0FBQ0EsUUFBQSxvQkFBQTtBQUlBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUyxDQUFDLEVBQUMsUUFBUSxFQUFDLElBQUcsRUFBQyxPQUFNLEdBQUEsVUFBQSwrQkFBOEI7TUFDNUQsUUFBUSxDQUFDLEVBQUMsUUFBUSxFQUFDLElBQUcsRUFBQyxPQUFNLEdBQUEsVUFBQSxhQUFZOztBQUczQyxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWSxDQUFDLFVBQVUsU0FBUztNQUNoQyxRQUFRO01BQ1I7TUFDQSxLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLFFBQVEsY0FBYyxHQUFFLElBQUk7QUFDbkMsY0FBTSxFQUFDLFlBQVcsSUFBSTtBQUN0QixXQUFHLFFBQVE7QUFDWCxhQUFJLEdBQUEsT0FBQSxtQkFBa0IsSUFBSSxNQUFNO0FBQUc7QUFDbkMsWUFBSTtBQUFhLFdBQUEsR0FBQSxrQkFBQSx5QkFBd0IsS0FBSyxXQUFXOztBQUNwRCxjQUFJLElBQUcsR0FBQSxPQUFBLGVBQWMsR0FBRyxDQUFDO01BQ2hDOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDNUJmLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQVFBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUyxDQUFDLEVBQUMsUUFBUSxFQUFDLEtBQUssSUFBRyxFQUFDLE1BQzNCLFFBQVEsVUFDSixHQUFBLFVBQUEsNkJBQTRCLHVCQUM1QixHQUFBLFVBQUEsNkJBQTRCLHdCQUF3QjtNQUMxRCxRQUFRLENBQUMsRUFBQyxRQUFRLEVBQUMsS0FBSyxJQUFHLEVBQUMsTUFDMUIsUUFBUSxVQUFZLEdBQUEsVUFBQSxtQkFBa0IsVUFBUyxHQUFBLFVBQUEsbUJBQWtCLHFCQUFxQjs7QUFHMUYsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsTUFBTTtNQUNOLFlBQVksQ0FBQyxVQUFVLFNBQVM7TUFDaEMsUUFBUTtNQUNSLGFBQWE7TUFDYjtNQUNBLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsS0FBSyxRQUFRLGNBQWMsTUFBTSxHQUFFLElBQUk7QUFDOUMsWUFBSTtBQUNKLFlBQUk7QUFDSixjQUFNLEVBQUMsYUFBYSxZQUFXLElBQUk7QUFDbkMsWUFBSSxHQUFHLEtBQUssTUFBTTtBQUNoQixnQkFBTSxnQkFBZ0IsU0FBWSxJQUFJO0FBQ3RDLGdCQUFNO2VBQ0Q7QUFDTCxnQkFBTTs7QUFFUixjQUFNLE1BQU0sSUFBSSxNQUFNLFFBQU8sR0FBQSxVQUFBLEtBQUksYUFBYTtBQUM5QyxZQUFJLFVBQVUsRUFBQyxLQUFLLElBQUcsQ0FBQztBQUN4QixZQUFJLFFBQVEsVUFBYSxRQUFRLEdBQUc7QUFDbEMsV0FBQSxHQUFBLE9BQUEsaUJBQWdCLElBQUksc0VBQXNFO0FBQzFGOztBQUVGLFlBQUksUUFBUSxVQUFhLE1BQU0sS0FBSztBQUNsQyxXQUFBLEdBQUEsT0FBQSxpQkFBZ0IsSUFBSSxpREFBaUQ7QUFDckUsY0FBSSxLQUFJO0FBQ1I7O0FBRUYsYUFBSSxHQUFBLE9BQUEsbUJBQWtCLElBQUksTUFBTSxHQUFHO0FBQ2pDLGNBQUksUUFBTyxHQUFBLFVBQUEsS0FBSSxVQUFVO0FBQ3pCLGNBQUksUUFBUTtBQUFXLG9CQUFPLEdBQUEsVUFBQSxLQUFJLFdBQVcsVUFBVTtBQUN2RCxjQUFJLEtBQUssSUFBSTtBQUNiOztBQUdGLFdBQUcsUUFBUTtBQUNYLGNBQU0sUUFBUSxJQUFJLEtBQUssT0FBTztBQUM5QixZQUFJLFFBQVEsVUFBYSxRQUFRLEdBQUc7QUFDbEMsd0JBQWMsT0FBTyxNQUFNLElBQUksR0FBRyxPQUFPLE1BQU0sSUFBSSxNQUFLLENBQUUsQ0FBQzttQkFDbEQsUUFBUSxHQUFHO0FBQ3BCLGNBQUksSUFBSSxPQUFPLElBQUk7QUFDbkIsY0FBSSxRQUFRO0FBQVcsZ0JBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxtQkFBbUIsc0JBQXNCO2VBQ3RFO0FBQ0wsY0FBSSxJQUFJLE9BQU8sS0FBSztBQUNwQixpQ0FBc0I7O0FBRXhCLFlBQUksT0FBTyxPQUFPLE1BQU0sSUFBSSxNQUFLLENBQUU7QUFFbkMsaUJBQVMseUJBQXNCO0FBQzdCLGdCQUFNLFdBQVcsSUFBSSxLQUFLLFFBQVE7QUFDbEMsZ0JBQU0sUUFBUSxJQUFJLElBQUksU0FBUyxDQUFDO0FBQ2hDLHdCQUFjLFVBQVUsTUFBTSxJQUFJLEdBQUcsVUFBVSxNQUFNLFlBQVksS0FBSyxDQUFDLENBQUM7UUFDMUU7QUFFQSxpQkFBUyxjQUFjLFFBQWMsT0FBaUI7QUFDcEQsY0FBSSxTQUFTLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBSztBQUM5QixnQkFBSSxVQUNGO2NBQ0UsU0FBUztjQUNULFVBQVU7Y0FDVixjQUFjLE9BQUEsS0FBSztjQUNuQixlQUFlO2VBRWpCLE1BQU07QUFFUixrQkFBSztVQUNQLENBQUM7UUFDSDtBQUVBLGlCQUFTLFlBQVksT0FBVztBQUM5QixjQUFJLE1BQUssR0FBQSxVQUFBLEtBQUksU0FBUztBQUN0QixjQUFJLFFBQVEsUUFBVztBQUNyQixnQkFBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLFlBQVksT0FBTyxNQUFNLElBQUksT0FBTyxPQUFPLElBQUksRUFBRSxNQUFLLENBQUU7aUJBQzlEO0FBQ0wsZ0JBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxXQUFXLE9BQU8sTUFBTSxJQUFJLE9BQU8sT0FBTyxLQUFLLEVBQUUsTUFBSyxDQUFFO0FBQ25FLGdCQUFJLFFBQVE7QUFBRyxrQkFBSSxPQUFPLE9BQU8sSUFBSTs7QUFDaEMsa0JBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxZQUFZLE9BQU8sTUFBTSxJQUFJLE9BQU8sT0FBTyxJQUFJLENBQUM7O1FBRXBFO01BQ0Y7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7O0FDcEdmLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQUNBLFFBQUEsU0FBQTtBQW1CYSxZQUFBLFFBQWdDO01BQzNDLFNBQVMsQ0FBQyxFQUFDLFFBQVEsRUFBQyxVQUFVLFdBQVcsS0FBSSxFQUFDLE1BQUs7QUFDakQsY0FBTSxlQUFlLGNBQWMsSUFBSSxhQUFhO0FBQ3BELGdCQUFPLEdBQUEsVUFBQSxpQkFBZ0IsZ0JBQWdCLHNCQUFzQjtNQUMvRDtNQUNBLFFBQVEsQ0FBQyxFQUFDLFFBQVEsRUFBQyxVQUFVLFdBQVcsTUFBTSxnQkFBZSxFQUFDLE9BQzVELEdBQUEsVUFBQSxnQkFBZTt1QkFDSTtpQkFDTjtZQUNMOzs7QUFHWixRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWTtNQUNaLE9BQUEsUUFBQTtNQUNBLEtBQUssS0FBZTtBQUNsQixjQUFNLENBQUMsVUFBVSxPQUFPLElBQUksa0JBQWtCLEdBQUc7QUFDakQsNkJBQXFCLEtBQUssUUFBUTtBQUNsQywyQkFBbUIsS0FBSyxPQUFPO01BQ2pDOztBQUdGLGFBQVMsa0JBQWtCLEVBQUMsT0FBTSxHQUFhO0FBQzdDLFlBQU0sZUFBcUMsQ0FBQTtBQUMzQyxZQUFNLGFBQWlDLENBQUE7QUFDdkMsaUJBQVcsT0FBTyxRQUFRO0FBQ3hCLFlBQUksUUFBUTtBQUFhO0FBQ3pCLGNBQU0sT0FBTyxNQUFNLFFBQVEsT0FBTyxHQUFHLENBQUMsSUFBSSxlQUFlO0FBQ3pELGFBQUssR0FBRyxJQUFJLE9BQU8sR0FBRzs7QUFFeEIsYUFBTyxDQUFDLGNBQWMsVUFBVTtJQUNsQztBQUVBLGFBQWdCLHFCQUNkLEtBQ0EsZUFBMkMsSUFBSSxRQUFNO0FBRXJELFlBQU0sRUFBQyxLQUFLLE1BQU0sR0FBRSxJQUFJO0FBQ3hCLFVBQUksT0FBTyxLQUFLLFlBQVksRUFBRSxXQUFXO0FBQUc7QUFDNUMsWUFBTSxVQUFVLElBQUksSUFBSSxTQUFTO0FBQ2pDLGlCQUFXLFFBQVEsY0FBYztBQUMvQixjQUFNLE9BQU8sYUFBYSxJQUFJO0FBQzlCLFlBQUksS0FBSyxXQUFXO0FBQUc7QUFDdkIsY0FBTSxlQUFjLEdBQUEsT0FBQSxnQkFBZSxLQUFLLE1BQU0sTUFBTSxHQUFHLEtBQUssYUFBYTtBQUN6RSxZQUFJLFVBQVU7VUFDWixVQUFVO1VBQ1YsV0FBVyxLQUFLO1VBQ2hCLE1BQU0sS0FBSyxLQUFLLElBQUk7U0FDckI7QUFDRCxZQUFJLEdBQUcsV0FBVztBQUNoQixjQUFJLEdBQUcsYUFBYSxNQUFLO0FBQ3ZCLHVCQUFXLFdBQVcsTUFBTTtBQUMxQixlQUFBLEdBQUEsT0FBQSx3QkFBdUIsS0FBSyxPQUFPOztVQUV2QyxDQUFDO2VBQ0k7QUFDTCxjQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksb0JBQW1CLEdBQUEsT0FBQSxrQkFBaUIsS0FBSyxNQUFNLE9BQU8sSUFBSTtBQUNyRSxXQUFBLEdBQUEsT0FBQSxtQkFBa0IsS0FBSyxPQUFPO0FBQzlCLGNBQUksS0FBSTs7O0lBR2Q7QUE1QkEsWUFBQSx1QkFBQTtBQThCQSxhQUFnQixtQkFBbUIsS0FBaUIsYUFBd0IsSUFBSSxRQUFNO0FBQ3BGLFlBQU0sRUFBQyxLQUFLLE1BQU0sU0FBUyxHQUFFLElBQUk7QUFDakMsWUFBTSxRQUFRLElBQUksS0FBSyxPQUFPO0FBQzlCLGlCQUFXLFFBQVEsWUFBWTtBQUM3QixhQUFJLEdBQUEsT0FBQSxtQkFBa0IsSUFBSSxXQUFXLElBQUksQ0FBYztBQUFHO0FBQzFELFlBQUk7V0FDRixHQUFBLE9BQUEsZ0JBQWUsS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLGFBQWE7VUFDckQsTUFBSztBQUNILGtCQUFNLFNBQVMsSUFBSSxVQUFVLEVBQUMsU0FBUyxZQUFZLEtBQUksR0FBRyxLQUFLO0FBQy9ELGdCQUFJLG9CQUFvQixRQUFRLEtBQUs7VUFDdkM7VUFDQSxNQUFNLElBQUksSUFBSSxPQUFPLElBQUk7OztBQUUzQixZQUFJLEdBQUcsS0FBSzs7SUFFaEI7QUFmQSxZQUFBLHFCQUFBO0FBaUJBLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDeEdmLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQUlBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUztNQUNULFFBQVEsQ0FBQyxFQUFDLE9BQU0sT0FBTSxHQUFBLFVBQUEsb0JBQW1CLE9BQU87O0FBR2xELFFBQU0sTUFBNkI7TUFDakMsU0FBUztNQUNULE1BQU07TUFDTixZQUFZLENBQUMsVUFBVSxTQUFTO01BQ2hDO01BQ0EsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxLQUFLLFFBQVEsTUFBTSxHQUFFLElBQUk7QUFDaEMsYUFBSSxHQUFBLE9BQUEsbUJBQWtCLElBQUksTUFBTTtBQUFHO0FBQ25DLGNBQU0sUUFBUSxJQUFJLEtBQUssT0FBTztBQUU5QixZQUFJLE1BQU0sT0FBTyxNQUFNLENBQUMsUUFBTztBQUM3QixjQUFJLFVBQVUsRUFBQyxjQUFjLElBQUcsQ0FBQztBQUNqQyxjQUFJLFVBQ0Y7WUFDRSxTQUFTO1lBQ1QsTUFBTTtZQUNOLFdBQVcsQ0FBQyxRQUFRO1lBQ3BCLGNBQWM7WUFDZCxlQUFlO2FBRWpCLEtBQUs7QUFFUCxjQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksS0FBSyxHQUFHLE1BQUs7QUFDdEIsZ0JBQUksTUFBTSxJQUFJO0FBQ2QsZ0JBQUksQ0FBQyxHQUFHO0FBQVcsa0JBQUksTUFBSztVQUM5QixDQUFDO1FBQ0gsQ0FBQztBQUVELFlBQUksR0FBRyxLQUFLO01BQ2Q7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUMxQ2YsUUFBQSxTQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxVQUFBO0FBRUEsUUFBQSxTQUFBO0FBUUEsUUFBTSxRQUFnQztNQUNwQyxTQUFTO01BQ1QsUUFBUSxDQUFDLEVBQUMsT0FBTSxPQUFNLEdBQUEsVUFBQSwwQkFBeUIsT0FBTzs7QUFHeEQsUUFBTSxNQUFzRDtNQUMxRCxTQUFTO01BQ1QsTUFBTSxDQUFDLFFBQVE7TUFDZixZQUFZLENBQUMsV0FBVyxRQUFRO01BQ2hDLGdCQUFnQjtNQUNoQixhQUFhO01BQ2I7TUFDQSxLQUFLLEtBQUc7QUFDTixjQUFNLEVBQUMsS0FBSyxRQUFRLGNBQWMsTUFBTSxXQUFXLEdBQUUsSUFBSTtBQUV6RCxZQUFJLENBQUM7QUFBVyxnQkFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQzFELGNBQU0sRUFBQyxXQUFXLEtBQUksSUFBSTtBQUMxQixXQUFHLFFBQVE7QUFDWCxZQUFJLEtBQUsscUJBQXFCLFVBQVMsR0FBQSxPQUFBLG1CQUFrQixJQUFJLE1BQU07QUFBRztBQUN0RSxjQUFNLFNBQVEsR0FBQSxPQUFBLHFCQUFvQixhQUFhLFVBQVU7QUFDekQsY0FBTSxZQUFXLEdBQUEsT0FBQSxxQkFBb0IsYUFBYSxpQkFBaUI7QUFDbkUsa0NBQXlCO0FBQ3pCLFlBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxpQkFBaUIsUUFBQSxRQUFFLFFBQVE7QUFFdEMsaUJBQVMsNEJBQXlCO0FBQ2hDLGNBQUksTUFBTSxPQUFPLE1BQU0sQ0FBQyxRQUFhO0FBQ25DLGdCQUFJLENBQUMsTUFBTSxVQUFVLENBQUMsU0FBUztBQUFRLHFDQUF1QixHQUFHOztBQUM1RCxrQkFBSSxHQUFHLGFBQWEsR0FBRyxHQUFHLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQztVQUNsRSxDQUFDO1FBQ0g7QUFFQSxpQkFBUyxhQUFhLEtBQVM7QUFDN0IsY0FBSTtBQUNKLGNBQUksTUFBTSxTQUFTLEdBQUc7QUFFcEIsa0JBQU0sZUFBYyxHQUFBLE9BQUEsZ0JBQWUsSUFBSSxhQUFhLFlBQVksWUFBWTtBQUM1RSwyQkFBYyxHQUFBLE9BQUEsZUFBYyxLQUFLLGFBQXFCLEdBQUc7cUJBQ2hELE1BQU0sUUFBUTtBQUN2QiwyQkFBYyxHQUFBLFVBQUEsSUFBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU0sR0FBQSxVQUFBLEtBQUksV0FBVyxHQUFHLENBQUM7aUJBQ25EO0FBQ0wsMEJBQWMsVUFBQTs7QUFFaEIsY0FBSSxTQUFTLFFBQVE7QUFDbkIsMkJBQWMsR0FBQSxVQUFBLElBQUcsYUFBYSxHQUFHLFNBQVMsSUFBSSxDQUFDLE9BQU0sR0FBQSxVQUFBLE1BQUksR0FBQSxPQUFBLFlBQVcsS0FBSyxDQUFDLFVBQVUsTUFBTSxDQUFDOztBQUU3RixrQkFBTyxHQUFBLFVBQUEsS0FBSSxXQUFXO1FBQ3hCO0FBRUEsaUJBQVMsaUJBQWlCLEtBQVM7QUFDakMsY0FBSSxNQUFLLEdBQUEsVUFBQSxZQUFXLFFBQVEsTUFBTTtRQUNwQztBQUVBLGlCQUFTLHVCQUF1QixLQUFTO0FBQ3ZDLGNBQUksS0FBSyxxQkFBcUIsU0FBVSxLQUFLLG9CQUFvQixXQUFXLE9BQVE7QUFDbEYsNkJBQWlCLEdBQUc7QUFDcEI7O0FBR0YsY0FBSSxXQUFXLE9BQU87QUFDcEIsZ0JBQUksVUFBVSxFQUFDLG9CQUFvQixJQUFHLENBQUM7QUFDdkMsZ0JBQUksTUFBSztBQUNULGdCQUFJLENBQUM7QUFBVyxrQkFBSSxNQUFLO0FBQ3pCOztBQUdGLGNBQUksT0FBTyxVQUFVLFlBQVksRUFBQyxHQUFBLE9BQUEsbUJBQWtCLElBQUksTUFBTSxHQUFHO0FBQy9ELGtCQUFNLFFBQVEsSUFBSSxLQUFLLE9BQU87QUFDOUIsZ0JBQUksS0FBSyxxQkFBcUIsV0FBVztBQUN2QyxvQ0FBc0IsS0FBSyxPQUFPLEtBQUs7QUFDdkMsa0JBQUksSUFBRyxHQUFBLFVBQUEsS0FBSSxLQUFLLEdBQUcsTUFBSztBQUN0QixvQkFBSSxNQUFLO0FBQ1QsaUNBQWlCLEdBQUc7Y0FDdEIsQ0FBQzttQkFDSTtBQUNMLG9DQUFzQixLQUFLLEtBQUs7QUFDaEMsa0JBQUksQ0FBQztBQUFXLG9CQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksS0FBSyxHQUFHLE1BQU0sSUFBSSxNQUFLLENBQUU7OztRQUcxRDtBQUVBLGlCQUFTLHNCQUFzQixLQUFXLE9BQWEsUUFBYztBQUNuRSxnQkFBTSxZQUEyQjtZQUMvQixTQUFTO1lBQ1QsVUFBVTtZQUNWLGNBQWMsT0FBQSxLQUFLOztBQUVyQixjQUFJLFdBQVcsT0FBTztBQUNwQixtQkFBTyxPQUFPLFdBQVc7Y0FDdkIsZUFBZTtjQUNmLGNBQWM7Y0FDZCxXQUFXO2FBQ1o7O0FBRUgsY0FBSSxVQUFVLFdBQVcsS0FBSztRQUNoQztNQUNGOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDcEhmLFFBQUEsYUFBQTtBQUNBLFFBQUEsU0FBQTtBQUNBLFFBQUEsU0FBQTtBQUNBLFFBQUEseUJBQUE7QUFFQSxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWTtNQUNaLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsS0FBSyxRQUFRLGNBQWMsTUFBTSxHQUFFLElBQUk7QUFDOUMsWUFBSSxHQUFHLEtBQUsscUJBQXFCLFNBQVMsYUFBYSx5QkFBeUIsUUFBVztBQUN6RixpQ0FBQSxRQUFNLEtBQUssSUFBSSxXQUFBLFdBQVcsSUFBSSx1QkFBQSxTQUFPLHNCQUFzQixDQUFDOztBQUU5RCxjQUFNLFlBQVcsR0FBQSxPQUFBLHFCQUFvQixNQUFNO0FBQzNDLG1CQUFXLFFBQVEsVUFBVTtBQUMzQixhQUFHLGtCQUFrQixJQUFJLElBQUk7O0FBRS9CLFlBQUksR0FBRyxLQUFLLGVBQWUsU0FBUyxVQUFVLEdBQUcsVUFBVSxNQUFNO0FBQy9ELGFBQUcsUUFBUSxPQUFBLGVBQWUsTUFBTSxNQUFLLEdBQUEsT0FBQSxRQUFPLFFBQVEsR0FBRyxHQUFHLEtBQUs7O0FBRWpFLGNBQU0sYUFBYSxTQUFTLE9BQU8sQ0FBQyxNQUFNLEVBQUMsR0FBQSxPQUFBLG1CQUFrQixJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDM0UsWUFBSSxXQUFXLFdBQVc7QUFBRztBQUM3QixjQUFNLFFBQVEsSUFBSSxLQUFLLE9BQU87QUFFOUIsbUJBQVcsUUFBUSxZQUFZO0FBQzdCLGNBQUksV0FBVyxJQUFJLEdBQUc7QUFDcEIsZ0NBQW9CLElBQUk7aUJBQ25CO0FBQ0wsZ0JBQUksSUFBRyxHQUFBLE9BQUEsZ0JBQWUsS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLGFBQWEsQ0FBQztBQUM3RCxnQ0FBb0IsSUFBSTtBQUN4QixnQkFBSSxDQUFDLEdBQUc7QUFBVyxrQkFBSSxLQUFJLEVBQUcsSUFBSSxPQUFPLElBQUk7QUFDN0MsZ0JBQUksTUFBSzs7QUFFWCxjQUFJLEdBQUcsa0JBQWtCLElBQUksSUFBSTtBQUNqQyxjQUFJLEdBQUcsS0FBSzs7QUFHZCxpQkFBUyxXQUFXLE1BQVk7QUFDOUIsaUJBQU8sR0FBRyxLQUFLLGVBQWUsQ0FBQyxHQUFHLGlCQUFpQixPQUFPLElBQUksRUFBRSxZQUFZO1FBQzlFO0FBRUEsaUJBQVMsb0JBQW9CLE1BQVk7QUFDdkMsY0FBSSxVQUNGO1lBQ0UsU0FBUztZQUNULFlBQVk7WUFDWixVQUFVO2FBRVosS0FBSztRQUVUO01BQ0Y7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUN0RGYsUUFBQSxTQUFBO0FBQ0EsUUFBQSxZQUFBO0FBQ0EsUUFBQSxTQUFBO0FBQ0EsUUFBQSxTQUFBO0FBR0EsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsTUFBTTtNQUNOLFlBQVk7TUFDWixLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLEtBQUssUUFBUSxNQUFNLGNBQWMsR0FBRSxJQUFJO0FBQzlDLGNBQU0sRUFBQyxLQUFJLElBQUk7QUFDZixjQUFNLFlBQVcsR0FBQSxPQUFBLHFCQUFvQixNQUFNO0FBQzNDLGNBQU0sc0JBQXNCLFNBQVMsT0FBTyxDQUFDLE9BQzNDLEdBQUEsT0FBQSxtQkFBa0IsSUFBSSxPQUFPLENBQUMsQ0FBYyxDQUFDO0FBRy9DLFlBQ0UsU0FBUyxXQUFXLEtBQ25CLG9CQUFvQixXQUFXLFNBQVMsV0FDdEMsQ0FBQyxHQUFHLEtBQUssZUFBZSxHQUFHLFVBQVUsT0FDeEM7QUFDQTs7QUFHRixjQUFNLGtCQUNKLEtBQUssZ0JBQWdCLENBQUMsS0FBSywyQkFBMkIsYUFBYTtBQUNyRSxjQUFNLFFBQVEsSUFBSSxLQUFLLE9BQU87QUFDOUIsWUFBSSxHQUFHLFVBQVUsUUFBUSxFQUFFLEdBQUcsaUJBQWlCLFVBQUEsT0FBTztBQUNwRCxhQUFHLFNBQVEsR0FBQSxPQUFBLHNCQUFxQixLQUFLLEdBQUcsS0FBSzs7QUFFL0MsY0FBTSxFQUFDLE1BQUssSUFBSTtBQUNoQixrQ0FBeUI7QUFFekIsaUJBQVMsNEJBQXlCO0FBQ2hDLHFCQUFXLE9BQU8sVUFBVTtBQUMxQixnQkFBSTtBQUFpQixzQ0FBd0IsR0FBRztBQUNoRCxnQkFBSSxHQUFHLFdBQVc7QUFDaEIsaUNBQW1CLEdBQUc7bUJBQ2pCO0FBQ0wsa0JBQUksSUFBSSxPQUFPLElBQUk7QUFDbkIsaUNBQW1CLEdBQUc7QUFDdEIsa0JBQUksR0FBRyxLQUFLOzs7UUFHbEI7QUFFQSxpQkFBUyx3QkFBd0IsS0FBVztBQUMxQyxxQkFBVyxRQUFRLGlCQUFpQjtBQUNsQyxnQkFBSSxJQUFJLE9BQU8sR0FBRyxFQUFFLEtBQUssSUFBSSxHQUFHO0FBQzlCLGVBQUEsR0FBQSxPQUFBLGlCQUNFLElBQ0EsWUFBWSx3QkFBd0IsbUNBQW1DOzs7UUFJL0U7QUFFQSxpQkFBUyxtQkFBbUIsS0FBVztBQUNyQyxjQUFJLE1BQU0sT0FBTyxNQUFNLENBQUMsUUFBTztBQUM3QixnQkFBSSxJQUFHLEdBQUEsVUFBQSxNQUFJLEdBQUEsT0FBQSxZQUFXLEtBQUssR0FBRyxVQUFVLFFBQVEsTUFBSztBQUNuRCxvQkFBTSxjQUFjLG9CQUFvQixTQUFTLEdBQUc7QUFDcEQsa0JBQUksQ0FBQyxhQUFhO0FBQ2hCLG9CQUFJLFVBQ0Y7a0JBQ0UsU0FBUztrQkFDVCxZQUFZO2tCQUNaLFVBQVU7a0JBQ1YsY0FBYyxPQUFBLEtBQUs7bUJBRXJCLEtBQUs7O0FBSVQsa0JBQUksR0FBRyxLQUFLLGVBQWUsVUFBVSxNQUFNO0FBQ3pDLG9CQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksU0FBUyxRQUFRLElBQUk7eUJBQzNCLENBQUMsZUFBZSxDQUFDLEdBQUcsV0FBVztBQUd4QyxvQkFBSSxJQUFHLEdBQUEsVUFBQSxLQUFJLEtBQUssR0FBRyxNQUFNLElBQUksTUFBSyxDQUFFOztZQUV4QyxDQUFDO1VBQ0gsQ0FBQztRQUNIO01BQ0Y7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUN4RmYsUUFBQSxTQUFBO0FBSUEsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsWUFBWSxDQUFDLFVBQVUsU0FBUztNQUNoQyxhQUFhO01BQ2IsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxLQUFLLFFBQVEsR0FBRSxJQUFJO0FBQzFCLGFBQUksR0FBQSxPQUFBLG1CQUFrQixJQUFJLE1BQU0sR0FBRztBQUNqQyxjQUFJLEtBQUk7QUFDUjs7QUFHRixjQUFNLFFBQVEsSUFBSSxLQUFLLE9BQU87QUFDOUIsWUFBSSxVQUNGO1VBQ0UsU0FBUztVQUNULGVBQWU7VUFDZixjQUFjO1VBQ2QsV0FBVztXQUViLEtBQUs7QUFHUCxZQUFJLFdBQ0YsT0FDQSxNQUFNLElBQUksTUFBSyxHQUNmLE1BQU0sSUFBSSxNQUFLLENBQUU7TUFFckI7TUFDQSxPQUFPLEVBQUMsU0FBUyxvQkFBbUI7O0FBR3RDLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDcENmLFFBQUEsU0FBQTtBQUlBLFFBQU0sTUFBNkI7TUFDakMsU0FBUztNQUNULFlBQVk7TUFDWixhQUFhO01BQ2IsTUFBTSxPQUFBO01BQ04sT0FBTyxFQUFDLFNBQVMsK0JBQThCOztBQUdqRCxZQUFBLFVBQWU7Ozs7Ozs7OztBQ05mLFFBQUEsWUFBQTtBQUNBLFFBQUEsU0FBQTtBQVNBLFFBQU0sUUFBZ0M7TUFDcEMsU0FBUztNQUNULFFBQVEsQ0FBQyxFQUFDLE9BQU0sT0FBTSxHQUFBLFVBQUEsc0JBQXFCLE9BQU87O0FBR3BELFFBQU0sTUFBNkI7TUFDakMsU0FBUztNQUNULFlBQVk7TUFDWixhQUFhO01BQ2I7TUFDQSxLQUFLLEtBQWU7QUFDbEIsY0FBTSxFQUFDLEtBQUssUUFBUSxjQUFjLEdBQUUsSUFBSTtBQUV4QyxZQUFJLENBQUMsTUFBTSxRQUFRLE1BQU07QUFBRyxnQkFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQ3RFLFlBQUksR0FBRyxLQUFLLGlCQUFpQixhQUFhO0FBQWU7QUFDekQsY0FBTSxTQUFzQjtBQUM1QixjQUFNLFFBQVEsSUFBSSxJQUFJLFNBQVMsS0FBSztBQUNwQyxjQUFNLFVBQVUsSUFBSSxJQUFJLFdBQVcsSUFBSTtBQUN2QyxjQUFNLFdBQVcsSUFBSSxLQUFLLFFBQVE7QUFDbEMsWUFBSSxVQUFVLEVBQUMsUUFBTyxDQUFDO0FBR3ZCLFlBQUksTUFBTSxhQUFhO0FBRXZCLFlBQUksT0FDRixPQUNBLE1BQU0sSUFBSSxNQUFLLEdBQ2YsTUFBTSxJQUFJLE1BQU0sSUFBSSxDQUFDO0FBR3ZCLGlCQUFTLGdCQUFhO0FBQ3BCLGlCQUFPLFFBQVEsQ0FBQyxLQUFnQixNQUFhO0FBQzNDLGdCQUFJO0FBQ0osaUJBQUksR0FBQSxPQUFBLG1CQUFrQixJQUFJLEdBQUcsR0FBRztBQUM5QixrQkFBSSxJQUFJLFVBQVUsSUFBSTttQkFDakI7QUFDTCx1QkFBUyxJQUFJLFVBQ1g7Z0JBQ0UsU0FBUztnQkFDVCxZQUFZO2dCQUNaLGVBQWU7aUJBRWpCLFFBQVE7O0FBSVosZ0JBQUksSUFBSSxHQUFHO0FBQ1Qsa0JBQ0csSUFBRyxHQUFBLFVBQUEsS0FBSSxlQUFlLE9BQU8sRUFDN0IsT0FBTyxPQUFPLEtBQUssRUFDbkIsT0FBTyxVQUFTLEdBQUEsVUFBQSxNQUFLLFlBQVksSUFBSSxFQUNyQyxLQUFJOztBQUdULGdCQUFJLEdBQUcsVUFBVSxNQUFLO0FBQ3BCLGtCQUFJLE9BQU8sT0FBTyxJQUFJO0FBQ3RCLGtCQUFJLE9BQU8sU0FBUyxDQUFDO0FBQ3JCLGtCQUFJO0FBQVEsb0JBQUksZUFBZSxRQUFRLFVBQUEsSUFBSTtZQUM3QyxDQUFDO1VBQ0gsQ0FBQztRQUNIO01BQ0Y7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUMvRWYsUUFBQSxTQUFBO0FBRUEsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsWUFBWTtNQUNaLEtBQUssS0FBZTtBQUNsQixjQUFNLEVBQUMsS0FBSyxRQUFRLEdBQUUsSUFBSTtBQUUxQixZQUFJLENBQUMsTUFBTSxRQUFRLE1BQU07QUFBRyxnQkFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQ3RFLGNBQU0sUUFBUSxJQUFJLEtBQUssT0FBTztBQUM5QixlQUFPLFFBQVEsQ0FBQyxLQUFnQixNQUFhO0FBQzNDLGVBQUksR0FBQSxPQUFBLG1CQUFrQixJQUFJLEdBQUc7QUFBRztBQUNoQyxnQkFBTSxTQUFTLElBQUksVUFBVSxFQUFDLFNBQVMsU0FBUyxZQUFZLEVBQUMsR0FBRyxLQUFLO0FBQ3JFLGNBQUksR0FBRyxLQUFLO0FBQ1osY0FBSSxlQUFlLE1BQU07UUFDM0IsQ0FBQztNQUNIOztBQUdGLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDYmYsUUFBQSxZQUFBO0FBQ0EsUUFBQSxTQUFBO0FBSUEsUUFBTSxRQUFnQztNQUNwQyxTQUFTLENBQUMsRUFBQyxPQUFNLE9BQU0sR0FBQSxVQUFBLG1CQUFrQixPQUFPO01BQ2hELFFBQVEsQ0FBQyxFQUFDLE9BQU0sT0FBTSxHQUFBLFVBQUEsc0JBQXFCLE9BQU87O0FBR3BELFFBQU0sTUFBNkI7TUFDakMsU0FBUztNQUNULFlBQVksQ0FBQyxVQUFVLFNBQVM7TUFDaEMsYUFBYTtNQUNiO01BQ0EsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxLQUFLLGNBQWMsR0FBRSxJQUFJO0FBQ2hDLFlBQUksYUFBYSxTQUFTLFVBQWEsYUFBYSxTQUFTLFFBQVc7QUFDdEUsV0FBQSxHQUFBLE9BQUEsaUJBQWdCLElBQUksMkNBQTJDOztBQUVqRSxjQUFNLFVBQVUsVUFBVSxJQUFJLE1BQU07QUFDcEMsY0FBTSxVQUFVLFVBQVUsSUFBSSxNQUFNO0FBQ3BDLFlBQUksQ0FBQyxXQUFXLENBQUM7QUFBUztBQUUxQixjQUFNLFFBQVEsSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUNuQyxjQUFNLFdBQVcsSUFBSSxLQUFLLFFBQVE7QUFDbEMsbUJBQVU7QUFDVixZQUFJLE1BQUs7QUFFVCxZQUFJLFdBQVcsU0FBUztBQUN0QixnQkFBTSxXQUFXLElBQUksSUFBSSxVQUFVO0FBQ25DLGNBQUksVUFBVSxFQUFDLFNBQVEsQ0FBQztBQUN4QixjQUFJLEdBQUcsVUFBVSxlQUFlLFFBQVEsUUFBUSxHQUFHLGVBQWUsUUFBUSxRQUFRLENBQUM7bUJBQzFFLFNBQVM7QUFDbEIsY0FBSSxHQUFHLFVBQVUsZUFBZSxNQUFNLENBQUM7ZUFDbEM7QUFDTCxjQUFJLElBQUcsR0FBQSxVQUFBLEtBQUksUUFBUSxHQUFHLGVBQWUsTUFBTSxDQUFDOztBQUc5QyxZQUFJLEtBQUssT0FBTyxNQUFNLElBQUksTUFBTSxJQUFJLENBQUM7QUFFckMsaUJBQVMsYUFBVTtBQUNqQixnQkFBTSxTQUFTLElBQUksVUFDakI7WUFDRSxTQUFTO1lBQ1QsZUFBZTtZQUNmLGNBQWM7WUFDZCxXQUFXO2FBRWIsUUFBUTtBQUVWLGNBQUksZUFBZSxNQUFNO1FBQzNCO0FBRUEsaUJBQVMsZUFBZSxTQUFpQixVQUFlO0FBQ3RELGlCQUFPLE1BQUs7QUFDVixrQkFBTSxTQUFTLElBQUksVUFBVSxFQUFDLFFBQU8sR0FBRyxRQUFRO0FBQ2hELGdCQUFJLE9BQU8sT0FBTyxRQUFRO0FBQzFCLGdCQUFJLG9CQUFvQixRQUFRLEtBQUs7QUFDckMsZ0JBQUk7QUFBVSxrQkFBSSxPQUFPLFdBQVUsR0FBQSxVQUFBLEtBQUksU0FBUzs7QUFDM0Msa0JBQUksVUFBVSxFQUFDLFVBQVUsUUFBTyxDQUFDO1VBQ3hDO1FBQ0Y7TUFDRjs7QUFHRixhQUFTLFVBQVUsSUFBa0IsU0FBZTtBQUNsRCxZQUFNLFNBQVMsR0FBRyxPQUFPLE9BQU87QUFDaEMsYUFBTyxXQUFXLFVBQWEsRUFBQyxHQUFBLE9BQUEsbUJBQWtCLElBQUksTUFBTTtJQUM5RDtBQUVBLFlBQUEsVUFBZTs7Ozs7Ozs7O0FDN0VmLFFBQUEsU0FBQTtBQUVBLFFBQU0sTUFBNkI7TUFDakMsU0FBUyxDQUFDLFFBQVEsTUFBTTtNQUN4QixZQUFZLENBQUMsVUFBVSxTQUFTO01BQ2hDLEtBQUssRUFBQyxTQUFTLGNBQWMsR0FBRSxHQUFhO0FBQzFDLFlBQUksYUFBYSxPQUFPO0FBQVcsV0FBQSxHQUFBLE9BQUEsaUJBQWdCLElBQUksSUFBSSxrQ0FBa0M7TUFDL0Y7O0FBR0YsWUFBQSxVQUFlOzs7Ozs7Ozs7QUNYZixRQUFBLG9CQUFBO0FBQ0EsUUFBQSxnQkFBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsYUFBQTtBQUNBLFFBQUEsaUJBQUE7QUFDQSxRQUFBLGtCQUFBO0FBQ0EsUUFBQSx5QkFBQTtBQUNBLFFBQUEsZUFBQTtBQUNBLFFBQUEsc0JBQUE7QUFDQSxRQUFBLFFBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLE9BQUE7QUFDQSxRQUFBLGFBQUE7QUFFQSxhQUF3QixjQUFjLFlBQVksT0FBSztBQUNyRCxZQUFNLGFBQWE7O1FBRWpCLE1BQUE7UUFDQSxRQUFBO1FBQ0EsUUFBQTtRQUNBLFFBQUE7UUFDQSxLQUFBO1FBQ0EsV0FBQTs7UUFFQSxnQkFBQTtRQUNBLHVCQUFBO1FBQ0EsZUFBQTtRQUNBLGFBQUE7UUFDQSxvQkFBQTs7QUFHRixVQUFJO0FBQVcsbUJBQVcsS0FBSyxjQUFBLFNBQWEsWUFBQSxPQUFTOztBQUNoRCxtQkFBVyxLQUFLLGtCQUFBLFNBQWlCLFFBQUEsT0FBSztBQUMzQyxpQkFBVyxLQUFLLFdBQUEsT0FBUTtBQUN4QixhQUFPO0lBQ1Q7QUFyQkEsWUFBQSxVQUFBOzs7Ozs7Ozs7QUNUQSxRQUFBLFlBQUE7QUFhQSxRQUFNLFFBQWdDO01BQ3BDLFNBQVMsQ0FBQyxFQUFDLFdBQVUsT0FBTSxHQUFBLFVBQUEsMEJBQXlCO01BQ3BELFFBQVEsQ0FBQyxFQUFDLFdBQVUsT0FBTSxHQUFBLFVBQUEsY0FBYTs7QUFHekMsUUFBTSxNQUE2QjtNQUNqQyxTQUFTO01BQ1QsTUFBTSxDQUFDLFVBQVUsUUFBUTtNQUN6QixZQUFZO01BQ1osT0FBTztNQUNQO01BQ0EsS0FBSyxLQUFpQixVQUFpQjtBQUNyQyxjQUFNLEVBQUMsS0FBSyxNQUFNLE9BQU8sUUFBUSxZQUFZLEdBQUUsSUFBSTtBQUNuRCxjQUFNLEVBQUMsTUFBTSxlQUFlLFdBQVcsTUFBQUMsTUFBSSxJQUFJO0FBQy9DLFlBQUksQ0FBQyxLQUFLO0FBQWlCO0FBRTNCLFlBQUk7QUFBTyw4QkFBbUI7O0FBQ3pCLHlCQUFjO0FBRW5CLGlCQUFTLHNCQUFtQjtBQUMxQixnQkFBTSxPQUFPLElBQUksV0FBVyxXQUFXO1lBQ3JDLEtBQUtBLE1BQUs7WUFDVixNQUFNLEtBQUssS0FBSztXQUNqQjtBQUNELGdCQUFNLE9BQU8sSUFBSSxNQUFNLFNBQVEsR0FBQSxVQUFBLEtBQUksUUFBUSxhQUFhO0FBQ3hELGdCQUFNLFFBQVEsSUFBSSxJQUFJLE9BQU87QUFDN0IsZ0JBQU0sU0FBUyxJQUFJLElBQUksUUFBUTtBQUUvQixjQUFJLElBQ0YsR0FBQSxVQUFBLFlBQVcseUJBQXlCLDJCQUNwQyxNQUFNLElBQUksT0FBTyxRQUFPLEdBQUEsVUFBQSxLQUFJLHVCQUF1QixFQUFFLE9BQU8sU0FBUSxHQUFBLFVBQUEsS0FBSSxlQUFlLEdBQ3ZGLE1BQU0sSUFBSSxPQUFPLFFBQU8sR0FBQSxVQUFBLFlBQVcsRUFBRSxPQUFPLFFBQVEsSUFBSSxDQUFDO0FBRTNELGNBQUksV0FBVSxHQUFBLFVBQUEsSUFBRyxXQUFVLEdBQUksV0FBVSxDQUFFLENBQUM7QUFFNUMsbUJBQVMsYUFBVTtBQUNqQixnQkFBSSxLQUFLLGlCQUFpQjtBQUFPLHFCQUFPLFVBQUE7QUFDeEMsb0JBQU8sR0FBQSxVQUFBLEtBQUksa0JBQWtCO1VBQy9CO0FBRUEsbUJBQVMsYUFBVTtBQUNqQixrQkFBTSxhQUFhLFVBQVUsVUFDekIsR0FBQSxVQUFBLE1BQUssc0JBQXNCLFVBQVUsV0FBVyxVQUFVLFlBQzFELEdBQUEsVUFBQSxLQUFJLFVBQVU7QUFDbEIsa0JBQU0sYUFBWSxHQUFBLFVBQUEsYUFBWSwwQkFBMEIsZ0JBQWdCLGVBQWU7QUFDdkYsb0JBQU8sR0FBQSxVQUFBLEtBQUksYUFBYSxzQkFBc0IsYUFBYSxnQkFBZ0I7VUFDN0U7UUFDRjtBQUVBLGlCQUFTLGlCQUFjO0FBQ3JCLGdCQUFNLFlBQXFDQSxNQUFLLFFBQVEsTUFBTTtBQUM5RCxjQUFJLENBQUMsV0FBVztBQUNkLDBCQUFhO0FBQ2I7O0FBRUYsY0FBSSxjQUFjO0FBQU07QUFDeEIsZ0JBQU0sQ0FBQyxTQUFTLFFBQVEsTUFBTSxJQUFJLFVBQVUsU0FBUztBQUNyRCxjQUFJLFlBQVk7QUFBVSxnQkFBSSxLQUFLLGVBQWMsQ0FBRTtBQUVuRCxtQkFBUyxnQkFBYTtBQUNwQixnQkFBSSxLQUFLLGlCQUFpQixPQUFPO0FBQy9CLGNBQUFBLE1BQUssT0FBTyxLQUFLLFdBQVUsQ0FBRTtBQUM3Qjs7QUFFRixrQkFBTSxJQUFJLE1BQU0sV0FBVSxDQUFFO0FBRTVCLHFCQUFTLGFBQVU7QUFDakIscUJBQU8sbUJBQW1CLHNDQUFnRDtZQUM1RTtVQUNGO0FBRUEsbUJBQVMsVUFBVSxRQUFtQjtBQUNwQyxrQkFBTSxPQUNKLGtCQUFrQixVQUNkLEdBQUEsVUFBQSxZQUFXLE1BQU0sSUFDakIsS0FBSyxLQUFLLFdBQ1YsR0FBQSxVQUFBLEtBQUksS0FBSyxLQUFLLFdBQVUsR0FBQSxVQUFBLGFBQVksTUFBTSxNQUMxQztBQUNOLGtCQUFNLE1BQU0sSUFBSSxXQUFXLFdBQVcsRUFBQyxLQUFLLFFBQVEsS0FBSyxRQUFRLEtBQUksQ0FBQztBQUN0RSxnQkFBSSxPQUFPLFVBQVUsWUFBWSxFQUFFLGtCQUFrQixTQUFTO0FBQzVELHFCQUFPLENBQUMsT0FBTyxRQUFRLFVBQVUsT0FBTyxXQUFVLEdBQUEsVUFBQSxLQUFJLGNBQWM7O0FBR3RFLG1CQUFPLENBQUMsVUFBVSxRQUFRLEdBQUc7VUFDL0I7QUFFQSxtQkFBUyxpQkFBYztBQUNyQixnQkFBSSxPQUFPLGFBQWEsWUFBWSxFQUFFLHFCQUFxQixXQUFXLFVBQVUsT0FBTztBQUNyRixrQkFBSSxDQUFDLFVBQVU7QUFBUSxzQkFBTSxJQUFJLE1BQU0sNkJBQTZCO0FBQ3BFLHNCQUFPLEdBQUEsVUFBQSxXQUFVLFVBQVU7O0FBRTdCLG1CQUFPLE9BQU8sVUFBVSxjQUFhLEdBQUEsVUFBQSxLQUFJLFVBQVUsV0FBVSxHQUFBLFVBQUEsS0FBSSxlQUFlO1VBQ2xGO1FBQ0Y7TUFDRjs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7OztBQ3RIZixRQUFBLFdBQUE7QUFFQSxRQUFNLFNBQXFCLENBQUMsU0FBQSxPQUFhO0FBRXpDLFlBQUEsVUFBZTs7Ozs7Ozs7OztBQ0hGLFlBQUEscUJBQWlDO01BQzVDO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztBQUdXLFlBQUEsb0JBQWdDO01BQzNDO01BQ0E7TUFDQTs7Ozs7Ozs7OztBQ2RGLFFBQUEsU0FBQTtBQUNBLFFBQUEsZUFBQTtBQUNBLFFBQUEsZUFBQTtBQUNBLFFBQUEsV0FBQTtBQUNBLFFBQUEsYUFBQTtBQUVBLFFBQU0scUJBQW1DO01BQ3ZDLE9BQUE7TUFDQSxhQUFBO09BQ0EsR0FBQSxhQUFBLFNBQXVCO01BQ3ZCLFNBQUE7TUFDQSxXQUFBO01BQ0EsV0FBQTs7QUFHRixZQUFBLFVBQWU7Ozs7Ozs7Ozs7QUNkZixRQUFZO0FBQVosS0FBQSxTQUFZQyxhQUFVO0FBQ3BCLE1BQUFBLFlBQUEsS0FBQSxJQUFBO0FBQ0EsTUFBQUEsWUFBQSxTQUFBLElBQUE7SUFDRixHQUhZLGFBQUEsUUFBQSxlQUFBLFFBQUEsYUFBVSxDQUFBLEVBQUE7Ozs7Ozs7OztBQ0F0QixRQUFBLFlBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFNBQUE7QUFJQSxRQUFNLFFBQWdDO01BQ3BDLFNBQVMsQ0FBQyxFQUFDLFFBQVEsRUFBQyxZQUFZLFFBQU8sRUFBQyxNQUN0QyxlQUFlLFFBQUEsV0FBVyxNQUN0QixRQUFRLDRCQUNSLGlCQUFpQjtNQUN2QixRQUFRLENBQUMsRUFBQyxRQUFRLEVBQUMsWUFBWSxLQUFLLFFBQU8sRUFBQyxPQUMxQyxHQUFBLFVBQUEsYUFBWSxvQkFBb0Isc0JBQXNCOztBQUcxRCxRQUFNLE1BQTZCO01BQ2pDLFNBQVM7TUFDVCxNQUFNO01BQ04sWUFBWTtNQUNaO01BQ0EsS0FBSyxLQUFlO0FBQ2xCLGNBQU0sRUFBQyxLQUFLLE1BQU0sUUFBUSxjQUFjLEdBQUUsSUFBSTtBQUM5QyxjQUFNLEVBQUMsTUFBSyxJQUFJO0FBQ2hCLFlBQUksQ0FBQyxHQUFHLEtBQUssZUFBZTtBQUMxQixnQkFBTSxJQUFJLE1BQU0sOENBQThDOztBQUVoRSxjQUFNLFVBQVUsT0FBTztBQUN2QixZQUFJLE9BQU8sV0FBVztBQUFVLGdCQUFNLElBQUksTUFBTSxzQ0FBc0M7QUFDdEYsWUFBSSxPQUFPO0FBQVMsZ0JBQU0sSUFBSSxNQUFNLHlDQUF5QztBQUM3RSxZQUFJLENBQUM7QUFBTyxnQkFBTSxJQUFJLE1BQU0sdUNBQXVDO0FBQ25FLGNBQU0sUUFBUSxJQUFJLElBQUksU0FBUyxLQUFLO0FBQ3BDLGNBQU0sTUFBTSxJQUFJLE1BQU0sUUFBTyxHQUFBLFVBQUEsS0FBSSxRQUFPLEdBQUEsVUFBQSxhQUFZLE9BQU8sR0FBRztBQUM5RCxZQUFJLElBQ0YsR0FBQSxVQUFBLFlBQVcsbUJBQ1gsTUFBTSxnQkFBZSxHQUNyQixNQUFNLElBQUksTUFBTSxPQUFPLEVBQUMsWUFBWSxRQUFBLFdBQVcsS0FBSyxLQUFLLFFBQU8sQ0FBQyxDQUFDO0FBRXBFLFlBQUksR0FBRyxLQUFLO0FBRVosaUJBQVMsa0JBQWU7QUFDdEIsZ0JBQU0sVUFBVSxXQUFVO0FBQzFCLGNBQUksR0FBRyxLQUFLO0FBQ1oscUJBQVcsWUFBWSxTQUFTO0FBQzlCLGdCQUFJLFFBQU8sR0FBQSxVQUFBLEtBQUksV0FBVyxVQUFVO0FBQ3BDLGdCQUFJLE9BQU8sT0FBTyxlQUFlLFFBQVEsUUFBUSxDQUFDLENBQUM7O0FBRXJELGNBQUksS0FBSTtBQUNSLGNBQUksTUFBTSxPQUFPLEVBQUMsWUFBWSxRQUFBLFdBQVcsU0FBUyxLQUFLLFFBQU8sQ0FBQztBQUMvRCxjQUFJLE1BQUs7UUFDWDtBQUVBLGlCQUFTLGVBQWUsWUFBbUI7QUFDekMsZ0JBQU0sU0FBUyxJQUFJLEtBQUssT0FBTztBQUMvQixnQkFBTSxTQUFTLElBQUksVUFBVSxFQUFDLFNBQVMsU0FBUyxXQUFVLEdBQUcsTUFBTTtBQUNuRSxjQUFJLGVBQWUsUUFBUSxVQUFBLElBQUk7QUFDL0IsaUJBQU87UUFDVDtBQUVBLGlCQUFTLGFBQVU7O0FBQ2pCLGdCQUFNLGVBQXlDLENBQUE7QUFDL0MsZ0JBQU0sY0FBYyxZQUFZLFlBQVk7QUFDNUMsY0FBSSxjQUFjO0FBQ2xCLG1CQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ3JDLGdCQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ2pCLGlCQUFJLFFBQUcsUUFBSCxRQUFHLFNBQUEsU0FBSCxJQUFLLFNBQVEsRUFBQyxHQUFBLE9BQUEsc0JBQXFCLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRztBQUMxRCxvQkFBTSxVQUFBLFdBQVcsS0FBSyxHQUFHLE1BQU0sR0FBRyxVQUFVLE1BQU0sR0FBRyxRQUFRLFFBQUcsUUFBSCxRQUFHLFNBQUEsU0FBSCxJQUFLLElBQUk7QUFDdEUsa0JBQUksZUFBZSxVQUFBO0FBQVcsc0JBQU0sSUFBSTs7QUFFMUMsa0JBQU0sV0FBVUMsTUFBQSxRQUFHLFFBQUgsUUFBRyxTQUFBLFNBQUgsSUFBSyxnQkFBVSxRQUFBQSxRQUFBLFNBQUEsU0FBQUEsSUFBRyxPQUFPO0FBQ3pDLGdCQUFJLE9BQU8sV0FBVyxVQUFVO0FBQzlCLG9CQUFNLElBQUksTUFDUixpRkFBaUYsVUFBVTs7QUFHL0YsMEJBQWMsZ0JBQWdCLGVBQWUsWUFBWSxHQUFHO0FBQzVELHdCQUFZLFNBQVMsQ0FBQzs7QUFFeEIsY0FBSSxDQUFDO0FBQWEsa0JBQU0sSUFBSSxNQUFNLG1CQUFtQiwyQkFBMkI7QUFDaEYsaUJBQU87QUFFUCxtQkFBUyxZQUFZLEVBQUMsU0FBUSxHQUFrQjtBQUM5QyxtQkFBTyxNQUFNLFFBQVEsUUFBUSxLQUFLLFNBQVMsU0FBUyxPQUFPO1VBQzdEO0FBRUEsbUJBQVMsWUFBWSxLQUFzQixHQUFTO0FBQ2xELGdCQUFJLElBQUksT0FBTztBQUNiLHlCQUFXLElBQUksT0FBTyxDQUFDO3VCQUNkLElBQUksTUFBTTtBQUNuQix5QkFBVyxZQUFZLElBQUksTUFBTTtBQUMvQiwyQkFBVyxVQUFVLENBQUM7O21CQUVuQjtBQUNMLG9CQUFNLElBQUksTUFBTSw4QkFBOEIsc0NBQXNDOztVQUV4RjtBQUVBLG1CQUFTLFdBQVcsVUFBbUIsR0FBUztBQUM5QyxnQkFBSSxPQUFPLFlBQVksWUFBWSxZQUFZLGNBQWM7QUFDM0Qsb0JBQU0sSUFBSSxNQUFNLG1CQUFtQix3Q0FBd0M7O0FBRTdFLHlCQUFhLFFBQVEsSUFBSTtVQUMzQjtRQUNGO01BQ0Y7O0FBR0YsWUFBQSxVQUFlOzs7OztBQzdHZjtBQUFBLDJHQUFBQyxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLE1BQ0UsU0FBVztBQUFBLE1BQ1gsS0FBTztBQUFBLE1BQ1AsT0FBUztBQUFBLE1BQ1QsYUFBZTtBQUFBLFFBQ2IsYUFBZTtBQUFBLFVBQ2IsTUFBUTtBQUFBLFVBQ1IsVUFBWTtBQUFBLFVBQ1osT0FBUyxFQUFDLE1BQVEsSUFBRztBQUFBLFFBQ3ZCO0FBQUEsUUFDQSxvQkFBc0I7QUFBQSxVQUNwQixNQUFRO0FBQUEsVUFDUixTQUFXO0FBQUEsUUFDYjtBQUFBLFFBQ0EsNEJBQThCO0FBQUEsVUFDNUIsT0FBUyxDQUFDLEVBQUMsTUFBUSxtQ0FBa0MsR0FBRyxFQUFDLFNBQVcsRUFBQyxDQUFDO0FBQUEsUUFDeEU7QUFBQSxRQUNBLGFBQWU7QUFBQSxVQUNiLE1BQVEsQ0FBQyxTQUFTLFdBQVcsV0FBVyxRQUFRLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDOUU7QUFBQSxRQUNBLGFBQWU7QUFBQSxVQUNiLE1BQVE7QUFBQSxVQUNSLE9BQVMsRUFBQyxNQUFRLFNBQVE7QUFBQSxVQUMxQixhQUFlO0FBQUEsVUFDZixTQUFXLENBQUM7QUFBQSxRQUNkO0FBQUEsTUFDRjtBQUFBLE1BQ0EsTUFBUSxDQUFDLFVBQVUsU0FBUztBQUFBLE1BQzVCLFlBQWM7QUFBQSxRQUNaLEtBQU87QUFBQSxVQUNMLE1BQVE7QUFBQSxVQUNSLFFBQVU7QUFBQSxRQUNaO0FBQUEsUUFDQSxTQUFXO0FBQUEsVUFDVCxNQUFRO0FBQUEsVUFDUixRQUFVO0FBQUEsUUFDWjtBQUFBLFFBQ0EsTUFBUTtBQUFBLFVBQ04sTUFBUTtBQUFBLFVBQ1IsUUFBVTtBQUFBLFFBQ1o7QUFBQSxRQUNBLFVBQVk7QUFBQSxVQUNWLE1BQVE7QUFBQSxRQUNWO0FBQUEsUUFDQSxPQUFTO0FBQUEsVUFDUCxNQUFRO0FBQUEsUUFDVjtBQUFBLFFBQ0EsYUFBZTtBQUFBLFVBQ2IsTUFBUTtBQUFBLFFBQ1Y7QUFBQSxRQUNBLFNBQVc7QUFBQSxRQUNYLFVBQVk7QUFBQSxVQUNWLE1BQVE7QUFBQSxVQUNSLFNBQVc7QUFBQSxRQUNiO0FBQUEsUUFDQSxVQUFZO0FBQUEsVUFDVixNQUFRO0FBQUEsVUFDUixPQUFTO0FBQUEsUUFDWDtBQUFBLFFBQ0EsWUFBYztBQUFBLFVBQ1osTUFBUTtBQUFBLFVBQ1Isa0JBQW9CO0FBQUEsUUFDdEI7QUFBQSxRQUNBLFNBQVc7QUFBQSxVQUNULE1BQVE7QUFBQSxRQUNWO0FBQUEsUUFDQSxrQkFBb0I7QUFBQSxVQUNsQixNQUFRO0FBQUEsUUFDVjtBQUFBLFFBQ0EsU0FBVztBQUFBLFVBQ1QsTUFBUTtBQUFBLFFBQ1Y7QUFBQSxRQUNBLGtCQUFvQjtBQUFBLFVBQ2xCLE1BQVE7QUFBQSxRQUNWO0FBQUEsUUFDQSxXQUFhLEVBQUMsTUFBUSxtQ0FBa0M7QUFBQSxRQUN4RCxXQUFhLEVBQUMsTUFBUSwyQ0FBMEM7QUFBQSxRQUNoRSxTQUFXO0FBQUEsVUFDVCxNQUFRO0FBQUEsVUFDUixRQUFVO0FBQUEsUUFDWjtBQUFBLFFBQ0EsaUJBQW1CLEVBQUMsTUFBUSxJQUFHO0FBQUEsUUFDL0IsT0FBUztBQUFBLFVBQ1AsT0FBUyxDQUFDLEVBQUMsTUFBUSxJQUFHLEdBQUcsRUFBQyxNQUFRLDRCQUEyQixDQUFDO0FBQUEsVUFDOUQsU0FBVztBQUFBLFFBQ2I7QUFBQSxRQUNBLFVBQVksRUFBQyxNQUFRLG1DQUFrQztBQUFBLFFBQ3ZELFVBQVksRUFBQyxNQUFRLDJDQUEwQztBQUFBLFFBQy9ELGFBQWU7QUFBQSxVQUNiLE1BQVE7QUFBQSxVQUNSLFNBQVc7QUFBQSxRQUNiO0FBQUEsUUFDQSxVQUFZLEVBQUMsTUFBUSxJQUFHO0FBQUEsUUFDeEIsZUFBaUIsRUFBQyxNQUFRLG1DQUFrQztBQUFBLFFBQzVELGVBQWlCLEVBQUMsTUFBUSwyQ0FBMEM7QUFBQSxRQUNwRSxVQUFZLEVBQUMsTUFBUSw0QkFBMkI7QUFBQSxRQUNoRCxzQkFBd0IsRUFBQyxNQUFRLElBQUc7QUFBQSxRQUNwQyxhQUFlO0FBQUEsVUFDYixNQUFRO0FBQUEsVUFDUixzQkFBd0IsRUFBQyxNQUFRLElBQUc7QUFBQSxVQUNwQyxTQUFXLENBQUM7QUFBQSxRQUNkO0FBQUEsUUFDQSxZQUFjO0FBQUEsVUFDWixNQUFRO0FBQUEsVUFDUixzQkFBd0IsRUFBQyxNQUFRLElBQUc7QUFBQSxVQUNwQyxTQUFXLENBQUM7QUFBQSxRQUNkO0FBQUEsUUFDQSxtQkFBcUI7QUFBQSxVQUNuQixNQUFRO0FBQUEsVUFDUixzQkFBd0IsRUFBQyxNQUFRLElBQUc7QUFBQSxVQUNwQyxlQUFpQixFQUFDLFFBQVUsUUFBTztBQUFBLFVBQ25DLFNBQVcsQ0FBQztBQUFBLFFBQ2Q7QUFBQSxRQUNBLGNBQWdCO0FBQUEsVUFDZCxNQUFRO0FBQUEsVUFDUixzQkFBd0I7QUFBQSxZQUN0QixPQUFTLENBQUMsRUFBQyxNQUFRLElBQUcsR0FBRyxFQUFDLE1BQVEsNEJBQTJCLENBQUM7QUFBQSxVQUNoRTtBQUFBLFFBQ0Y7QUFBQSxRQUNBLGVBQWlCLEVBQUMsTUFBUSxJQUFHO0FBQUEsUUFDN0IsT0FBUztBQUFBLFFBQ1QsTUFBUTtBQUFBLFVBQ04sTUFBUTtBQUFBLFVBQ1IsT0FBUztBQUFBLFVBQ1QsVUFBWTtBQUFBLFVBQ1osYUFBZTtBQUFBLFFBQ2pCO0FBQUEsUUFDQSxNQUFRO0FBQUEsVUFDTixPQUFTO0FBQUEsWUFDUCxFQUFDLE1BQVEsNEJBQTJCO0FBQUEsWUFDcEM7QUFBQSxjQUNFLE1BQVE7QUFBQSxjQUNSLE9BQVMsRUFBQyxNQUFRLDRCQUEyQjtBQUFBLGNBQzdDLFVBQVk7QUFBQSxjQUNaLGFBQWU7QUFBQSxZQUNqQjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsUUFDQSxRQUFVLEVBQUMsTUFBUSxTQUFRO0FBQUEsUUFDM0Isa0JBQW9CLEVBQUMsTUFBUSxTQUFRO0FBQUEsUUFDckMsaUJBQW1CLEVBQUMsTUFBUSxTQUFRO0FBQUEsUUFDcEMsSUFBTSxFQUFDLE1BQVEsSUFBRztBQUFBLFFBQ2xCLE1BQVEsRUFBQyxNQUFRLElBQUc7QUFBQSxRQUNwQixNQUFRLEVBQUMsTUFBUSxJQUFHO0FBQUEsUUFDcEIsT0FBUyxFQUFDLE1BQVEsNEJBQTJCO0FBQUEsUUFDN0MsT0FBUyxFQUFDLE1BQVEsNEJBQTJCO0FBQUEsUUFDN0MsT0FBUyxFQUFDLE1BQVEsNEJBQTJCO0FBQUEsUUFDN0MsS0FBTyxFQUFDLE1BQVEsSUFBRztBQUFBLE1BQ3JCO0FBQUEsTUFDQSxTQUFXO0FBQUEsSUFDYjtBQUFBO0FBQUE7Ozs7Ozs7O0FDckpBLFFBQUEsU0FBQTtBQUNBLFFBQUEsV0FBQTtBQUNBLFFBQUEsa0JBQUE7QUFDQSxRQUFBLG1CQUFBO0FBRUEsUUFBTSxvQkFBb0IsQ0FBQyxhQUFhO0FBRXhDLFFBQU0saUJBQWlCO0FBRXZCLFFBQU0sTUFBTixjQUFrQixPQUFBLFFBQU87TUFDdkIsbUJBQWdCO0FBQ2QsY0FBTSxpQkFBZ0I7QUFDdEIsaUJBQUEsUUFBbUIsUUFBUSxDQUFDLE1BQU0sS0FBSyxjQUFjLENBQUMsQ0FBQztBQUN2RCxZQUFJLEtBQUssS0FBSztBQUFlLGVBQUssV0FBVyxnQkFBQSxPQUFhO01BQzVEO01BRUEsd0JBQXFCO0FBQ25CLGNBQU0sc0JBQXFCO0FBQzNCLFlBQUksQ0FBQyxLQUFLLEtBQUs7QUFBTTtBQUNyQixjQUFNLGFBQWEsS0FBSyxLQUFLLFFBQ3pCLEtBQUssZ0JBQWdCLGtCQUFrQixpQkFBaUIsSUFDeEQ7QUFDSixhQUFLLGNBQWMsWUFBWSxnQkFBZ0IsS0FBSztBQUNwRCxhQUFLLEtBQUssK0JBQStCLElBQUk7TUFDL0M7TUFFQSxjQUFXO0FBQ1QsZUFBUSxLQUFLLEtBQUssY0FDaEIsTUFBTSxZQUFXLE1BQU8sS0FBSyxVQUFVLGNBQWMsSUFBSSxpQkFBaUI7TUFDOUU7O0FBR0YsSUFBQUMsUUFBTyxVQUFVLFVBQVU7QUFDM0IsV0FBTyxlQUFlLFNBQVMsY0FBYyxFQUFDLE9BQU8sS0FBSSxDQUFDO0FBRTFELFlBQUEsVUFBZTtBQTBCZixRQUFBLGFBQUE7QUFBUSxXQUFBLGVBQUEsU0FBQSxjQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsV0FBQTtJQUFVLEVBQUEsQ0FBQTtBQUlsQixRQUFBLFlBQUE7QUFBUSxXQUFBLGVBQUEsU0FBQSxLQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsVUFBQTtJQUFDLEVBQUEsQ0FBQTtBQUFFLFdBQUEsZUFBQSxTQUFBLE9BQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxVQUFBO0lBQUcsRUFBQSxDQUFBO0FBQUUsV0FBQSxlQUFBLFNBQUEsYUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFVBQUE7SUFBUyxFQUFBLENBQUE7QUFBRSxXQUFBLGVBQUEsU0FBQSxPQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsVUFBQTtJQUFHLEVBQUEsQ0FBQTtBQUFFLFdBQUEsZUFBQSxTQUFBLFFBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxVQUFBO0lBQUksRUFBQSxDQUFBO0FBQVEsV0FBQSxlQUFBLFNBQUEsV0FBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFVBQUE7SUFBTyxFQUFBLENBQUE7QUFDbkQsUUFBQSxxQkFBQTtBQUFRLFdBQUEsZUFBQSxTQUFBLG1CQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsbUJBQUE7SUFBTyxFQUFBLENBQUE7QUFDZixRQUFBLGNBQUE7QUFBUSxXQUFBLGVBQUEsU0FBQSxtQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFlBQUE7SUFBTyxFQUFBLENBQUE7Ozs7Ozs7Ozs7QUNwRVIsUUFBTSxTQUFTLFdBQUE7QUFJcEIsYUFBTyxPQUFPLGdCQUFnQjtJQUNoQztBQUxhLFlBQUEsU0FBTTs7Ozs7Ozs7Ozs7OztBQ0FuQixRQUFBLFFBQUEsZ0JBQUEsYUFBQTtBQUVBLFFBQUEsV0FBQTtBQUNBLFFBQUEsZ0JBQUE7QUFFQSxRQUFNLFVBQVUsU0FBQyxRQUFnQixTQUFlO0FBQzlDLGFBQU8sR0FBQSxPQUFHLFFBQU0sR0FBQSxFQUFBLE9BQUksT0FBTztJQUM3QjtBQUVBLFFBQU0sMEJBQTBCO0FBQ2hDLFFBQU0sK0JBQStCO0FBQ3JDLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sNkJBQTZCO0FBSW5DLFFBQU0sWUFBWTtBQUVsQixRQUFNLHdCQUF3QixTQUFDLEdBQUcsc0JBQW9CO0FBQ3BELFVBQUksRUFBRSxXQUFXLFFBQVEsWUFBWSxJQUFJLElBQUk7QUFFM0MsWUFBSSxFQUFFLFdBQVcsUUFBUSxPQUFPLElBQUksSUFBSTtBQUV0QyxjQUFNLGdCQUFnQiw2QkFBNkIsS0FBSyxFQUFFLFVBQVU7QUFDcEUsY0FBTSxXQUFXLGdCQUFnQixjQUFjLENBQUMsSUFBSTtBQUNwRCxjQUFNLGlCQUFpQiwyQkFBMkIsS0FBSyxFQUFFLFlBQVk7QUFDckUsY0FBTSxZQUFZLGlCQUFpQixlQUFlLENBQUMsSUFBSTtBQUN2RCwrQkFBcUIsS0FDbkIsaUJBQUEsT0FBaUIsV0FBUyxXQUFBLEVBQUEsT0FBWSxVQUFRLFVBQUEsRUFBQSxPQUFXLEVBQUUsT0FBTyxDQUFFO2VBRWpFO0FBRUwsY0FBTSxnQkFBZ0Isd0JBQXdCLEtBQUssRUFBRSxVQUFVO0FBQy9ELGNBQU0sV0FBVyxnQkFBZ0IsY0FBYyxDQUFDLElBQUk7QUFDcEQsK0JBQXFCLEtBQUssYUFBQSxPQUFhLFVBQVEsSUFBQSxFQUFBLE9BQUssRUFBRSxPQUFPLENBQUU7O2lCQUV4RCxFQUFFLFdBQVcsUUFBUSxPQUFPLElBQUksSUFBSTtBQUU3QyxZQUFNLGlCQUFpQiwyQkFBMkIsS0FBSyxFQUFFLFlBQVk7QUFDckUsWUFBTSxZQUFZLGlCQUFpQixlQUFlLENBQUMsSUFBSTtBQUN2RCw2QkFBcUIsS0FDbkIsaUJBQUEsT0FBaUIsV0FBUyxnQkFBQSxFQUFBLE9BQWlCLEVBQUUsT0FBTyxDQUFFO2lCQUUvQyxFQUFFLGlCQUFpQixJQUFJO0FBRWhDLDZCQUFxQixLQUFLLFlBQUEsT0FBWSxFQUFFLE9BQU8sQ0FBRTs7SUFFckQ7QUFFQSxRQUFNLDBCQUEwQixTQUM5QixTQUNBLFFBQ0EsY0FBMkI7QUFFM0IsVUFBTSx1QkFBdUIsT0FDMUIsT0FBTyxTQUFDLE9BQUs7QUFBSyxlQUFBLE1BQU0sWUFBWTtNQUFsQixDQUE0QixFQUM5QyxJQUFJLFNBQUMsT0FBSztBQUNULGVBQU8sTUFBTSxPQUFPLG9CQUFvQixTQUNwQyxNQUFNLE9BQU8sa0JBQ2I7TUFDTixDQUFDO0FBQ0gsVUFBSSxxQkFBcUIsU0FBUyxHQUFHO0FBQ25DLFlBQU0saUJBQWlCLFFBQ3JCLFNBQ0EsR0FBQSxPQUFHLGFBQWEsU0FBUyxJQUFJLE1BQU0sS0FBRyxvQkFBQSxFQUFBLE9BQ3BDLHFCQUFxQixTQUFTLElBQUksZUFBZSxZQUFVLElBQUEsRUFBQSxPQUN4RCxxQkFBcUIsS0FBSyxJQUFJLEdBQUMsR0FBQSxDQUFHO0FBRXpDLHFCQUFhLEtBQUssY0FBYzs7SUFFcEM7QUFFQSxRQUFNLGNBQWMsU0FDbEIsU0FDQSxRQUNBLGNBQTJCO0FBRTNCLFVBQU0sc0JBQXNCLE9BQ3pCLE9BQU8sU0FBQyxPQUFLO0FBQUssZUFBQSxNQUFNLFlBQVk7TUFBbEIsQ0FBdUIsRUFDekMsSUFBSSxTQUFDLE9BQUs7QUFDVCxlQUFPLE1BQU0sYUFBYSxNQUFNLENBQUM7TUFDbkMsQ0FBQztBQUNILFVBQUksb0JBQW9CLFNBQVMsR0FBRztBQUNsQyxZQUFNLGVBQWUsUUFDbkIsU0FDQSxpQkFBQSxPQUNFLG9CQUFvQixTQUFTLElBQUksZUFBZSxZQUFVLElBQUEsRUFBQSxPQUN2RCxvQkFBb0IsS0FBSyxJQUFJLEdBQUMsR0FBQSxDQUFHO0FBRXhDLHFCQUFhLEtBQUssWUFBWTs7SUFFbEM7QUFFQSxRQUFNLGFBQWEsU0FDakIsU0FDQSxRQUNBLGNBQTJCO0FBRTNCLFVBQU0saUJBQWdDLENBQUE7QUFDdEMsVUFBSSxhQUFhO0FBRWpCLGVBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEtBQUs7QUFDdEMsWUFBTSxJQUFJLE9BQU8sQ0FBQztBQUVsQixZQUFJLEVBQUUsWUFBWSxRQUFRO0FBQ3hCLHdCQUFjO0FBQ2QsY0FBSSxjQUFjLFdBQVc7QUFDM0Isa0NBQXNCLEdBQUcsY0FBYzs7OztBQUs3QyxVQUFJLGFBQWEsV0FBVztBQUMxQix1QkFBZSxLQUFLLE9BQUEsT0FBTyxhQUFhLFdBQVMsZUFBQSxDQUFlOztBQUdsRSxVQUFJLGVBQWUsU0FBUyxHQUFHO0FBQzdCLFlBQU0sU0FDSixhQUFhLFNBQVMsSUFDbEIsaUNBQ0EsR0FBQSxPQUFHLFNBQU8sbUJBQUE7QUFDaEIsWUFBTSxtQkFBbUIsUUFBUSxRQUFRLGVBQWUsS0FBSyxJQUFJLENBQUMsSUFBSTtBQUV0RSxxQkFBYSxLQUFLLGdCQUFnQjs7SUFFdEM7QUFFQSxRQUFNLG1CQUFtQixTQUN2QixTQUNBLFFBQ0EsY0FBMkI7QUFFM0IsVUFBTUMsb0JBQWtDLENBQUE7QUFDeEMsVUFBSSxhQUFhO0FBR2pCLGVBQWdCLEtBQUEsR0FBQSxXQUFBLFFBQUEsS0FBQSxTQUFBLFFBQUEsTUFBUTtBQUFuQixZQUFNLElBQUMsU0FBQSxFQUFBO0FBQ1YsWUFBSSxFQUFFLFlBQVksZUFBZSxFQUFFLE9BQU8sVUFBVSxHQUFHO0FBQ3JELFlBQUUsVUFBVTs7QUFHZCxnQkFBUSxFQUFFLFNBQVM7VUFDakIsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO1VBQ0wsS0FBSztVQUNMLEtBQUs7VUFDTCxLQUFLO0FBQ0gsMEJBQWM7QUFDZCxnQkFBSSxhQUFhLFdBQVc7QUFDMUI7bUJBQ0s7QUFDTCxvQ0FBc0IsR0FBR0EsaUJBQWdCOztBQUUzQztVQUNGOzs7QUFLSixVQUFJLGFBQWEsV0FBVztBQUMxQixRQUFBQSxrQkFBaUIsS0FBSyxPQUFBLE9BQU8sYUFBYSxXQUFTLGVBQUEsQ0FBZTs7QUFHcEUsVUFBSUEsa0JBQWlCLFNBQVMsR0FBRztBQUMvQixZQUFNLFNBQ0osYUFBYSxTQUFTLElBQ2xCLHVDQUNBLEdBQUEsT0FBRyxTQUFPLHlCQUFBO0FBQ2hCLFlBQU0seUJBQ0osUUFBUSxRQUFRQSxrQkFBaUIsS0FBSyxJQUFJLENBQUMsSUFBSTtBQUVqRCxxQkFBYSxLQUFLLHNCQUFzQjs7SUFFNUM7QUFFTyxRQUFNLGlCQUFpQixTQUFDLFNBQWlCLFFBQTBCO0FBQ3hFLFVBQU0sY0FBYyxPQUFPLE9BQ3pCLFNBQUNDLFFBQUs7QUFDSixlQUFBQSxPQUFNLFdBQVcsUUFBUSxPQUFPLElBQUksTUFBTUEsT0FBTSxZQUFZO01BQTVELENBQW1FO0FBRXZFLFVBQUksWUFBWSxTQUFTLEdBQUc7QUFDMUIsWUFBTSxTQUFTLENBQUE7QUFDZixpQkFBb0IsS0FBQSxHQUFBLGdCQUFBLGFBQUEsS0FBQSxjQUFBLFFBQUEsTUFBYTtBQUE1QixjQUFNLFFBQUssY0FBQSxFQUFBO0FBQ2QsY0FBTSxrQkFBa0IsMkJBQTJCLEtBQUssTUFBTSxVQUFVO0FBQ3hFLGNBQU0sY0FBYyxrQkFBa0IsZ0JBQWdCLENBQUMsSUFBSTtBQUczRCxnQkFBTSxhQUFhLGtCQUFrQixnQkFBZ0IsQ0FBQyxJQUFJO0FBRTFELGNBQUksT0FBTyxXQUFXLEdBQUc7QUFDdkIsbUJBQU8sV0FBVyxFQUFFLEtBQUssS0FBSztpQkFDekI7QUFDTCxtQkFBTyxXQUFXLElBQUksQ0FBQyxLQUFLOzs7QUFLaEMsZUFDRSxHQUFBLE9BQUcsU0FBTyxrQ0FBQSxJQUNWLE9BQU8sUUFBUSxNQUFNLEVBQ2xCLElBQ0MsU0FBQ0MsS0FBWTtjQUFYLE1BQUdBLElBQUEsQ0FBQSxHQUFFLFFBQUtBLElBQUEsQ0FBQTtBQUNWLGlCQUFBLEdBQUEsT0FBRyxTQUFTLEdBQUcsSUFBSSxHQUFDLEdBQUEsS0FDcEIsR0FBQSxRQUFBLGdCQUFlLElBQUksS0FBMkI7UUFEOUMsQ0FDK0MsRUFFbEQsS0FBSyxHQUFHOztBQUlmLFVBQU0sZUFBOEIsQ0FBQTtBQUVwQyxrQkFBWSxTQUFTLFFBQVEsWUFBWTtBQUN6Qyw4QkFBd0IsU0FBUyxRQUFRLFlBQVk7QUFDckQsaUJBQVcsU0FBUyxRQUFRLFlBQVk7QUFDeEMsdUJBQWlCLFNBQVMsUUFBUSxZQUFZO0FBRTlDLGFBQU8sYUFBYSxLQUFLLEdBQUc7SUFDOUI7QUExQ2EsWUFBQSxpQkFBYztBQTRDcEIsUUFBTSxpQkFBaUIsU0FBQyxvQkFBNEIsUUFBVztBQUNwRSxXQUFJLEdBQUEsY0FBQSxRQUFNLEdBQUk7QUFFWixlQUFPLFNBQUMsTUFBUztRQUFNOztBQUd6QixVQUNFLFdBQ0EsUUFBUSxPQUNSLFFBQVEsSUFBSSxzQ0FDWjtBQVdBLGVBQU8sU0FBQyxNQUFTO1FBQU07O0FBR3pCLFVBQU0sTUFBTSxJQUFJLE1BQUEsUUFBSSxFQUFFLFdBQVcsS0FBSSxDQUFFO0FBQ3ZDLFVBQU0sV0FBVyxJQUFJLFFBQVEsTUFBTTtBQUVuQyxhQUFPLFNBQUMsTUFBUztBQUNmLFlBQU0sUUFBUSxTQUFTLElBQUk7QUFDM0IsWUFBSSxDQUFDLE9BQU87QUFDVixjQUFNLFNBQVMsU0FBUyxVQUFXLENBQUE7QUFDbkMsY0FBTSxPQUFNLEdBQUEsUUFBQSxnQkFBZSxvQkFBb0IsTUFBTTtBQUNyRCxnQkFBTSxJQUFJLFNBQUEsc0JBQXNCLEdBQUc7O0FBRXJDLGVBQU87TUFDVDtJQUNGO0FBcENhLFlBQUEsaUJBQWM7QUFzQ3BCLFFBQU0sdUJBQXVCLFNBQUMsUUFBYSxZQUFrQjtBQUNsRSxVQUFNLFNBQVMsbUJBQUEsT0FBbUIsVUFBVTtBQUM1QyxjQUFPLEdBQUEsUUFBQSxnQkFBZSxRQUFRLE1BQU07SUFDdEM7QUFIYSxZQUFBLHVCQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2UWpDLFFBQUEsV0FBQTtBQUVPLFFBQU0sb0JBQW9CLFNBQy9CLEtBQ0EsTUFBWTtBQUFBLGFBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7Ozs7QUFHUyxxQkFBQSxDQUFBLEdBQU0sSUFBSSxZQUFXLENBQUU7O0FBQXBDLDJCQUFhQyxJQUFBLEtBQUE7QUFDbkIscUJBQUEsQ0FBQSxHQUFPLFVBQUEsT0FBVSxNQUFJLHdDQUFBLEVBQUEsT0FBeUMsV0FDM0QsSUFBSSxTQUFDLEdBQUM7QUFBSyx1QkFBQSxJQUFBLE9BQUksR0FBQyxHQUFBO2NBQUwsQ0FBUSxFQUNuQixLQUFLLElBQUksR0FBQyxHQUFBLENBQUc7OztBQUtoQixxQkFBQSxDQUFBLEdBQU8sVUFBQSxPQUFVLE1BQUksbUJBQUEsQ0FBbUI7Ozs7Ozs7Ozs7QUFiL0IsWUFBQSxvQkFBaUI7QUFpQnZCLFFBQU0seUJBQXlCLFNBQ3BDLEtBQ0EsTUFBWTtBQUFBLGFBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7Ozs7QUFHUyxxQkFBQSxDQUFBLEdBQU0sSUFBSSxnQkFBZSxDQUFFOztBQUF4QywyQkFBYUEsSUFBQSxLQUFBO0FBQ25CLHFCQUFBLENBQUEsR0FBTyxlQUFBLE9BQWUsTUFBSSw2Q0FBQSxFQUFBLE9BQThDLFdBQ3JFLElBQUksU0FBQyxHQUFDO0FBQUssdUJBQUEsSUFBQSxPQUFJLEdBQUMsR0FBQTtjQUFMLENBQVEsRUFDbkIsS0FBSyxJQUFJLEdBQUMsR0FBQSxDQUFHOzs7QUFLaEIscUJBQUEsQ0FBQSxHQUFPLGVBQUEsT0FBZSxNQUFJLG1CQUFBLENBQW1COzs7Ozs7Ozs7O0FBYnBDLFlBQUEseUJBQXNCO0FBaUI1QixRQUFNLDBCQUEwQixTQUNyQyxHQUNBLEtBQ0EsV0FBaUI7QUFBQSxhQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7OztBQUVWLHFCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBRyxTQUFPLFlBQVksZ0JBQWM7QUFBQSx1QkFBQSxVQUFBLFFBQUEsUUFBQSxRQUFBLFdBQUE7Ozs7OzhCQUM5RCxlQUFlO0FBQWYsaUNBQUEsQ0FBQSxHQUFBLENBQUE7QUFDSSwrQkFBQSxDQUFBLElBQU0sR0FBQSxRQUFBLG1CQUFrQixLQUFLLFNBQVMsQ0FBQzs7QUFBdkMsd0JBQUFBLE1BQUEsR0FBQSxLQUFBOzs7QUFDQSx3QkFBQUEsTUFBQTs7O0FBRkosK0JBQUEsQ0FBQSxHQUFBQSxHQUFBOzs7O2VBRWtCLENBQ25COztBQUpELHFCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBSU47Ozs7O0FBVFUsWUFBQSwwQkFBdUI7QUFZN0IsUUFBTSwrQkFBK0IsU0FDMUMsR0FDQSxLQUNBLGdCQUFzQjtBQUFBLGFBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7O0FBRWYscUJBQUEsQ0FBQSxJQUFNLEdBQUEsU0FBQSxnQkFBZSxHQUFHLFNBQU8sWUFBWSxnQkFBYztBQUFBLHVCQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7OEJBQzlELGVBQWU7QUFBZixpQ0FBQSxDQUFBLEdBQUEsQ0FBQTtBQUNJLCtCQUFBLENBQUEsSUFBTSxHQUFBLFFBQUEsd0JBQXVCLEtBQUssY0FBYyxDQUFDOztBQUFqRCx3QkFBQUEsTUFBQSxHQUFBLEtBQUE7OztBQUNBLHdCQUFBQSxNQUFBOzs7QUFGSiwrQkFBQSxDQUFBLEdBQUFBLEdBQUE7Ozs7ZUFFa0IsQ0FDbkI7O0FBSkQscUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FJTjs7Ozs7QUFUVSxZQUFBLCtCQUE0Qjs7Ozs7QUNqRHpDO0FBQUE7QUFBQTtBQTRCQSxXQUFPLGVBQWUsU0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFLLENBQUM7QUFDNUQsWUFBUSxPQUFPLFFBQVEsZUFBZSxRQUFRLHNCQUFzQixRQUFRLHNCQUFzQixRQUFRLGNBQWMsUUFBUSwyQkFBMkIsUUFBUSwyQkFBMkIsUUFBUSx3QkFBd0IsUUFBUSx3QkFBd0IsUUFBUSw2QkFBNkIsUUFBUSwwQkFBMEIsUUFBUSx5QkFBeUIsUUFBUSxnQkFBZ0IsUUFBUSxtQkFBbUIsUUFBUSxjQUFjLFFBQVEsWUFBWSxRQUFRLGtCQUFrQixRQUFRLFlBQVksUUFBUSxjQUFjLFFBQVEsb0JBQW9CLFFBQVEsbUJBQW1CLFFBQVEsWUFBWSxRQUFRLDRCQUE0QixRQUFRLGlCQUFpQixRQUFRLGVBQWUsUUFBUSxxQkFBcUIsUUFBUSxxQkFBcUIsUUFBUSxzQkFBc0IsUUFBUSxnQkFBZ0IsUUFBUSxnQkFBZ0IsUUFBUSxpQkFBaUIsUUFBUSxPQUFPLFFBQVEsT0FBTyxRQUFRLFdBQVc7QUFJeDNCLFlBQVEsV0FBVyxPQUFPLElBQUksa0JBQWtCO0FBQ2hELFlBQVEsT0FBTyxPQUFPLElBQUksY0FBYztBQUN4QyxZQUFRLE9BQU8sT0FBTyxJQUFJLGNBQWM7QUFJeEMsWUFBUSxpQkFBaUI7QUFDekIsWUFBUSxnQkFBZ0I7QUFDeEIsWUFBUSxnQkFBZ0I7QUFDeEIsWUFBUSxzQkFBc0IsSUFBSSxRQUFRO0FBQzFDLFlBQVEscUJBQXFCLElBQUksUUFBUTtBQUN6QyxZQUFRLHFCQUFxQixJQUFJLFFBQVE7QUFFekMsUUFBSTtBQUNKLEtBQUMsU0FBVUMsZUFBYztBQUNyQixZQUFNLE1BQU0sb0JBQUksSUFBSTtBQUVwQixlQUFTLFVBQVU7QUFDZixlQUFPLElBQUksSUFBSSxHQUFHO0FBQUEsTUFDdEI7QUFDQSxNQUFBQSxjQUFhLFVBQVU7QUFFdkIsZUFBUyxRQUFRO0FBQ2IsZUFBTyxJQUFJLE1BQU07QUFBQSxNQUNyQjtBQUNBLE1BQUFBLGNBQWEsUUFBUTtBQUVyQixlQUFTLElBQUlDLE9BQU07QUFDZixlQUFPLElBQUksSUFBSUEsS0FBSTtBQUFBLE1BQ3ZCO0FBQ0EsTUFBQUQsY0FBYSxNQUFNO0FBRW5CLGVBQVNFLEtBQUlELE9BQU0sTUFBTTtBQUNyQixZQUFJLElBQUlBLE9BQU0sSUFBSTtBQUFBLE1BQ3RCO0FBQ0EsTUFBQUQsY0FBYSxNQUFNRTtBQUVuQixlQUFTLElBQUlELE9BQU07QUFDZixlQUFPLElBQUksSUFBSUEsS0FBSTtBQUFBLE1BQ3ZCO0FBQ0EsTUFBQUQsY0FBYSxNQUFNO0FBQUEsSUFDdkIsR0FBRyxpQkFBaUIsUUFBUSxlQUFlLGVBQWUsQ0FBQyxFQUFFO0FBRTdELFFBQUk7QUFDSixLQUFDLFNBQVVHLGlCQUFnQjtBQUN2QixZQUFNLE1BQU0sb0JBQUksSUFBSTtBQUVwQixlQUFTLFVBQVU7QUFDZixlQUFPLElBQUksSUFBSSxHQUFHO0FBQUEsTUFDdEI7QUFDQSxNQUFBQSxnQkFBZSxVQUFVO0FBRXpCLGVBQVMsUUFBUTtBQUNiLGVBQU8sSUFBSSxNQUFNO0FBQUEsTUFDckI7QUFDQSxNQUFBQSxnQkFBZSxRQUFRO0FBRXZCLGVBQVMsSUFBSSxRQUFRO0FBQ2pCLGVBQU8sSUFBSSxJQUFJLE1BQU07QUFBQSxNQUN6QjtBQUNBLE1BQUFBLGdCQUFlLE1BQU07QUFFckIsZUFBU0QsS0FBSSxRQUFRLE1BQU07QUFDdkIsWUFBSSxJQUFJLFFBQVEsSUFBSTtBQUFBLE1BQ3hCO0FBQ0EsTUFBQUMsZ0JBQWUsTUFBTUQ7QUFFckIsZUFBUyxJQUFJLFFBQVE7QUFDakIsZUFBTyxJQUFJLElBQUksTUFBTTtBQUFBLE1BQ3pCO0FBQ0EsTUFBQUMsZ0JBQWUsTUFBTTtBQUFBLElBQ3pCLEdBQUcsbUJBQW1CLFFBQVEsaUJBQWlCLGlCQUFpQixDQUFDLEVBQUU7QUFJbkUsUUFBTSw0QkFBTixjQUF3QyxNQUFNO0FBQUEsTUFDMUMsWUFBWSxRQUFRO0FBQ2hCLGNBQU0seUJBQXlCO0FBQy9CLGFBQUssU0FBUztBQUFBLE1BQ2xCO0FBQUEsSUFDSjtBQUNBLFlBQVEsNEJBQTRCO0FBRXBDLFFBQUk7QUFDSixLQUFDLFNBQVVDLFlBQVc7QUFDbEIsZUFBUyxTQUFTLE9BQU87QUFDckIsZUFBTyxPQUFPLFVBQVUsWUFBWSxVQUFVLFFBQVEsQ0FBQyxNQUFNLFFBQVEsS0FBSztBQUFBLE1BQzlFO0FBQ0EsZUFBUyxRQUFRLE9BQU87QUFDcEIsZUFBTyxPQUFPLFVBQVUsWUFBWSxVQUFVLFFBQVEsTUFBTSxRQUFRLEtBQUs7QUFBQSxNQUM3RTtBQUNBLGVBQVMsVUFBVSxPQUFPO0FBQ3RCLFlBQUk7QUFDQSxjQUFJLE9BQU8sS0FBSztBQUNoQixpQkFBTztBQUFBLFFBQ1gsU0FDTSxHQUFOO0FBQ0ksaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUNBLGVBQVMsdUJBQXVCLE9BQU87QUFDbkMsWUFBSSxPQUFPLFVBQVU7QUFDakIsaUJBQU87QUFDWCxpQkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNuQyxnQkFBTSxPQUFPLE1BQU0sV0FBVyxDQUFDO0FBQy9CLGNBQUssUUFBUSxLQUFLLFFBQVEsTUFBTyxTQUFTLE1BQU0sU0FBUyxLQUFLO0FBQzFELG1CQUFPO0FBQUEsVUFDWDtBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUNBLGVBQVMsdUJBQXVCLE9BQU87QUFDbkMsZUFBTyxrQkFBa0IsS0FBSyxLQUFLLFFBQVEsS0FBSztBQUFBLE1BQ3BEO0FBQ0EsZUFBUyxTQUFTLE9BQU87QUFDckIsZUFBTyxPQUFPLFVBQVU7QUFBQSxNQUM1QjtBQUNBLGVBQVMsU0FBUyxPQUFPO0FBQ3JCLGVBQU8sT0FBTyxVQUFVO0FBQUEsTUFDNUI7QUFDQSxlQUFTLFNBQVMsT0FBTztBQUNyQixlQUFPLE9BQU8sVUFBVSxZQUFZLFdBQVcsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUN4RTtBQUNBLGVBQVMsVUFBVSxPQUFPO0FBQ3RCLGVBQU8sT0FBTyxVQUFVO0FBQUEsTUFDNUI7QUFDQSxlQUFTLGlCQUFpQixPQUFPO0FBQzdCLGVBQU8sVUFBVSxVQUFjLFVBQVUsVUFBYSxTQUFTLEtBQUs7QUFBQSxNQUN4RTtBQUNBLGVBQVMsaUJBQWlCLE9BQU87QUFDN0IsZUFBTyxVQUFVLFVBQWMsVUFBVSxVQUFhLFNBQVMsS0FBSztBQUFBLE1BQ3hFO0FBQ0EsZUFBUyxrQkFBa0IsT0FBTztBQUM5QixlQUFPLFVBQVUsVUFBYyxVQUFVLFVBQWEsVUFBVSxLQUFLO0FBQUEsTUFDekU7QUFDQSxlQUFTLGlCQUFpQixPQUFPO0FBQzdCLGVBQU8sVUFBVSxVQUFjLFVBQVUsVUFBYSxTQUFTLEtBQUs7QUFBQSxNQUN4RTtBQUNBLGVBQVMsa0JBQWtCLE9BQU87QUFDOUIsZUFBTyxVQUFVLFVBQWMsVUFBVSxVQUFhLFNBQVMsS0FBSyxLQUFLLHVCQUF1QixLQUFLLEtBQUssVUFBVSxLQUFLO0FBQUEsTUFDN0g7QUFDQSxlQUFTLGlCQUFpQixPQUFPO0FBQzdCLGVBQU8sVUFBVSxVQUFjLFVBQVUsVUFBYSxTQUFTLEtBQUssS0FBSyx1QkFBdUIsS0FBSztBQUFBLE1BQ3pHO0FBQ0EsZUFBUyxpQkFBaUIsT0FBTztBQUM3QixlQUFPLFVBQVUsVUFBYSxRQUFRLEtBQUs7QUFBQSxNQUMvQztBQUVBLGVBQVMsS0FBSyxRQUFRO0FBQ2xCLGVBQU8sTUFBTSxNQUFNLEtBQUssT0FBTyxRQUFRLElBQUksTUFBTSxTQUFTLGlCQUFpQixPQUFPLEdBQUc7QUFBQSxNQUN6RjtBQUNBLE1BQUFBLFdBQVUsT0FBTztBQUVqQixlQUFTLE9BQU8sUUFBUTtBQUNwQixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLFdBQ3pCLE9BQU8sU0FBUyxXQUNoQixpQkFBaUIsT0FBTyxHQUFHLEtBQzNCLFFBQVEsT0FBTyxLQUFLLEtBQ3BCLGlCQUFpQixPQUFPLFFBQVEsS0FDaEMsaUJBQWlCLE9BQU8sUUFBUSxLQUNoQyxrQkFBa0IsT0FBTyxXQUFXO0FBQUEsTUFDNUM7QUFDQSxNQUFBQSxXQUFVLFNBQVM7QUFFbkIsZUFBUyxRQUFRLFFBQVE7QUFFckIsZUFBUSxNQUFNLE1BQU0sS0FDaEIsT0FBTyxRQUFRLElBQUksTUFBTSxZQUN6QixPQUFPLFNBQVMsVUFDaEIsT0FBTyxXQUFXLFlBQ2xCLGlCQUFpQixPQUFPLEdBQUcsS0FDM0IsaUJBQWlCLE9BQU8sVUFBVSxLQUNsQyxpQkFBaUIsT0FBTyxPQUFPLEtBQy9CLGlCQUFpQixPQUFPLE9BQU8sS0FDL0IsaUJBQWlCLE9BQU8sZ0JBQWdCLEtBQ3hDLGlCQUFpQixPQUFPLGdCQUFnQjtBQUFBLE1BQ2hEO0FBQ0EsTUFBQUEsV0FBVSxVQUFVO0FBRXBCLGVBQVMsU0FBUyxRQUFRO0FBRXRCLGVBQVEsTUFBTSxNQUFNLEtBQ2hCLE9BQU8sUUFBUSxJQUFJLE1BQU0sYUFDekIsT0FBTyxTQUFTLGFBQ2hCLGlCQUFpQixPQUFPLEdBQUc7QUFBQSxNQUNuQztBQUNBLE1BQUFBLFdBQVUsV0FBVztBQUVyQixlQUFTLGFBQWEsUUFBUTtBQUUxQixZQUFJLEVBQUUsTUFBTSxNQUFNLEtBQ2QsT0FBTyxRQUFRLElBQUksTUFBTSxpQkFDekIsT0FBTyxTQUFTLFlBQ2hCLE9BQU8sZUFBZSxpQkFDdEIsaUJBQWlCLE9BQU8sR0FBRyxLQUMzQixRQUFRLE9BQU8sVUFBVSxLQUN6QixRQUFRLE9BQU8sT0FBTyxJQUFJO0FBQzFCLGlCQUFPO0FBQUEsUUFDWDtBQUNBLG1CQUFXLGFBQWEsT0FBTyxZQUFZO0FBQ3ZDLGNBQUksQ0FBQyxRQUFRLFNBQVM7QUFDbEIsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFDQSxNQUFBQSxXQUFVLGVBQWU7QUFFekIsZUFBUyxNQUFNLFFBQVE7QUFDbkIsZUFBUSxNQUFNLE1BQU0sS0FDaEIsT0FBTyxRQUFRLElBQUksTUFBTSxVQUN6QixPQUFPLFNBQVMsWUFDaEIsT0FBTyxlQUFlLFVBQ3RCLGlCQUFpQixPQUFPLEdBQUcsS0FDM0IsaUJBQWlCLE9BQU8sZ0JBQWdCLEtBQ3hDLGlCQUFpQixPQUFPLGdCQUFnQixLQUN4QyxpQkFBaUIsT0FBTyx5QkFBeUIsS0FDakQsaUJBQWlCLE9BQU8seUJBQXlCO0FBQUEsTUFDekQ7QUFDQSxNQUFBQSxXQUFVLFFBQVE7QUFFbEIsZUFBUyxVQUFVLFFBQVE7QUFFdkIsWUFBSSxFQUFFLE1BQU0sTUFBTSxLQUNkLE9BQU8sUUFBUSxJQUFJLE1BQU0sY0FDekIsT0FBTyxTQUFTLFlBQ2hCLE9BQU8sZUFBZSxjQUN0QixpQkFBaUIsT0FBTyxHQUFHLEtBQzNCLFFBQVEsT0FBTyxVQUFVLEtBQ3pCLFFBQVEsT0FBTyxPQUFPLElBQUk7QUFDMUIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsbUJBQVcsYUFBYSxPQUFPLFlBQVk7QUFDdkMsY0FBSSxDQUFDLFFBQVEsU0FBUztBQUNsQixtQkFBTztBQUFBLFFBQ2Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUNBLE1BQUFBLFdBQVUsWUFBWTtBQUV0QixlQUFTLFNBQVMsUUFBUTtBQUN0QixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLGFBQ3pCLE9BQU8sU0FBUyxhQUNoQixpQkFBaUIsT0FBTyxHQUFHLEtBQzNCLGlCQUFpQixPQUFPLFVBQVUsS0FDbEMsaUJBQWlCLE9BQU8sT0FBTyxLQUMvQixpQkFBaUIsT0FBTyxPQUFPLEtBQy9CLGlCQUFpQixPQUFPLGdCQUFnQixLQUN4QyxpQkFBaUIsT0FBTyxnQkFBZ0I7QUFBQSxNQUNoRDtBQUNBLE1BQUFBLFdBQVUsV0FBVztBQUVyQixlQUFTLFdBQVcsUUFBUTtBQUV4QixZQUFJLEVBQUUsTUFBTSxNQUFNLEtBQ2QsT0FBTyxRQUFRLElBQUksTUFBTSxlQUN6QixRQUFRLE9BQU8sS0FBSyxLQUNwQixpQkFBaUIsT0FBTyxJQUFJLE1BQzNCLGtCQUFrQixPQUFPLHFCQUFxQixLQUFLLGlCQUFpQixPQUFPLHFCQUFxQixNQUNqRyxpQkFBaUIsT0FBTyxHQUFHLElBQUk7QUFDL0IsaUJBQU87QUFBQSxRQUNYO0FBQ0EsWUFBSSxVQUFVLFVBQVUsT0FBTyxTQUFTLFVBQVU7QUFDOUMsaUJBQU87QUFBQSxRQUNYO0FBQ0EsbUJBQVcsU0FBUyxPQUFPLE9BQU87QUFDOUIsY0FBSSxDQUFDLFFBQVEsS0FBSztBQUNkLG1CQUFPO0FBQUEsUUFDZjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQ0EsTUFBQUEsV0FBVSxhQUFhO0FBRXZCLGVBQVMsTUFBTSxRQUFRO0FBQ25CLGVBQU8sU0FBUyxNQUFNLEtBQUssUUFBUSxRQUFRLFVBQVUsT0FBTyxPQUFPLFFBQVEsSUFBSSxNQUFNO0FBQUEsTUFDekY7QUFDQSxNQUFBQSxXQUFVLFFBQVE7QUFFbEIsZUFBUyxlQUFlLFFBQVE7QUFDNUIsZUFBTyxNQUFNLE1BQU0sS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLGFBQWEsaUJBQWlCLE9BQU8sR0FBRyxLQUFLLE9BQU8sT0FBTyxVQUFVO0FBQUEsTUFDMUg7QUFDQSxNQUFBQSxXQUFVLGlCQUFpQjtBQUUzQixlQUFTLGVBQWUsUUFBUTtBQUM1QixlQUFPLE1BQU0sTUFBTSxLQUFLLE9BQU8sUUFBUSxJQUFJLE1BQU0sYUFBYSxpQkFBaUIsT0FBTyxHQUFHLEtBQUssT0FBTyxPQUFPLFVBQVU7QUFBQSxNQUMxSDtBQUNBLE1BQUFBLFdBQVUsaUJBQWlCO0FBRTNCLGVBQVMsZ0JBQWdCLFFBQVE7QUFDN0IsZUFBTyxNQUFNLE1BQU0sS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLGFBQWEsaUJBQWlCLE9BQU8sR0FBRyxLQUFLLE9BQU8sT0FBTyxVQUFVO0FBQUEsTUFDMUg7QUFDQSxNQUFBQSxXQUFVLGtCQUFrQjtBQUU1QixlQUFTLFNBQVMsUUFBUTtBQUN0QixlQUFPLGVBQWUsTUFBTSxLQUFLLGVBQWUsTUFBTSxLQUFLLGdCQUFnQixNQUFNO0FBQUEsTUFDckY7QUFDQSxNQUFBQSxXQUFVLFdBQVc7QUFFckIsZUFBUyxPQUFPLFFBQVE7QUFDcEIsZUFBTyxNQUFNLE1BQU0sS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLFdBQVcsU0FBUyxPQUFPLEdBQUcsS0FBSyxXQUFXLE9BQU8sb0JBQW9CLE9BQU8sR0FBRyxFQUFFLFdBQVc7QUFBQSxNQUNySjtBQUNBLE1BQUFBLFdBQVUsU0FBUztBQUVuQixlQUFTLEtBQUssUUFBUTtBQUVsQixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLFNBQ3pCLFFBQVEsT0FBTyxHQUFHO0FBQUEsTUFDMUI7QUFDQSxNQUFBQSxXQUFVLE9BQU87QUFFakIsZUFBUyxNQUFNLFFBQVE7QUFFbkIsZUFBUSxNQUFNLE1BQU0sS0FDaEIsT0FBTyxRQUFRLElBQUksTUFBTSxVQUN6QixPQUFPLFNBQVMsVUFDaEIsaUJBQWlCLE9BQU8sR0FBRztBQUFBLE1BQ25DO0FBQ0EsTUFBQUEsV0FBVSxRQUFRO0FBRWxCLGVBQVMsUUFBUSxRQUFRO0FBQ3JCLGVBQVEsTUFBTSxNQUFNLEtBQ2hCLE9BQU8sUUFBUSxJQUFJLE1BQU0sWUFDekIsT0FBTyxTQUFTLFlBQ2hCLGlCQUFpQixPQUFPLEdBQUcsS0FDM0IsaUJBQWlCLE9BQU8sVUFBVSxLQUNsQyxpQkFBaUIsT0FBTyxPQUFPLEtBQy9CLGlCQUFpQixPQUFPLE9BQU8sS0FDL0IsaUJBQWlCLE9BQU8sZ0JBQWdCLEtBQ3hDLGlCQUFpQixPQUFPLGdCQUFnQjtBQUFBLE1BQ2hEO0FBQ0EsTUFBQUEsV0FBVSxVQUFVO0FBRXBCLGVBQVMsUUFBUSxRQUFRO0FBQ3JCLFlBQUksRUFBRSxNQUFNLE1BQU0sS0FDZCxPQUFPLFFBQVEsSUFBSSxNQUFNLFlBQ3pCLE9BQU8sU0FBUyxZQUNoQixpQkFBaUIsT0FBTyxHQUFHLEtBQzNCLFNBQVMsT0FBTyxVQUFVLEtBQzFCLHVCQUF1QixPQUFPLG9CQUFvQixLQUNsRCxpQkFBaUIsT0FBTyxhQUFhLEtBQ3JDLGlCQUFpQixPQUFPLGFBQWEsSUFBSTtBQUN6QyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxtQkFBVyxDQUFDLEtBQUssS0FBSyxLQUFLLE9BQU8sUUFBUSxPQUFPLFVBQVUsR0FBRztBQUMxRCxjQUFJLENBQUMsdUJBQXVCLEdBQUc7QUFDM0IsbUJBQU87QUFDWCxjQUFJLENBQUMsUUFBUSxLQUFLO0FBQ2QsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFDQSxNQUFBQSxXQUFVLFVBQVU7QUFFcEIsZUFBUyxTQUFTLFFBQVE7QUFFdEIsZUFBUSxNQUFNLE1BQU0sS0FDaEIsT0FBTyxRQUFRLElBQUksTUFBTSxhQUN6QixPQUFPLFNBQVMsWUFDaEIsT0FBTyxlQUFlLGFBQ3RCLGlCQUFpQixPQUFPLEdBQUcsS0FDM0IsUUFBUSxPQUFPLElBQUk7QUFBQSxNQUMzQjtBQUNBLE1BQUFBLFdBQVUsV0FBVztBQUVyQixlQUFTLFFBQVEsUUFBUTtBQUVyQixZQUFJLEVBQUUsTUFBTSxNQUFNLEtBQ2QsT0FBTyxRQUFRLElBQUksTUFBTSxZQUN6QixPQUFPLFNBQVMsWUFDaEIsaUJBQWlCLE9BQU8sR0FBRyxLQUMzQix1QkFBdUIsT0FBTyxvQkFBb0IsS0FDbEQsU0FBUyxPQUFPLGlCQUFpQixJQUFJO0FBQ3JDLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGNBQU0sT0FBTyxPQUFPLEtBQUssT0FBTyxpQkFBaUI7QUFDakQsWUFBSSxLQUFLLFdBQVcsR0FBRztBQUNuQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJLENBQUMsVUFBVSxLQUFLLENBQUMsQ0FBQyxHQUFHO0FBQ3JCLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFlBQUksQ0FBQyxRQUFRLE9BQU8sa0JBQWtCLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRztBQUM3QyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUNBLE1BQUFBLFdBQVUsVUFBVTtBQUVwQixlQUFTLEtBQUssUUFBUTtBQUVsQixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLFNBQ3pCLGlCQUFpQixPQUFPLEdBQUcsS0FDM0IsU0FBUyxPQUFPLElBQUk7QUFBQSxNQUM1QjtBQUNBLE1BQUFBLFdBQVUsT0FBTztBQUVqQixlQUFTLFFBQVEsUUFBUTtBQUNyQixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLFlBQ3pCLE9BQU8sU0FBUyxZQUNoQixpQkFBaUIsT0FBTyxHQUFHLEtBQzNCLGlCQUFpQixPQUFPLFNBQVMsS0FDakMsaUJBQWlCLE9BQU8sU0FBUyxLQUNqQyxrQkFBa0IsT0FBTyxPQUFPLEtBQ2hDLGlCQUFpQixPQUFPLE1BQU07QUFBQSxNQUN0QztBQUNBLE1BQUFBLFdBQVUsVUFBVTtBQUVwQixlQUFTLFFBQVEsUUFBUTtBQUVyQixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLFlBQ3pCLE9BQU8sU0FBUyxVQUNoQixPQUFPLFdBQVcsWUFDbEIsaUJBQWlCLE9BQU8sR0FBRztBQUFBLE1BQ25DO0FBQ0EsTUFBQUEsV0FBVSxVQUFVO0FBRXBCLGVBQVMsaUJBQWlCLFFBQVE7QUFFOUIsZUFBUSxNQUFNLE1BQU0sS0FDaEIsT0FBTyxRQUFRLElBQUksTUFBTSxxQkFDekIsT0FBTyxTQUFTLFlBQ2hCLFNBQVMsT0FBTyxPQUFPLEtBQ3ZCLE9BQU8sUUFBUSxDQUFDLE1BQU0sT0FDdEIsT0FBTyxRQUFRLE9BQU8sUUFBUSxTQUFTLENBQUMsTUFBTTtBQUFBLE1BQ3REO0FBQ0EsTUFBQUEsV0FBVSxtQkFBbUI7QUFFN0IsZUFBUyxNQUFNLFFBQVE7QUFFbkIsZUFBUSxNQUFNLE1BQU0sS0FDaEIsT0FBTyxRQUFRLElBQUksTUFBTSxVQUN6QixpQkFBaUIsT0FBTyxHQUFHLEtBQzNCLFNBQVMsT0FBTyxJQUFJO0FBQUEsTUFDNUI7QUFDQSxNQUFBQSxXQUFVLFFBQVE7QUFFbEIsZUFBUyxPQUFPLFFBQVE7QUFFcEIsWUFBSSxFQUFFLE1BQU0sTUFBTSxLQUNkLE9BQU8sUUFBUSxJQUFJLE1BQU0sV0FDekIsT0FBTyxTQUFTLFdBQ2hCLGlCQUFpQixPQUFPLEdBQUcsS0FDM0IsU0FBUyxPQUFPLFFBQVEsS0FDeEIsU0FBUyxPQUFPLFFBQVEsS0FDeEIsT0FBTyxhQUFhLE9BQU8sV0FBVztBQUN0QyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJLE9BQU8sVUFBVSxVQUFhLE9BQU8sb0JBQW9CLFVBQWEsT0FBTyxhQUFhLEdBQUc7QUFDN0YsaUJBQU87QUFBQSxRQUNYO0FBQ0EsWUFBSSxDQUFDLFFBQVEsT0FBTyxLQUFLLEdBQUc7QUFDeEIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsbUJBQVcsU0FBUyxPQUFPLE9BQU87QUFDOUIsY0FBSSxDQUFDLFFBQVEsS0FBSztBQUNkLG1CQUFPO0FBQUEsUUFDZjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQ0EsTUFBQUEsV0FBVSxTQUFTO0FBRW5CLGVBQVMsV0FBVyxRQUFRO0FBRXhCLGVBQVEsTUFBTSxNQUFNLEtBQ2hCLE9BQU8sUUFBUSxJQUFJLE1BQU0sZUFDekIsT0FBTyxTQUFTLFVBQ2hCLE9BQU8sV0FBVyxlQUNsQixpQkFBaUIsT0FBTyxHQUFHO0FBQUEsTUFDbkM7QUFDQSxNQUFBQSxXQUFVLGFBQWE7QUFFdkIsZUFBUyxjQUFjLFFBQVE7QUFDM0IsZUFBTyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sTUFBTSxDQUFDQyxZQUFXLGVBQWVBLE9BQU0sS0FBSyxlQUFlQSxPQUFNLENBQUM7QUFBQSxNQUM1RztBQUNBLE1BQUFELFdBQVUsZ0JBQWdCO0FBRTFCLGVBQVMsT0FBTyxRQUFRO0FBRXBCLFlBQUksRUFBRSxNQUFNLE1BQU0sS0FDZCxPQUFPLFFBQVEsSUFBSSxNQUFNLFdBQ3pCLFFBQVEsT0FBTyxLQUFLLEtBQ3BCLGlCQUFpQixPQUFPLEdBQUcsSUFBSTtBQUMvQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxtQkFBVyxTQUFTLE9BQU8sT0FBTztBQUM5QixjQUFJLENBQUMsUUFBUSxLQUFLO0FBQ2QsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFDQSxNQUFBQSxXQUFVLFNBQVM7QUFFbkIsZUFBUyxZQUFZLFFBQVE7QUFDekIsZUFBTyxNQUFNLE1BQU0sS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLGdCQUFnQixPQUFPLFNBQVMsWUFBWSxpQkFBaUIsT0FBTyxHQUFHLEtBQUssT0FBTyxlQUFlLGdCQUFnQixpQkFBaUIsT0FBTyxhQUFhLEtBQUssaUJBQWlCLE9BQU8sYUFBYTtBQUFBLE1BQ3RQO0FBQ0EsTUFBQUEsV0FBVSxjQUFjO0FBRXhCLGVBQVMsU0FBUyxRQUFRO0FBRXRCLGVBQVEsTUFBTSxNQUFNLEtBQ2hCLE9BQU8sUUFBUSxJQUFJLE1BQU0sYUFDekIsaUJBQWlCLE9BQU8sR0FBRztBQUFBLE1BQ25DO0FBQ0EsTUFBQUEsV0FBVSxXQUFXO0FBRXJCLGVBQVMsUUFBUSxRQUFRO0FBRXJCLGVBQVEsTUFBTSxNQUFNLEtBQ2hCLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFBQSxNQUNqQztBQUNBLE1BQUFBLFdBQVUsVUFBVTtBQUVwQixlQUFTLE1BQU0sUUFBUTtBQUVuQixlQUFRLE1BQU0sTUFBTSxLQUNoQixPQUFPLFFBQVEsSUFBSSxNQUFNLFVBQ3pCLE9BQU8sU0FBUyxVQUNoQixPQUFPLFdBQVcsVUFDbEIsaUJBQWlCLE9BQU8sR0FBRztBQUFBLE1BQ25DO0FBQ0EsTUFBQUEsV0FBVSxRQUFRO0FBRWxCLGVBQVMsa0JBQWtCLFFBQVE7QUFDL0IsZUFBTyxTQUFTLE1BQU0sS0FBSyxPQUFPLFFBQVEsUUFBUSxNQUFNO0FBQUEsTUFDNUQ7QUFDQSxNQUFBQSxXQUFVLG9CQUFvQjtBQUU5QixlQUFTLFVBQVUsUUFBUTtBQUN2QixlQUFPLFNBQVMsTUFBTSxLQUFLLE9BQU8sUUFBUSxRQUFRLE1BQU07QUFBQSxNQUM1RDtBQUNBLE1BQUFBLFdBQVUsWUFBWTtBQUV0QixlQUFTLFVBQVUsUUFBUTtBQUN2QixlQUFPLFNBQVMsTUFBTSxLQUFLLE9BQU8sUUFBUSxRQUFRLE1BQU07QUFBQSxNQUM1RDtBQUNBLE1BQUFBLFdBQVUsWUFBWTtBQUV0QixlQUFTLFFBQVEsUUFBUTtBQUNyQixlQUFRLE9BQU8sV0FBVyxhQUNyQixLQUFLLE1BQU0sS0FDUixPQUFPLE1BQU0sS0FDYixTQUFTLE1BQU0sS0FDZixRQUFRLE1BQU0sS0FDZCxhQUFhLE1BQU0sS0FDbkIsTUFBTSxNQUFNLEtBQ1osVUFBVSxNQUFNLEtBQ2hCLFNBQVMsTUFBTSxLQUNmLFdBQVcsTUFBTSxLQUNqQixTQUFTLE1BQU0sS0FDZixPQUFPLE1BQU0sS0FDYixLQUFLLE1BQU0sS0FDWCxNQUFNLE1BQU0sS0FDWixRQUFRLE1BQU0sS0FDZCxRQUFRLE1BQU0sS0FDZCxTQUFTLE1BQU0sS0FDZixRQUFRLE1BQU0sS0FDZCxLQUFLLE1BQU0sS0FDWCxRQUFRLE1BQU0sS0FDZCxRQUFRLE1BQU0sS0FDZCxpQkFBaUIsTUFBTSxLQUN2QixNQUFNLE1BQU0sS0FDWixPQUFPLE1BQU0sS0FDYixXQUFXLE1BQU0sS0FDakIsT0FBTyxNQUFNLEtBQ2IsWUFBWSxNQUFNLEtBQ2xCLFNBQVMsTUFBTSxLQUNmLFFBQVEsTUFBTSxLQUNkLE1BQU0sTUFBTSxLQUNYLE1BQU0sTUFBTSxLQUFLLGFBQWEsSUFBSSxPQUFPLFFBQVEsSUFBSSxDQUFDO0FBQUEsTUFDbkU7QUFDQSxNQUFBQSxXQUFVLFVBQVU7QUFBQSxJQUN4QixHQUFHLGNBQWMsUUFBUSxZQUFZLFlBQVksQ0FBQyxFQUFFO0FBS3BELFFBQUk7QUFDSixLQUFDLFNBQVVFLG1CQUFrQjtBQUN6QixlQUFTLE1BQU0sUUFBUTtBQUNuQixZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFDekIsaUJBQU87QUFDWCxZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU0sT0FBTztBQUNoQyxpQkFBTyxDQUFDLE1BQU0sT0FBTyxHQUFHO0FBQUEsUUFDNUI7QUFDQSxZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU0sYUFBYTtBQUN0QyxnQkFBTSxZQUFZO0FBQ2xCLGlCQUFPLFVBQVUsTUFBTSxNQUFNLENBQUNELFlBQVcsTUFBTUEsT0FBTSxDQUFDO0FBQUEsUUFDMUQ7QUFDQSxZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU0sU0FBUztBQUNsQyxnQkFBTSxRQUFRO0FBQ2QsaUJBQU8sTUFBTSxNQUFNLEtBQUssQ0FBQ0EsWUFBVyxNQUFNQSxPQUFNLENBQUM7QUFBQSxRQUNyRDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQ0EsTUFBQUMsa0JBQWlCLFFBQVE7QUFBQSxJQUM3QixHQUFHLHFCQUFxQixRQUFRLG1CQUFtQixtQkFBbUIsQ0FBQyxFQUFFO0FBSXpFLFFBQUk7QUFDSixLQUFDLFNBQVVDLG9CQUFtQjtBQUMxQixNQUFBQSxtQkFBa0JBLG1CQUFrQixPQUFPLElBQUksQ0FBQyxJQUFJO0FBQ3BELE1BQUFBLG1CQUFrQkEsbUJBQWtCLE1BQU0sSUFBSSxDQUFDLElBQUk7QUFDbkQsTUFBQUEsbUJBQWtCQSxtQkFBa0IsT0FBTyxJQUFJLENBQUMsSUFBSTtBQUFBLElBQ3hELEdBQUcsc0JBQXNCLFFBQVEsb0JBQW9CLG9CQUFvQixDQUFDLEVBQUU7QUFDNUUsUUFBSTtBQUNKLEtBQUMsU0FBVUMsY0FBYTtBQUlwQixlQUFTLGtCQUFrQixRQUFRO0FBQy9CLGVBQU8sV0FBVyxrQkFBa0IsUUFBUSxrQkFBa0IsUUFBUSxrQkFBa0I7QUFBQSxNQUM1RjtBQUlBLGVBQVMsU0FBUyxNQUFNLE9BQU87QUFDM0IsZUFBTyxrQkFBa0I7QUFBQSxNQUM3QjtBQUNBLGVBQVMsSUFBSSxNQUFNLE9BQU87QUFDdEIsWUFBSSxVQUFVLFdBQVcsS0FBSztBQUMxQixpQkFBTyxlQUFlLE1BQU0sS0FBSztBQUNyQyxZQUFJLFVBQVUsT0FBTyxLQUFLLEtBQUssTUFBTSxNQUFNLEtBQUssQ0FBQyxXQUFXLFVBQVUsS0FBSyxNQUFNLEtBQUssVUFBVSxTQUFTLE1BQU0sQ0FBQztBQUM1RyxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxrQkFBa0I7QUFBQSxNQUM3QjtBQUlBLGVBQVMsV0FBVyxNQUFNLE9BQU87QUFDN0IsWUFBSSxVQUFVLFNBQVMsSUFBSTtBQUN2QixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLEtBQUssSUFBSTtBQUNuQixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLE9BQU8sSUFBSTtBQUNyQixpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxrQkFBa0I7QUFBQSxNQUM3QjtBQUNBLGVBQVNDLE9BQU0sTUFBTSxPQUFPO0FBQ3hCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxLQUFLLEtBQUs7QUFDcEIsaUJBQU8sU0FBUyxNQUFNLEtBQUs7QUFDL0IsWUFBSSxVQUFVLFFBQVEsS0FBSyxLQUFLLGtCQUFrQixLQUFLO0FBQ25ELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLENBQUMsVUFBVSxPQUFPLEtBQUs7QUFDdkIsaUJBQU8sa0JBQWtCO0FBQzdCLGVBQU8sa0JBQWtCLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxDQUFDO0FBQUEsTUFDM0Q7QUFJQSxlQUFTLE9BQU8sTUFBTSxPQUFPO0FBQ3pCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsZUFBTyxVQUFVLFFBQVEsS0FBSyxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQ2pGO0FBSUEsZUFBUyxhQUFhLE1BQU0sT0FBTztBQUMvQixZQUFJLFVBQVUsU0FBUyxJQUFJLEtBQUssT0FBTyxLQUFLLFVBQVU7QUFDbEQsaUJBQU8sa0JBQWtCO0FBQzdCLGVBQU8sVUFBVSxTQUFTLElBQUksSUFBSSxrQkFBa0IsT0FBTyxrQkFBa0I7QUFBQSxNQUNqRjtBQUNBLGVBQVNDLFNBQVEsTUFBTSxPQUFPO0FBQzFCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsZUFBTyxVQUFVLFNBQVMsS0FBSyxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQ2xGO0FBSUEsZUFBUyxZQUFZLE1BQU0sT0FBTztBQUM5QixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxDQUFDLFVBQVUsYUFBYSxLQUFLO0FBQzdCLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLEtBQUssV0FBVyxTQUFTLE1BQU0sV0FBVztBQUMxQyxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxDQUFDLEtBQUssV0FBVyxNQUFNLENBQUMsUUFBUSxVQUFVLGtCQUFrQixNQUFNLE1BQU0sV0FBVyxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLElBQUksR0FBRztBQUNqSSxpQkFBTyxrQkFBa0I7QUFBQSxRQUM3QjtBQUNBLGVBQU8sa0JBQWtCLE1BQU0sS0FBSyxTQUFTLE1BQU0sT0FBTyxDQUFDO0FBQUEsTUFDL0Q7QUFJQSxlQUFTQyxNQUFLLE1BQU0sT0FBTztBQUN2QixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxlQUFPLFVBQVUsTUFBTSxLQUFLLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDL0U7QUFJQSxlQUFTQyxVQUFTLE1BQU0sT0FBTztBQUMzQixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxDQUFDLFVBQVUsVUFBVSxLQUFLO0FBQzFCLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLEtBQUssV0FBVyxTQUFTLE1BQU0sV0FBVztBQUMxQyxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxDQUFDLEtBQUssV0FBVyxNQUFNLENBQUMsUUFBUSxVQUFVLGtCQUFrQixNQUFNLE1BQU0sV0FBVyxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLElBQUksR0FBRztBQUNqSSxpQkFBTyxrQkFBa0I7QUFBQSxRQUM3QjtBQUNBLGVBQU8sa0JBQWtCLE1BQU0sS0FBSyxTQUFTLE1BQU0sT0FBTyxDQUFDO0FBQUEsTUFDL0Q7QUFJQSxlQUFTLGFBQWEsTUFBTSxPQUFPO0FBQy9CLFlBQUksVUFBVSxTQUFTLElBQUksS0FBSyxPQUFPLEtBQUssVUFBVTtBQUNsRCxpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxVQUFVLFFBQVEsSUFBSSxLQUFLLFVBQVUsU0FBUyxJQUFJLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDNUc7QUFDQSxlQUFTLFFBQVEsTUFBTSxPQUFPO0FBQzFCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsZUFBTyxVQUFVLFNBQVMsS0FBSyxLQUFLLFVBQVUsUUFBUSxLQUFLLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDOUc7QUFJQSxlQUFTLGVBQWUsTUFBTSxPQUFPO0FBQ2pDLGVBQU8sTUFBTSxNQUFNLE1BQU0sQ0FBQyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sa0JBQWtCLElBQUksSUFBSSxrQkFBa0IsT0FBTyxrQkFBa0I7QUFBQSxNQUN0STtBQUNBLGVBQVMsVUFBVSxNQUFNLE9BQU87QUFDNUIsZUFBTyxLQUFLLE1BQU0sS0FBSyxDQUFDLFdBQVcsTUFBTSxRQUFRLEtBQUssTUFBTSxrQkFBa0IsSUFBSSxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQ3JJO0FBSUEsZUFBUyxnQkFBZ0IsUUFBUTtBQUM3QixlQUFPLE9BQU8sT0FBTyxVQUFVO0FBQUEsTUFDbkM7QUFDQSxlQUFTLGdCQUFnQixRQUFRO0FBQzdCLGVBQU8sT0FBTyxPQUFPLFVBQVU7QUFBQSxNQUNuQztBQUNBLGVBQVMsaUJBQWlCLFFBQVE7QUFDOUIsZUFBTyxPQUFPLE9BQU8sVUFBVTtBQUFBLE1BQ25DO0FBQ0EsZUFBUyxRQUFRLE1BQU0sT0FBTztBQUMxQixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxLQUFLLEtBQUs7QUFDcEIsaUJBQU8sU0FBUyxNQUFNLEtBQUs7QUFDL0IsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsZUFBTyxVQUFVLFNBQVMsS0FBSyxLQUFLLE1BQU0sVUFBVSxLQUFLLFFBQVEsa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDaEg7QUFJQSxlQUFTLFdBQVcsTUFBTSxPQUFPO0FBQzdCLGVBQU8sa0JBQWtCO0FBQUEsTUFDN0I7QUFDQSxlQUFTLE1BQU0sTUFBTSxPQUFPO0FBQ3hCLGVBQU8sa0JBQWtCO0FBQUEsTUFDN0I7QUFJQSxlQUFTLFVBQVUsUUFBUTtBQUN2QixZQUFJLENBQUMsU0FBUyxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDakMsZUFBTyxNQUFNO0FBQ1QsY0FBSSxDQUFDLFVBQVUsS0FBSyxPQUFPO0FBQ3ZCO0FBQ0osb0JBQVUsUUFBUTtBQUNsQixtQkFBUztBQUFBLFFBQ2I7QUFDQSxlQUFPLFFBQVEsTUFBTSxJQUFJLFVBQVUsUUFBUSxLQUFLLFFBQVE7QUFBQSxNQUM1RDtBQUNBLGVBQVMsSUFBSSxNQUFNLE9BQU87QUFJdEIsWUFBSSxVQUFVLEtBQUssSUFBSTtBQUNuQixpQkFBTyxNQUFNLFVBQVUsSUFBSSxHQUFHLEtBQUs7QUFDdkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxNQUFNLE1BQU0sVUFBVSxLQUFLLENBQUM7QUFDdkMsY0FBTSxJQUFJLE1BQU0sMENBQTBDO0FBQUEsTUFDOUQ7QUFJQSxlQUFTLEtBQUssTUFBTSxPQUFPO0FBQ3ZCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsZUFBTyxVQUFVLE1BQU0sS0FBSyxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQy9FO0FBSUEsZUFBUyxZQUFZLE1BQU0sT0FBTztBQUM5QixZQUFJLFVBQVUsU0FBUyxJQUFJLEtBQUssZ0JBQWdCLElBQUk7QUFDaEQsaUJBQU8sa0JBQWtCO0FBQzdCLGVBQU8sVUFBVSxRQUFRLElBQUksS0FBSyxVQUFVLFNBQVMsSUFBSSxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQzVHO0FBQ0EsZUFBU0MsUUFBTyxNQUFNLE9BQU87QUFDekIsWUFBSSxVQUFVLFdBQVcsS0FBSztBQUMxQixpQkFBTyxlQUFlLE1BQU0sS0FBSztBQUNyQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxlQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssVUFBVSxRQUFRLEtBQUssSUFBSSxrQkFBa0IsT0FBTyxrQkFBa0I7QUFBQSxNQUM5RztBQUlBLGVBQVMsc0JBQXNCLFFBQVEsT0FBTztBQUMxQyxlQUFPLFdBQVcsT0FBTyxLQUFLLE9BQU8sVUFBVSxFQUFFLFdBQVc7QUFBQSxNQUNoRTtBQUNBLGVBQVMsbUJBQW1CLFFBQVE7QUFDaEMsZUFBTyxrQkFBa0IsTUFBTTtBQUFBLE1BQ25DO0FBQ0EsZUFBUyxtQkFBbUIsUUFBUTtBQUVoQyxlQUFPLHNCQUFzQixRQUFRLENBQUMsS0FBTSxzQkFBc0IsUUFBUSxDQUFDLEtBQUssaUJBQWlCLE9BQU8sY0FBYyxVQUFVLE9BQU8sT0FBTyxXQUFXLFdBQVcsS0FBSyxPQUFPLFdBQVcsWUFBWSxNQUFNLFdBQVcsTUFBTyxVQUFVLFFBQVEsT0FBTyxXQUFXLFlBQVksTUFBTSxDQUFDLENBQUMsS0FDblIsVUFBVSxXQUFXLE9BQU8sV0FBVyxZQUFZLE1BQU0sQ0FBQyxDQUFDLEtBQU8sVUFBVSxRQUFRLE9BQU8sV0FBVyxZQUFZLE1BQU0sQ0FBQyxDQUFDLEtBQzFILFVBQVUsV0FBVyxPQUFPLFdBQVcsWUFBWSxNQUFNLENBQUMsQ0FBQztBQUFBLE1BQ25FO0FBQ0EsZUFBUyxtQkFBbUIsUUFBUTtBQUNoQyxlQUFPLHNCQUFzQixRQUFRLENBQUM7QUFBQSxNQUMxQztBQUNBLGVBQVMsb0JBQW9CLFFBQVE7QUFDakMsZUFBTyxzQkFBc0IsUUFBUSxDQUFDO0FBQUEsTUFDMUM7QUFDQSxlQUFTLG1CQUFtQixRQUFRO0FBQ2hDLGVBQU8sc0JBQXNCLFFBQVEsQ0FBQztBQUFBLE1BQzFDO0FBQ0EsZUFBUyxpQkFBaUIsUUFBUTtBQUM5QixlQUFPLHNCQUFzQixRQUFRLENBQUM7QUFBQSxNQUMxQztBQUNBLGVBQVMsdUJBQXVCLFFBQVE7QUFDcEMsZUFBTyxrQkFBa0IsTUFBTTtBQUFBLE1BQ25DO0FBQ0EsZUFBUyxxQkFBcUIsUUFBUTtBQUNsQyxjQUFNLFNBQVMsUUFBUSxLQUFLLE9BQU87QUFDbkMsZUFBTyxzQkFBc0IsUUFBUSxDQUFDLEtBQU0sc0JBQXNCLFFBQVEsQ0FBQyxLQUFLLFlBQVksT0FBTyxjQUFjLGtCQUFrQixNQUFNLE9BQU8sV0FBVyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sa0JBQWtCO0FBQUEsTUFDek07QUFDQSxlQUFTLHdCQUF3QixRQUFRO0FBQ3JDLGVBQU8sc0JBQXNCLFFBQVEsQ0FBQztBQUFBLE1BQzFDO0FBQ0EsZUFBUyxrQkFBa0IsUUFBUTtBQUMvQixjQUFNLFNBQVMsUUFBUSxLQUFLLE9BQU87QUFDbkMsZUFBTyxzQkFBc0IsUUFBUSxDQUFDLEtBQU0sc0JBQXNCLFFBQVEsQ0FBQyxLQUFLLFlBQVksT0FBTyxjQUFjLGtCQUFrQixNQUFNLE9BQU8sV0FBVyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sa0JBQWtCO0FBQUEsTUFDek07QUFDQSxlQUFTLG9CQUFvQixRQUFRO0FBQ2pDLGNBQU0sT0FBTyxRQUFRLEtBQUssU0FBUyxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLEtBQUssSUFBSSxDQUFDO0FBQzNFLGVBQU8sc0JBQXNCLFFBQVEsQ0FBQyxLQUFNLHNCQUFzQixRQUFRLENBQUMsS0FBSyxVQUFVLE9BQU8sY0FBYyxrQkFBa0IsTUFBTSxPQUFPLFdBQVcsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLGtCQUFrQjtBQUFBLE1BQ25NO0FBSUEsZUFBUyxTQUFTLE1BQU0sT0FBTztBQUMzQixZQUFJLE1BQU0sTUFBTSxLQUFLLE1BQU0sa0JBQWtCO0FBQ3pDLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsVUFBVSxJQUFJLEtBQUssQ0FBQyxVQUFVLFVBQVUsS0FBSztBQUN2RCxpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxrQkFBa0I7QUFBQSxNQUM3QjtBQUNBLGVBQVMsWUFBWSxNQUFNLE9BQU87QUFDOUIsWUFBSSxVQUFVLFNBQVMsSUFBSTtBQUN2QixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLEtBQUssSUFBSTtBQUNuQixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLE9BQU8sSUFBSTtBQUNyQixpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLFNBQVMsSUFBSSxLQUFLLGdCQUFnQixJQUFJLEtBQUssbUJBQW1CLEtBQUs7QUFDN0UsaUJBQU8sa0JBQWtCO0FBQzdCLFlBQUksVUFBVSxTQUFTLElBQUksS0FBSyxnQkFBZ0IsSUFBSSxLQUFLLG1CQUFtQixLQUFLO0FBQzdFLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsU0FBUyxJQUFJLEtBQUssaUJBQWlCLElBQUksS0FBSyxvQkFBb0IsS0FBSztBQUMvRSxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLFFBQVEsSUFBSSxLQUFLLG1CQUFtQixLQUFLO0FBQ25ELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsUUFBUSxJQUFJLEtBQUssbUJBQW1CLEtBQUs7QUFDbkQsaUJBQU8sa0JBQWtCO0FBQzdCLFlBQUksVUFBVSxRQUFRLElBQUksS0FBSyxtQkFBbUIsS0FBSztBQUNuRCxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLFFBQVEsSUFBSSxLQUFLLG1CQUFtQixLQUFLO0FBQ25ELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsUUFBUSxJQUFJLEtBQUssbUJBQW1CLEtBQUs7QUFDbkQsaUJBQU8sa0JBQWtCO0FBQzdCLFlBQUksVUFBVSxTQUFTLElBQUksS0FBSyxtQkFBbUIsS0FBSztBQUNwRCxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLFNBQVMsSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBQ3JELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsWUFBWSxJQUFJLEtBQUssdUJBQXVCLEtBQUs7QUFDM0QsaUJBQU8sa0JBQWtCO0FBQzdCLFlBQUksVUFBVSxNQUFNLElBQUksS0FBSyxpQkFBaUIsS0FBSztBQUMvQyxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLGFBQWEsSUFBSSxLQUFLLHdCQUF3QixLQUFLO0FBQzdELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsVUFBVSxJQUFJLEtBQUsscUJBQXFCLEtBQUs7QUFDdkQsaUJBQU8sa0JBQWtCO0FBQzdCLFlBQUksVUFBVSxRQUFRLElBQUksS0FBSyxVQUFVLFFBQVEsVUFBVSxJQUFJLENBQUMsR0FBRztBQUcvRCxpQkFBTyxNQUFNLFFBQVEsSUFBSSxNQUFNLFdBQVcsa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsUUFDekY7QUFDQSxZQUFJLFVBQVUsUUFBUSxJQUFJLEtBQUssVUFBVSxRQUFRLFVBQVUsSUFBSSxDQUFDLEdBQUc7QUFDL0QsaUJBQU8sc0JBQXNCLE9BQU8sQ0FBQyxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLFFBQ3hGO0FBQ0EsZUFBTyxrQkFBa0I7QUFBQSxNQUM3QjtBQUNBLGVBQVNDLFFBQU8sTUFBTSxPQUFPO0FBQ3pCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxLQUFLLEtBQUs7QUFDcEIsaUJBQU8sU0FBUyxNQUFNLEtBQUs7QUFDL0IsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxZQUFJLENBQUMsVUFBVSxRQUFRLEtBQUs7QUFDeEIsaUJBQU8sa0JBQWtCO0FBQzdCLG1CQUFXLE9BQU8sV0FBVyxPQUFPLEtBQUssTUFBTSxVQUFVLEdBQUc7QUFDeEQsY0FBSSxFQUFFLE9BQU8sS0FBSztBQUNkLG1CQUFPLGtCQUFrQjtBQUM3QixjQUFJLFNBQVMsS0FBSyxXQUFXLEdBQUcsR0FBRyxNQUFNLFdBQVcsR0FBRyxDQUFDLE1BQU0sa0JBQWtCLE9BQU87QUFDbkYsbUJBQU8sa0JBQWtCO0FBQUEsVUFDN0I7QUFBQSxRQUNKO0FBQ0EsZUFBTyxrQkFBa0I7QUFBQSxNQUM3QjtBQUlBLGVBQVNDLFNBQVEsTUFBTSxPQUFPO0FBQzFCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxLQUFLLEtBQUs7QUFDcEIsaUJBQU8sU0FBUyxNQUFNLEtBQUs7QUFDL0IsWUFBSSxVQUFVLFFBQVEsS0FBSyxLQUFLLG9CQUFvQixLQUFLO0FBQ3JELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLENBQUMsVUFBVSxTQUFTLEtBQUs7QUFDekIsaUJBQU8sa0JBQWtCO0FBQzdCLGVBQU8sa0JBQWtCLE1BQU0sS0FBSyxNQUFNLE1BQU0sSUFBSSxDQUFDO0FBQUEsTUFDekQ7QUFJQSxlQUFTLFVBQVUsUUFBUTtBQUN2QixZQUFJLFFBQVEsc0JBQXNCLE9BQU87QUFDckMsaUJBQU8sUUFBUSxLQUFLLE9BQU87QUFDL0IsWUFBSSxRQUFRLHNCQUFzQixPQUFPO0FBQ3JDLGlCQUFPLFFBQVEsS0FBSyxPQUFPO0FBQy9CLGNBQU0sTUFBTSxvQ0FBb0M7QUFBQSxNQUNwRDtBQUNBLGVBQVMsWUFBWSxRQUFRO0FBQ3pCLFlBQUksUUFBUSxzQkFBc0IsT0FBTztBQUNyQyxpQkFBTyxPQUFPLGtCQUFrQixRQUFRLGtCQUFrQjtBQUM5RCxZQUFJLFFBQVEsc0JBQXNCLE9BQU87QUFDckMsaUJBQU8sT0FBTyxrQkFBa0IsUUFBUSxrQkFBa0I7QUFDOUQsY0FBTSxNQUFNLHNDQUFzQztBQUFBLE1BQ3REO0FBQ0EsZUFBUyxZQUFZLE1BQU0sT0FBTztBQUM5QixjQUFNLE1BQU0sVUFBVSxLQUFLO0FBQzNCLGNBQU0sUUFBUSxZQUFZLEtBQUs7QUFDL0IsWUFBSSxVQUFVLFNBQVMsSUFBSSxLQUFLLGdCQUFnQixJQUFJLEtBQUssVUFBVSxRQUFRLEdBQUcsS0FBSyxrQkFBa0IsTUFBTSxNQUFNLEtBQUssQ0FBQyxNQUFNLGtCQUFrQjtBQUMzSSxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLFlBQVksSUFBSSxLQUFLLFVBQVUsUUFBUSxHQUFHO0FBQ3BELGlCQUFPLE1BQU0sTUFBTSxLQUFLO0FBQzVCLFlBQUksVUFBVSxRQUFRLElBQUksS0FBSyxVQUFVLFFBQVEsR0FBRztBQUNoRCxpQkFBTyxNQUFNLE1BQU0sS0FBSztBQUM1QixZQUFJLFVBQVUsT0FBTyxJQUFJLEtBQUssVUFBVSxRQUFRLEdBQUc7QUFDL0MsaUJBQU8sTUFBTSxNQUFNLEtBQUs7QUFDNUIsWUFBSSxVQUFVLFFBQVEsSUFBSSxHQUFHO0FBQ3pCLHFCQUFXLE9BQU8sV0FBVyxPQUFPLEtBQUssS0FBSyxVQUFVLEdBQUc7QUFDdkQsZ0JBQUksU0FBUyxPQUFPLEtBQUssV0FBVyxHQUFHLENBQUMsTUFBTSxrQkFBa0IsT0FBTztBQUNuRSxxQkFBTyxrQkFBa0I7QUFBQSxZQUM3QjtBQUFBLFVBQ0o7QUFDQSxpQkFBTyxrQkFBa0I7QUFBQSxRQUM3QjtBQUNBLGVBQU8sa0JBQWtCO0FBQUEsTUFDN0I7QUFDQSxlQUFTLE9BQU8sTUFBTSxPQUFPO0FBQ3pCLGNBQU0sUUFBUSxZQUFZLElBQUk7QUFDOUIsWUFBSSxVQUFVLFdBQVcsS0FBSztBQUMxQixpQkFBTyxlQUFlLE1BQU0sS0FBSztBQUNyQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksQ0FBQyxVQUFVLFFBQVEsS0FBSztBQUN4QixpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxNQUFNLE9BQU8sWUFBWSxLQUFLLENBQUM7QUFBQSxNQUMxQztBQUlBLGVBQVMsWUFBWSxNQUFNLE9BQU87QUFDOUIsWUFBSSxVQUFVLFNBQVMsSUFBSSxLQUFLLE9BQU8sS0FBSyxVQUFVO0FBQ2xELGlCQUFPLGtCQUFrQjtBQUM3QixlQUFPLFVBQVUsUUFBUSxJQUFJLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDaEY7QUFDQSxlQUFTQyxRQUFPLE1BQU0sT0FBTztBQUN6QixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxLQUFLLEtBQUs7QUFDcEIsaUJBQU8sU0FBUyxNQUFNLEtBQUs7QUFDL0IsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLGVBQU8sVUFBVSxRQUFRLEtBQUssSUFBSSxrQkFBa0IsT0FBTyxrQkFBa0I7QUFBQSxNQUNqRjtBQUlBLGVBQVNDLFFBQU8sTUFBTSxPQUFPO0FBQ3pCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsZUFBTyxVQUFVLFFBQVEsS0FBSyxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQ2pGO0FBSUEsZUFBUyxnQkFBZ0IsTUFBTSxPQUFPO0FBSWxDLFlBQUksVUFBVSxpQkFBaUIsSUFBSTtBQUMvQixpQkFBTyxNQUFNLHdCQUF3QixRQUFRLElBQUksR0FBRyxLQUFLO0FBQzdELFlBQUksVUFBVSxpQkFBaUIsS0FBSztBQUNoQyxpQkFBTyxNQUFNLE1BQU0sd0JBQXdCLFFBQVEsS0FBSyxDQUFDO0FBQzdELGNBQU0sSUFBSSxNQUFNLHNEQUFzRDtBQUFBLE1BQzFFO0FBSUEsZUFBUyxXQUFXLE1BQU0sT0FBTztBQUM3QixZQUFJLFVBQVUsU0FBUyxJQUFJO0FBQ3ZCLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsS0FBSyxJQUFJO0FBQ25CLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLFVBQVUsT0FBTyxJQUFJO0FBQ3JCLGlCQUFPLGtCQUFrQjtBQUM3QixlQUFPLGtCQUFrQjtBQUFBLE1BQzdCO0FBQ0EsZUFBUyxlQUFlLE1BQU0sT0FBTztBQUNqQyxlQUFPLFVBQVUsT0FBTyxLQUFLLEtBQUssS0FBSyxVQUFVLFVBQWEsS0FBSyxNQUFNLE1BQU0sQ0FBQyxXQUFXLE1BQU0sUUFBUSxNQUFNLEtBQUssTUFBTSxrQkFBa0IsSUFBSTtBQUFBLE1BQ3BKO0FBQ0EsZUFBUyxNQUFNLE1BQU0sT0FBTztBQUN4QixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUssS0FBSyxrQkFBa0IsS0FBSztBQUNuRCxpQkFBTyxrQkFBa0I7QUFDN0IsWUFBSSxVQUFVLE9BQU8sS0FBSyxLQUFLLGVBQWUsTUFBTSxLQUFLO0FBQ3JELGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLENBQUMsVUFBVSxPQUFPLEtBQUs7QUFDdkIsaUJBQU8sa0JBQWtCO0FBQzdCLFlBQUssS0FBSyxVQUFVLFVBQWEsTUFBTSxVQUFVLFVBQWUsS0FBSyxVQUFVLFVBQWEsTUFBTSxVQUFVO0FBQ3hHLGlCQUFPLGtCQUFrQjtBQUM3QixZQUFJLEtBQUssVUFBVSxVQUFhLE1BQU0sVUFBVTtBQUM1QyxpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxLQUFLLE1BQU0sTUFBTSxDQUFDLFFBQVEsVUFBVSxNQUFNLFFBQVEsTUFBTSxNQUFNLEtBQUssQ0FBQyxNQUFNLGtCQUFrQixJQUFJLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDMUo7QUFJQSxlQUFTQyxZQUFXLE1BQU0sT0FBTztBQUM3QixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxVQUFVLFFBQVEsS0FBSztBQUN2QixpQkFBTyxZQUFZLE1BQU0sS0FBSztBQUNsQyxlQUFPLFVBQVUsWUFBWSxLQUFLLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDckY7QUFJQSxlQUFTLFVBQVUsTUFBTSxPQUFPO0FBQzVCLFlBQUksVUFBVSxXQUFXLEtBQUs7QUFDMUIsaUJBQU8sZUFBZSxNQUFNLEtBQUs7QUFDckMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsT0FBTyxLQUFLO0FBQ3RCLGlCQUFPLFdBQVcsTUFBTSxLQUFLO0FBQ2pDLFlBQUksVUFBVSxTQUFTLEtBQUs7QUFDeEIsaUJBQU8sYUFBYSxNQUFNLEtBQUs7QUFDbkMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxVQUFVLE1BQU0sS0FBSztBQUNyQixpQkFBTyxVQUFVLE1BQU0sS0FBSztBQUNoQyxlQUFPLFVBQVUsV0FBVyxLQUFLLElBQUksa0JBQWtCLE9BQU8sa0JBQWtCO0FBQUEsTUFDcEY7QUFJQSxlQUFTLFdBQVcsTUFBTSxPQUFPO0FBQzdCLGVBQU8sTUFBTSxNQUFNLEtBQUssQ0FBQyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sa0JBQWtCLElBQUksSUFBSSxrQkFBa0IsT0FBTyxrQkFBa0I7QUFBQSxNQUNySTtBQUNBLGVBQVMsTUFBTSxNQUFNLE9BQU87QUFDeEIsZUFBTyxLQUFLLE1BQU0sTUFBTSxDQUFDLFdBQVcsTUFBTSxRQUFRLEtBQUssTUFBTSxrQkFBa0IsSUFBSSxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQ3RJO0FBSUEsZUFBUyxhQUFhLE1BQU0sT0FBTztBQUMvQixlQUFPLGtCQUFrQjtBQUFBLE1BQzdCO0FBQ0EsZUFBUyxRQUFRLE1BQU0sT0FBTztBQUMxQixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLEtBQUssS0FBSztBQUNwQixpQkFBTyxTQUFTLE1BQU0sS0FBSztBQUMvQixZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsU0FBUyxLQUFLO0FBQ3hCLGlCQUFPLGFBQWEsTUFBTSxLQUFLO0FBQ25DLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLE9BQU8sS0FBSztBQUN0QixpQkFBTyxXQUFXLE1BQU0sS0FBSztBQUNqQyxZQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3ZCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLGVBQU8sVUFBVSxTQUFTLEtBQUssSUFBSSxrQkFBa0IsT0FBTyxrQkFBa0I7QUFBQSxNQUNsRjtBQUlBLGVBQVMsVUFBVSxNQUFNLE9BQU87QUFDNUIsWUFBSSxVQUFVLFdBQVcsSUFBSTtBQUN6QixpQkFBTyxrQkFBa0I7QUFDN0IsZUFBTyxVQUFVLFdBQVcsSUFBSSxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQ25GO0FBQ0EsZUFBUyxLQUFLLE1BQU0sT0FBTztBQUN2QixZQUFJLFVBQVUsV0FBVyxLQUFLO0FBQzFCLGlCQUFPLGVBQWUsTUFBTSxLQUFLO0FBQ3JDLFlBQUksVUFBVSxPQUFPLEtBQUs7QUFDdEIsaUJBQU8sV0FBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFNBQVMsS0FBSztBQUN4QixpQkFBTyxhQUFhLE1BQU0sS0FBSztBQUNuQyxZQUFJLFVBQVUsS0FBSyxLQUFLO0FBQ3BCLGlCQUFPLFNBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxRQUFRLEtBQUs7QUFDdkIsaUJBQU8sWUFBWSxNQUFNLEtBQUs7QUFDbEMsZUFBTyxVQUFVLE1BQU0sS0FBSyxJQUFJLGtCQUFrQixPQUFPLGtCQUFrQjtBQUFBLE1BQy9FO0FBQ0EsZUFBUyxNQUFNLE1BQU0sT0FBTztBQUV4QixZQUFJLFVBQVUsaUJBQWlCLElBQUksS0FBSyxVQUFVLGlCQUFpQixLQUFLO0FBQ3BFLGlCQUFPLGdCQUFnQixNQUFNLEtBQUs7QUFDdEMsWUFBSSxVQUFVLEtBQUssSUFBSSxLQUFLLFVBQVUsS0FBSyxLQUFLO0FBQzVDLGlCQUFPLElBQUksTUFBTSxLQUFLO0FBRTFCLFlBQUksVUFBVSxLQUFLLElBQUk7QUFDbkIsaUJBQU8sSUFBSSxNQUFNLEtBQUs7QUFDMUIsWUFBSSxVQUFVLE9BQU8sSUFBSTtBQUNyQixpQkFBT1QsT0FBTSxNQUFNLEtBQUs7QUFDNUIsWUFBSSxVQUFVLFFBQVEsSUFBSTtBQUN0QixpQkFBTyxPQUFPLE1BQU0sS0FBSztBQUM3QixZQUFJLFVBQVUsU0FBUyxJQUFJO0FBQ3ZCLGlCQUFPQyxTQUFRLE1BQU0sS0FBSztBQUM5QixZQUFJLFVBQVUsYUFBYSxJQUFJO0FBQzNCLGlCQUFPLFlBQVksTUFBTSxLQUFLO0FBQ2xDLFlBQUksVUFBVSxNQUFNLElBQUk7QUFDcEIsaUJBQU9DLE1BQUssTUFBTSxLQUFLO0FBQzNCLFlBQUksVUFBVSxVQUFVLElBQUk7QUFDeEIsaUJBQU9DLFVBQVMsTUFBTSxLQUFLO0FBQy9CLFlBQUksVUFBVSxTQUFTLElBQUk7QUFDdkIsaUJBQU8sUUFBUSxNQUFNLEtBQUs7QUFDOUIsWUFBSSxVQUFVLFdBQVcsSUFBSTtBQUN6QixpQkFBTyxVQUFVLE1BQU0sS0FBSztBQUNoQyxZQUFJLFVBQVUsU0FBUyxJQUFJO0FBQ3ZCLGlCQUFPLFFBQVEsTUFBTSxLQUFLO0FBQzlCLFlBQUksVUFBVSxPQUFPLElBQUk7QUFDckIsaUJBQU8sTUFBTSxNQUFNLEtBQUs7QUFDNUIsWUFBSSxVQUFVLE1BQU0sSUFBSTtBQUNwQixpQkFBTyxLQUFLLE1BQU0sS0FBSztBQUMzQixZQUFJLFVBQVUsUUFBUSxJQUFJO0FBQ3RCLGlCQUFPQyxRQUFPLE1BQU0sS0FBSztBQUM3QixZQUFJLFVBQVUsUUFBUSxJQUFJO0FBQ3RCLGlCQUFPQyxRQUFPLE1BQU0sS0FBSztBQUM3QixZQUFJLFVBQVUsUUFBUSxJQUFJO0FBQ3RCLGlCQUFPLE9BQU8sTUFBTSxLQUFLO0FBQzdCLFlBQUksVUFBVSxRQUFRLElBQUk7QUFDdEIsaUJBQU9FLFFBQU8sTUFBTSxLQUFLO0FBQzdCLFlBQUksVUFBVSxRQUFRLElBQUk7QUFDdEIsaUJBQU9DLFFBQU8sTUFBTSxLQUFLO0FBQzdCLFlBQUksVUFBVSxPQUFPLElBQUk7QUFDckIsaUJBQU8sTUFBTSxNQUFNLEtBQUs7QUFDNUIsWUFBSSxVQUFVLFNBQVMsSUFBSTtBQUN2QixpQkFBT0YsU0FBUSxNQUFNLEtBQUs7QUFDOUIsWUFBSSxVQUFVLFlBQVksSUFBSTtBQUMxQixpQkFBT0csWUFBVyxNQUFNLEtBQUs7QUFDakMsWUFBSSxVQUFVLFdBQVcsSUFBSTtBQUN6QixpQkFBTyxVQUFVLE1BQU0sS0FBSztBQUNoQyxZQUFJLFVBQVUsT0FBTyxJQUFJO0FBQ3JCLGlCQUFPLE1BQU0sTUFBTSxLQUFLO0FBQzVCLFlBQUksVUFBVSxTQUFTLElBQUk7QUFDdkIsaUJBQU8sUUFBUSxNQUFNLEtBQUs7QUFDOUIsWUFBSSxVQUFVLE1BQU0sSUFBSTtBQUNwQixpQkFBTyxLQUFLLE1BQU0sS0FBSztBQUMzQixjQUFNLE1BQU0sMkNBQTJDLEtBQUssUUFBUSxJQUFJLElBQUk7QUFBQSxNQUNoRjtBQUNBLGVBQVMsUUFBUSxNQUFNLE9BQU87QUFDMUIsZUFBTyxNQUFNLE1BQU0sS0FBSztBQUFBLE1BQzVCO0FBQ0EsTUFBQVYsYUFBWSxVQUFVO0FBQUEsSUFDMUIsR0FBRyxnQkFBZ0IsUUFBUSxjQUFjLGNBQWMsQ0FBQyxFQUFFO0FBSzFELFFBQUk7QUFDSixLQUFDLFNBQVVXLFlBQVc7QUFDbEIsZUFBUyxTQUFTLE9BQU87QUFDckIsZUFBTyxPQUFPLFVBQVUsWUFBWSxVQUFVO0FBQUEsTUFDbEQ7QUFDQSxlQUFTLFFBQVEsT0FBTztBQUNwQixlQUFPLFdBQVcsTUFBTSxRQUFRLEtBQUs7QUFBQSxNQUN6QztBQUNBLGVBQVNWLE9BQU0sT0FBTztBQUNsQixlQUFPLE1BQU0sSUFBSSxDQUFDVyxXQUFVLE1BQU1BLE1BQUssQ0FBQztBQUFBLE1BQzVDO0FBQ0EsZUFBU04sUUFBTyxPQUFPO0FBQ25CLGNBQU0sbUJBQW1CLFdBQVcsT0FBTyxvQkFBb0IsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLFFBQVE7QUFDdkYsaUJBQU8sRUFBRSxHQUFHLEtBQUssQ0FBQyxHQUFHLEdBQUcsTUFBTSxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQUEsUUFDOUMsR0FBRyxDQUFDLENBQUM7QUFDTCxjQUFNLGdCQUFnQixXQUFXLE9BQU8sc0JBQXNCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxRQUFRO0FBQ3RGLGlCQUFPLEVBQUUsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLE1BQU0sTUFBTSxHQUFHLENBQUMsRUFBRTtBQUFBLFFBQzlDLEdBQUcsQ0FBQyxDQUFDO0FBQ0wsZUFBTyxFQUFFLEdBQUcsa0JBQWtCLEdBQUcsY0FBYztBQUFBLE1BQ25EO0FBQ0EsZUFBUyxNQUFNLE9BQU87QUFDbEIsWUFBSSxRQUFRLEtBQUs7QUFDYixpQkFBT0wsT0FBTSxLQUFLO0FBQ3RCLFlBQUksU0FBUyxLQUFLO0FBQ2QsaUJBQU9LLFFBQU8sS0FBSztBQUN2QixlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsTUFBTSxRQUFRLFNBQVM7QUFDNUIsZUFBTyxFQUFFLEdBQUcsTUFBTSxNQUFNLEdBQUcsR0FBRyxRQUFRO0FBQUEsTUFDMUM7QUFDQSxNQUFBSyxXQUFVLFFBQVE7QUFBQSxJQUN0QixHQUFHLGNBQWMsUUFBUSxZQUFZLFlBQVksQ0FBQyxFQUFFO0FBSXBELFFBQUk7QUFDSixLQUFDLFNBQVVFLGtCQUFpQjtBQUN4QixlQUFTLGVBQWUsUUFBUTtBQUM1QixlQUFPLE9BQU8sSUFBSSxDQUFDaEIsWUFBVztBQUMxQixnQkFBTSxFQUFFLENBQUMsUUFBUSxRQUFRLEdBQUcsR0FBRyxHQUFHLE1BQU0sSUFBSSxVQUFVLE1BQU1BLFNBQVEsQ0FBQyxDQUFDO0FBQ3RFLGlCQUFPO0FBQUEsUUFDWCxDQUFDO0FBQUEsTUFDTDtBQUNBLGVBQVMsb0JBQW9CLFFBQVE7QUFDakMsZUFBTyxPQUFPLE1BQU0sQ0FBQ0EsWUFBVyxVQUFVLFVBQVVBLE9BQU0sQ0FBQztBQUFBLE1BQy9EO0FBQ0EsZUFBUyxnQkFBZ0IsUUFBUTtBQUM3QixlQUFPLE9BQU8sS0FBSyxDQUFDQSxZQUFXLFVBQVUsVUFBVUEsT0FBTSxDQUFDO0FBQUEsTUFDOUQ7QUFDQSxlQUFTLGlCQUFpQixRQUFRO0FBQzlCLGNBQU0sV0FBVyxvQkFBb0IsT0FBTyxLQUFLO0FBQ2pELGVBQU8sV0FBVyxRQUFRLEtBQUssU0FBUyxRQUFRLEtBQUssVUFBVSxlQUFlLE9BQU8sS0FBSyxDQUFDLENBQUMsSUFBSTtBQUFBLE1BQ3BHO0FBQ0EsZUFBUyxhQUFhLFFBQVE7QUFDMUIsY0FBTSxXQUFXLGdCQUFnQixPQUFPLEtBQUs7QUFDN0MsZUFBTyxXQUFXLFFBQVEsS0FBSyxTQUFTLFFBQVEsS0FBSyxNQUFNLGVBQWUsT0FBTyxLQUFLLENBQUMsQ0FBQyxJQUFJO0FBQUEsTUFDaEc7QUFDQSxlQUFTLGdCQUFnQixRQUFRO0FBQzdCLFlBQUksT0FBTyxRQUFRLElBQUksTUFBTTtBQUN6QixpQkFBTyxpQkFBaUIsTUFBTTtBQUNsQyxZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFDekIsaUJBQU8sYUFBYSxNQUFNO0FBQzlCLGVBQU87QUFBQSxNQUNYO0FBQ0EsZUFBUyxVQUFVLFFBQVEsS0FBSztBQUM1QixjQUFNLFdBQVcsT0FBTyxNQUFNLE9BQU8sQ0FBQyxLQUFLQSxZQUFXO0FBQ2xELGdCQUFNLFVBQVUsTUFBTUEsU0FBUSxHQUFHO0FBQ2pDLGlCQUFPLFFBQVEsUUFBUSxJQUFJLE1BQU0sVUFBVSxNQUFNLENBQUMsR0FBRyxLQUFLLE9BQU87QUFBQSxRQUNyRSxHQUFHLENBQUMsQ0FBQztBQUNMLGVBQU8sZ0JBQWdCLFFBQVEsS0FBSyxVQUFVLFFBQVEsQ0FBQztBQUFBLE1BQzNEO0FBQ0EsZUFBUyxNQUFNLFFBQVEsS0FBSztBQUN4QixjQUFNLFdBQVcsT0FBTyxNQUFNLElBQUksQ0FBQ0EsWUFBVyxNQUFNQSxTQUFRLEdBQUcsQ0FBQztBQUNoRSxlQUFPLGdCQUFnQixRQUFRLEtBQUssTUFBTSxRQUFRLENBQUM7QUFBQSxNQUN2RDtBQUNBLGVBQVNTLFFBQU8sUUFBUSxLQUFLO0FBQ3pCLGNBQU0sV0FBVyxPQUFPLFdBQVcsR0FBRztBQUN0QyxlQUFPLGFBQWEsU0FBWSxRQUFRLEtBQUssTUFBTSxJQUFJLFFBQVEsS0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDO0FBQUEsTUFDeEY7QUFDQSxlQUFTLE1BQU0sUUFBUSxLQUFLO0FBQ3hCLGNBQU0sUUFBUSxPQUFPO0FBQ3JCLFlBQUksVUFBVTtBQUNWLGlCQUFPLFFBQVEsS0FBSyxNQUFNO0FBQzlCLGNBQU0sVUFBVSxNQUFNLEdBQUc7QUFDekIsWUFBSSxZQUFZO0FBQ1osaUJBQU8sUUFBUSxLQUFLLE1BQU07QUFDOUIsZUFBTztBQUFBLE1BQ1g7QUFDQSxlQUFTLE1BQU0sUUFBUSxLQUFLO0FBQ3hCLFlBQUksT0FBTyxRQUFRLElBQUksTUFBTTtBQUN6QixpQkFBTyxVQUFVLFFBQVEsR0FBRztBQUNoQyxZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFDekIsaUJBQU8sTUFBTSxRQUFRLEdBQUc7QUFDNUIsWUFBSSxPQUFPLFFBQVEsSUFBSSxNQUFNO0FBQ3pCLGlCQUFPQSxRQUFPLFFBQVEsR0FBRztBQUM3QixZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFDekIsaUJBQU8sTUFBTSxRQUFRLEdBQUc7QUFDNUIsZUFBTyxRQUFRLEtBQUssTUFBTTtBQUFBLE1BQzlCO0FBQ0EsZUFBUyxRQUFRLFFBQVEsTUFBTSxVQUFVLENBQUMsR0FBRztBQUN6QyxjQUFNLFdBQVcsS0FBSyxJQUFJLENBQUMsUUFBUSxNQUFNLFFBQVEsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUNoRSxlQUFPLGdCQUFnQixRQUFRLEtBQUssTUFBTSxVQUFVLE9BQU8sQ0FBQztBQUFBLE1BQ2hFO0FBQ0EsTUFBQU8saUJBQWdCLFVBQVU7QUFBQSxJQUM5QixHQUFHLG9CQUFvQixRQUFRLGtCQUFrQixrQkFBa0IsQ0FBQyxFQUFFO0FBSXRFLFFBQUk7QUFDSixLQUFDLFNBQVVDLFlBQVc7QUFDbEIsZUFBUyxVQUFVLFFBQVEsVUFBVTtBQUVqQyxlQUFPLFFBQVEsS0FBSyxVQUFVLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxNQUFNLE9BQU8sUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUFBLE1BQ3BHO0FBQ0EsZUFBUyxNQUFNLFFBQVEsVUFBVTtBQUU3QixlQUFPLFFBQVEsS0FBSyxNQUFNLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxNQUFNLE9BQU8sUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUFBLE1BQ2hHO0FBQ0EsZUFBU1IsUUFBTyxRQUFRLFVBQVU7QUFDOUIsZUFBTyxTQUFTLE1BQU07QUFBQSxNQUMxQjtBQUNBLGVBQVMsTUFBTSxRQUFRLFVBQVU7QUFLN0IsWUFBSSxPQUFPLFFBQVEsSUFBSSxNQUFNO0FBQ3pCLGlCQUFPLFVBQVUsUUFBUSxRQUFRO0FBQ3JDLFlBQUksT0FBTyxRQUFRLElBQUksTUFBTTtBQUN6QixpQkFBTyxNQUFNLFFBQVEsUUFBUTtBQUNqQyxZQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU07QUFDekIsaUJBQU9BLFFBQU8sUUFBUSxRQUFRO0FBQ2xDLGVBQU87QUFBQSxNQUNYO0FBQ0EsZUFBU1MsS0FBSSxRQUFRLFVBQVUsU0FBUztBQUNwQyxlQUFPLEVBQUUsR0FBRyxNQUFNLFVBQVUsTUFBTSxRQUFRLENBQUMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxHQUFHLFFBQVE7QUFBQSxNQUN6RTtBQUNBLE1BQUFELFdBQVUsTUFBTUM7QUFBQSxJQUNwQixHQUFHLGNBQWMsUUFBUSxZQUFZLFlBQVksQ0FBQyxFQUFFO0FBQ3BELFFBQUk7QUFDSixLQUFDLFNBQVVDLGNBQWE7QUFDcEIsZUFBUyxjQUFjLEtBQUs7QUFDeEIsZUFBTyxJQUFJLENBQUMsTUFBTSxPQUFPLElBQUksSUFBSSxTQUFTLENBQUMsTUFBTSxNQUFNLElBQUksTUFBTSxHQUFHLElBQUksU0FBUyxDQUFDLElBQUk7QUFBQSxNQUMxRjtBQUNBLGVBQVMsVUFBVSxRQUFRLFNBQVM7QUFDaEMsZUFBTyxPQUFPLE1BQU0sT0FBTyxDQUFDLEtBQUtuQixZQUFXLENBQUMsR0FBRyxLQUFLLEdBQUcsTUFBTUEsU0FBUSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFBQSxNQUN2RjtBQUNBLGVBQVMsTUFBTSxRQUFRLFNBQVM7QUFDNUIsY0FBTSxPQUFPLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxNQUFNLE9BQU8sT0FBTyxDQUFDO0FBQzlELGVBQU8sQ0FBQyxHQUFHLEtBQUssT0FBTyxDQUFDLEtBQUssVUFBVSxNQUFNLElBQUksQ0FBQyxRQUFTLEtBQUssTUFBTSxDQUFDLFVBQVUsTUFBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxHQUFHLElBQUksR0FBSSxFQUFFLENBQUMsR0FBRyxvQkFBSSxJQUFJLENBQUMsQ0FBQztBQUFBLE1BQy9JO0FBQ0EsZUFBU1MsUUFBTyxRQUFRLFNBQVM7QUFDN0IsZUFBTyxXQUFXLE9BQU8sS0FBSyxPQUFPLFVBQVU7QUFBQSxNQUNuRDtBQUNBLGVBQVMsT0FBTyxRQUFRLFNBQVM7QUFDN0IsZUFBTyxRQUFRLGtCQUFrQixXQUFXLE9BQU8sS0FBSyxPQUFPLGlCQUFpQixJQUFJLENBQUM7QUFBQSxNQUN6RjtBQUNBLGVBQVMsTUFBTSxRQUFRLFNBQVM7QUFDNUIsWUFBSSxVQUFVLFdBQVcsTUFBTTtBQUMzQixpQkFBTyxVQUFVLFFBQVEsT0FBTztBQUNwQyxZQUFJLFVBQVUsT0FBTyxNQUFNO0FBQ3ZCLGlCQUFPLE1BQU0sUUFBUSxPQUFPO0FBQ2hDLFlBQUksVUFBVSxRQUFRLE1BQU07QUFDeEIsaUJBQU9BLFFBQU8sUUFBUSxPQUFPO0FBQ2pDLFlBQUksVUFBVSxRQUFRLE1BQU07QUFDeEIsaUJBQU8sT0FBTyxRQUFRLE9BQU87QUFDakMsZUFBTyxDQUFDO0FBQUEsTUFDWjtBQUVBLGVBQVMsWUFBWSxRQUFRLFNBQVM7QUFDbEMsZUFBTyxDQUFDLEdBQUcsSUFBSSxJQUFJLE1BQU0sUUFBUSxPQUFPLENBQUMsQ0FBQztBQUFBLE1BQzlDO0FBQ0EsTUFBQVUsYUFBWSxjQUFjO0FBRTFCLGVBQVMsZUFBZSxRQUFRO0FBQzVCLGNBQU0sT0FBTyxZQUFZLFFBQVEsRUFBRSxpQkFBaUIsS0FBSyxDQUFDO0FBQzFELGNBQU0sVUFBVSxLQUFLLElBQUksQ0FBQyxRQUFRLElBQUksY0FBYyxHQUFHLElBQUk7QUFDM0QsZUFBTyxLQUFLLFFBQVEsS0FBSyxHQUFHO0FBQUEsTUFDaEM7QUFDQSxNQUFBQSxhQUFZLGlCQUFpQjtBQUFBLElBQ2pDLEdBQUcsZ0JBQWdCLFFBQVEsY0FBYyxjQUFjLENBQUMsRUFBRTtBQUkxRCxRQUFJO0FBQ0osS0FBQyxTQUFVQyxtQkFBa0I7QUFFekIsZUFBUyxRQUFRLFFBQVE7QUFDckIsWUFBSSxXQUFXLE1BQU0sUUFBUSxNQUFNO0FBQy9CLGlCQUFPO0FBQ1gsWUFBSSxVQUFVLGNBQWMsTUFBTTtBQUM5QixpQkFBTyxPQUFPLE1BQU0sSUFBSSxDQUFDcEIsWUFBV0EsUUFBTyxNQUFNLFNBQVMsQ0FBQztBQUMvRCxZQUFJLFVBQVUsU0FBUyxNQUFNO0FBQ3pCLGlCQUFPLENBQUMsT0FBTyxLQUFLO0FBQ3hCLFlBQUksVUFBVSxpQkFBaUIsTUFBTSxHQUFHO0FBQ3BDLGdCQUFNLGFBQWEsc0JBQXNCLFdBQVcsT0FBTyxPQUFPO0FBQ2xFLGNBQUksQ0FBQyxzQkFBc0IsTUFBTSxVQUFVO0FBQ3ZDLGtCQUFNLE1BQU0seUVBQXlFO0FBQ3pGLGlCQUFPLENBQUMsR0FBRyx5QkFBeUIsU0FBUyxVQUFVLENBQUM7QUFBQSxRQUM1RDtBQUNBLGVBQU8sQ0FBQztBQUFBLE1BQ1o7QUFDQSxNQUFBb0Isa0JBQWlCLFVBQVU7QUFBQSxJQUMvQixHQUFHLHFCQUFxQixRQUFRLG1CQUFtQixtQkFBbUIsQ0FBQyxFQUFFO0FBSXpFLFFBQUk7QUFDSixLQUFDLFNBQVVDLGdCQUFlO0FBQ3RCLGdCQUFVLE1BQU0sT0FBTztBQUNuQixtQkFBVyxVQUFVLE1BQU0sT0FBTztBQUM5QixjQUFJLE9BQU8sUUFBUSxJQUFJLE1BQU0sU0FBUztBQUNsQyxtQkFBTyxNQUFNLE1BQU07QUFBQSxVQUN2QixPQUNLO0FBQ0Qsa0JBQU07QUFBQSxVQUNWO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFFQSxlQUFTLFFBQVEsT0FBTztBQUNwQixlQUFPLFFBQVEsS0FBSyxNQUFNLENBQUMsR0FBRyxNQUFNLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFBQSxNQUM3RDtBQUNBLE1BQUFBLGVBQWMsVUFBVTtBQUFBLElBQzVCLEdBQUcsa0JBQWtCLFFBQVEsZ0JBQWdCLGdCQUFnQixDQUFDLEVBQUU7QUFJaEUsUUFBSTtBQUNKLEtBQUMsU0FBVUMseUJBQXdCO0FBQy9CLGVBQVMsT0FBTyxPQUFPO0FBQ25CLGVBQU8sTUFBTSxRQUFRLHVCQUF1QixNQUFNO0FBQUEsTUFDdEQ7QUFDQSxlQUFTLE1BQU0sUUFBUSxLQUFLO0FBQ3hCLFlBQUksVUFBVSxpQkFBaUIsTUFBTSxHQUFHO0FBQ3BDLGdCQUFNLFVBQVUsT0FBTyxRQUFRLE1BQU0sR0FBRyxPQUFPLFFBQVEsU0FBUyxDQUFDO0FBQ2pFLGlCQUFPO0FBQUEsUUFDWCxXQUNTLFVBQVUsT0FBTyxNQUFNLEdBQUc7QUFDL0IsZ0JBQU0sU0FBUyxPQUFPLE1BQU0sSUFBSSxDQUFDdEIsWUFBVyxNQUFNQSxTQUFRLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztBQUN4RSxpQkFBTyxJQUFJO0FBQUEsUUFDZixXQUNTLFVBQVUsUUFBUSxNQUFNLEdBQUc7QUFDaEMsaUJBQU8sR0FBRyxNQUFNLFFBQVE7QUFBQSxRQUM1QixXQUNTLFVBQVUsU0FBUyxNQUFNLEdBQUc7QUFDakMsaUJBQU8sR0FBRyxNQUFNLFFBQVE7QUFBQSxRQUM1QixXQUNTLFVBQVUsUUFBUSxNQUFNLEdBQUc7QUFDaEMsaUJBQU8sR0FBRyxNQUFNLFFBQVE7QUFBQSxRQUM1QixXQUNTLFVBQVUsUUFBUSxNQUFNLEdBQUc7QUFDaEMsaUJBQU8sR0FBRyxNQUFNLFFBQVE7QUFBQSxRQUM1QixXQUNTLFVBQVUsU0FBUyxNQUFNLEdBQUc7QUFDakMsaUJBQU8sR0FBRyxNQUFNLE9BQU8sT0FBTyxNQUFNLFNBQVMsQ0FBQztBQUFBLFFBQ2xELFdBQ1MsVUFBVSxTQUFTLE1BQU0sR0FBRztBQUNqQyxpQkFBTyxHQUFHLE1BQU0sUUFBUTtBQUFBLFFBQzVCLFdBQ1MsVUFBVSxPQUFPLE1BQU0sR0FBRztBQUMvQixnQkFBTSxNQUFNLDJFQUEyRTtBQUFBLFFBQzNGLE9BQ0s7QUFDRCxnQkFBTSxNQUFNLDRDQUE0QyxPQUFPLFFBQVEsSUFBSSxJQUFJO0FBQUEsUUFDbkY7QUFBQSxNQUNKO0FBQ0EsZUFBUyxPQUFPLE9BQU87QUFDbkIsZUFBTyxJQUFJLE1BQU0sSUFBSSxDQUFDLFdBQVcsTUFBTSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUFBLE1BQy9EO0FBQ0EsTUFBQXNCLHdCQUF1QixTQUFTO0FBQUEsSUFDcEMsR0FBRywyQkFBMkIsUUFBUSx5QkFBeUIseUJBQXlCLENBQUMsRUFBRTtBQUkzRixRQUFJO0FBQ0osS0FBQyxTQUFVQywwQkFBeUI7QUFFaEMsZUFBUyxRQUFRLFVBQVU7QUFDdkIsY0FBTSxhQUFhLHNCQUFzQixXQUFXLFNBQVMsT0FBTztBQUNwRSxZQUFJLENBQUMsc0JBQXNCLE1BQU0sVUFBVTtBQUN2QyxpQkFBTyxRQUFRLEtBQUssT0FBTztBQUMvQixjQUFNLFdBQVcsQ0FBQyxHQUFHLHlCQUF5QixTQUFTLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQyxVQUFVLFFBQVEsS0FBSyxRQUFRLEtBQUssQ0FBQztBQUM5RyxlQUFPLFFBQVEsS0FBSyxNQUFNLFFBQVE7QUFBQSxNQUN0QztBQUNBLE1BQUFBLHlCQUF3QixVQUFVO0FBQUEsSUFDdEMsR0FBRyw0QkFBNEIsUUFBUSwwQkFBMEIsMEJBQTBCLENBQUMsRUFBRTtBQUk5RixRQUFNLDZCQUFOLGNBQXlDLE1BQU07QUFBQSxNQUMzQyxZQUFZLFNBQVM7QUFDakIsY0FBTSxPQUFPO0FBQUEsTUFDakI7QUFBQSxJQUNKO0FBQ0EsWUFBUSw2QkFBNkI7QUFDckMsUUFBSTtBQUNKLEtBQUMsU0FBVUMsd0JBQXVCO0FBQzlCLGVBQVMsYUFBYSxTQUFTLE9BQU8sTUFBTTtBQUN4QyxlQUFPLFFBQVEsS0FBSyxNQUFNLFFBQVEsUUFBUSxXQUFXLFFBQVEsQ0FBQyxNQUFNO0FBQUEsTUFDeEU7QUFDQSxlQUFTLFlBQVksU0FBUyxPQUFPO0FBQ2pDLGVBQU8sYUFBYSxTQUFTLE9BQU8sR0FBRztBQUFBLE1BQzNDO0FBQ0EsZUFBUyxhQUFhLFNBQVMsT0FBTztBQUNsQyxlQUFPLGFBQWEsU0FBUyxPQUFPLEdBQUc7QUFBQSxNQUMzQztBQUNBLGVBQVMsWUFBWSxTQUFTLE9BQU87QUFDakMsZUFBTyxhQUFhLFNBQVMsT0FBTyxHQUFHO0FBQUEsTUFDM0M7QUFDQSxlQUFTLFFBQVEsU0FBUztBQUN0QixZQUFJLEVBQUUsWUFBWSxTQUFTLENBQUMsS0FBSyxhQUFhLFNBQVMsUUFBUSxTQUFTLENBQUM7QUFDckUsaUJBQU87QUFDWCxZQUFJLFFBQVE7QUFDWixpQkFBUyxRQUFRLEdBQUcsUUFBUSxRQUFRLFFBQVEsU0FBUztBQUNqRCxjQUFJLFlBQVksU0FBUyxLQUFLO0FBQzFCLHFCQUFTO0FBQ2IsY0FBSSxhQUFhLFNBQVMsS0FBSztBQUMzQixxQkFBUztBQUNiLGNBQUksVUFBVSxLQUFLLFVBQVUsUUFBUSxTQUFTO0FBQzFDLG1CQUFPO0FBQUEsUUFDZjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQ0EsZUFBUyxRQUFRLFNBQVM7QUFDdEIsZUFBTyxRQUFRLE1BQU0sR0FBRyxRQUFRLFNBQVMsQ0FBQztBQUFBLE1BQzlDO0FBQ0EsZUFBUyxlQUFlLFNBQVM7QUFDN0IsWUFBSSxRQUFRO0FBQ1osaUJBQVMsUUFBUSxHQUFHLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDakQsY0FBSSxZQUFZLFNBQVMsS0FBSztBQUMxQixxQkFBUztBQUNiLGNBQUksYUFBYSxTQUFTLEtBQUs7QUFDM0IscUJBQVM7QUFDYixjQUFJLFlBQVksU0FBUyxLQUFLLEtBQUssVUFBVTtBQUN6QyxtQkFBTztBQUFBLFFBQ2Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUNBLGVBQVMsZ0JBQWdCLFNBQVM7QUFDOUIsaUJBQVMsUUFBUSxHQUFHLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDakQsY0FBSSxZQUFZLFNBQVMsS0FBSztBQUMxQixtQkFBTztBQUFBLFFBQ2Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUNBLGVBQVMsR0FBRyxTQUFTO0FBQ2pCLFlBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUMxQixjQUFNLGNBQWMsQ0FBQztBQUNyQixpQkFBUyxRQUFRLEdBQUcsUUFBUSxRQUFRLFFBQVEsU0FBUztBQUNqRCxjQUFJLFlBQVksU0FBUyxLQUFLO0FBQzFCLHFCQUFTO0FBQ2IsY0FBSSxhQUFhLFNBQVMsS0FBSztBQUMzQixxQkFBUztBQUNiLGNBQUksWUFBWSxTQUFTLEtBQUssS0FBSyxVQUFVLEdBQUc7QUFDNUMsa0JBQU1DLFNBQVEsUUFBUSxNQUFNLE9BQU8sS0FBSztBQUN4QyxnQkFBSUEsT0FBTSxTQUFTO0FBQ2YsMEJBQVksS0FBSyxNQUFNQSxNQUFLLENBQUM7QUFDakMsb0JBQVEsUUFBUTtBQUFBLFVBQ3BCO0FBQUEsUUFDSjtBQUNBLGNBQU0sUUFBUSxRQUFRLE1BQU0sS0FBSztBQUNqQyxZQUFJLE1BQU0sU0FBUztBQUNmLHNCQUFZLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDakMsWUFBSSxZQUFZLFdBQVc7QUFDdkIsaUJBQU8sRUFBRSxNQUFNLFNBQVMsT0FBTyxHQUFHO0FBQ3RDLFlBQUksWUFBWSxXQUFXO0FBQ3ZCLGlCQUFPLFlBQVksQ0FBQztBQUN4QixlQUFPLEVBQUUsTUFBTSxNQUFNLE1BQU0sWUFBWTtBQUFBLE1BQzNDO0FBQ0EsZUFBUyxJQUFJLFNBQVM7QUFDbEIsaUJBQVMsTUFBTSxPQUFPLE9BQU87QUFDekIsY0FBSSxDQUFDLFlBQVksT0FBTyxLQUFLO0FBQ3pCLGtCQUFNLElBQUksMkJBQTJCLHdEQUF3RDtBQUNqRyxjQUFJLFFBQVE7QUFDWixtQkFBUyxPQUFPLE9BQU8sT0FBTyxNQUFNLFFBQVEsUUFBUTtBQUNoRCxnQkFBSSxZQUFZLE9BQU8sSUFBSTtBQUN2Qix1QkFBUztBQUNiLGdCQUFJLGFBQWEsT0FBTyxJQUFJO0FBQ3hCLHVCQUFTO0FBQ2IsZ0JBQUksVUFBVTtBQUNWLHFCQUFPLENBQUMsT0FBTyxJQUFJO0FBQUEsVUFDM0I7QUFDQSxnQkFBTSxJQUFJLDJCQUEyQiw0REFBNEQ7QUFBQSxRQUNyRztBQUNBLGlCQUFTLE1BQU1DLFVBQVMsT0FBTztBQUMzQixtQkFBUyxPQUFPLE9BQU8sT0FBT0EsU0FBUSxRQUFRLFFBQVE7QUFDbEQsZ0JBQUksWUFBWUEsVUFBUyxJQUFJO0FBQ3pCLHFCQUFPLENBQUMsT0FBTyxJQUFJO0FBQUEsVUFDM0I7QUFDQSxpQkFBTyxDQUFDLE9BQU9BLFNBQVEsTUFBTTtBQUFBLFFBQ2pDO0FBQ0EsY0FBTSxjQUFjLENBQUM7QUFDckIsaUJBQVMsUUFBUSxHQUFHLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDakQsY0FBSSxZQUFZLFNBQVMsS0FBSyxHQUFHO0FBQzdCLGtCQUFNLENBQUMsT0FBTyxHQUFHLElBQUksTUFBTSxTQUFTLEtBQUs7QUFDekMsa0JBQU0sUUFBUSxRQUFRLE1BQU0sT0FBTyxNQUFNLENBQUM7QUFDMUMsd0JBQVksS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM3QixvQkFBUTtBQUFBLFVBQ1osT0FDSztBQUNELGtCQUFNLENBQUMsT0FBTyxHQUFHLElBQUksTUFBTSxTQUFTLEtBQUs7QUFDekMsa0JBQU0sUUFBUSxRQUFRLE1BQU0sT0FBTyxHQUFHO0FBQ3RDLGdCQUFJLE1BQU0sU0FBUztBQUNmLDBCQUFZLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDakMsb0JBQVEsTUFBTTtBQUFBLFVBQ2xCO0FBQUEsUUFDSjtBQUNBLFlBQUksWUFBWSxXQUFXO0FBQ3ZCLGlCQUFPLEVBQUUsTUFBTSxTQUFTLE9BQU8sR0FBRztBQUN0QyxZQUFJLFlBQVksV0FBVztBQUN2QixpQkFBTyxZQUFZLENBQUM7QUFDeEIsZUFBTyxFQUFFLE1BQU0sT0FBTyxNQUFNLFlBQVk7QUFBQSxNQUM1QztBQUVBLGVBQVMsTUFBTSxTQUFTO0FBQ3BCLFlBQUksUUFBUSxPQUFPO0FBQ2YsaUJBQU8sTUFBTSxRQUFRLE9BQU8sQ0FBQztBQUNqQyxZQUFJLGVBQWUsT0FBTztBQUN0QixpQkFBTyxHQUFHLE9BQU87QUFDckIsWUFBSSxnQkFBZ0IsT0FBTztBQUN2QixpQkFBTyxJQUFJLE9BQU87QUFDdEIsZUFBTyxFQUFFLE1BQU0sU0FBUyxPQUFPLFFBQVE7QUFBQSxNQUMzQztBQUNBLE1BQUFGLHVCQUFzQixRQUFRO0FBRTlCLGVBQVMsV0FBVyxTQUFTO0FBQ3pCLGVBQU8sTUFBTSxRQUFRLE1BQU0sR0FBRyxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsTUFDckQ7QUFDQSxNQUFBQSx1QkFBc0IsYUFBYTtBQUFBLElBQ3ZDLEdBQUcsMEJBQTBCLFFBQVEsd0JBQXdCLHdCQUF3QixDQUFDLEVBQUU7QUFJeEYsUUFBSTtBQUNKLEtBQUMsU0FBVUcsd0JBQXVCO0FBQzlCLGVBQVMsU0FBUyxZQUFZO0FBRTFCLGVBQVEsV0FBVyxTQUFTLFFBQ3hCLFdBQVcsS0FBSyxXQUFXLEtBQzNCLFdBQVcsS0FBSyxDQUFDLEVBQUUsU0FBUyxXQUM1QixXQUFXLEtBQUssQ0FBQyxFQUFFLFVBQVUsT0FDN0IsV0FBVyxLQUFLLENBQUMsRUFBRSxTQUFTLFdBQzVCLFdBQVcsS0FBSyxDQUFDLEVBQUUsVUFBVTtBQUFBLE1BQ3JDO0FBQ0EsZUFBUyxVQUFVLFlBQVk7QUFFM0IsZUFBUSxXQUFXLFNBQVMsUUFDeEIsV0FBVyxLQUFLLFdBQVcsS0FDM0IsV0FBVyxLQUFLLENBQUMsRUFBRSxTQUFTLFdBQzVCLFdBQVcsS0FBSyxDQUFDLEVBQUUsVUFBVSxVQUM3QixXQUFXLEtBQUssQ0FBQyxFQUFFLFNBQVMsV0FDNUIsV0FBVyxLQUFLLENBQUMsRUFBRSxVQUFVO0FBQUEsTUFDckM7QUFDQSxlQUFTLFNBQVMsWUFBWTtBQUMxQixlQUFPLFdBQVcsU0FBUyxXQUFXLFdBQVcsVUFBVTtBQUFBLE1BQy9EO0FBQ0EsZUFBUyxNQUFNLFlBQVk7QUFDdkIsWUFBSSxVQUFVLFVBQVU7QUFDcEIsaUJBQU87QUFDWCxZQUFJLFNBQVMsVUFBVSxLQUFLLFNBQVMsVUFBVTtBQUMzQyxpQkFBTztBQUNYLFlBQUksV0FBVyxTQUFTO0FBQ3BCLGlCQUFPLFdBQVcsS0FBSyxNQUFNLENBQUMsU0FBUyxNQUFNLElBQUksQ0FBQztBQUN0RCxZQUFJLFdBQVcsU0FBUztBQUNwQixpQkFBTyxXQUFXLEtBQUssTUFBTSxDQUFDLFNBQVMsTUFBTSxJQUFJLENBQUM7QUFDdEQsWUFBSSxXQUFXLFNBQVM7QUFDcEIsaUJBQU87QUFDWCxjQUFNLE1BQU0sZ0RBQWdEO0FBQUEsTUFDaEU7QUFDQSxNQUFBQSx1QkFBc0IsUUFBUTtBQUFBLElBQ2xDLEdBQUcsMEJBQTBCLFFBQVEsd0JBQXdCLHdCQUF3QixDQUFDLEVBQUU7QUFJeEYsUUFBSTtBQUNKLEtBQUMsU0FBVUMsMkJBQTBCO0FBQ2pDLGdCQUFVLE9BQU8sUUFBUTtBQUNyQixZQUFJLE9BQU8sV0FBVztBQUNsQixpQkFBTyxPQUFPLE9BQU8sQ0FBQztBQUMxQixtQkFBVyxRQUFRLE9BQU8sQ0FBQyxHQUFHO0FBQzFCLHFCQUFXLFNBQVMsT0FBTyxPQUFPLE1BQU0sQ0FBQyxDQUFDLEdBQUc7QUFDekMsa0JBQU0sR0FBRyxPQUFPO0FBQUEsVUFDcEI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUNBLGdCQUFVLElBQUksWUFBWTtBQUN0QixlQUFPLE9BQU8sT0FBTyxXQUFXLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUFBLE1BQzNFO0FBQ0EsZ0JBQVUsR0FBRyxZQUFZO0FBQ3JCLG1CQUFXLFFBQVEsV0FBVztBQUMxQixpQkFBTyxTQUFTLElBQUk7QUFBQSxNQUM1QjtBQUNBLGdCQUFVLE1BQU0sWUFBWTtBQUN4QixlQUFPLE1BQU0sV0FBVztBQUFBLE1BQzVCO0FBQ0EsZ0JBQVUsU0FBUyxZQUFZO0FBQzNCLFlBQUksV0FBVyxTQUFTO0FBQ3BCLGlCQUFPLE9BQU8sSUFBSSxVQUFVO0FBQ2hDLFlBQUksV0FBVyxTQUFTO0FBQ3BCLGlCQUFPLE9BQU8sR0FBRyxVQUFVO0FBQy9CLFlBQUksV0FBVyxTQUFTO0FBQ3BCLGlCQUFPLE9BQU8sTUFBTSxVQUFVO0FBQ2xDLGNBQU0sTUFBTSw4Q0FBOEM7QUFBQSxNQUM5RDtBQUNBLE1BQUFBLDBCQUF5QixXQUFXO0FBQUEsSUFDeEMsR0FBRyw2QkFBNkIsUUFBUSwyQkFBMkIsMkJBQTJCLENBQUMsRUFBRTtBQUlqRyxRQUFJO0FBQ0osS0FBQyxTQUFVQywyQkFBMEI7QUFDakMsZ0JBQVUsV0FBVyxVQUFVO0FBQzNCLGNBQU0sT0FBTyxTQUFTLEtBQUssRUFBRSxRQUFRLFFBQVEsRUFBRTtBQUMvQyxZQUFJLFNBQVM7QUFDVCxpQkFBTyxNQUFNLFFBQVEsS0FBSyxRQUFRO0FBQ3RDLFlBQUksU0FBUztBQUNULGlCQUFPLE1BQU0sUUFBUSxLQUFLLE9BQU87QUFDckMsWUFBSSxTQUFTO0FBQ1QsaUJBQU8sTUFBTSxRQUFRLEtBQUssT0FBTztBQUNyQyxZQUFJLFNBQVM7QUFDVCxpQkFBTyxNQUFNLFFBQVEsS0FBSyxPQUFPO0FBQ3JDLGNBQU0sV0FBVyxLQUFLLE1BQU0sR0FBRyxFQUFFLElBQUksQ0FBQyxZQUFZLFFBQVEsS0FBSyxRQUFRLFFBQVEsS0FBSyxDQUFDLENBQUM7QUFDdEYsZUFBTyxNQUFNLFNBQVMsV0FBVyxJQUFJLFFBQVEsS0FBSyxNQUFNLElBQUksU0FBUyxXQUFXLElBQUksU0FBUyxDQUFDLElBQUksUUFBUSxLQUFLLE1BQU0sUUFBUTtBQUFBLE1BQ2pJO0FBQ0EsZ0JBQVUsY0FBYyxVQUFVO0FBQzlCLFlBQUksU0FBUyxDQUFDLE1BQU0sS0FBSztBQUNyQixnQkFBTSxJQUFJLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDbEMsZ0JBQU0sSUFBSSxhQUFhLFNBQVMsTUFBTSxDQUFDLENBQUM7QUFDeEMsaUJBQU8sT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQUEsUUFDMUI7QUFDQSxpQkFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSztBQUN0QyxjQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUs7QUFDckIsa0JBQU0sSUFBSSxXQUFXLFNBQVMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN6QyxrQkFBTSxJQUFJLGFBQWEsU0FBUyxNQUFNLElBQUksQ0FBQyxDQUFDO0FBQzVDLG1CQUFPLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQUEsVUFDN0I7QUFBQSxRQUNKO0FBQ0EsY0FBTSxRQUFRLEtBQUssUUFBUSxRQUFRO0FBQUEsTUFDdkM7QUFDQSxnQkFBVSxhQUFhLFVBQVU7QUFDN0IsaUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDdEMsY0FBSSxTQUFTLENBQUMsTUFBTSxLQUFLO0FBQ3JCLGtCQUFNLElBQUksUUFBUSxLQUFLLFFBQVEsU0FBUyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ25ELGtCQUFNLElBQUksY0FBYyxTQUFTLE1BQU0sQ0FBQyxDQUFDO0FBQ3pDLG1CQUFPLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLFVBQzFCO0FBQUEsUUFDSjtBQUNBLGNBQU0sUUFBUSxLQUFLLFFBQVEsUUFBUTtBQUFBLE1BQ3ZDO0FBQ0EsZUFBUyxNQUFNLGNBQWM7QUFDekIsZUFBTyxDQUFDLEdBQUcsYUFBYSxZQUFZLENBQUM7QUFBQSxNQUN6QztBQUNBLE1BQUFBLDBCQUF5QixRQUFRO0FBQUEsSUFDckMsR0FBRyw2QkFBNkIsUUFBUSwyQkFBMkIsMkJBQTJCLENBQUMsRUFBRTtBQUlqRyxRQUFJLGNBQWM7QUFJbEIsUUFBTSxjQUFOLE1BQWtCO0FBQUE7QUFBQSxNQUVkLE9BQU8sUUFBUTtBQUNYLGVBQU87QUFBQSxNQUNYO0FBQUE7QUFBQSxNQUVBLE9BQU8sUUFBUTtBQUNYLGVBQU8sS0FBSyxNQUFNLEtBQUssVUFBVSxNQUFNLENBQUM7QUFBQSxNQUM1QztBQUFBLElBQ0o7QUFDQSxZQUFRLGNBQWM7QUFJdEIsUUFBTSxzQkFBTixjQUFrQyxZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUsxQyxTQUFTLFFBQVE7QUFDYixlQUFPLEVBQUUsQ0FBQyxRQUFRLFFBQVEsR0FBRyxZQUFZLEdBQUcsVUFBVSxNQUFNLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFBQSxNQUM1RTtBQUFBO0FBQUEsTUFFQSxpQkFBaUIsUUFBUTtBQUNyQixlQUFPLEVBQUUsQ0FBQyxRQUFRLFFBQVEsR0FBRyxvQkFBb0IsR0FBRyxVQUFVLE1BQU0sUUFBUSxDQUFDLENBQUMsRUFBRTtBQUFBLE1BQ3BGO0FBQUE7QUFBQSxNQUVBLFNBQVMsUUFBUTtBQUNiLGVBQU8sRUFBRSxDQUFDLFFBQVEsUUFBUSxHQUFHLFlBQVksR0FBRyxPQUFPO0FBQUEsTUFDdkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsSUFBSSxVQUFVLENBQUMsR0FBRztBQUNkLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsTUFBTSxDQUFDO0FBQUEsTUFDNUQ7QUFBQTtBQUFBLE1BRUEsTUFBTSxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQ3ZCLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsU0FBUyxNQUFNLFNBQVMsT0FBTyxVQUFVLE1BQU0sT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQUEsTUFDaEg7QUFBQTtBQUFBLE1BRUEsUUFBUSxVQUFVLENBQUMsR0FBRztBQUNsQixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFdBQVcsTUFBTSxVQUFVLENBQUM7QUFBQSxNQUNqRjtBQUFBO0FBQUEsTUFFQSxVQUFVLFNBQVMsU0FBUztBQUN4QixjQUFNLFlBQVksUUFBUSxLQUFLLFVBQVUsU0FBUyxDQUFDLENBQUM7QUFDcEQsY0FBTSxPQUFPLFlBQVksWUFBWSxXQUFXLEVBQUUsaUJBQWlCLE1BQU0sQ0FBQztBQUMxRSxjQUFNLGFBQWEsS0FBSyxPQUFPLENBQUMsS0FBSyxTQUFTLEVBQUUsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLFFBQVEsS0FBSyxNQUFNLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxRyxlQUFPLFFBQVEsS0FBSyxPQUFPLFlBQVksT0FBTztBQUFBLE1BQ2xEO0FBQUE7QUFBQSxNQUVBLEtBQUssTUFBTSxVQUFVLENBQUMsR0FBRztBQUVyQixjQUFNLFNBQVMsV0FBVyxPQUFPLEtBQUssSUFBSSxFQUFFLE9BQU8sQ0FBQyxRQUFRLE1BQU0sR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsS0FBSyxHQUFHLENBQUM7QUFDOUYsY0FBTSxRQUFRLE9BQU8sSUFBSSxDQUFDLFVBQVcsT0FBTyxVQUFVLFdBQVcsRUFBRSxDQUFDLFFBQVEsSUFBSSxHQUFHLFdBQVcsTUFBTSxVQUFVLE9BQU8sTUFBTSxJQUFJLEVBQUUsQ0FBQyxRQUFRLElBQUksR0FBRyxXQUFXLE1BQU0sVUFBVSxPQUFPLE1BQU0sQ0FBRTtBQUMzTCxlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFNBQVMsTUFBTSxDQUFDO0FBQUEsTUFDckU7QUFBQTtBQUFBLE1BRUEsUUFBUSxNQUFNLE9BQU8sVUFBVSxXQUFXLFVBQVUsQ0FBQyxHQUFHO0FBQ3BELGdCQUFRLFlBQVksUUFBUSxNQUFNLEtBQUssR0FBRztBQUFBLFVBQ3RDLEtBQUssa0JBQWtCO0FBQ25CLG1CQUFPLEtBQUssTUFBTSxDQUFDLFVBQVUsTUFBTSxVQUFVLE9BQU8sR0FBRyxVQUFVLE1BQU0sV0FBVyxPQUFPLENBQUMsQ0FBQztBQUFBLFVBQy9GLEtBQUssa0JBQWtCO0FBQ25CLG1CQUFPLFVBQVUsTUFBTSxVQUFVLE9BQU87QUFBQSxVQUM1QyxLQUFLLGtCQUFrQjtBQUNuQixtQkFBTyxVQUFVLE1BQU0sV0FBVyxPQUFPO0FBQUEsUUFDakQ7QUFBQSxNQUNKO0FBQUE7QUFBQSxNQUVBLFFBQVEsTUFBTSxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQy9CLFlBQUksVUFBVSxpQkFBaUIsSUFBSTtBQUMvQixpQkFBTyxLQUFLLFFBQVEsd0JBQXdCLFFBQVEsSUFBSSxHQUFHLE9BQU8sT0FBTztBQUM3RSxZQUFJLFVBQVUsaUJBQWlCLEtBQUs7QUFDaEMsaUJBQU8sS0FBSyxRQUFRLE1BQU0sd0JBQXdCLFFBQVEsS0FBSyxHQUFHLE9BQU87QUFDN0UsWUFBSSxVQUFVLE9BQU8sSUFBSSxHQUFHO0FBQ3hCLGdCQUFNLFdBQVcsS0FBSyxNQUFNLE9BQU8sQ0FBQyxVQUFVLFlBQVksUUFBUSxPQUFPLEtBQUssTUFBTSxrQkFBa0IsS0FBSztBQUMzRyxpQkFBUSxTQUFTLFdBQVcsSUFBSSxVQUFVLE1BQU0sU0FBUyxDQUFDLEdBQUcsT0FBTyxJQUFJLEtBQUssTUFBTSxVQUFVLE9BQU87QUFBQSxRQUN4RyxPQUNLO0FBQ0QsaUJBQVEsWUFBWSxRQUFRLE1BQU0sS0FBSyxNQUFNLGtCQUFrQixRQUFRLEtBQUssTUFBTSxPQUFPLElBQUksVUFBVSxNQUFNLE1BQU0sT0FBTztBQUFBLFFBQzlIO0FBQUEsTUFDSjtBQUFBO0FBQUEsTUFFQSxRQUFRLE1BQU0sT0FBTyxVQUFVLENBQUMsR0FBRztBQUMvQixZQUFJLFVBQVUsaUJBQWlCLElBQUk7QUFDL0IsaUJBQU8sS0FBSyxRQUFRLHdCQUF3QixRQUFRLElBQUksR0FBRyxPQUFPLE9BQU87QUFDN0UsWUFBSSxVQUFVLGlCQUFpQixLQUFLO0FBQ2hDLGlCQUFPLEtBQUssUUFBUSxNQUFNLHdCQUF3QixRQUFRLEtBQUssR0FBRyxPQUFPO0FBQzdFLFlBQUksVUFBVSxPQUFPLElBQUksR0FBRztBQUN4QixnQkFBTSxXQUFXLEtBQUssTUFBTSxPQUFPLENBQUMsVUFBVSxZQUFZLFFBQVEsT0FBTyxLQUFLLE1BQU0sa0JBQWtCLEtBQUs7QUFDM0csaUJBQVEsU0FBUyxXQUFXLElBQUksVUFBVSxNQUFNLFNBQVMsQ0FBQyxHQUFHLE9BQU8sSUFBSSxLQUFLLE1BQU0sVUFBVSxPQUFPO0FBQUEsUUFDeEcsT0FDSztBQUNELGlCQUFRLFlBQVksUUFBUSxNQUFNLEtBQUssTUFBTSxrQkFBa0IsUUFBUSxVQUFVLE1BQU0sTUFBTSxPQUFPLElBQUksS0FBSyxNQUFNLE9BQU87QUFBQSxRQUM5SDtBQUFBLE1BQ0o7QUFBQTtBQUFBLE1BRUEsTUFBTSxRQUFRLFlBQVksVUFBVSxDQUFDLEdBQUc7QUFDcEMsWUFBSSxVQUFVLE9BQU8sTUFBTSxLQUFLLFVBQVUsUUFBUSxVQUFVLEdBQUc7QUFDM0QsaUJBQU8sVUFBVSxNQUFNLE9BQU8sT0FBTyxPQUFPO0FBQUEsUUFDaEQsV0FDUyxVQUFVLE9BQU8sTUFBTSxLQUFLLFVBQVUsUUFBUSxVQUFVLEdBQUc7QUFDaEUsZ0JBQU0sUUFBUSxPQUFPLFVBQVUsU0FBWSxDQUFDLElBQUksT0FBTztBQUN2RCxnQkFBTSxTQUFTLE1BQU0sSUFBSSxDQUFDN0IsWUFBVyxVQUFVLE1BQU1BLFNBQVEsQ0FBQyxDQUFDLENBQUM7QUFDaEUsaUJBQU8sS0FBSyxNQUFNLFFBQVEsT0FBTztBQUFBLFFBQ3JDLE9BQ0s7QUFDRCxnQkFBTSxPQUFPLGlCQUFpQixRQUFRLFVBQVU7QUFDaEQsZ0JBQU0sUUFBUSxVQUFVLE1BQU0sUUFBUSxDQUFDLENBQUM7QUFDeEMsaUJBQU8sZ0JBQWdCLFFBQVEsT0FBTyxNQUFNLE9BQU87QUFBQSxRQUN2RDtBQUFBLE1BQ0o7QUFBQTtBQUFBLE1BRUEsUUFBUSxVQUFVLENBQUMsR0FBRztBQUNsQixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFdBQVcsTUFBTSxVQUFVLENBQUM7QUFBQSxNQUNqRjtBQUFBLE1BQ0EsVUFBVSxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQzNCLFlBQUksTUFBTSxXQUFXO0FBQ2pCLGlCQUFPLFFBQVEsS0FBSyxNQUFNO0FBQzlCLFlBQUksTUFBTSxXQUFXO0FBQ2pCLGlCQUFPLFVBQVUsTUFBTSxNQUFNLENBQUMsR0FBRyxPQUFPO0FBQzVDLGNBQU0sVUFBVSxNQUFNLE1BQU0sQ0FBQyxXQUFXLFVBQVUsUUFBUSxNQUFNLENBQUM7QUFDakUsY0FBTSxTQUFTLE1BQU0sSUFBSSxDQUFDLFdBQVcsVUFBVSxNQUFNLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDaEUsY0FBTSw4QkFBOEIsVUFBVSxRQUFRLFFBQVEscUJBQXFCLElBQUksRUFBRSx1QkFBdUIsVUFBVSxNQUFNLFFBQVEsdUJBQXVCLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQztBQUN4SyxZQUFJLFFBQVEsMEJBQTBCLFNBQVMsVUFBVSxRQUFRLFFBQVEscUJBQXFCLEtBQUssU0FBUztBQUN4RyxpQkFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsR0FBRyw2QkFBNkIsQ0FBQyxRQUFRLElBQUksR0FBRyxhQUFhLE1BQU0sVUFBVSxPQUFPLE9BQU8sQ0FBQztBQUFBLFFBQ2pJLE9BQ0s7QUFDRCxpQkFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsR0FBRyw2QkFBNkIsQ0FBQyxRQUFRLElBQUksR0FBRyxhQUFhLE9BQU8sT0FBTyxDQUFDO0FBQUEsUUFDakg7QUFBQSxNQUNKO0FBQUE7QUFBQSxNQUVBLE1BQU0sUUFBUSxVQUFVLENBQUMsR0FBRztBQUN4QixZQUFJLFVBQVUsUUFBUSxNQUFNLEdBQUc7QUFDM0IsZ0JBQU0sVUFBVSxPQUFPLG9CQUFvQixPQUFPLGlCQUFpQixFQUFFLENBQUM7QUFDdEUsY0FBSSxZQUFZLFFBQVE7QUFDcEIsbUJBQU8sS0FBSyxPQUFPLE9BQU87QUFDOUIsY0FBSSxZQUFZLFFBQVE7QUFDcEIsbUJBQU8sS0FBSyxPQUFPLE9BQU87QUFDOUIsZ0JBQU0sTUFBTSx5RUFBeUU7QUFBQSxRQUN6RixXQUNTLFVBQVUsT0FBTyxNQUFNLEdBQUc7QUFDL0IsZ0JBQU0sUUFBUSxPQUFPLFVBQVUsU0FBWSxDQUFDLElBQUksT0FBTztBQUN2RCxnQkFBTSxXQUFXLE1BQU0sSUFBSSxDQUFDLEdBQUcsVUFBVSxRQUFRLEtBQUssUUFBUSxLQUFLLENBQUM7QUFDcEUsaUJBQU8sS0FBSyxNQUFNLFVBQVUsT0FBTztBQUFBLFFBQ3ZDLFdBQ1MsVUFBVSxPQUFPLE1BQU0sR0FBRztBQUMvQixpQkFBTyxLQUFLLE9BQU8sT0FBTztBQUFBLFFBQzlCLE9BQ0s7QUFDRCxnQkFBTSxPQUFPLFlBQVksWUFBWSxRQUFRLEVBQUUsaUJBQWlCLE1BQU0sQ0FBQztBQUN2RSxjQUFJLEtBQUssV0FBVztBQUNoQixtQkFBTyxLQUFLLE1BQU0sT0FBTztBQUM3QixnQkFBTSxXQUFXLEtBQUssSUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEdBQUcsQ0FBQztBQUNwRCxpQkFBTyxLQUFLLE1BQU0sVUFBVSxPQUFPO0FBQUEsUUFDdkM7QUFBQSxNQUNKO0FBQUE7QUFBQSxNQUVBLFFBQVEsT0FBTyxVQUFVLENBQUMsR0FBRztBQUN6QixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFdBQVcsT0FBTyxPQUFPLE1BQU0sT0FBTyxNQUFNLENBQUM7QUFBQSxNQUNsRztBQUFBO0FBQUEsTUFFQSxNQUFNLFVBQVUsQ0FBQyxHQUFHO0FBQ2hCLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsU0FBUyxLQUFLLENBQUMsRUFBRSxDQUFDO0FBQUEsTUFDdkU7QUFBQTtBQUFBLE1BRUEsSUFBSSxLQUFLLFNBQVM7QUFDZCxlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLE9BQU8sSUFBSSxDQUFDO0FBQUEsTUFDakU7QUFBQTtBQUFBLE1BRUEsS0FBSyxVQUFVLENBQUMsR0FBRztBQUNmLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsUUFBUSxNQUFNLE9BQU8sQ0FBQztBQUFBLE1BQzNFO0FBQUE7QUFBQSxNQUVBLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFDakIsZUFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxVQUFVLE1BQU0sU0FBUyxDQUFDO0FBQUEsTUFDL0U7QUFBQTtBQUFBLE1BRUEsT0FBTyxZQUFZLFVBQVUsQ0FBQyxHQUFHO0FBQzdCLGNBQU0sZUFBZSxXQUFXLE9BQU8sb0JBQW9CLFVBQVU7QUFDckUsY0FBTSxlQUFlLGFBQWEsT0FBTyxDQUFDLFFBQVEsVUFBVSxVQUFVLFdBQVcsR0FBRyxDQUFDLEtBQUssVUFBVSxrQkFBa0IsV0FBVyxHQUFHLENBQUMsQ0FBQztBQUN0SSxjQUFNLGVBQWUsYUFBYSxPQUFPLENBQUMsU0FBUyxDQUFDLGFBQWEsU0FBUyxJQUFJLENBQUM7QUFDL0UsY0FBTSw2QkFBNkIsVUFBVSxRQUFRLFFBQVEsb0JBQW9CLElBQUksRUFBRSxzQkFBc0IsVUFBVSxNQUFNLFFBQVEsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQztBQUNwSyxjQUFNLG1CQUFtQixhQUFhLE9BQU8sQ0FBQyxLQUFLLFNBQVMsRUFBRSxHQUFHLEtBQUssQ0FBQyxHQUFHLEdBQUcsVUFBVSxNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hILFlBQUksYUFBYSxTQUFTLEdBQUc7QUFDekIsaUJBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLEdBQUcsNEJBQTRCLENBQUMsUUFBUSxJQUFJLEdBQUcsVUFBVSxNQUFNLFVBQVUsWUFBWSxrQkFBa0IsVUFBVSxhQUFhLENBQUM7QUFBQSxRQUNwSyxPQUNLO0FBQ0QsaUJBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLEdBQUcsNEJBQTRCLENBQUMsUUFBUSxJQUFJLEdBQUcsVUFBVSxNQUFNLFVBQVUsWUFBWSxpQkFBaUIsQ0FBQztBQUFBLFFBQzVJO0FBQUEsTUFDSjtBQUFBLE1BQ0EsS0FBSyxRQUFRLFlBQVksVUFBVSxDQUFDLEdBQUc7QUFDbkMsY0FBTSxPQUFPLGlCQUFpQixRQUFRLFVBQVU7QUFFaEQsZUFBTyxVQUFVLElBQUksVUFBVSxNQUFNLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQ0EsWUFBVztBQUMxRCxjQUFJQSxRQUFPLFVBQVU7QUFDakIsWUFBQUEsUUFBTyxXQUFXQSxRQUFPLFNBQVMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLFNBQVMsR0FBRyxDQUFDO0FBQ3JFLGdCQUFJQSxRQUFPLFNBQVMsV0FBVztBQUMzQixxQkFBT0EsUUFBTztBQUFBLFVBQ3RCO0FBQ0EscUJBQVcsT0FBTyxXQUFXLE9BQU8sS0FBS0EsUUFBTyxVQUFVLEdBQUc7QUFDekQsZ0JBQUksS0FBSyxTQUFTLEdBQUc7QUFDakIscUJBQU9BLFFBQU8sV0FBVyxHQUFHO0FBQUEsVUFDcEM7QUFDQSxpQkFBTyxLQUFLLE9BQU9BLE9BQU07QUFBQSxRQUM3QixHQUFHLE9BQU87QUFBQSxNQUNkO0FBQUE7QUFBQSxNQUVBLFFBQVEsUUFBUSxVQUFVLENBQUMsR0FBRztBQUMxQixpQkFBUyxNQUFNQSxTQUFRO0FBRW5CLGtCQUFRQSxRQUFPLFFBQVEsUUFBUSxHQUFHO0FBQUEsWUFDOUIsS0FBSztBQUNELGNBQUFBLFFBQU8sUUFBUSxRQUFRLElBQUk7QUFDM0I7QUFBQSxZQUNKLEtBQUs7QUFDRCxjQUFBQSxRQUFPLFFBQVEsUUFBUSxJQUFJO0FBQzNCO0FBQUEsWUFDSixLQUFLO0FBQ0QsY0FBQUEsUUFBTyxRQUFRLFFBQVEsSUFBSTtBQUMzQjtBQUFBLFlBQ0o7QUFDSSxjQUFBQSxRQUFPLFFBQVEsUUFBUSxJQUFJO0FBQzNCO0FBQUEsVUFDUjtBQUFBLFFBQ0o7QUFFQSxlQUFPLFVBQVUsSUFBSSxVQUFVLE1BQU0sUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDQSxZQUFXO0FBQzFELGlCQUFPQSxRQUFPO0FBQ2QscUJBQVcsT0FBTyxLQUFLQSxRQUFPLFVBQVUsRUFBRSxRQUFRLFNBQU8sTUFBTUEsUUFBTyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3RGLGlCQUFPQTtBQUFBLFFBQ1gsR0FBRyxPQUFPO0FBQUEsTUFDZDtBQUFBLE1BQ0EsS0FBSyxRQUFRLFlBQVksVUFBVSxDQUFDLEdBQUc7QUFDbkMsY0FBTSxPQUFPLGlCQUFpQixRQUFRLFVBQVU7QUFFaEQsZUFBTyxVQUFVLElBQUksVUFBVSxNQUFNLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQ0EsWUFBVztBQUMxRCxjQUFJQSxRQUFPLFVBQVU7QUFDakIsWUFBQUEsUUFBTyxXQUFXQSxRQUFPLFNBQVMsT0FBTyxDQUFDLFFBQVEsS0FBSyxTQUFTLEdBQUcsQ0FBQztBQUNwRSxnQkFBSUEsUUFBTyxTQUFTLFdBQVc7QUFDM0IscUJBQU9BLFFBQU87QUFBQSxVQUN0QjtBQUNBLHFCQUFXLE9BQU8sV0FBVyxPQUFPLEtBQUtBLFFBQU8sVUFBVSxHQUFHO0FBQ3pELGdCQUFJLENBQUMsS0FBSyxTQUFTLEdBQUc7QUFDbEIscUJBQU9BLFFBQU8sV0FBVyxHQUFHO0FBQUEsVUFDcEM7QUFDQSxpQkFBTyxLQUFLLE9BQU9BLE9BQU07QUFBQSxRQUM3QixHQUFHLE9BQU87QUFBQSxNQUNkO0FBQUE7QUFBQSxNQUVBLE9BQU8sS0FBSyxRQUFRLFVBQVUsQ0FBQyxHQUFHO0FBQzlCLFlBQUksVUFBVSxpQkFBaUIsR0FBRyxHQUFHO0FBQ2pDLGdCQUFNLGFBQWEsc0JBQXNCLFdBQVcsSUFBSSxPQUFPO0FBRS9ELGlCQUFPLHNCQUFzQixNQUFNLFVBQVUsSUFDdEMsS0FBSyxPQUFPLENBQUMsR0FBRyx5QkFBeUIsU0FBUyxVQUFVLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSzhCLFVBQVMsRUFBRSxHQUFHLEtBQUssQ0FBQ0EsSUFBRyxHQUFHLFVBQVUsTUFBTSxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsT0FBTyxJQUNuSixLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxVQUFVLE1BQU0sVUFBVSxtQkFBbUIsRUFBRSxDQUFDLElBQUksT0FBTyxHQUFHLFVBQVUsTUFBTSxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUFBLFFBQ2pKLFdBQ1MsVUFBVSxPQUFPLEdBQUcsR0FBRztBQUM1QixnQkFBTSxRQUFRLGNBQWMsUUFBUSxHQUFHO0FBQ3ZDLGNBQUksVUFBVSxjQUFjLEtBQUssR0FBRztBQUNoQyxrQkFBTSxhQUFhLE1BQU0sTUFBTSxPQUFPLENBQUMsS0FBSyxhQUFhLEVBQUUsR0FBRyxLQUFLLENBQUMsUUFBUSxLQUFLLEdBQUcsVUFBVSxNQUFNLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDdEgsbUJBQU8sS0FBSyxPQUFPLFlBQVksRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxTQUFTLENBQUM7QUFBQSxVQUMzRTtBQUVJLGtCQUFNLE1BQU0sa0VBQWtFO0FBQUEsUUFDdEYsV0FDUyxVQUFVLFNBQVMsR0FBRyxHQUFHO0FBQzlCLGNBQUksT0FBTyxJQUFJLFVBQVUsWUFBWSxPQUFPLElBQUksVUFBVSxVQUFVO0FBQ2hFLG1CQUFPLEtBQUssT0FBTyxFQUFFLENBQUMsSUFBSSxLQUFLLEdBQUcsVUFBVSxNQUFNLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxPQUFPO0FBQUEsVUFDNUU7QUFFSSxrQkFBTSxNQUFNLHlFQUF5RTtBQUFBLFFBQzdGLFdBQ1MsVUFBVSxTQUFTLEdBQUcsS0FBSyxVQUFVLFFBQVEsR0FBRyxHQUFHO0FBQ3hELGdCQUFNLFVBQVUsUUFBUTtBQUN4QixpQkFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxVQUFVLE1BQU0sVUFBVSxtQkFBbUIsRUFBRSxDQUFDLE9BQU8sR0FBRyxVQUFVLE1BQU0sUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7QUFBQSxRQUM5SSxXQUNTLFVBQVUsUUFBUSxHQUFHLEdBQUc7QUFDN0IsZ0JBQU0sVUFBVSxJQUFJLFlBQVksU0FBWSxRQUFRLHFCQUFxQixJQUFJO0FBQzdFLGlCQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFVBQVUsTUFBTSxVQUFVLG1CQUFtQixFQUFFLENBQUMsT0FBTyxHQUFHLFVBQVUsTUFBTSxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUFBLFFBQzlJLE9BQ0s7QUFDRCxnQkFBTSxNQUFNLG9EQUFvRDtBQUFBLFFBQ3BFO0FBQUEsTUFDSjtBQUFBO0FBQUEsTUFFQSxVQUFVLFVBQVUsVUFBVSxDQUFDLEdBQUc7QUFDOUIsWUFBSSxRQUFRLFFBQVE7QUFDaEIsa0JBQVEsTUFBTSxJQUFJO0FBQ3RCLGNBQU0sV0FBVyxTQUFTLEVBQUUsQ0FBQyxRQUFRLElBQUksR0FBRyxRQUFRLE1BQU0sR0FBRyxRQUFRLE1BQU0sQ0FBQztBQUM1RSxpQkFBUyxNQUFNLFFBQVE7QUFDdkIsZUFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxhQUFhLEdBQUcsU0FBUyxDQUFDO0FBQUEsTUFDL0U7QUFBQTtBQUFBLE1BRUEsSUFBSSxRQUFRLFVBQVUsQ0FBQyxHQUFHO0FBQ3RCLFlBQUksT0FBTyxRQUFRO0FBQ2YsZ0JBQU0sTUFBTSwwREFBMEQ7QUFDMUUsZUFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxPQUFPLE1BQU0sT0FBTyxJQUFJLENBQUM7QUFBQSxNQUM5RTtBQUFBO0FBQUEsTUFFQSxTQUFTLFFBQVEsVUFBVSxDQUFDLEdBQUc7QUFDM0IsaUJBQVMsTUFBTTlCLFNBQVE7QUFFbkIsa0JBQVFBLFFBQU8sUUFBUSxRQUFRLEdBQUc7QUFBQSxZQUM5QixLQUFLO0FBQ0QsY0FBQUEsUUFBTyxRQUFRLFFBQVEsSUFBSTtBQUMzQjtBQUFBLFlBQ0osS0FBSztBQUNELGNBQUFBLFFBQU8sUUFBUSxRQUFRLElBQUk7QUFDM0I7QUFBQSxZQUNKLEtBQUs7QUFDRCxxQkFBT0EsUUFBTyxRQUFRLFFBQVE7QUFDOUI7QUFBQSxZQUNKO0FBQ0kscUJBQU9BLFFBQU8sUUFBUSxRQUFRO0FBQzlCO0FBQUEsVUFDUjtBQUFBLFFBQ0o7QUFFQSxlQUFPLFVBQVUsSUFBSSxVQUFVLE1BQU0sUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDQSxZQUFXO0FBQzFELFVBQUFBLFFBQU8sV0FBVyxXQUFXLE9BQU8sS0FBS0EsUUFBTyxVQUFVO0FBQzFELHFCQUFXLE9BQU8sS0FBS0EsUUFBTyxVQUFVLEVBQUUsUUFBUSxTQUFPLE1BQU1BLFFBQU8sV0FBVyxHQUFHLENBQUMsQ0FBQztBQUN0RixpQkFBT0E7QUFBQSxRQUNYLEdBQUcsT0FBTztBQUFBLE1BQ2Q7QUFBQTtBQUFBLE1BRUEsS0FBSyxRQUFRO0FBQ1QsWUFBSSxVQUFVLE9BQU8sTUFBTSxHQUFHO0FBQzFCLGNBQUksT0FBTyxVQUFVO0FBQ2pCLG1CQUFPLENBQUM7QUFDWixpQkFBTyxPQUFPLE1BQU0sSUFBSSxDQUFDQSxZQUFXLFVBQVUsTUFBTUEsU0FBUSxDQUFDLENBQUMsQ0FBQztBQUFBLFFBQ25FLE9BQ0s7QUFDRCxpQkFBTyxDQUFDLFVBQVUsTUFBTSxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQUEsUUFDdkM7QUFBQSxNQUNKO0FBQUE7QUFBQSxNQUVBLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFDakIsZUFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxVQUFVLE1BQU0sU0FBUyxDQUFDO0FBQUEsTUFDL0U7QUFBQTtBQUFBLE1BRUEsZ0JBQWdCLFlBQVksVUFBVSxDQUFDLEdBQUc7QUFFdEMsY0FBTSxVQUFXLE9BQU8sZUFBZSxXQUNqQyx1QkFBdUIsT0FBTyx5QkFBeUIsTUFBTSxVQUFVLENBQUMsSUFDeEUsdUJBQXVCLE9BQU8sVUFBVTtBQUM5QyxlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLG1CQUFtQixNQUFNLFVBQVUsUUFBUSxDQUFDO0FBQUEsTUFDakc7QUFBQTtBQUFBLE1BRUEsTUFBTSxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQ3ZCLGNBQU0sQ0FBQyxpQkFBaUIsVUFBVSxRQUFRLElBQUksQ0FBQyxPQUFPLE1BQU0sUUFBUSxNQUFNLE1BQU07QUFDaEYsY0FBTSxjQUFjLE1BQU0sSUFBSSxDQUFDLFNBQVMsVUFBVSxNQUFNLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFFakUsY0FBTSxTQUFVLE1BQU0sU0FBUyxJQUMzQixFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFNBQVMsTUFBTSxTQUFTLE9BQU8sYUFBYSxpQkFBaUIsVUFBVSxTQUFTLElBQzlHLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsU0FBUyxNQUFNLFNBQVMsVUFBVSxTQUFTO0FBQzdFLGVBQU8sS0FBSyxPQUFPLE1BQU07QUFBQSxNQUM3QjtBQUFBLE1BQ0EsTUFBTSxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQ3ZCLFlBQUksVUFBVSxpQkFBaUIsS0FBSyxHQUFHO0FBQ25DLGlCQUFPLHdCQUF3QixRQUFRLEtBQUs7QUFBQSxRQUNoRCxPQUNLO0FBQ0QsZ0JBQU0sUUFBUTtBQUNkLGNBQUksTUFBTSxXQUFXO0FBQ2pCLG1CQUFPLEtBQUssTUFBTSxPQUFPO0FBQzdCLGNBQUksTUFBTSxXQUFXO0FBQ2pCLG1CQUFPLEtBQUssT0FBTyxVQUFVLE1BQU0sTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDO0FBQ3pELGdCQUFNLGNBQWMsTUFBTSxJQUFJLENBQUMsV0FBVyxVQUFVLE1BQU0sUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNyRSxpQkFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxTQUFTLE9BQU8sWUFBWSxDQUFDO0FBQUEsUUFDbEY7QUFBQSxNQUNKO0FBQUE7QUFBQSxNQUVBLFFBQVEsVUFBVSxDQUFDLEdBQUc7QUFDbEIsZUFBTyxLQUFLLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLElBQUksR0FBRyxVQUFVLENBQUM7QUFBQSxNQUNoRTtBQUFBO0FBQUEsTUFFQSxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQ2pCLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsUUFBUSxRQUFRLElBQUksS0FBSyxTQUFTLENBQUM7QUFBQSxNQUN4RjtBQUFBLElBQ0o7QUFDQSxZQUFRLHNCQUFzQjtBQUk5QixRQUFNLHNCQUFOLGNBQWtDLG9CQUFvQjtBQUFBO0FBQUEsTUFFbEQsT0FBTyxVQUFVLENBQUMsR0FBRztBQUNqQixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFVBQVUsTUFBTSxRQUFRLFFBQVEsU0FBUyxDQUFDO0FBQUEsTUFDL0Y7QUFBQTtBQUFBLE1BRUEsc0JBQXNCLFFBQVEsVUFBVSxDQUFDLEdBQUc7QUFDeEMsZUFBTyxLQUFLLE1BQU0sQ0FBQyxHQUFHLE9BQU8sVUFBVSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUM7QUFBQSxNQUM1RDtBQUFBO0FBQUEsTUFFQSxZQUFZLFlBQVksU0FBUyxTQUFTO0FBQ3RDLGNBQU0sZ0JBQWdCLFVBQVUsTUFBTSxTQUFTLENBQUMsQ0FBQztBQUNqRCxjQUFNLG1CQUFtQixXQUFXLElBQUksQ0FBQyxjQUFjLFVBQVUsTUFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQ3JGLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsZUFBZSxNQUFNLFVBQVUsWUFBWSxlQUFlLFlBQVksa0JBQWtCLFNBQVMsY0FBYyxDQUFDO0FBQUEsTUFDcks7QUFBQTtBQUFBLE1BRUEsS0FBSyxVQUFVLENBQUMsR0FBRztBQUNmLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsUUFBUSxNQUFNLFVBQVUsWUFBWSxPQUFPLENBQUM7QUFBQSxNQUNqRztBQUFBO0FBQUEsTUFFQSxTQUFTLFlBQVksU0FBUyxTQUFTO0FBQ25DLGNBQU0sZ0JBQWdCLFVBQVUsTUFBTSxTQUFTLENBQUMsQ0FBQztBQUNqRCxjQUFNLG1CQUFtQixXQUFXLElBQUksQ0FBQyxjQUFjLFVBQVUsTUFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQ3JGLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsWUFBWSxNQUFNLFVBQVUsWUFBWSxZQUFZLFlBQVksa0JBQWtCLFNBQVMsY0FBYyxDQUFDO0FBQUEsTUFDL0o7QUFBQTtBQUFBLE1BRUEsYUFBYSxRQUFRLFVBQVUsQ0FBQyxHQUFHO0FBQy9CLGVBQU8sVUFBVSxNQUFNLE9BQU8sU0FBUyxPQUFPO0FBQUEsTUFDbEQ7QUFBQTtBQUFBLE1BRUEsV0FBVyxRQUFRLFVBQVUsQ0FBQyxHQUFHO0FBQzdCLGVBQU8sS0FBSyxNQUFNLE9BQU8sWUFBWSxFQUFFLEdBQUcsUUFBUSxDQUFDO0FBQUEsTUFDdkQ7QUFBQTtBQUFBLE1BRUEsUUFBUSxNQUFNLFVBQVUsQ0FBQyxHQUFHO0FBQ3hCLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsV0FBVyxNQUFNLFVBQVUsWUFBWSxXQUFXLE1BQU0sVUFBVSxNQUFNLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUFBLE1BQ3hJO0FBQUE7QUFBQSxNQUVBLE1BQU0sT0FBTyxVQUFVLENBQUMsR0FBRztBQUN2QixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFVBQVUsTUFBTSxVQUFVLFNBQVMsTUFBTSxPQUFPLENBQUM7QUFBQSxNQUN0RztBQUFBO0FBQUEsTUFFQSxXQUFXLFFBQVEsVUFBVSxDQUFDLEdBQUc7QUFDN0IsZUFBTyxVQUFVLE1BQU0sT0FBTyxTQUFTLE9BQU87QUFBQSxNQUNsRDtBQUFBO0FBQUEsTUFFQSxPQUFPLFNBQVM7QUFDWixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLFVBQVUsTUFBTSxRQUFRLFFBQVEsU0FBUyxDQUFDO0FBQUEsTUFDL0Y7QUFBQTtBQUFBLE1BRUEsVUFBVSxVQUFVLENBQUMsR0FBRztBQUNwQixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLGFBQWEsTUFBTSxRQUFRLFFBQVEsWUFBWSxDQUFDO0FBQUEsTUFDckc7QUFBQTtBQUFBLE1BRUEsV0FBVyxVQUFVLENBQUMsR0FBRztBQUNyQixlQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLFFBQVEsSUFBSSxHQUFHLGNBQWMsTUFBTSxVQUFVLFlBQVksYUFBYSxDQUFDO0FBQUEsTUFDN0c7QUFBQTtBQUFBLE1BRUEsS0FBSyxVQUFVLENBQUMsR0FBRztBQUNmLGVBQU8sS0FBSyxPQUFPLEVBQUUsR0FBRyxTQUFTLENBQUMsUUFBUSxJQUFJLEdBQUcsUUFBUSxNQUFNLFFBQVEsUUFBUSxPQUFPLENBQUM7QUFBQSxNQUMzRjtBQUFBLElBQ0o7QUFDQSxZQUFRLHNCQUFzQjtBQUU5QixZQUFRLGVBQWUsSUFBSSxvQkFBb0I7QUFFL0MsWUFBUSxPQUFPLElBQUksb0JBQW9CO0FBQUE7QUFBQTs7Ozs7Ozs7QUN4M0V2QyxRQUFBLFlBQUE7QUFFQSxRQUFNLGlCQUFpQixVQUFBLEtBQUssT0FBTyxFQUFFLFdBQVcsRUFBQyxDQUFFO0FBQ25ELFFBQU0sa0JBQWtCLFVBQUEsS0FBSyxRQUFRLEVBQUUsU0FBUyxFQUFDLENBQUU7QUFPdEMsWUFBQSxrQkFBa0I7QUFHbEIsWUFBQSxnQkFBZ0I7QUFDaEIsWUFBQSxpQkFBaUI7QUFDakIsWUFBQSxhQUFhO0FBQ2IsWUFBQSxlQUFlO0FBQ2YsWUFBQSxrQkFBa0I7QUFDbEIsWUFBQSx1QkFBdUIsVUFBQSxLQUFLLE9BQ3ZDO01BQ0UsU0FBUyxVQUFBLEtBQUssTUFBTSxjQUFjO09BRXBDLEVBQUUsc0JBQXNCLE1BQUssQ0FBRTtBQVFwQixZQUFBLHVCQUF1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QnBDLFFBQUEsV0FBQTtBQUNBLFFBQUEsY0FBQTtBQUVBLFFBQUEsVUFBQTtBQUVBLFFBQUEsWUFBQTtBQUNBLFFBQUEsVUFBQTtBQUVBLFFBQU0sOEJBQThCLFVBQUEsS0FBSyxPQUN2QztNQUNFLFVBQVUsVUFBQSxLQUFLLFNBQVMsUUFBQSxjQUFjO01BQ3RDLFNBQVMsVUFBQSxLQUFLLFNBQVMsUUFBQSxhQUFhO09BRXRDLEVBQUUsc0JBQXNCLE1BQUssQ0FBRTtBQUkxQixRQUFNLGlCQUFpQixTQUFDLEtBQXVCO0FBQ3BELFVBQU0sc0JBQXFCLEdBQUEsWUFBQSxnQkFDekIsd0NBQ0EsUUFBQSxlQUFlO0FBRWpCLFVBQU0seUJBQXdCLEdBQUEsWUFBQSxnQkFDNUIseUNBQ0EsMkJBQTJCO0FBRzdCLGFBQU8sU0FDTCxNQUNBLFNBQThCO0FBQUEsZUFBQSxVQUFBLFFBQUEsUUFBQSxRQUFBLFdBQUE7Ozs7O0FBRTlCLG1DQUFtQixJQUFJO0FBQ3ZCLHNDQUFzQixPQUFPO0FBRTdCLG9CQUFJLE9BQU8sS0FBSyxPQUFPLEVBQUUsV0FBVyxHQUFHO0FBQ3JDLHdCQUFNLElBQUksU0FBQSxzQkFDUixzSUFBc0k7Ozs7O0FBS3hJLHVCQUFBLENBQUEsR0FBTSxJQUFJLGVBQWUsRUFBRSxXQUFXLE1BQU0sY0FBYyxRQUFPLENBQUUsQ0FBQzs7QUFBcEUsZ0JBQUErQixJQUFBLEtBQUE7QUFDQSx1QkFBQTtrQkFBQTs7Z0JBQUE7OztBQUVZLHVCQUFBLENBQUEsSUFBTSxHQUFBLFFBQUEseUJBQXdCLEtBQUcsS0FBSyxJQUFJLENBQUM7O0FBQWpELHNCQUFNQSxJQUFBLEtBQUE7QUFDWixzQkFBTTs7Ozs7Ozs7OztJQUdaO0FBL0JhLFlBQUEsaUJBQWM7Ozs7Ozs7Ozs7QUNsQnBCLFFBQU0sV0FBVyxTQUFDLEtBQVc7QUFDbEMsVUFBSSxXQUFXLFFBQVEsT0FBTyxRQUFRLElBQUksZ0JBQWdCO0FBQ3hELGdCQUFRLElBQUksR0FBRzs7SUFFbkI7QUFKYSxZQUFBLFdBQVE7Ozs7Ozs7Ozs7QUNPckIsYUFBZ0IscUJBQ2QsUUFDQSxRQUFtQjtBQUFuQixVQUFBLFdBQUEsUUFBQTtBQUFBLGlCQUFBO01BQW1CO0FBRW5CLGFBQU8sT0FBTyxLQUFLLE1BQU0sRUFDdEIsSUFBSSxTQUFDLEtBQUc7QUFBSyxlQUFBLHFCQUFxQixLQUFLLE9BQU8sR0FBRyxHQUFHLE1BQU07TUFBN0MsQ0FBOEMsRUFDM0QsT0FBTyxTQUFDLE1BQUk7QUFBSyxlQUFBLEtBQUssU0FBUztNQUFkLENBQWUsRUFDaEMsS0FBSyxHQUFHO0lBQ2I7QUFSQSxZQUFBLHVCQUFBO0FBVUEsYUFBUyxxQkFDUCxLQUNBLE9BU0EsV0FBc0I7QUFBdEIsVUFBQSxjQUFBLFFBQUE7QUFBQSxvQkFBQTtNQUFzQjtBQUV0QixVQUFNLFVBQVUsYUFBYSxVQUFVLFNBQVMsSUFBQSxPQUFJLEtBQUcsR0FBQSxJQUFNO0FBSzdELFVBQUksTUFBTSxRQUFRLEtBQUssR0FBRztBQUN4QixZQUFNLGFBQWEsTUFDaEIsSUFBSSxTQUFDLGFBQVc7QUFBSyxpQkFBQSxtQkFBbUIsT0FBTyxXQUFXLENBQUM7UUFBdEMsQ0FBdUMsRUFDNUQsS0FBSyxJQUFBLE9BQUksbUJBQW1CLE9BQU8sR0FBQyxHQUFBLENBQUc7QUFDMUMsZUFBTyxHQUFBLE9BQUcsbUJBQW1CLE9BQU8sR0FBQyxHQUFBLEVBQUEsT0FBSSxVQUFVOztBQUVyRCxVQUFJLGlCQUFpQixLQUFLO0FBQ3hCLFlBQU0sZUFBZSxNQUFNLEtBQUssS0FBSztBQUNyQyxlQUFPLHFCQUFxQixLQUFLLGNBQWMsU0FBUzs7QUFFMUQsVUFBSSxpQkFBaUIsTUFBTTtBQUN6QixlQUFPLEdBQUEsT0FBRyxtQkFBbUIsT0FBTyxHQUFDLEdBQUEsRUFBQSxPQUFJLG1CQUN2QyxNQUFNLFlBQVcsQ0FBRSxDQUNwQjs7QUFFSCxVQUFJLGlCQUFpQixRQUFRO0FBQzNCLGVBQU8scUJBQXFCLE9BQW9CLE9BQU87O0FBRXpELGFBQU8sR0FBQSxPQUFHLG1CQUFtQixPQUFPLEdBQUMsR0FBQSxFQUFBLE9BQUksbUJBQW1CLE9BQU8sS0FBSyxDQUFDLENBQUM7SUFDNUU7Ozs7O0FDdERBO0FBQUEsd0VBQUFDLFNBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsTUFDSSxNQUFRO0FBQUEsTUFDUixTQUFXO0FBQUEsSUFDZjtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQSxRQUFBLGdCQUFBO0FBQ0EsUUFBQSxjQUFBLGFBQUEsaUJBQUE7QUFFTyxRQUFNLGlCQUFpQixTQUFDLFVBQWlCO0FBSTlDLFVBQU0saUJBQWlCO1FBQ3JCLEdBQUEsT0FBRyxZQUFZLE1BQUksSUFBQSxFQUFBLE9BQUssWUFBWSxPQUFPO1FBQzNDOztBQUdGLFdBQUksR0FBQSxjQUFBLFFBQU0sR0FBSTtBQUNaLHVCQUFlLEtBQUssY0FBYzs7QUFJcEMsVUFBSSxXQUFXLFFBQVEsU0FBUztBQUM5Qix1QkFBZSxLQUFLLFFBQUEsT0FBUSxRQUFRLE9BQU8sQ0FBRTs7QUFLL0MscUJBQWUsS0FBSyxnQkFBQSxPQUFnQixRQUFRLENBQUU7QUFFOUMsYUFBTyxlQUFlLEtBQUssSUFBSTtJQUNqQztBQXZCYSxZQUFBLGlCQUFjOzs7OztBQ0gzQjtBQUFBLCtEQUFBQyxTQUFBO0FBQUEsUUFBSUMsVUFBUyxPQUFPLFNBQVMsY0FBYyxPQUFPO0FBQ2xELFFBQUksV0FBWSxXQUFZO0FBQzVCLGVBQVMsSUFBSTtBQUNiLGFBQUssUUFBUTtBQUNiLGFBQUssZUFBZUEsUUFBTztBQUFBLE1BQzNCO0FBQ0EsUUFBRSxZQUFZQTtBQUNkLGFBQU8sSUFBSSxFQUFFO0FBQUEsSUFDYixFQUFHO0FBQ0gsS0FBQyxTQUFTQyxPQUFNO0FBRWhCLFVBQUksYUFBYyxTQUFVQyxVQUFTO0FBRW5DLFlBQUksVUFBVTtBQUFBLFVBQ1osY0FBYyxxQkFBcUJEO0FBQUEsVUFDbkMsVUFBVSxZQUFZQSxTQUFRLGNBQWM7QUFBQSxVQUM1QyxNQUNFLGdCQUFnQkEsU0FDaEIsVUFBVUEsU0FDVCxXQUFXO0FBQ1YsZ0JBQUk7QUFDRixrQkFBSSxLQUFLO0FBQ1QscUJBQU87QUFBQSxZQUNULFNBQVMsR0FBUDtBQUNBLHFCQUFPO0FBQUEsWUFDVDtBQUFBLFVBQ0YsRUFBRztBQUFBLFVBQ0wsVUFBVSxjQUFjQTtBQUFBLFVBQ3hCLGFBQWEsaUJBQWlCQTtBQUFBLFFBQ2hDO0FBRUEsaUJBQVMsV0FBVyxLQUFLO0FBQ3ZCLGlCQUFPLE9BQU8sU0FBUyxVQUFVLGNBQWMsR0FBRztBQUFBLFFBQ3BEO0FBRUEsWUFBSSxRQUFRLGFBQWE7QUFDdkIsY0FBSSxjQUFjO0FBQUEsWUFDaEI7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFFQSxjQUFJLG9CQUNGLFlBQVksVUFDWixTQUFTLEtBQUs7QUFDWixtQkFBTyxPQUFPLFlBQVksUUFBUSxPQUFPLFVBQVUsU0FBUyxLQUFLLEdBQUcsQ0FBQyxJQUFJO0FBQUEsVUFDM0U7QUFBQSxRQUNKO0FBRUEsaUJBQVMsY0FBYyxNQUFNO0FBQzNCLGNBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsbUJBQU8sT0FBTyxJQUFJO0FBQUEsVUFDcEI7QUFDQSxjQUFJLDRCQUE0QixLQUFLLElBQUksR0FBRztBQUMxQyxrQkFBTSxJQUFJLFVBQVUsd0NBQXdDO0FBQUEsVUFDOUQ7QUFDQSxpQkFBTyxLQUFLLFlBQVk7QUFBQSxRQUMxQjtBQUVBLGlCQUFTLGVBQWUsT0FBTztBQUM3QixjQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLG9CQUFRLE9BQU8sS0FBSztBQUFBLFVBQ3RCO0FBQ0EsaUJBQU87QUFBQSxRQUNUO0FBR0EsaUJBQVMsWUFBWSxPQUFPO0FBQzFCLGNBQUksV0FBVztBQUFBLFlBQ2IsTUFBTSxXQUFXO0FBQ2Ysa0JBQUksUUFBUSxNQUFNLE1BQU07QUFDeEIscUJBQU8sRUFBQyxNQUFNLFVBQVUsUUFBVyxNQUFZO0FBQUEsWUFDakQ7QUFBQSxVQUNGO0FBRUEsY0FBSSxRQUFRLFVBQVU7QUFDcEIscUJBQVMsT0FBTyxRQUFRLElBQUksV0FBVztBQUNyQyxxQkFBTztBQUFBLFlBQ1Q7QUFBQSxVQUNGO0FBRUEsaUJBQU87QUFBQSxRQUNUO0FBRUEsaUJBQVNFLFNBQVEsU0FBUztBQUN4QixlQUFLLE1BQU0sQ0FBQztBQUVaLGNBQUksbUJBQW1CQSxVQUFTO0FBQzlCLG9CQUFRLFFBQVEsU0FBUyxPQUFPLE1BQU07QUFDcEMsbUJBQUssT0FBTyxNQUFNLEtBQUs7QUFBQSxZQUN6QixHQUFHLElBQUk7QUFBQSxVQUNULFdBQVcsTUFBTSxRQUFRLE9BQU8sR0FBRztBQUNqQyxvQkFBUSxRQUFRLFNBQVMsUUFBUTtBQUMvQixtQkFBSyxPQUFPLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0FBQUEsWUFDbEMsR0FBRyxJQUFJO0FBQUEsVUFDVCxXQUFXLFNBQVM7QUFDbEIsbUJBQU8sb0JBQW9CLE9BQU8sRUFBRSxRQUFRLFNBQVMsTUFBTTtBQUN6RCxtQkFBSyxPQUFPLE1BQU0sUUFBUSxJQUFJLENBQUM7QUFBQSxZQUNqQyxHQUFHLElBQUk7QUFBQSxVQUNUO0FBQUEsUUFDRjtBQUVBLFFBQUFBLFNBQVEsVUFBVSxTQUFTLFNBQVMsTUFBTSxPQUFPO0FBQy9DLGlCQUFPLGNBQWMsSUFBSTtBQUN6QixrQkFBUSxlQUFlLEtBQUs7QUFDNUIsY0FBSSxXQUFXLEtBQUssSUFBSSxJQUFJO0FBQzVCLGVBQUssSUFBSSxJQUFJLElBQUksV0FBVyxXQUFXLE9BQU8sUUFBUTtBQUFBLFFBQ3hEO0FBRUEsUUFBQUEsU0FBUSxVQUFVLFFBQVEsSUFBSSxTQUFTLE1BQU07QUFDM0MsaUJBQU8sS0FBSyxJQUFJLGNBQWMsSUFBSSxDQUFDO0FBQUEsUUFDckM7QUFFQSxRQUFBQSxTQUFRLFVBQVUsTUFBTSxTQUFTLE1BQU07QUFDckMsaUJBQU8sY0FBYyxJQUFJO0FBQ3pCLGlCQUFPLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSTtBQUFBLFFBQzNDO0FBRUEsUUFBQUEsU0FBUSxVQUFVLE1BQU0sU0FBUyxNQUFNO0FBQ3JDLGlCQUFPLEtBQUssSUFBSSxlQUFlLGNBQWMsSUFBSSxDQUFDO0FBQUEsUUFDcEQ7QUFFQSxRQUFBQSxTQUFRLFVBQVUsTUFBTSxTQUFTLE1BQU0sT0FBTztBQUM1QyxlQUFLLElBQUksY0FBYyxJQUFJLENBQUMsSUFBSSxlQUFlLEtBQUs7QUFBQSxRQUN0RDtBQUVBLFFBQUFBLFNBQVEsVUFBVSxVQUFVLFNBQVMsVUFBVSxTQUFTO0FBQ3RELG1CQUFTLFFBQVEsS0FBSyxLQUFLO0FBQ3pCLGdCQUFJLEtBQUssSUFBSSxlQUFlLElBQUksR0FBRztBQUNqQyx1QkFBUyxLQUFLLFNBQVMsS0FBSyxJQUFJLElBQUksR0FBRyxNQUFNLElBQUk7QUFBQSxZQUNuRDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBRUEsUUFBQUEsU0FBUSxVQUFVLE9BQU8sV0FBVztBQUNsQyxjQUFJLFFBQVEsQ0FBQztBQUNiLGVBQUssUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUNqQyxrQkFBTSxLQUFLLElBQUk7QUFBQSxVQUNqQixDQUFDO0FBQ0QsaUJBQU8sWUFBWSxLQUFLO0FBQUEsUUFDMUI7QUFFQSxRQUFBQSxTQUFRLFVBQVUsU0FBUyxXQUFXO0FBQ3BDLGNBQUksUUFBUSxDQUFDO0FBQ2IsZUFBSyxRQUFRLFNBQVMsT0FBTztBQUMzQixrQkFBTSxLQUFLLEtBQUs7QUFBQSxVQUNsQixDQUFDO0FBQ0QsaUJBQU8sWUFBWSxLQUFLO0FBQUEsUUFDMUI7QUFFQSxRQUFBQSxTQUFRLFVBQVUsVUFBVSxXQUFXO0FBQ3JDLGNBQUksUUFBUSxDQUFDO0FBQ2IsZUFBSyxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ2pDLGtCQUFNLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQztBQUFBLFVBQzFCLENBQUM7QUFDRCxpQkFBTyxZQUFZLEtBQUs7QUFBQSxRQUMxQjtBQUVBLFlBQUksUUFBUSxVQUFVO0FBQ3BCLFVBQUFBLFNBQVEsVUFBVSxPQUFPLFFBQVEsSUFBSUEsU0FBUSxVQUFVO0FBQUEsUUFDekQ7QUFFQSxpQkFBUyxTQUFTLE1BQU07QUFDdEIsY0FBSSxLQUFLLFVBQVU7QUFDakIsbUJBQU8sUUFBUSxPQUFPLElBQUksVUFBVSxjQUFjLENBQUM7QUFBQSxVQUNyRDtBQUNBLGVBQUssV0FBVztBQUFBLFFBQ2xCO0FBRUEsaUJBQVMsZ0JBQWdCLFFBQVE7QUFDL0IsaUJBQU8sSUFBSSxRQUFRLFNBQVMsU0FBUyxRQUFRO0FBQzNDLG1CQUFPLFNBQVMsV0FBVztBQUN6QixzQkFBUSxPQUFPLE1BQU07QUFBQSxZQUN2QjtBQUNBLG1CQUFPLFVBQVUsV0FBVztBQUMxQixxQkFBTyxPQUFPLEtBQUs7QUFBQSxZQUNyQjtBQUFBLFVBQ0YsQ0FBQztBQUFBLFFBQ0g7QUFFQSxpQkFBUyxzQkFBc0IsTUFBTTtBQUNuQyxjQUFJLFNBQVMsSUFBSSxXQUFXO0FBQzVCLGNBQUksVUFBVSxnQkFBZ0IsTUFBTTtBQUNwQyxpQkFBTyxrQkFBa0IsSUFBSTtBQUM3QixpQkFBTztBQUFBLFFBQ1Q7QUFFQSxpQkFBUyxlQUFlLE1BQU07QUFDNUIsY0FBSSxTQUFTLElBQUksV0FBVztBQUM1QixjQUFJLFVBQVUsZ0JBQWdCLE1BQU07QUFDcEMsaUJBQU8sV0FBVyxJQUFJO0FBQ3RCLGlCQUFPO0FBQUEsUUFDVDtBQUVBLGlCQUFTLHNCQUFzQixLQUFLO0FBQ2xDLGNBQUksT0FBTyxJQUFJLFdBQVcsR0FBRztBQUM3QixjQUFJLFFBQVEsSUFBSSxNQUFNLEtBQUssTUFBTTtBQUVqQyxtQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxrQkFBTSxDQUFDLElBQUksT0FBTyxhQUFhLEtBQUssQ0FBQyxDQUFDO0FBQUEsVUFDeEM7QUFDQSxpQkFBTyxNQUFNLEtBQUssRUFBRTtBQUFBLFFBQ3RCO0FBRUEsaUJBQVMsWUFBWSxLQUFLO0FBQ3hCLGNBQUksSUFBSSxPQUFPO0FBQ2IsbUJBQU8sSUFBSSxNQUFNLENBQUM7QUFBQSxVQUNwQixPQUFPO0FBQ0wsZ0JBQUksT0FBTyxJQUFJLFdBQVcsSUFBSSxVQUFVO0FBQ3hDLGlCQUFLLElBQUksSUFBSSxXQUFXLEdBQUcsQ0FBQztBQUM1QixtQkFBTyxLQUFLO0FBQUEsVUFDZDtBQUFBLFFBQ0Y7QUFFQSxpQkFBUyxPQUFPO0FBQ2QsZUFBSyxXQUFXO0FBRWhCLGVBQUssWUFBWSxTQUFTLE1BQU07QUFDOUIsaUJBQUssWUFBWTtBQUNqQixnQkFBSSxDQUFDLE1BQU07QUFDVCxtQkFBSyxZQUFZO0FBQUEsWUFDbkIsV0FBVyxPQUFPLFNBQVMsVUFBVTtBQUNuQyxtQkFBSyxZQUFZO0FBQUEsWUFDbkIsV0FBVyxRQUFRLFFBQVEsS0FBSyxVQUFVLGNBQWMsSUFBSSxHQUFHO0FBQzdELG1CQUFLLFlBQVk7QUFBQSxZQUNuQixXQUFXLFFBQVEsWUFBWSxTQUFTLFVBQVUsY0FBYyxJQUFJLEdBQUc7QUFDckUsbUJBQUssZ0JBQWdCO0FBQUEsWUFDdkIsV0FBVyxRQUFRLGdCQUFnQixnQkFBZ0IsVUFBVSxjQUFjLElBQUksR0FBRztBQUNoRixtQkFBSyxZQUFZLEtBQUssU0FBUztBQUFBLFlBQ2pDLFdBQVcsUUFBUSxlQUFlLFFBQVEsUUFBUSxXQUFXLElBQUksR0FBRztBQUNsRSxtQkFBSyxtQkFBbUIsWUFBWSxLQUFLLE1BQU07QUFFL0MsbUJBQUssWUFBWSxJQUFJLEtBQUssQ0FBQyxLQUFLLGdCQUFnQixDQUFDO0FBQUEsWUFDbkQsV0FBVyxRQUFRLGdCQUFnQixZQUFZLFVBQVUsY0FBYyxJQUFJLEtBQUssa0JBQWtCLElBQUksSUFBSTtBQUN4RyxtQkFBSyxtQkFBbUIsWUFBWSxJQUFJO0FBQUEsWUFDMUMsT0FBTztBQUNMLG1CQUFLLFlBQVksT0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLElBQUk7QUFBQSxZQUM3RDtBQUVBLGdCQUFJLENBQUMsS0FBSyxRQUFRLElBQUksY0FBYyxHQUFHO0FBQ3JDLGtCQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLHFCQUFLLFFBQVEsSUFBSSxnQkFBZ0IsMEJBQTBCO0FBQUEsY0FDN0QsV0FBVyxLQUFLLGFBQWEsS0FBSyxVQUFVLE1BQU07QUFDaEQscUJBQUssUUFBUSxJQUFJLGdCQUFnQixLQUFLLFVBQVUsSUFBSTtBQUFBLGNBQ3RELFdBQVcsUUFBUSxnQkFBZ0IsZ0JBQWdCLFVBQVUsY0FBYyxJQUFJLEdBQUc7QUFDaEYscUJBQUssUUFBUSxJQUFJLGdCQUFnQixpREFBaUQ7QUFBQSxjQUNwRjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBRUEsY0FBSSxRQUFRLE1BQU07QUFDaEIsaUJBQUssT0FBTyxXQUFXO0FBQ3JCLGtCQUFJLFdBQVcsU0FBUyxJQUFJO0FBQzVCLGtCQUFJLFVBQVU7QUFDWix1QkFBTztBQUFBLGNBQ1Q7QUFFQSxrQkFBSSxLQUFLLFdBQVc7QUFDbEIsdUJBQU8sUUFBUSxRQUFRLEtBQUssU0FBUztBQUFBLGNBQ3ZDLFdBQVcsS0FBSyxrQkFBa0I7QUFDaEMsdUJBQU8sUUFBUSxRQUFRLElBQUksS0FBSyxDQUFDLEtBQUssZ0JBQWdCLENBQUMsQ0FBQztBQUFBLGNBQzFELFdBQVcsS0FBSyxlQUFlO0FBQzdCLHNCQUFNLElBQUksTUFBTSxzQ0FBc0M7QUFBQSxjQUN4RCxPQUFPO0FBQ0wsdUJBQU8sUUFBUSxRQUFRLElBQUksS0FBSyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUM7QUFBQSxjQUNuRDtBQUFBLFlBQ0Y7QUFFQSxpQkFBSyxjQUFjLFdBQVc7QUFDNUIsa0JBQUksS0FBSyxrQkFBa0I7QUFDekIsdUJBQU8sU0FBUyxJQUFJLEtBQUssUUFBUSxRQUFRLEtBQUssZ0JBQWdCO0FBQUEsY0FDaEUsT0FBTztBQUNMLHVCQUFPLEtBQUssS0FBSyxFQUFFLEtBQUsscUJBQXFCO0FBQUEsY0FDL0M7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUVBLGVBQUssT0FBTyxXQUFXO0FBQ3JCLGdCQUFJLFdBQVcsU0FBUyxJQUFJO0FBQzVCLGdCQUFJLFVBQVU7QUFDWixxQkFBTztBQUFBLFlBQ1Q7QUFFQSxnQkFBSSxLQUFLLFdBQVc7QUFDbEIscUJBQU8sZUFBZSxLQUFLLFNBQVM7QUFBQSxZQUN0QyxXQUFXLEtBQUssa0JBQWtCO0FBQ2hDLHFCQUFPLFFBQVEsUUFBUSxzQkFBc0IsS0FBSyxnQkFBZ0IsQ0FBQztBQUFBLFlBQ3JFLFdBQVcsS0FBSyxlQUFlO0FBQzdCLG9CQUFNLElBQUksTUFBTSxzQ0FBc0M7QUFBQSxZQUN4RCxPQUFPO0FBQ0wscUJBQU8sUUFBUSxRQUFRLEtBQUssU0FBUztBQUFBLFlBQ3ZDO0FBQUEsVUFDRjtBQUVBLGNBQUksUUFBUSxVQUFVO0FBQ3BCLGlCQUFLLFdBQVcsV0FBVztBQUN6QixxQkFBTyxLQUFLLEtBQUssRUFBRSxLQUFLLE1BQU07QUFBQSxZQUNoQztBQUFBLFVBQ0Y7QUFFQSxlQUFLLE9BQU8sV0FBVztBQUNyQixtQkFBTyxLQUFLLEtBQUssRUFBRSxLQUFLLEtBQUssS0FBSztBQUFBLFVBQ3BDO0FBRUEsaUJBQU87QUFBQSxRQUNUO0FBR0EsWUFBSSxVQUFVLENBQUMsVUFBVSxPQUFPLFFBQVEsV0FBVyxRQUFRLEtBQUs7QUFFaEUsaUJBQVMsZ0JBQWdCLFFBQVE7QUFDL0IsY0FBSSxVQUFVLE9BQU8sWUFBWTtBQUNqQyxpQkFBTyxRQUFRLFFBQVEsT0FBTyxJQUFJLEtBQUssVUFBVTtBQUFBLFFBQ25EO0FBRUEsaUJBQVNDLFNBQVEsT0FBTyxTQUFTO0FBQy9CLG9CQUFVLFdBQVcsQ0FBQztBQUN0QixjQUFJLE9BQU8sUUFBUTtBQUVuQixjQUFJLGlCQUFpQkEsVUFBUztBQUM1QixnQkFBSSxNQUFNLFVBQVU7QUFDbEIsb0JBQU0sSUFBSSxVQUFVLGNBQWM7QUFBQSxZQUNwQztBQUNBLGlCQUFLLE1BQU0sTUFBTTtBQUNqQixpQkFBSyxjQUFjLE1BQU07QUFDekIsZ0JBQUksQ0FBQyxRQUFRLFNBQVM7QUFDcEIsbUJBQUssVUFBVSxJQUFJRCxTQUFRLE1BQU0sT0FBTztBQUFBLFlBQzFDO0FBQ0EsaUJBQUssU0FBUyxNQUFNO0FBQ3BCLGlCQUFLLE9BQU8sTUFBTTtBQUNsQixpQkFBSyxTQUFTLE1BQU07QUFDcEIsZ0JBQUksQ0FBQyxRQUFRLE1BQU0sYUFBYSxNQUFNO0FBQ3BDLHFCQUFPLE1BQU07QUFDYixvQkFBTSxXQUFXO0FBQUEsWUFDbkI7QUFBQSxVQUNGLE9BQU87QUFDTCxpQkFBSyxNQUFNLE9BQU8sS0FBSztBQUFBLFVBQ3pCO0FBRUEsZUFBSyxjQUFjLFFBQVEsZUFBZSxLQUFLLGVBQWU7QUFDOUQsY0FBSSxRQUFRLFdBQVcsQ0FBQyxLQUFLLFNBQVM7QUFDcEMsaUJBQUssVUFBVSxJQUFJQSxTQUFRLFFBQVEsT0FBTztBQUFBLFVBQzVDO0FBQ0EsZUFBSyxTQUFTLGdCQUFnQixRQUFRLFVBQVUsS0FBSyxVQUFVLEtBQUs7QUFDcEUsZUFBSyxPQUFPLFFBQVEsUUFBUSxLQUFLLFFBQVE7QUFDekMsZUFBSyxTQUFTLFFBQVEsVUFBVSxLQUFLO0FBQ3JDLGVBQUssV0FBVztBQUVoQixlQUFLLEtBQUssV0FBVyxTQUFTLEtBQUssV0FBVyxXQUFXLE1BQU07QUFDN0Qsa0JBQU0sSUFBSSxVQUFVLDJDQUEyQztBQUFBLFVBQ2pFO0FBQ0EsZUFBSyxVQUFVLElBQUk7QUFBQSxRQUNyQjtBQUVBLFFBQUFDLFNBQVEsVUFBVSxRQUFRLFdBQVc7QUFDbkMsaUJBQU8sSUFBSUEsU0FBUSxNQUFNLEVBQUMsTUFBTSxLQUFLLFVBQVMsQ0FBQztBQUFBLFFBQ2pEO0FBRUEsaUJBQVMsT0FBTyxNQUFNO0FBQ3BCLGNBQUksT0FBTyxJQUFJLFNBQVM7QUFDeEIsZUFDRyxLQUFLLEVBQ0wsTUFBTSxHQUFHLEVBQ1QsUUFBUSxTQUFTLE9BQU87QUFDdkIsZ0JBQUksT0FBTztBQUNULGtCQUFJLFFBQVEsTUFBTSxNQUFNLEdBQUc7QUFDM0Isa0JBQUksT0FBTyxNQUFNLE1BQU0sRUFBRSxRQUFRLE9BQU8sR0FBRztBQUMzQyxrQkFBSSxRQUFRLE1BQU0sS0FBSyxHQUFHLEVBQUUsUUFBUSxPQUFPLEdBQUc7QUFDOUMsbUJBQUssT0FBTyxtQkFBbUIsSUFBSSxHQUFHLG1CQUFtQixLQUFLLENBQUM7QUFBQSxZQUNqRTtBQUFBLFVBQ0YsQ0FBQztBQUNILGlCQUFPO0FBQUEsUUFDVDtBQUVBLGlCQUFTLGFBQWEsWUFBWTtBQUNoQyxjQUFJLFVBQVUsSUFBSUQsU0FBUTtBQUcxQixjQUFJLHNCQUFzQixXQUFXLFFBQVEsZ0JBQWdCLEdBQUc7QUFDaEUsOEJBQW9CLE1BQU0sT0FBTyxFQUFFLFFBQVEsU0FBUyxNQUFNO0FBQ3hELGdCQUFJLFFBQVEsS0FBSyxNQUFNLEdBQUc7QUFDMUIsZ0JBQUksTUFBTSxNQUFNLE1BQU0sRUFBRSxLQUFLO0FBQzdCLGdCQUFJLEtBQUs7QUFDUCxrQkFBSSxRQUFRLE1BQU0sS0FBSyxHQUFHLEVBQUUsS0FBSztBQUNqQyxzQkFBUSxPQUFPLEtBQUssS0FBSztBQUFBLFlBQzNCO0FBQUEsVUFDRixDQUFDO0FBQ0QsaUJBQU87QUFBQSxRQUNUO0FBRUEsYUFBSyxLQUFLQyxTQUFRLFNBQVM7QUFFM0IsaUJBQVNDLFVBQVMsVUFBVSxTQUFTO0FBQ25DLGNBQUksQ0FBQyxTQUFTO0FBQ1osc0JBQVUsQ0FBQztBQUFBLFVBQ2I7QUFFQSxlQUFLLE9BQU87QUFDWixlQUFLLFNBQVMsUUFBUSxXQUFXLFNBQVksTUFBTSxRQUFRO0FBQzNELGVBQUssS0FBSyxLQUFLLFVBQVUsT0FBTyxLQUFLLFNBQVM7QUFDOUMsZUFBSyxhQUFhLGdCQUFnQixVQUFVLFFBQVEsYUFBYTtBQUNqRSxlQUFLLFVBQVUsSUFBSUYsU0FBUSxRQUFRLE9BQU87QUFDMUMsZUFBSyxNQUFNLFFBQVEsT0FBTztBQUMxQixlQUFLLFVBQVUsUUFBUTtBQUFBLFFBQ3pCO0FBRUEsYUFBSyxLQUFLRSxVQUFTLFNBQVM7QUFFNUIsUUFBQUEsVUFBUyxVQUFVLFFBQVEsV0FBVztBQUNwQyxpQkFBTyxJQUFJQSxVQUFTLEtBQUssV0FBVztBQUFBLFlBQ2xDLFFBQVEsS0FBSztBQUFBLFlBQ2IsWUFBWSxLQUFLO0FBQUEsWUFDakIsU0FBUyxJQUFJRixTQUFRLEtBQUssT0FBTztBQUFBLFlBQ2pDLEtBQUssS0FBSztBQUFBLFVBQ1osQ0FBQztBQUFBLFFBQ0g7QUFFQSxRQUFBRSxVQUFTLFFBQVEsV0FBVztBQUMxQixjQUFJLFdBQVcsSUFBSUEsVUFBUyxNQUFNLEVBQUMsUUFBUSxHQUFHLFlBQVksR0FBRSxDQUFDO0FBQzdELG1CQUFTLE9BQU87QUFDaEIsaUJBQU87QUFBQSxRQUNUO0FBRUEsWUFBSSxtQkFBbUIsQ0FBQyxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFFL0MsUUFBQUEsVUFBUyxXQUFXLFNBQVMsS0FBSyxRQUFRO0FBQ3hDLGNBQUksaUJBQWlCLFFBQVEsTUFBTSxNQUFNLElBQUk7QUFDM0Msa0JBQU0sSUFBSSxXQUFXLHFCQUFxQjtBQUFBLFVBQzVDO0FBRUEsaUJBQU8sSUFBSUEsVUFBUyxNQUFNLEVBQUMsUUFBZ0IsU0FBUyxFQUFDLFVBQVUsSUFBRyxFQUFDLENBQUM7QUFBQSxRQUN0RTtBQUVBLFFBQUFILFNBQVEsZUFBZUQsTUFBSztBQUM1QixZQUFJO0FBQ0YsY0FBSUMsU0FBUSxhQUFhO0FBQUEsUUFDM0IsU0FBUyxLQUFQO0FBQ0EsVUFBQUEsU0FBUSxlQUFlLFNBQVMsU0FBUyxNQUFNO0FBQzdDLGlCQUFLLFVBQVU7QUFDZixpQkFBSyxPQUFPO0FBQ1osZ0JBQUksUUFBUSxNQUFNLE9BQU87QUFDekIsaUJBQUssUUFBUSxNQUFNO0FBQUEsVUFDckI7QUFDQSxVQUFBQSxTQUFRLGFBQWEsWUFBWSxPQUFPLE9BQU8sTUFBTSxTQUFTO0FBQzlELFVBQUFBLFNBQVEsYUFBYSxVQUFVLGNBQWNBLFNBQVE7QUFBQSxRQUN2RDtBQUVBLGlCQUFTSSxPQUFNLE9BQU8sTUFBTTtBQUMxQixpQkFBTyxJQUFJLFFBQVEsU0FBUyxTQUFTLFFBQVE7QUFDM0MsZ0JBQUksVUFBVSxJQUFJRixTQUFRLE9BQU8sSUFBSTtBQUVyQyxnQkFBSSxRQUFRLFVBQVUsUUFBUSxPQUFPLFNBQVM7QUFDNUMscUJBQU8sT0FBTyxJQUFJRixTQUFRLGFBQWEsV0FBVyxZQUFZLENBQUM7QUFBQSxZQUNqRTtBQUVBLGdCQUFJLE1BQU0sSUFBSSxlQUFlO0FBRTdCLHFCQUFTLFdBQVc7QUFDbEIsa0JBQUksTUFBTTtBQUFBLFlBQ1o7QUFFQSxnQkFBSSxTQUFTLFdBQVc7QUFDdEIsa0JBQUksVUFBVTtBQUFBLGdCQUNaLFFBQVEsSUFBSTtBQUFBLGdCQUNaLFlBQVksSUFBSTtBQUFBLGdCQUNoQixTQUFTLGFBQWEsSUFBSSxzQkFBc0IsS0FBSyxFQUFFO0FBQUEsY0FDekQ7QUFDQSxzQkFBUSxNQUFNLGlCQUFpQixNQUFNLElBQUksY0FBYyxRQUFRLFFBQVEsSUFBSSxlQUFlO0FBQzFGLGtCQUFJLE9BQU8sY0FBYyxNQUFNLElBQUksV0FBVyxJQUFJO0FBQ2xELHNCQUFRLElBQUlHLFVBQVMsTUFBTSxPQUFPLENBQUM7QUFBQSxZQUNyQztBQUVBLGdCQUFJLFVBQVUsV0FBVztBQUN2QixxQkFBTyxJQUFJLFVBQVUsd0JBQXdCLENBQUM7QUFBQSxZQUNoRDtBQUVBLGdCQUFJLFlBQVksV0FBVztBQUN6QixxQkFBTyxJQUFJLFVBQVUsd0JBQXdCLENBQUM7QUFBQSxZQUNoRDtBQUVBLGdCQUFJLFVBQVUsV0FBVztBQUN2QixxQkFBTyxJQUFJSCxTQUFRLGFBQWEsV0FBVyxZQUFZLENBQUM7QUFBQSxZQUMxRDtBQUVBLGdCQUFJLEtBQUssUUFBUSxRQUFRLFFBQVEsS0FBSyxJQUFJO0FBRTFDLGdCQUFJLFFBQVEsZ0JBQWdCLFdBQVc7QUFDckMsa0JBQUksa0JBQWtCO0FBQUEsWUFDeEIsV0FBVyxRQUFRLGdCQUFnQixRQUFRO0FBQ3pDLGtCQUFJLGtCQUFrQjtBQUFBLFlBQ3hCO0FBRUEsZ0JBQUksa0JBQWtCLE9BQU8sUUFBUSxNQUFNO0FBQ3pDLGtCQUFJLGVBQWU7QUFBQSxZQUNyQjtBQUVBLG9CQUFRLFFBQVEsUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUM1QyxrQkFBSSxpQkFBaUIsTUFBTSxLQUFLO0FBQUEsWUFDbEMsQ0FBQztBQUVELGdCQUFJLFFBQVEsUUFBUTtBQUNsQixzQkFBUSxPQUFPLGlCQUFpQixTQUFTLFFBQVE7QUFFakQsa0JBQUkscUJBQXFCLFdBQVc7QUFFbEMsb0JBQUksSUFBSSxlQUFlLEdBQUc7QUFDeEIsMEJBQVEsT0FBTyxvQkFBb0IsU0FBUyxRQUFRO0FBQUEsZ0JBQ3REO0FBQUEsY0FDRjtBQUFBLFlBQ0Y7QUFFQSxnQkFBSSxLQUFLLE9BQU8sUUFBUSxjQUFjLGNBQWMsT0FBTyxRQUFRLFNBQVM7QUFBQSxVQUM5RSxDQUFDO0FBQUEsUUFDSDtBQUVBLFFBQUFJLE9BQU0sV0FBVztBQUVqQixZQUFJLENBQUNMLE1BQUssT0FBTztBQUNmLFVBQUFBLE1BQUssUUFBUUs7QUFDYixVQUFBTCxNQUFLLFVBQVVFO0FBQ2YsVUFBQUYsTUFBSyxVQUFVRztBQUNmLFVBQUFILE1BQUssV0FBV0k7QUFBQSxRQUNsQjtBQUVBLFFBQUFILFNBQVEsVUFBVUM7QUFDbEIsUUFBQUQsU0FBUSxVQUFVRTtBQUNsQixRQUFBRixTQUFRLFdBQVdHO0FBQ25CLFFBQUFILFNBQVEsUUFBUUk7QUFFaEIsZUFBTyxlQUFlSixVQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUU1RCxlQUFPQTtBQUFBLE1BRVQsRUFBRyxDQUFDLENBQUM7QUFBQSxJQUNMLEdBQUcsUUFBUTtBQUNYLGFBQVMsTUFBTSxXQUFXO0FBRTFCLFdBQU8sU0FBUyxNQUFNO0FBR3RCLFFBQUksTUFBTTtBQUNWLGNBQVUsSUFBSTtBQUNkLFlBQVEsVUFBVSxJQUFJO0FBQ3RCLFlBQVEsUUFBUSxJQUFJO0FBQ3BCLFlBQVEsVUFBVSxJQUFJO0FBQ3RCLFlBQVEsVUFBVSxJQUFJO0FBQ3RCLFlBQVEsV0FBVyxJQUFJO0FBQ3ZCLElBQUFILFFBQU8sVUFBVTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FDemlCakIsUUFBQSxnQkFBQSxnQkFBQSwwQkFBQTtBQUdPLFFBQU0sV0FBVyxTQUFDLFFBQTZCO0FBQ3BELFVBQUksT0FBTyxVQUFVO0FBRW5CLGVBQU8sT0FBTztpQkFDTCxPQUFPLE9BQU87QUFLdkIsZUFBTyxPQUFPO2FBQ1Q7QUFFTCxlQUFPLGNBQUE7O0lBRVg7QUFkYSxZQUFBLFdBQVE7Ozs7Ozs7Ozs7QUNIckIsUUFBQSxhQUFBO0FBS1MsV0FBQSxlQUFBLFNBQUEsWUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUxBLFdBQUE7SUFBUSxFQUFBLENBQUE7QUFDakIsUUFBQSx5QkFBQTtBQUltQixXQUFBLGVBQUEsU0FBQSx3QkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUpWLHVCQUFBO0lBQW9CLEVBQUEsQ0FBQTtBQUM3QixRQUFBLGVBQUE7QUFHeUMsV0FBQSxlQUFBLFNBQUEsa0JBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFIaEMsYUFBQTtJQUFjLEVBQUEsQ0FBQTtBQUN2QixRQUFBLFVBQUE7QUFFeUQsV0FBQSxlQUFBLFNBQUEsWUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUZoRCxRQUFBO0lBQVEsRUFBQSxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZqQixRQUFBLGNBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFdBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFlBQUE7QUFDQSxRQUFBLFVBQUE7QUF5QkEsUUFBTSwyQkFBMkIsVUFBQSxLQUFLLE9BQ3BDO01BQ0UsTUFBTSxRQUFBO01BQ04sV0FBVyxRQUFBO01BQ1gsUUFBUSxVQUFBLEtBQUssU0FBUyxRQUFBLFlBQVk7TUFDbEMsTUFBTSxVQUFBLEtBQUssU0FBUyxRQUFBLFVBQVU7TUFDOUIsVUFBVSxVQUFBLEtBQUssU0FBUyxRQUFBLGNBQWM7TUFDdEMsU0FBUyxVQUFBLEtBQUssU0FBUyxRQUFBLGFBQWE7TUFDcEMsZ0JBQWdCLFVBQUEsS0FBSyxTQUFTLFFBQUEsb0JBQW9CO01BQ2xELGtCQUFrQixVQUFBLEtBQUssU0FBUyxRQUFBLG9CQUFvQjtNQUNwRCxnQkFBZ0IsVUFBQSxLQUFLLFNBQVMsVUFBQSxLQUFLLFFBQU8sQ0FBRTtNQUM1QyxtQkFBbUIsVUFBQSxLQUFLLFNBQVMsVUFBQSxLQUFLLFFBQU8sQ0FBRTtPQUVqRCxFQUFFLHNCQUFzQixNQUFLLENBQUU7QUFHMUIsUUFBTSxjQUFjLFNBQUMsS0FBdUI7QUFDakQsVUFBTSxhQUFZLEdBQUEsWUFBQSxzQkFDaEIsMEJBQ0EsYUFBYTtBQUdmLGFBQU8sU0FBTyxTQUEyQjtBQUFBLGVBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUN2QywwQkFBVSxPQUFPOzs7O0FBR2YsdUJBQUEsQ0FBQSxHQUFNLElBQUksWUFBWSxFQUFFLGVBQWUsUUFBTyxDQUFFLENBQUM7O0FBQWpELGdCQUFBUSxJQUFBLEtBQUE7cUJBQ0ksUUFBUTtBQUFSLHlCQUFBLENBQUEsR0FBQSxDQUFBO0FBQ0ssdUJBQUEsQ0FBQSxHQUFNLHNCQUFzQixLQUFLLFFBQVEsSUFBSSxDQUFDOztBQUFyRCx1QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUE4Qzs7QUFFdkQsdUJBQUE7a0JBQUE7O2dCQUFBOzs7QUFFWSx1QkFBQSxDQUFBLElBQU0sR0FBQSxRQUFBLHlCQUF3QixLQUFHLEtBQUssUUFBUSxJQUFJLENBQUM7O0FBQXpELHNCQUFNQSxJQUFBLEtBQUE7QUFDWixvQkFBSSxRQUFRLHFCQUFxQixJQUFJLFNBQVMseUJBQXlCO0FBQ3JFLHlCQUFBO29CQUFBOztrQkFBQTs7QUFFRixzQkFBTTs7Ozs7Ozs7OztJQUdaO0FBdkJhLFlBQUEsY0FBVztBQXlCeEIsUUFBTSx3QkFBd0IsU0FDNUIsS0FDQSxXQUNBLFNBQW1CO0FBQW5CLFVBQUEsWUFBQSxRQUFBO0FBQUEsa0JBQUE7TUFBbUI7Ozs7Ozs7O0FBR1EscUJBQUEsQ0FBQSxHQUFNLElBQUksY0FBYyxFQUFFLFVBQVMsQ0FBRSxDQUFDOztBQUF6RCxpQ0FBbUIsR0FBQSxLQUFBO21CQUNyQixHQUFDQSxNQUFBLGlCQUFpQixZQUFNLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFO0FBQTFCLHVCQUFBLENBQUEsR0FBQSxDQUFBO0FBQ0YscUJBQUEsQ0FBQSxHQUFNLElBQUksUUFBUSxTQUFDLEdBQUM7QUFBSyx1QkFBQSxXQUFXLEdBQUcsR0FBSTtjQUFsQixDQUFtQixDQUFDOztBQUE3QyxpQkFBQSxLQUFBO0FBQ08scUJBQUEsQ0FBQSxHQUFNLHNCQUFzQixLQUFLLFdBQVcsVUFBVSxDQUFDLENBQUM7O0FBQS9ELHFCQUFBLENBQUEsR0FBTyxHQUFBLEtBQUEsQ0FBd0Q7O0FBRS9ELGVBQUEsR0FBQSxRQUFBLFVBQVMsU0FBQSxPQUFTLFdBQVMsa0JBQUEsRUFBQSxPQUFtQixPQUFPLENBQUU7QUFDdkQscUJBQUE7Z0JBQUE7O2NBQUE7Ozs7O0FBR1UscUJBQUEsQ0FBQSxJQUFNLEdBQUEsU0FBQSxnQkFDaEIsS0FDQSxTQUFPLEdBQUcsZ0JBQWM7QUFBQSx1QkFBQSxVQUFBLFFBQUEsUUFBQSxRQUFBLFdBQUE7QUFBQSx5QkFBQSxZQUFBLE1BQUEsU0FBQUEsS0FBQTtBQUN0QiwyQkFBQSxDQUFBLEdBQUEsd0JBQUEsT0FBd0IsV0FBUyxJQUFBLEVBQUEsT0FBSyxjQUFjLENBQUU7OztlQUFBLENBQ3pEOztBQUpLLG9CQUFNLEdBQUEsS0FBQTtBQUtaLG9CQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNGVixRQUFBLGNBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFVBQUE7QUFJTyxRQUFNLGNBQWMsU0FBQyxLQUF1QjtBQUNqRCxVQUFNLGFBQVksR0FBQSxZQUFBLHNCQUFxQixRQUFBLGlCQUFpQixhQUFhO0FBRXJFLGFBQU8sU0FBTyxXQUE2QjtBQUFBLGVBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUN6QywwQkFBVSxTQUFTOzs7O0FBR2pCLHVCQUFBLENBQUEsR0FBTSxJQUFJLFlBQVksRUFBRSxVQUFvQixDQUFFLENBQUM7O0FBQS9DLGdCQUFBQyxJQUFBLEtBQUE7QUFDQSx1QkFBQTtrQkFBQTs7Z0JBQUE7OztBQUVZLHVCQUFBLENBQUEsSUFBTSxHQUFBLFFBQUEseUJBQXdCLEtBQUcsS0FBSyxTQUFTLENBQUM7O0FBQXRELHNCQUFNQSxJQUFBLEtBQUE7QUFDWixzQkFBTTs7Ozs7Ozs7OztJQUdaO0FBZGEsWUFBQSxjQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ054QixRQUFBLGNBQUE7QUFFQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFVBQUE7QUFNTyxRQUFNLGdCQUFnQixTQUFDLEtBQXVCO0FBQ25ELFVBQU0sYUFBWSxHQUFBLFlBQUEsc0JBQXFCLFFBQUEsaUJBQWlCLGVBQWU7QUFFdkUsVUFBTSx5QkFBeUIsU0FBQyxRQUFXO0FBQ3pDLFlBQUksT0FBTyxVQUFVO0FBQ25CLG1CQUFrQixLQUFBLEdBQUFDLE1BQUEsT0FBTyxLQUFLLE9BQU8sUUFBUSxHQUEzQixLQUFBQSxJQUFBLFFBQUEsTUFBOEI7QUFBM0MsZ0JBQU0sTUFBR0EsSUFBQSxFQUFBO0FBQ1osZ0JBQUksT0FBTyxTQUFTLEdBQUcsTUFBTSxRQUFXO0FBQ3RDLHFCQUFPLE9BQU8sU0FBUyxHQUFHOzs7O01BSWxDO0FBRUEsYUFBTyxTQUFPLE1BQWU7QUFBQSxlQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7QUFDM0IsMEJBQVUsSUFBSTs7OztBQUdHLHVCQUFBLENBQUEsR0FBTSxJQUFJLGNBQWMsRUFBRSxXQUFXLEtBQUksQ0FBRSxDQUFDOztBQUFyRCx5QkFBU0EsSUFBQSxLQUFBO0FBQ2YsdUNBQXVCLE1BQU07QUFDN0IsdUJBQUEsQ0FBQSxHQUFPLE1BQU07OztBQUVELHVCQUFBLENBQUEsSUFBTSxHQUFBLFFBQUEseUJBQXdCLEtBQUcsS0FBSyxJQUFJLENBQUM7O0FBQWpELHNCQUFNQSxJQUFBLEtBQUE7QUFDWixzQkFBTTs7Ozs7Ozs7OztJQUdaO0FBekJhLFlBQUEsZ0JBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVDFCLFFBQUEsV0FBQTtBQU9PLFFBQU0sY0FBYyxTQUFDLEtBQXVCO0FBQ2pELGFBQU8sV0FBQTtBQUFBLGVBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7Ozs7QUFFVyx1QkFBQSxDQUFBLEdBQU0sSUFBSSxZQUFXLENBQUU7O0FBQS9CLHdCQUFRQyxJQUFBLEtBQUE7QUFPZCx1QkFBQSxDQUFBLEdBQU8sTUFBTSxJQUFJLFNBQUMsR0FBQztBQUFLLHlCQUFDLEVBQUUsTUFBTSxFQUFDO2dCQUFWLENBQWEsQ0FBQzs7O0FBRTFCLHVCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBQyxDQUFDOztBQUE3QixzQkFBTUEsSUFBQSxLQUFBO0FBQ1osc0JBQU07Ozs7Ozs7Ozs7SUFHWjtBQWhCYSxZQUFBLGNBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUHhCLFFBQUEsY0FBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsVUFBQTtBQUVBLFFBQUEsWUFBQTtBQUVBLFFBQU0sZ0NBQWdDLFVBQUEsS0FBSyxPQUN6QztNQUNFLE1BQU0sUUFBQTtNQUNOLFFBQVEsUUFBQTtPQUVWLEVBQUUsc0JBQXNCLE1BQUssQ0FBRTtBQVExQixRQUFNLG1CQUFtQixTQUFDLEtBQXVCO0FBQ3RELFVBQU0sYUFBWSxHQUFBLFlBQUEsc0JBQ2hCLCtCQUNBLGtCQUFrQjtBQUdwQixhQUFPLFNBQU8sU0FBZ0M7QUFBQSxlQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7QUFDNUMsMEJBQVUsT0FBTzs7OztBQUdmLHVCQUFBLENBQUEsR0FBTSxJQUFJLGlCQUFpQixFQUFFLHlCQUF5QixRQUFPLENBQUUsQ0FBQzs7QUFBaEUsZ0JBQUFDLElBQUEsS0FBQTtBQUNBLHVCQUFBO2tCQUFBOztnQkFBQTs7O0FBRVksdUJBQUEsQ0FBQSxJQUFNLEdBQUEsUUFBQSx5QkFBd0IsS0FBRyxLQUFLLFFBQVEsTUFBTSxDQUFDOztBQUEzRCxzQkFBTUEsSUFBQSxLQUFBO0FBQ1osc0JBQU07Ozs7Ozs7Ozs7SUFHWjtBQWpCYSxZQUFBLG1CQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQjdCLFFBQUEsY0FBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsVUFBQTtBQUtPLFFBQU0sbUJBQW1CLFNBQUMsS0FBdUI7QUFDdEQsVUFBTSxhQUFZLEdBQUEsWUFBQSxzQkFDaEIsUUFBQSxzQkFDQSxrQkFBa0I7QUFHcEIsYUFBTyxTQUFPLGdCQUE4QjtBQUFBLGVBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUMxQywwQkFBVSxjQUFjOzs7O0FBR3RCLHVCQUFBLENBQUEsR0FBTSxJQUFJLGlCQUFpQixFQUFFLGVBQThCLENBQUUsQ0FBQzs7QUFBOUQsZ0JBQUFDLElBQUEsS0FBQTtBQUNBLHVCQUFBO2tCQUFBOztnQkFBQTs7O0FBRVksdUJBQUEsQ0FBQSxJQUFNLEdBQUEsUUFBQSw4QkFBNkIsS0FBRyxLQUFLLGNBQWMsQ0FBQzs7QUFBaEUsc0JBQU1BLElBQUEsS0FBQTtBQUNaLHNCQUFNOzs7Ozs7Ozs7O0lBR1o7QUFqQmEsWUFBQSxtQkFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUDdCLFFBQUEsY0FBQTtBQUNBLFFBQUEsVUFBQTtBQUNBLFFBQUEsVUFBQTtBQVlPLFFBQU0scUJBQXFCLFNBQUMsS0FBdUI7QUFDeEQsVUFBTSxhQUFZLEdBQUEsWUFBQSxzQkFDaEIsUUFBQSxzQkFDQSxvQkFBb0I7QUFHdEIsYUFBTyxTQUFPLE1BQW9CO0FBQUEsZUFBQSxVQUFBLFFBQUEsUUFBQSxRQUFBLFdBQUE7Ozs7O0FBQ2hDLDBCQUFVLElBQUk7Ozs7QUFHRyx1QkFBQSxDQUFBLEdBQU0sSUFBSSxtQkFBbUIsRUFBRSxnQkFBZ0IsS0FBSSxDQUFFLENBQUM7O0FBQS9ELHlCQUFTQyxJQUFBLEtBQUE7QUFHZix1QkFBQSxDQUFBLEdBQU87a0JBQ0wsTUFBTSxPQUFPO2tCQUNiLE1BQU0sT0FBTztrQkFDYixRQUFRLE9BQU87a0JBQ2YsV0FBVyxPQUFPO2tCQUNsQixhQUFhLE9BQU87aUJBQ3JCOzs7QUFFVyx1QkFBQSxDQUFBLElBQU0sR0FBQSxRQUFBLDhCQUE2QixLQUFHLEtBQUssSUFBSSxDQUFDOztBQUF0RCxzQkFBTUEsSUFBQSxLQUFBO0FBQ1osc0JBQU07Ozs7Ozs7Ozs7SUFHWjtBQXpCYSxZQUFBLHFCQUFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkL0IsUUFBQSxXQUFBO0FBT08sUUFBTSxrQkFBa0IsU0FBQyxLQUF1QjtBQUNyRCxhQUFPLFdBQUE7QUFBQSxlQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7O0FBRWEsdUJBQUEsQ0FBQSxHQUFNLElBQUksZ0JBQWUsQ0FBRTs7QUFBckMsMEJBQVVDLElBQUEsS0FBQTtBQU9oQix1QkFBQSxDQUFBLEdBQU8sUUFBUSxJQUFJLFNBQUMsR0FBQztBQUFLLHlCQUFDLEVBQUUsTUFBTSxFQUFDO2dCQUFWLENBQWEsQ0FBQzs7O0FBRTVCLHVCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBQyxDQUFDOztBQUE3QixzQkFBTUEsSUFBQSxLQUFBO0FBQ1osc0JBQU07Ozs7Ozs7Ozs7SUFHWjtBQWhCYSxZQUFBLGtCQUFlOzs7Ozs7Ozs7O0FDTjVCLFFBQUEsbUJBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSxrQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLGlCQUFBO0lBQWMsRUFBQSxDQUFBO0FBRXZCLFFBQUEsZ0JBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSxlQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsY0FBQTtJQUFXLEVBQUEsQ0FBQTtBQUVwQixRQUFBLGdCQUFBO0FBQVMsV0FBQSxlQUFBLFNBQUEsZUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLGNBQUE7SUFBVyxFQUFBLENBQUE7QUFFcEIsUUFBQSxrQkFBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLGlCQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEsZ0JBQUE7SUFBYSxFQUFBLENBQUE7QUFFdEIsUUFBQSxnQkFBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLGVBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxjQUFBO0lBQVcsRUFBQSxDQUFBO0FBS3BCLFFBQUEscUJBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSxvQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLG1CQUFBO0lBQWdCLEVBQUEsQ0FBQTtBQUd6QixRQUFBLHFCQUFBO0FBQVMsV0FBQSxlQUFBLFNBQUEsb0JBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxtQkFBQTtJQUFnQixFQUFBLENBQUE7QUFHekIsUUFBQSx1QkFBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLHNCQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBQUEscUJBQUE7SUFBa0IsRUFBQSxDQUFBO0FBSzNCLFFBQUEsb0JBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSxtQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLGtCQUFBO0lBQWUsRUFBQSxDQUFBOzs7Ozs7Ozs7O0FDMUJ4QixRQUFBLFlBQUE7QUFHYSxZQUFBLDhCQUE4QixVQUFBLEtBQUssT0FDOUM7TUFDRSxhQUFhLFVBQUEsS0FBSyxPQUFPLEVBQUUsV0FBVyxFQUFDLENBQUU7TUFDekMsUUFBUSxVQUFBLEtBQUssT0FBTyxFQUFFLFdBQVcsRUFBQyxDQUFFO01BQ3BDLFdBQVcsVUFBQSxLQUFLLFNBQVMsVUFBQSxLQUFLLE9BQU8sRUFBRSxXQUFXLEVBQUMsQ0FBRSxDQUFDOzs7Ozs7TUFPdEQsVUFBVSxVQUFBLEtBQUssU0FBUyxVQUFBLEtBQUssSUFBRyxDQUFFO09BRXBDLEVBQUUsc0JBQXNCLE1BQUssQ0FBRTtBQVNwQixZQUFBLGlCQUFpQixVQUFBLEtBQUssT0FBTyxFQUFFLFdBQVcsRUFBQyxDQUFFO0FBQzdDLFlBQUEscUJBQXFCLFVBQUEsS0FBSyxNQUFNLFVBQUEsS0FBSyxPQUFNLENBQUU7QUFDN0MsWUFBQSwyQkFBMkIsVUFBQSxLQUFLLE9BQzNDO01BQ0UsU0FBUyxVQUFBLEtBQUssTUFBTSxVQUFBLEtBQUssUUFBTyxDQUFFO01BQ2xDLFFBQVEsVUFBQSxLQUFLLE1BQU0sVUFBQSxLQUFLLE9BQU0sQ0FBRTtPQUVsQyxFQUFFLHNCQUFzQixNQUFLLENBQUU7QUFFcEIsWUFBQSx1QkFBdUIsVUFBQSxLQUFLLE9BQ3ZDO01BQ0UsSUFBSSxRQUFBO01BQ0osUUFBUSxRQUFBO01BQ1IsY0FBYyxVQUFBLEtBQUssU0FBUyxRQUFBLHdCQUF3QjtNQUNwRCxVQUFVLFVBQUEsS0FBSyxTQUFTLFVBQUEsS0FBSyxPQUFPLENBQUEsR0FBSSxFQUFFLHNCQUFzQixLQUFJLENBQUUsQ0FBQztPQUV6RSxFQUFFLHNCQUFzQixNQUFLLENBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNqQyxRQUFBLFdBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFVBQUE7QUFDQSxRQUFBLFlBQUE7QUFLQSxRQUFNLGNBQWMsVUFBQSxLQUFLLE1BQU0sUUFBQSxvQkFBb0I7QUFFbkQsUUFBQTs7TUFBQSxXQUFBO0FBS0UsaUJBQUFDLGVBQVksYUFBYSxXQUFTO0FBQ2hDLGVBQUssY0FBYztBQUNuQixlQUFLLFlBQVk7QUFDakIsZUFBSyxhQUFZLEdBQUEsWUFBQSxzQkFBcUIsYUFBYSxRQUFRO1FBQzdEO0FBRU0sUUFBQUEsZUFBQSxVQUFBLE1BQU4sU0FBVSxTQUFpQzs7Ozs7O0FBQ3pDLHVCQUFLLFVBQVUsT0FBTzs7OztBQUdSLHlCQUFBLENBQUEsR0FBTSxLQUFLLFlBQVksUUFBTyxDQUFFOztBQUF0Qyx3QkFBTUMsSUFBQSxLQUFBO0FBQ1oseUJBQUEsQ0FBQSxHQUFNLElBQUksT0FBTztvQkFDZixlQUFlO3NCQUNiLFNBQVM7c0JBQ1QsV0FBVyxLQUFLOzttQkFFbkIsQ0FBQzs7QUFMRixrQkFBQUEsSUFBQSxLQUFBO0FBTUEseUJBQUE7b0JBQUE7O2tCQUFBOzs7QUFFWSx5QkFBQSxDQUFBLElBQU0sR0FBQSxTQUFBLGdCQUFlLEdBQUMsQ0FBQzs7QUFBN0Isd0JBQU1BLElBQUEsS0FBQTtBQUNaLHdCQUFNOzs7Ozs7Ozs7O0FBR1osZUFBQUQ7TUFBQSxFQTVCQTs7QUFBYSxZQUFBLGdCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZiLFFBQUEsV0FBQTtBQUNBLFFBQUEsY0FBQTtBQUVBLFFBQUEsVUFBQTtBQUVBLFFBQUEsWUFBQTtBQUVBLFFBQU0saUJBQWlCLFVBQUEsS0FBSyxNQUFNLFFBQUEsZ0JBQWdCLEVBQUUsVUFBVSxFQUFDLENBQUU7QUFRakUsUUFBQTs7TUFBQSxXQUFBO0FBS0UsaUJBQUFFLGNBQVksYUFBYSxXQUFTO0FBQ2hDLGVBQUssY0FBYztBQUNuQixlQUFLLFlBQVk7QUFDakIsZUFBSyxhQUFZLEdBQUEsWUFBQSxzQkFBcUIsZ0JBQWdCLE9BQU87UUFDL0Q7QUFFTSxRQUFBQSxjQUFBLFVBQUEsTUFBTixTQUFVLEtBQWlCOzs7Ozs7QUFDekIsdUJBQUssVUFBVSxHQUFHOzs7O0FBR0oseUJBQUEsQ0FBQSxHQUFNLEtBQUssWUFBWSxRQUFPLENBQUU7O0FBQXRDLHdCQUFNQyxJQUFBLEtBQUE7QUFDSyx5QkFBQSxDQUFBLEdBQU0sSUFBSSxNQUFNLEVBQUUsS0FBVSxXQUFXLEtBQUssVUFBUyxDQUFFLENBQUM7O0FBQW5FLDZCQUFXQSxJQUFBLEtBQUE7QUFFakIseUJBQUEsQ0FBQSxHQUFPO29CQUNMLFNBQVMsU0FBUztvQkFDbEIsV0FBVyxTQUFTO21CQUNEOzs7QUFFVCx5QkFBQSxDQUFBLElBQU0sR0FBQSxTQUFBLGdCQUFlLEdBQUMsQ0FBQzs7QUFBN0Isd0JBQU1BLElBQUEsS0FBQTtBQUNaLHdCQUFNOzs7Ozs7Ozs7O0FBR1osZUFBQUQ7TUFBQSxFQTNCQTs7QUFBYSxZQUFBLGVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZmIsUUFBQSxXQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxZQUFBO0FBRUEsUUFBQSxVQUFBO0FBWUEsUUFBTSw0QkFBNEIsVUFBQSxLQUFLLE9BQ3JDO01BQ0UsSUFBSSxRQUFBO01BQ0osUUFBUSxVQUFBLEtBQUssU0FBUyxRQUFBLGtCQUFrQjtNQUN4QyxjQUFjLFVBQUEsS0FBSyxTQUFTLFFBQUEsd0JBQXdCO01BQ3BELFVBQVUsVUFBQSxLQUFLLFNBQVMsVUFBQSxLQUFLLE9BQU8sQ0FBQSxHQUFJLEVBQUUsc0JBQXNCLEtBQUksQ0FBRSxDQUFDO09BRXpFLEVBQUUsc0JBQXNCLE1BQUssQ0FBRTtBQWFqQyxRQUFBOztNQUFBLFdBQUE7QUFLRSxpQkFBQUUsZUFBWSxhQUFhLFdBQVM7QUFDaEMsZUFBSyxjQUFjO0FBQ25CLGVBQUssWUFBWTtBQUNqQixlQUFLLGFBQVksR0FBQSxZQUFBLHNCQUFxQiwyQkFBMkIsUUFBUTtRQUMzRTtBQUVNLFFBQUFBLGVBQUEsVUFBQSxNQUFOLFNBQVUsU0FBeUI7Ozs7OztBQUNqQyx1QkFBSyxVQUFVLE9BQU87QUFFaEIsbUNBQWlCO29CQUNyQixJQUFJLFFBQVEsSUFBSTtvQkFDaEIsUUFBUSxRQUFRLFFBQVE7b0JBQ3hCLGNBQWMsUUFBUSxjQUFjO29CQUNwQyxhQUFhLFFBQVEsVUFBVTs7Ozs7QUFJbkIseUJBQUEsQ0FBQSxHQUFNLEtBQUssWUFBWSxRQUFPLENBQUU7O0FBQXRDLHdCQUFNQyxJQUFBLEtBQUE7QUFDWix5QkFBQSxDQUFBLEdBQU0sSUFBSSxPQUFPO29CQUNmLGVBQWEsU0FBQSxTQUFBLENBQUEsR0FBTyxjQUFjLEdBQUEsRUFBRSxXQUFXLEtBQUssVUFBUyxDQUFBO21CQUM5RCxDQUFDOztBQUZGLGtCQUFBQSxJQUFBLEtBQUE7QUFHQSx5QkFBQTtvQkFBQTs7a0JBQUE7OztBQUVZLHlCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBQyxDQUFDOztBQUE3Qix3QkFBTUEsSUFBQSxLQUFBO0FBQ1osd0JBQU07Ozs7Ozs7Ozs7QUFHWixlQUFBRDtNQUFBLEVBaENBOztBQUFhLFlBQUEsZ0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENiLFFBQUEsV0FBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsVUFBQTtBQU9BLFFBQUEsWUFBQTtBQUdBLFFBQU0sU0FBUztNQUNiLE1BQU0sVUFBQSxLQUFLLE9BQU07TUFDakIsZUFBZSxVQUFBLEtBQUssU0FBUyxVQUFBLEtBQUssUUFBTyxDQUFFO01BQzNDLGlCQUFpQixVQUFBLEtBQUssU0FBUyxVQUFBLEtBQUssUUFBTyxDQUFFO01BQzdDLFFBQVEsVUFBQSxLQUFLLFNBQVMsVUFBQSxLQUFLLE9BQU8sQ0FBQSxDQUFFLENBQUM7O0FBR3ZDLFFBQU0sa0JBQWtCLFVBQUEsS0FBSyxPQUFNLFNBQUEsU0FBQSxDQUFBLEdBRTVCLE1BQU0sR0FBQSxFQUNULElBQUksUUFBQSxnQkFDSixRQUFRLFVBQUEsS0FBSyxTQUFTLFVBQUEsS0FBSyxNQUFLLENBQUUsR0FDbEMsY0FBYyxVQUFBLEtBQUssU0FBUyxVQUFBLEtBQUssTUFBSyxDQUFFLEVBQUMsQ0FBQSxHQUUzQyxFQUFFLHNCQUFzQixNQUFLLENBQUU7QUFHakMsUUFBTSxzQkFBc0IsVUFBQSxLQUFLLE9BQU0sU0FBQSxTQUFBLENBQUEsR0FFaEMsTUFBTSxHQUFBLEVBQ1QsUUFBUSxRQUFBLG9CQUNSLGNBQWMsVUFBQSxLQUFLLFNBQVMsUUFBQSx3QkFBd0IsR0FDcEQsSUFBSSxVQUFBLEtBQUssU0FBUyxVQUFBLEtBQUssTUFBSyxDQUFFLEVBQUMsQ0FBQSxHQUVqQyxFQUFFLHNCQUFzQixNQUFLLENBQUU7QUFHakMsUUFBTSxjQUFjLFVBQUEsS0FBSyxNQUFNLENBQUMsaUJBQWlCLG1CQUFtQixDQUFDO0FBc0JyRSxRQUFBOztNQUFBLFdBQUE7QUFLRSxpQkFBQUUsY0FBWSxhQUFhLFdBQVM7QUFDaEMsZUFBSyxjQUFjO0FBQ25CLGVBQUssWUFBWTtBQUNqQixlQUFLLGFBQVksR0FBQSxZQUFBLHNCQUFxQixhQUFhLE9BQU87UUFDNUQ7QUFFTSxRQUFBQSxjQUFBLFVBQUEsTUFBTixTQUFVLE9BQW1COzs7Ozs7QUFDM0IsdUJBQUssVUFBVSxLQUFLOzs7O0FBR04seUJBQUEsQ0FBQSxHQUFNLEtBQUssWUFBWSxRQUFPLENBQUU7O0FBQXRDLHdCQUFNQyxJQUFBLEtBQUE7QUFDSSx5QkFBQSxDQUFBLEdBQU0sSUFBSSxNQUFNO29CQUM5QixjQUFZLFNBQUEsU0FBQSxDQUFBLEdBQU8sS0FBSyxHQUFBLEVBQUUsV0FBVyxLQUFLLFVBQVMsQ0FBQTttQkFDcEQsQ0FBQzs7QUFGSSw0QkFBVUEsSUFBQSxLQUFBO0FBR2hCLHlCQUFBLENBQUEsR0FBTztvQkFDTCxTQUFTLFFBQVE7b0JBQ2pCLFdBQVcsS0FBSzttQkFDakI7OztBQUVXLHlCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBQyxDQUFDOztBQUE3Qix3QkFBTUEsSUFBQSxLQUFBO0FBQ1osd0JBQU07Ozs7Ozs7Ozs7QUFHWixlQUFBRDtNQUFBLEVBNUJBOztBQUFhLFlBQUEsZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1RGIsUUFBQSxXQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxVQUFBO0FBS08sUUFBTSxZQUFZLFNBQ3ZCLGFBQ0EsV0FBaUI7QUFFakIsVUFBTSxhQUFZLEdBQUEsWUFBQSxzQkFBcUIsUUFBQSxnQkFBZ0IsV0FBVztBQUVsRSxhQUFPLFNBQU8sU0FBaUI7QUFBQSxlQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7QUFDN0IsMEJBQVUsT0FBTzs7OztBQUdILHVCQUFBLENBQUEsR0FBTSxZQUFZLFFBQU8sQ0FBRTs7QUFBakMsc0JBQU1FLElBQUEsS0FBQTtBQUNaLHVCQUFBLENBQUEsR0FBTSxJQUFJLFFBQVEsRUFBRSxlQUFlLEVBQUUsS0FBSyxDQUFDLE9BQU8sR0FBRyxVQUFTLEVBQUUsQ0FBRSxDQUFDOztBQUFuRSxnQkFBQUEsSUFBQSxLQUFBO0FBQ0EsdUJBQUE7a0JBQUE7O2dCQUFBOzs7QUFFWSx1QkFBQSxDQUFBLElBQU0sR0FBQSxTQUFBLGdCQUFlLEdBQUMsQ0FBQzs7QUFBN0Isc0JBQU1BLElBQUEsS0FBQTtBQUNaLHNCQUFNOzs7Ozs7Ozs7O0lBR1o7QUFsQmEsWUFBQSxZQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1B0QixRQUFBLFdBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLFlBQUE7QUFFQSxRQUFBLFVBQUE7QUFHQSxRQUFNLDZCQUE2QixVQUFBLEtBQUssTUFBTSxRQUFBLGNBQWM7QUFFNUQsUUFBTSwyQkFBMkIsVUFBQSxLQUFLLE9BQ3BDLENBQUEsR0FDQSxFQUFFLHNCQUFzQixNQUFNLGVBQWUsRUFBQyxDQUFFO0FBR2xELFFBQU0sbUJBQW1CLFVBQUEsS0FBSyxNQUFNO01BQ2xDO01BQ0E7S0FDRDtBQVFNLFFBQU0sYUFBYSxTQUN4QixhQUNBLFdBQWlCO0FBRWpCLFVBQU0sYUFBWSxHQUFBLFlBQUEsc0JBQXFCLGtCQUFrQixZQUFZO0FBRXJFLGFBQU8sU0FBTyxTQUEwQjtBQUFBLGVBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUN0QywwQkFBVSxPQUFPO0FBRVgsaUNBQWdDLENBQUE7QUFFdEMsb0JBQUksTUFBTSxRQUFRLE9BQU8sR0FBRztBQUMxQixpQ0FBZSxNQUFNO3VCQUNoQjtBQUNMLGlDQUFlLFNBQVM7Ozs7O0FBSVosdUJBQUEsQ0FBQSxHQUFNLFlBQVksUUFBTyxDQUFFOztBQUFqQyxzQkFBTUMsSUFBQSxLQUFBO0FBQ1osdUJBQUEsQ0FBQSxHQUFNLElBQUksUUFBUSxFQUFFLGVBQWEsU0FBQSxTQUFBLENBQUEsR0FBTyxjQUFjLEdBQUEsRUFBRSxVQUFTLENBQUEsRUFBRSxDQUFFLENBQUM7O0FBQXRFLGdCQUFBQSxJQUFBLEtBQUE7Ozs7QUFFWSx1QkFBQSxDQUFBLElBQU0sR0FBQSxTQUFBLGdCQUFlLEdBQUMsQ0FBQzs7QUFBN0Isc0JBQU1BLElBQUEsS0FBQTtBQUNaLHNCQUFNOzs7Ozs7Ozs7O0lBR1o7QUF6QmEsWUFBQSxhQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCdkIsUUFBQSxXQUFBO0FBR08sUUFBTSxZQUFZLFNBQ3ZCLGFBQ0EsV0FBaUI7QUFFakIsYUFBTyxXQUFBO0FBQUEsZUFBQSxVQUFBLFFBQUEsUUFBQSxRQUFBLFdBQUE7Ozs7OztBQUVTLHVCQUFBLENBQUEsR0FBTSxZQUFZLFFBQU8sQ0FBRTs7QUFBakMsc0JBQU1DLElBQUEsS0FBQTtBQUNaLHVCQUFBLENBQUEsR0FBTSxJQUFJLFFBQVEsRUFBRSxlQUFlLEVBQUUsV0FBVyxNQUFNLFVBQVMsRUFBRSxDQUFFLENBQUM7O0FBQXBFLGdCQUFBQSxJQUFBLEtBQUE7QUFDQSx1QkFBQTtrQkFBQTs7Z0JBQUE7OztBQUVZLHVCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBQyxDQUFDOztBQUE3QixzQkFBTUEsSUFBQSxLQUFBO0FBQ1osc0JBQU07Ozs7Ozs7Ozs7SUFHWjtBQWRhLFlBQUEsWUFBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIdEIsUUFBQSxXQUFBO0FBQ0EsUUFBQSxjQUFBO0FBQ0EsUUFBQSxZQUFBO0FBY0EsUUFBTSxrQ0FBa0MsVUFBQSxLQUFLLE9BQzNDO01BQ0UsUUFBUSxVQUFBLEtBQUssU0FBUyxVQUFBLEtBQUssT0FBTyxDQUFBLEdBQUksRUFBRSxzQkFBc0IsS0FBSSxDQUFFLENBQUM7T0FFdkUsRUFBRSxzQkFBc0IsTUFBSyxDQUFFO0FBSTFCLFFBQU0scUJBQXFCLFNBQUMsYUFBcUM7QUFDdEUsVUFBTSxhQUFZLEdBQUEsWUFBQSxzQkFDaEIsaUNBQ0Esb0JBQW9CO0FBR3RCLGFBQU8sU0FDTCxTQUFtQztBQUFBLGVBQUEsVUFBQSxRQUFBLFFBQUEsUUFBQSxXQUFBOzs7OztBQUVuQyxvQkFBSSxTQUFTO0FBQ1gsNEJBQVUsT0FBTzs7Ozs7QUFJTCx1QkFBQSxDQUFBLEdBQU0sWUFBWSxRQUFPLENBQUU7O0FBQWpDLHNCQUFNQyxJQUFBLEtBQUE7QUFDSSx1QkFBQSxDQUFBLEdBQU0sSUFBSSxtQkFBbUI7a0JBQzNDLDJCQUF5QixTQUFBLENBQUEsR0FBTyxPQUFPO2lCQUN4QyxDQUFDOztBQUZJLDBCQUFVQSxJQUFBLEtBQUE7QUFJViwrQkFBZTtrQkFDbkIsWUFBWSxDQUFBO2tCQUNaLFdBQVcsUUFBUTtrQkFDbkIsZUFBZSxRQUFRO2tCQUN2QixrQkFBa0IsUUFBUTs7QUFFNUIsb0JBQUksUUFBUSxZQUFZO0FBQ3RCLHVCQUFXLE9BQU8sUUFBUSxZQUFZO0FBQ3BDLGlDQUFhLFdBQVcsR0FBRyxJQUFJO3NCQUM3QixhQUFhLFFBQVEsV0FBVyxHQUFHLEVBQUU7Ozs7QUFLM0MsdUJBQUEsQ0FBQSxHQUFPLFlBQVk7OztBQUVQLHVCQUFBLENBQUEsSUFBTSxHQUFBLFNBQUEsZ0JBQWUsR0FBQyxDQUFDOztBQUE3QixzQkFBTUEsSUFBQSxLQUFBO0FBQ1osc0JBQU07Ozs7Ozs7Ozs7SUFHWjtBQXZDYSxZQUFBLHFCQUFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Qi9CLFFBQUEsV0FBQTtBQU9BLFFBQUEsVUFBQTtBQUthLFlBQUEscUJBQXNCLFdBQUE7QUFBQSxVQUFBLFFBQUE7QUFDakMsVUFBTSxhQUFhLENBQUE7QUFFbkIsVUFBTSxrQkFBa0IsU0FDdEIsU0FBOEI7QUFBQSxlQUFBLFVBQUEsT0FBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7O0FBRXRCLHlCQUF3QixRQUFPLFFBQXZCLGNBQWdCLFFBQU87QUFDakMsZ0JBQUFDLFVBQVEsR0FBQSxRQUFBLFVBQVMsT0FBTztBQUN4QixnQkFBQUMsTUFBbUIsb0JBQW9CLGFBQWEsTUFBTSxHQUF4RCxNQUFHQSxJQUFBLEtBQUUsVUFBT0EsSUFBQTs7OztBQUlQLHVCQUFBLENBQUEsR0FBTUQsT0FBTSxLQUFLLE9BQU8sQ0FBQzs7QUFBcEMsMkJBQVcsR0FBQSxLQUFBOzs7O0FBT1gsb0JBQUksZUFBYSxXQUFXO0FBQzFCLHdCQUFNLElBQUksU0FBQSwyQkFDUiwwREFBQSxPQUEwRCxLQUFHLG1MQUFBLENBQW1MO3VCQUU3TztBQUNMLHdCQUFNLElBQUksU0FBQSw4QkFBOEIsS0FBSyxHQUFDOzs7O3NCQUk5QyxTQUFTLFVBQVU7QUFBbkIseUJBQUEsQ0FBQSxHQUFBLENBQUE7QUFDSSxxQkFBQSxTQUFBOztrQkFDSixRQUFRLFNBQVM7a0JBQ2pCOztBQUNTLHVCQUFBLENBQUEsR0FBTSxTQUFTLEtBQUksQ0FBRTs7QUFIaEMsc0JBQU0sR0FBQSxNQUFBLFFBQUEsRUFHSixHQUFBLFVBQVMsR0FBQSxLQUFBOzs7QUFNSix1QkFBQSxDQUFBLEdBQU0sU0FBUyxLQUFJLENBQUU7O0FBQTVCLHVCQUFPLEdBQUEsS0FBQTs7OztxQkFFRyxTQUFBLGdDQUErQjs7O2tCQUN2QztrQkFDQSxTQUFTO2dCQUFNO0FBQ2YsdUJBQUEsQ0FBQSxHQUFNLFNBQVMsS0FBSSxDQUFFOztBQUh2QixzQkFBTSxLQUFBLEdBQUEsTUFBSSxTQUFBLGlDQUErQixHQUFBLE9BQUEsQ0FHdkMsR0FBQSxLQUFBLEdBQ0EsdUVBQXVFLENBQUEsQ0FBQSxHQUFBOztxQkFJdkUsQ0FBQyxLQUFLO0FBQU4seUJBQUEsQ0FBQSxHQUFBLEVBQUE7cUJBQ1EsU0FBQSxnQ0FBK0I7OztrQkFDdkM7a0JBQ0EsU0FBUztnQkFBTTtBQUNmLHVCQUFBLENBQUEsR0FBTSxTQUFTLEtBQUksQ0FBRTs7QUFIdkIsc0JBQU0sS0FBQSxHQUFBLE1BQUksU0FBQSxpQ0FBK0IsR0FBQSxPQUFBLENBR3ZDLEdBQUEsS0FBQSxHQUNBLDZFQUE2RSxDQUFBLENBQUEsR0FBQTs7QUFJakYsdUJBQUEsQ0FBQSxHQUFPLEtBQUssWUFBWTs7Ozs7QUFJMUIsVUFBTSxzQkFBc0IsU0FDMUIsYUFDQSxRQUFjO0FBRWQsWUFBTSxNQUFNLHNCQUFBLE9BQXNCLGFBQVcsNkJBQUE7QUFDN0MsWUFBTSxVQUFVO1VBQ2QsUUFBUTtVQUNSLFNBQVM7WUFDUCxnQkFBZ0I7WUFDaEIsV0FBVztZQUNYLGVBQWMsR0FBQSxRQUFBLGdCQUFlLEtBQUs7OztBQUd0QyxlQUFPLEVBQUUsS0FBSyxRQUFPO01BQ3ZCO0FBRUEsVUFBTSxNQUFNLFNBQUMsUUFBTTtBQUFLLGVBQUEsR0FBQSxPQUFHLE9BQU8sUUFBTSxHQUFBLEVBQUEsT0FBSSxPQUFPLFdBQVc7TUFBdEM7QUFFeEIsYUFBTztRQUNMLGNBQWMsU0FBZ0IsUUFBNkI7Ozs7OztBQUNuRCw2QkFBVyxJQUFJLE1BQU07d0JBQ3ZCLFlBQVk7QUFBWiwyQkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUNGLHlCQUFBLENBQUEsR0FBTyxXQUFXLFFBQVEsQ0FBQzs7QUFFVCx5QkFBQSxDQUFBLEdBQU0sZ0JBQWdCLE1BQU0sQ0FBQzs7QUFBekMsOEJBQVlDLElBQUEsS0FBQTtBQUNsQiw2QkFBVyxRQUFRLElBQUk7QUFDdkIseUJBQUEsQ0FBQSxHQUFPLFNBQVM7Ozs7O1FBSXBCLFFBQVEsV0FBQTtBQUNOLG1CQUFrQixLQUFBLEdBQUFBLE1BQUEsT0FBTyxLQUFLLFVBQVUsR0FBdEIsS0FBQUEsSUFBQSxRQUFBLE1BQXlCO0FBQXRDLGdCQUFNLFFBQUdBLElBQUEsRUFBQTtBQUNaLG1CQUFPLFdBQVcsS0FBRzs7UUFFekI7UUFFQSxNQUFNLFNBQUMsUUFBUSxXQUFTO0FBQ3RCLGNBQU0sV0FBVyxJQUFJLE1BQU07QUFDM0IscUJBQVcsUUFBUSxJQUFJO1FBQ3pCOztJQUVKLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakhGLFFBQUEsZ0NBQUE7QUFLQSxRQUFBLFVBQUE7QUFDQSxRQUFBLHVCQUFBO0FBRUEsUUFBTSxXQUFXLFNBQUMsUUFBK0IsV0FBaUI7QUFDaEUsYUFBQSxXQUFBLE9BQVcsV0FBUyxHQUFBLEVBQUEsT0FBSSxPQUFPLFdBQVMsT0FBQSxFQUFBLE9BQVEsT0FBTyxhQUFXLGNBQUE7SUFBbEU7QUFFRixRQUFBOztNQUFBLFdBQUE7QUFLRSxpQkFBQUMsMEJBQVksUUFBK0IsV0FBaUI7QUFDMUQsZUFBSyxTQUFTO0FBQ2QsZUFBSyxZQUFZO1FBQ25CO0FBRU0sUUFBQUEsMEJBQUEsVUFBQSxVQUFOLFdBQUE7Ozs7OztBQUNFLHNCQUFJLEtBQUssa0JBQWtCO0FBQ3pCLDJCQUFBLENBQUEsR0FBTyxLQUFLLGdCQUFnQjs7dUJBRzFCLEtBQUssT0FBTztBQUFaLDJCQUFBLENBQUEsR0FBQSxDQUFBO0FBQ0YsdUJBQUssbUJBQW1CLEtBQUssNEJBQzNCLEtBQUssUUFDTCxLQUFLLFNBQVM7OztBQUdoQixrQkFBQUMsTUFBQSxLQUFLO0FBQW1CLHlCQUFBLENBQUEsR0FBTSxxQkFBQSxtQkFBbUIsYUFDL0MsS0FBSyxNQUFNLENBQ1o7O0FBRkQsa0JBQUFBLElBQVksWUFBWSxHQUFBLEtBQUE7QUFHeEIsdUJBQUssbUJBQW1CLEtBQUssNEJBQzNCLEtBQUssUUFDTCxLQUFLLFNBQVM7OztBQUlsQix5QkFBQSxDQUFBLEdBQU8sS0FBSyxnQkFBZ0I7Ozs7O0FBRzlCLFFBQUFELDBCQUFBLFVBQUEsOEJBQUEsU0FBNEIsUUFBUSxXQUFTO0FBQzNDLGNBQU0sK0JBQXdEO1lBQzVELFVBQVUsU0FBUyxRQUFRLFNBQVM7WUFDcEMsUUFBUSxPQUFPO1lBQ2Ysc0JBQW9CLFFBQUE7WUFDcEIsU0FBUztjQUNQLGVBQWMsR0FBQSxRQUFBLGdCQUFlLEtBQUs7O1lBRXBDLFdBQVUsR0FBQSxRQUFBLFVBQVMsTUFBTTs7QUFHM0IsY0FBTSxxQkFBcUIsSUFBSSw4QkFBQSxjQUFjLDRCQUE0QjtBQUN6RSxjQUFNLG1CQUFtQixJQUFJLDhCQUFBLG9CQUFvQixrQkFBa0I7QUFFbkUsaUJBQU87UUFDVDtBQUNGLGVBQUFBO01BQUEsRUFqREE7O0FBQWEsWUFBQSwyQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaYixRQUFBLFdBQUE7QUFDQSxRQUFBLFVBQUE7QUFFQSxRQUFBLFdBQUE7QUFFQSxRQUFBLFVBQUE7QUFFQSxRQUFBLGNBQUE7QUFDQSxRQUFBLGVBQUE7QUFDQSxRQUFBLGNBQUE7QUFDQSxRQUFBLHVCQUFBO0FBQ0EsUUFBQSw2QkFBQTtBQWdCQSxRQUFBLFVBQUE7QUFBUyxXQUFBLGVBQUEsU0FBQSwrQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQUFBLFFBQUE7SUFBMkIsRUFBQSxDQUFBO0FBMEJwQyxRQUFBOztNQUFBLFdBQUE7QUF1SEUsaUJBQUFFLE9BQ0UsV0FDQSxRQUNBLFdBQWM7QUFBZCxjQUFBLGNBQUEsUUFBQTtBQUFBLHdCQUFBO1VBQWM7QUFFZCxlQUFLLFNBQVM7QUFDZCxlQUFLLFNBQVM7WUFDWixPQUFPO1lBQ1A7O0FBR0YsY0FBTSxjQUFjLElBQUksMkJBQUEseUJBQXlCLFFBQVEsU0FBUztBQUVsRSxlQUFLLGFBQVksR0FBQSxZQUFBLFdBQVUsYUFBYSxTQUFTO0FBQ2pELGVBQUssY0FBYSxHQUFBLGFBQUEsWUFBVyxhQUFhLFNBQVM7QUFDbkQsZUFBSyxhQUFZLEdBQUEsWUFBQSxXQUFVLGFBQWEsU0FBUztBQUNqRCxlQUFLLHNCQUFxQixHQUFBLHFCQUFBLG9CQUFtQixXQUFXO0FBRXhELGVBQUssZ0JBQWdCLElBQUksUUFBQSxhQUFnQixhQUFhLFNBQVM7QUFDL0QsZUFBSyxnQkFBZ0IsSUFBSSxRQUFBLGFBQWdCLGFBQWEsU0FBUztBQUMvRCxlQUFLLGlCQUFpQixJQUFJLFNBQUEsY0FBaUIsYUFBYSxTQUFTO0FBQ2pFLGVBQUssaUJBQWlCLElBQUksU0FBQSxjQUFpQixhQUFhLFNBQVM7UUFDbkU7QUFhQSxRQUFBQSxPQUFBLFVBQUEsWUFBQSxTQUFVLFdBQWlCO0FBQ3pCLGlCQUFPLElBQUlBLE9BQVMsS0FBSyxPQUFPLE9BQU8sS0FBSyxRQUFRLFNBQVM7UUFDL0Q7QUFzQk0sUUFBQUEsT0FBQSxVQUFBLFNBQU4sU0FBYSxNQUE4Qjs7Ozs7QUFDbEMseUJBQUEsQ0FBQSxHQUFNLEtBQUssZUFBZSxJQUFJLElBQUksQ0FBQzs7QUFBMUMseUJBQUEsQ0FBQSxHQUFPQyxJQUFBLEtBQUEsQ0FBbUM7Ozs7O0FBZ0J0QyxRQUFBRCxPQUFBLFVBQUEsUUFBTixTQUFZLFNBQXFCOzs7OztBQUN4Qix5QkFBQSxDQUFBLEdBQU0sS0FBSyxjQUFjLElBQUksT0FBTyxDQUFDOztBQUE1Qyx5QkFBQSxDQUFBLEdBQU9DLElBQUEsS0FBQSxDQUFxQzs7Ozs7QUFzQnhDLFFBQUFELE9BQUEsVUFBQSxRQUFOLFNBQVksU0FBcUI7Ozs7O0FBQ3hCLHlCQUFBLENBQUEsR0FBTSxLQUFLLGNBQWMsSUFBSSxPQUFPLENBQUM7O0FBQTVDLHlCQUFBLENBQUEsR0FBT0MsSUFBQSxLQUFBLENBQXFDOzs7OztBQVd4QyxRQUFBRCxPQUFBLFVBQUEsU0FBTixTQUFhLFNBQXlCOzs7OztBQUM3Qix5QkFBQSxDQUFBLEdBQU0sS0FBSyxlQUFlLElBQUksT0FBTyxDQUFDOztBQUE3Qyx5QkFBQSxDQUFBLEdBQU9DLElBQUEsS0FBQSxDQUFzQzs7Ozs7QUFFakQsZUFBQUQ7TUFBQSxFQXpPQTs7QUFBYSxZQUFBLFFBQUE7Ozs7Ozs7Ozs7QUNwRGIsUUFBQSxnQ0FBQTtBQUlBLFFBQUEsWUFBQTtBQVdBLFFBQUEsV0FBQTtBQUlBLFFBQUEsU0FBQTtBQUNBLFFBQUEsY0FBQTtBQUNBLFFBQUEsVUFBQTtBQVVBLFFBQUFFOztNQUFBLFdBQUE7QUFlRSxpQkFBQUEsVUFBWSxTQUErQjtBQUN6QyxjQUFJLFlBQVksUUFBVztBQUN6QixzQkFBVSxLQUFLLHVCQUFzQjs7QUFHdkMsZUFBSyxnQkFBZ0IsT0FBTztBQUU1QixlQUFLLFNBQVM7QUFFTixjQUFBLFNBQXdCLFFBQU8sUUFBdkIsY0FBZ0IsUUFBTztBQUN2QyxjQUFNLGlCQUFpQixzQkFBQSxPQUFzQixhQUFXLGNBQUE7QUFDeEQsY0FBTSxZQUF1RDtZQUMzRCxVQUFVO1lBQ1Y7WUFDQSxzQkFBb0IsUUFBQTtZQUNwQixTQUFTO2NBQ1AsZUFBYyxHQUFBLFFBQUEsZ0JBQWUsS0FBSzs7WUFFcEMsV0FBVSxHQUFBLFFBQUEsVUFBUyxPQUFPOztBQUU1QixjQUFNLE1BQU0sSUFBSSw4QkFBQSxtQkFBbUIsSUFBSSw4QkFBQSxjQUFpQixTQUFTLENBQUM7QUFFbEUsZUFBSyxpQkFBZ0IsR0FBQSxVQUFBLGVBQWMsR0FBRztBQUN0QyxlQUFLLGVBQWMsR0FBQSxVQUFBLGFBQVksR0FBRztBQUNsQyxlQUFLLGVBQWMsR0FBQSxVQUFBLGFBQVksR0FBRztBQUNsQyxlQUFLLGVBQWMsR0FBQSxVQUFBLGFBQVksR0FBRztBQUNsQyxlQUFLLGtCQUFpQixHQUFBLFVBQUEsZ0JBQWUsR0FBRztBQUV4QyxlQUFLLG9CQUFtQixHQUFBLFVBQUEsa0JBQWlCLEdBQUc7QUFDNUMsZUFBSyxtQkFBa0IsR0FBQSxVQUFBLGlCQUFnQixHQUFHO0FBQzFDLGVBQUssc0JBQXFCLEdBQUEsVUFBQSxvQkFBbUIsR0FBRztBQUNoRCxlQUFLLG9CQUFtQixHQUFBLFVBQUEsa0JBQWlCLEdBQUc7UUFDOUM7QUFhQSxRQUFBQSxVQUFBLFVBQUEseUJBQUEsV0FBQTtBQUNFLGNBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxLQUFLO0FBQzVCLGtCQUFNLElBQUksU0FBQSx5Q0FDUiwrSkFBK0o7O0FBSW5LLGNBQU0sb0JBQW9CLENBQUE7QUFDMUIsY0FBTSxvQkFBb0I7WUFDeEIsYUFBYTtZQUNiLFFBQVE7O0FBRVYsY0FBTSxjQUE2QixDQUFBO0FBQ25DLG1CQUE0QixLQUFBLEdBQUFDLE1BQUEsT0FBTyxRQUFRLGlCQUFpQixHQUFoQyxLQUFBQSxJQUFBLFFBQUEsTUFBbUM7QUFBcEQsZ0JBQUEsS0FBQUEsSUFBQSxFQUFBLEdBQUMsTUFBRyxHQUFBLENBQUEsR0FBRSxTQUFNLEdBQUEsQ0FBQTtBQUNyQixnQkFBTSxRQUFRLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFDckMsZ0JBQUksQ0FBQyxPQUFPO0FBQ1YsMEJBQVksS0FBSyxNQUFNOztBQUV6Qiw4QkFBa0IsR0FBRyxJQUFJOztBQUUzQixjQUFJLFlBQVksU0FBUyxHQUFHO0FBQzFCLGtCQUFNLElBQUksU0FBQSwyQkFDUiw4TUFBQSxPQUE4TSxZQUFZLEtBQ3hOLElBQUksR0FDTCxHQUFBLENBQUc7O0FBSVIsY0FBTSxvQkFBb0IsRUFBRSxXQUFXLHNCQUFxQjtBQUM1RCxtQkFBNEIsS0FBQSxHQUFBLEtBQUEsT0FBTyxRQUFRLGlCQUFpQixHQUFoQyxLQUFBLEdBQUEsUUFBQSxNQUFtQztBQUFwRCxnQkFBQSxLQUFBLEdBQUEsRUFBQSxHQUFDLE1BQUcsR0FBQSxDQUFBLEdBQUUsU0FBTSxHQUFBLENBQUE7QUFDckIsZ0JBQU0sUUFBUSxRQUFRLElBQUksTUFBTTtBQUNoQyxnQkFBSSxVQUFVLFFBQVc7QUFDdkIsZ0NBQWtCLEdBQUcsSUFBSTs7O0FBSTdCLGlCQUFPO1FBQ1Q7QUF1TEEsUUFBQUQsVUFBQSxVQUFBLGtCQUFBLFNBQWdCLFNBQThCO0FBQzVDLFdBQUEsR0FBQSxZQUFBLGdCQUNFLDRCQUNBLE9BQUEsMkJBQTJCLEVBQzNCLE9BQU87UUFDWDtBQUtBLFFBQUFBLFVBQUEsVUFBQSxZQUFBLFdBQUE7QUFDRSxpQkFBTyxLQUFLO1FBQ2Q7QUFTQSxRQUFBQSxVQUFBLFVBQUEsUUFBQSxTQUFpRCxXQUFpQjtBQUNoRSxpQkFBTyxJQUFJLE9BQUEsTUFBUyxXQUFXLEtBQUssTUFBTTtRQUM1QztBQU1BLFFBQUFBLFVBQUEsVUFBQSxRQUFBLFNBQWlELFdBQWlCO0FBQ2hFLGlCQUFPLEtBQUssTUFBUyxTQUFTO1FBQ2hDO0FBRUEsUUFBQUEsVUFBQSxVQUFBLGdCQUFBLFdBQUE7QUFHRSxrQkFBUSxJQUFJLHdDQUF3QztBQUNwRCxrQkFBUSxJQUNOLDRCQUFBLE9BQTRCLEtBQUssT0FBTyxhQUFXLHVDQUFBLEVBQUEsT0FBd0MsS0FBSyxPQUFPLFFBQU0saUNBQUEsQ0FBaUM7UUFFbEo7QUFDRixlQUFBQTtNQUFBLEVBalVBOztBQUFhLFlBQUEsV0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJBLFlBQUEsWUFBWSxrREFBa0QsUUFBUSxRQUFRLEVBQUU7QUFlN0YsUUFBQTs7TUFBQSxXQUFBO0FBQ0ksaUJBQUFFLGVBQW9CLGVBQTJDO0FBQTNDLGNBQUEsa0JBQUEsUUFBQTtBQUFBLDRCQUFBLENBQUE7VUFBMkM7QUFBM0MsZUFBQSxnQkFBQTtRQUE4QztBQUVsRSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxVQUFNO2VBQVYsU0FBVyxlQUE0QjtBQUNuQyxpQkFBSyxnQkFBZ0I7VUFDekI7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxZQUFRO2VBQVosV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYyxZQUFZLE9BQU8sS0FBSyxjQUFjLFdBQVcsUUFBQTtVQUMvRTs7OztBQUVBLGVBQUEsZUFBSUEsZUFBQSxXQUFBLFlBQVE7ZUFBWixXQUFBO0FBQ0ksbUJBQU8sS0FBSyxjQUFjO1VBQzlCOzs7O0FBRUEsZUFBQSxlQUFJQSxlQUFBLFdBQUEsY0FBVTtlQUFkLFdBQUE7QUFDSSxtQkFBTyxLQUFLLGNBQWMsY0FBYyxDQUFBO1VBQzVDOzs7O0FBRUEsZUFBQSxlQUFJQSxlQUFBLFdBQUEsd0JBQW9CO2VBQXhCLFdBQUE7QUFDSSxtQkFBTyxLQUFLLGNBQWMsd0JBQXdCO1VBQ3REOzs7O0FBRUEsZUFBQSxlQUFJQSxlQUFBLFdBQUEsWUFBUTtlQUFaLFdBQUE7QUFDSSxtQkFBTyxLQUFLLGNBQWM7VUFDOUI7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxZQUFRO2VBQVosV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYztVQUM5Qjs7OztBQUVBLGVBQUEsZUFBSUEsZUFBQSxXQUFBLFVBQU07ZUFBVixXQUFBO0FBQ0ksZ0JBQU0sU0FBUyxLQUFLLGNBQWM7QUFDbEMsZ0JBQUksUUFBUTtBQUNSLHFCQUFPLE9BQU8sV0FBVyxhQUFhLFNBQVMsV0FBQTtBQUFNLHVCQUFBO2NBQUE7O0FBRXpELG1CQUFPO1VBQ1g7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxlQUFXO2VBQWYsV0FBQTtBQUFBLGdCQUFBLFFBQUE7QUFDSSxnQkFBTSxjQUFjLEtBQUssY0FBYztBQUN2QyxnQkFBSSxhQUFhO0FBQ2IscUJBQU8sT0FBTyxnQkFBZ0IsYUFBYSxjQUFjLFdBQUE7QUFBQSx1QkFBQSxVQUFBLE9BQUEsUUFBQSxRQUFBLFdBQUE7QUFBQSx5QkFBQSxZQUFBLE1BQUEsU0FBQUMsS0FBQTtBQUFZLDJCQUFBLENBQUEsR0FBQSxXQUFXOzs7OztBQUVwRixtQkFBTztVQUNYOzs7O0FBRUEsZUFBQSxlQUFJRCxlQUFBLFdBQUEsV0FBTztlQUFYLFdBQUE7QUFDSSxtQkFBTyxLQUFLLGNBQWM7VUFDOUI7Ozs7QUFFQSxlQUFBLGVBQUlBLGVBQUEsV0FBQSxlQUFXO2VBQWYsV0FBQTtBQUNJLG1CQUFPLEtBQUssY0FBYztVQUM5Qjs7OztBQUNKLGVBQUFBO01BQUEsRUF0REE7O0FBQWEsWUFBQSxnQkFBQTtBQXdEQSxZQUFBLGdCQUFnQixJQUFJLGNBQWE7QUFLOUMsUUFBQTs7TUFBQSxXQUFBO0FBSUksaUJBQUFFLFNBQXNCLGVBQTZCO0FBQTdCLGNBQUEsa0JBQUEsUUFBQTtBQUFBLDRCQUFnQixRQUFBO1VBQWE7QUFBbkQsY0FBQSxRQUFBO0FBQXNCLGVBQUEsZ0JBQUE7QUEwRWQsZUFBQSxXQUFXLFNBQU8sS0FBYSxNQUFpQjtBQUFBLG1CQUFBLFVBQUEsT0FBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7QUFDaEQsa0NBQWMsRUFBRSxLQUFLLEtBQUk7NEJBQ0pELE1BQUEsS0FBSzs7OzBCQUFMLEtBQUFBLElBQUE7QUFBZSw2QkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUE3QixpQ0FBVUEsSUFBQSxFQUFBO3lCQUNiLFdBQVc7QUFBWCw2QkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUNjLDJCQUFBLENBQUEsR0FBTSxXQUFXLElBQUcsU0FBQSxFQUM5QixPQUFPLEtBQUssU0FBUSxHQUNqQixXQUFXLENBQUEsQ0FDaEI7O0FBSEYsa0NBQWMsR0FBQSxLQUFBLEtBR1I7OztBQUxXOzs7QUFRckIsK0JBQWlDOzs7O0FBRXRCLDJCQUFBLENBQUEsSUFBTyxLQUFLLGNBQWMsWUFBWSxPQUFPLFlBQVksS0FBSyxZQUFZLElBQUksQ0FBQzs7QUFBMUYsK0JBQVcsR0FBQSxLQUFBOzs7OzRCQUVjLEtBQUEsS0FBSzs7OzBCQUFMLEtBQUEsR0FBQTtBQUFlLDZCQUFBLENBQUEsR0FBQSxFQUFBO0FBQTdCLGlDQUFVLEdBQUEsRUFBQTt5QkFDYixXQUFXO0FBQVgsNkJBQUEsQ0FBQSxHQUFBLEVBQUE7QUFDVywyQkFBQSxDQUFBLEdBQU0sV0FBVyxRQUFRO3NCQUNoQyxPQUFPLEtBQUs7c0JBQ1osS0FBSyxZQUFZO3NCQUNqQixNQUFNLFlBQVk7c0JBQ2xCLE9BQU87c0JBQ1AsVUFBVSxXQUFXLFNBQVMsTUFBSyxJQUFLO3FCQUMzQyxDQUFDOztBQU5GLCtCQUFXLEdBQUEsS0FBQSxLQU1MOzs7QUFSVzs7O0FBV3pCLHdCQUFJLGFBQWEsUUFBVztBQUMxQiwwQkFBSSxlQUFhLE9BQU87QUFDdEIsOEJBQU0sSUFBSSxXQUFXLEtBQUcsZ0ZBQWdGOzZCQUNuRztBQUNMLDhCQUFNOzs7Ozs0QkFJVyxLQUFBLEtBQUs7OzswQkFBTCxLQUFBLEdBQUE7QUFBZSw2QkFBQSxDQUFBLEdBQUEsRUFBQTtBQUE3QixpQ0FBVSxHQUFBLEVBQUE7eUJBQ2IsV0FBVztBQUFYLDZCQUFBLENBQUEsR0FBQSxFQUFBO0FBQ1csMkJBQUEsQ0FBQSxHQUFNLFdBQVcsS0FBSztzQkFDN0IsT0FBTyxLQUFLO3NCQUNaLEtBQUssWUFBWTtzQkFDakIsTUFBTSxZQUFZO3NCQUNsQixVQUFVLFNBQVMsTUFBSztxQkFDM0IsQ0FBQzs7QUFMRiwrQkFBVyxHQUFBLEtBQUEsS0FLTDs7O0FBUFc7OztBQVV6QiwyQkFBQSxDQUFBLEdBQU8sUUFBUTs7Ozs7QUFwSGYsZUFBSyxhQUFhLGNBQWM7UUFDcEM7QUFFQSxRQUFBQyxTQUFBLFVBQUEsaUJBQUEsV0FBQTs7QUFBMkMsY0FBQSxjQUFBLENBQUE7bUJBQUEsS0FBQSxHQUFBLEtBQUEsVUFBQSxRQUFBLE1BQTRCO0FBQTVCLHdCQUFBLEVBQUEsSUFBQSxVQUFBLEVBQUE7O0FBQ3ZDLGNBQU0sT0FBTyxLQUFLLE1BQUs7QUFDdkIsZUFBSyxjQUFhRCxNQUFBLEtBQUssWUFBVyxPQUFNLE1BQUFBLEtBQUksV0FBVztBQUN2RCxpQkFBTztRQUNYO0FBRUEsUUFBQUMsU0FBQSxVQUFBLG9CQUFBLFdBQUE7QUFBOEMsY0FBQSxpQkFBQSxDQUFBO21CQUFBLEtBQUEsR0FBQSxLQUFBLFVBQUEsUUFBQSxNQUEyQztBQUEzQywyQkFBQSxFQUFBLElBQUEsVUFBQSxFQUFBOztBQUMxQyxjQUFNLGNBQWMsZUFBZSxJQUFJLFNBQUMsS0FBRztBQUFLLG1CQUFDLEVBQUUsSUFBRztVQUFOLENBQVM7QUFDekQsaUJBQU8sS0FBSyxlQUFjLE1BQW5CLE1BQTBCLFdBQVc7UUFDaEQ7QUFFQSxRQUFBQSxTQUFBLFVBQUEscUJBQUEsV0FBQTtBQUErQyxjQUFBLGtCQUFBLENBQUE7bUJBQUEsS0FBQSxHQUFBLEtBQUEsVUFBQSxRQUFBLE1BQTZDO0FBQTdDLDRCQUFBLEVBQUEsSUFBQSxVQUFBLEVBQUE7O0FBQzNDLGNBQU0sY0FBYyxnQkFBZ0IsSUFBSSxTQUFDLE1BQUk7QUFBSyxtQkFBQyxFQUFFLEtBQUk7VUFBUCxDQUFVO0FBQzVELGlCQUFPLEtBQUssZUFBYyxNQUFuQixNQUEwQixXQUFXO1FBQ2hEO0FBRWdCLFFBQUFBLFNBQUEsVUFBQSxVQUFoQixTQUF3QixTQUFzQixlQUFrRDs7Ozs7O0FBQ3RFLHlCQUFBLENBQUEsR0FBTSxLQUFLLGtCQUFrQixTQUFTLGFBQWEsQ0FBQzs7QUFBcEUsa0JBQUFELE1BQWdCLEdBQUEsS0FBQSxHQUFkLE1BQUdBLElBQUEsS0FBRSxPQUFJQSxJQUFBO0FBQ0EseUJBQUEsQ0FBQSxHQUFNLEtBQUssU0FBUyxLQUFLLElBQUksQ0FBQzs7QUFBekMsNkJBQVcsR0FBQSxLQUFBO0FBQ2pCLHNCQUFJLGFBQWEsU0FBUyxVQUFVLE9BQU8sU0FBUyxTQUFTLE1BQU07QUFDL0QsMkJBQUEsQ0FBQSxHQUFPLFFBQVE7O0FBRW5CLHdCQUFNLElBQUksY0FBYyxVQUFVLGlDQUFpQzs7Ozs7QUFHekQsUUFBQUMsU0FBQSxVQUFBLG9CQUFkLFNBQWdDLFNBQXNCLGVBQWtEOzs7Ozs7O0FBQ2hHLHdCQUFNLEtBQUssY0FBYyxXQUFXLFFBQVE7QUFDaEQsc0JBQUksUUFBUSxVQUFVLFVBQWEsT0FBTyxLQUFLLFFBQVEsS0FBSyxFQUFFLFdBQVcsR0FBRztBQUl4RSwyQkFBTyxNQUFNLEtBQUssY0FBYyxxQkFBcUIsUUFBUSxLQUFLOztBQUdoRSw0QkFBVSxPQUFPLE9BQU8sQ0FBQSxHQUFJLEtBQUssY0FBYyxTQUFTLFFBQVEsT0FBTztBQUM3RSx5QkFBTyxLQUFLLE9BQU8sRUFBRSxRQUFRLFNBQUEsS0FBRztBQUFJLDJCQUFBLFFBQVEsR0FBRyxNQUFNLFNBQVksT0FBTyxRQUFRLEdBQUcsSUFBSSxDQUFBO2tCQUFuRCxDQUFxRDtBQUVuRixtQ0FDRixPQUFPLGtCQUFrQixhQUNuQixnQkFDQSxXQUFBO0FBQUEsMkJBQUEsVUFBQSxPQUFBLFFBQUEsUUFBQSxXQUFBO0FBQUEsNkJBQUEsWUFBQSxNQUFBLFNBQUFELEtBQUE7QUFBWSwrQkFBQSxDQUFBLEdBQUEsYUFBYTs7OztBQUU3QiwrQkFBYTtvQkFDZixRQUFRLFFBQVE7b0JBQ2hCO29CQUNBLE1BQU0sUUFBUTtvQkFDZCxhQUFhLEtBQUssY0FBYzs7c0NBSTdCLFVBQVUsQ0FBQTtBQUNULHlCQUFBLENBQUEsR0FBTSxlQUFlO29CQUNyQixNQUFNO29CQUNOO21CQUNILENBQUM7O0FBTEEsbUNBQWMsU0FBQSxNQUFBLFFBQUFBLElBQUEsT0FBQSxDQUVaLEdBQUEsS0FBQSxDQUdELENBQUEsQ0FBQTtBQUdELHlCQUFJLFNBQUEsU0FBQSxDQUFBLEdBQ0gsY0FBYyxHQUFBLEVBQ2pCLE1BQ0ksV0FBVyxlQUFlLElBQUksS0FDOUIsZUFBZSxnQkFBZ0IsbUJBQy9CLE9BQU8sZUFBZSxJQUFJLElBQ3BCLGVBQWUsT0FDZixLQUFLLFVBQVUsZUFBZSxJQUFJLEVBQUMsQ0FBQTtBQUdqRCx5QkFBQSxDQUFBLEdBQU8sRUFBRSxLQUFLLEtBQUksQ0FBRTs7Ozs7QUFxRGhCLFFBQUFDLFNBQUEsVUFBQSxRQUFSLFdBQUE7QUFDSSxjQUFNLGNBQWMsS0FBSztBQUN6QixjQUFNLE9BQU8sSUFBSSxZQUFZLEtBQUssYUFBYTtBQUMvQyxlQUFLLGFBQWEsS0FBSyxXQUFXLE1BQUs7QUFDdkMsaUJBQU87UUFDWDtBQUNKLGVBQUFBO01BQUEsRUF0SUE7O0FBQWEsWUFBQSxVQUFBO0FBd0liLGFBQVMsT0FBTyxPQUFVO0FBQ3RCLGFBQU8sT0FBTyxTQUFTLGVBQWUsaUJBQWlCO0lBQzNEO0FBRUEsYUFBUyxXQUFXLE9BQVU7QUFDMUIsYUFBTyxPQUFPLGFBQWEsZUFBZSxpQkFBaUI7SUFDL0Q7QUFFQSxRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUFtQyxrQkFBQUMsZ0JBQUEsTUFBQTtBQUUvQixpQkFBQUEsZUFBbUIsVUFBb0IsS0FBWTtBQUFuRCxjQUFBLFFBQ0ksT0FBQSxLQUFBLE1BQU0sR0FBRyxLQUFDO0FBREssZ0JBQUEsV0FBQTtBQURWLGdCQUFBLE9BQXdCOztRQUdqQztBQUNKLGVBQUFBO01BQUEsRUFMbUMsS0FBSzs7QUFBM0IsWUFBQSxnQkFBQTtBQU9iLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQWdDLGtCQUFBQyxhQUFBLE1BQUE7QUFFNUIsaUJBQUFBLFlBQW1CLE9BQWMsS0FBWTtBQUE3QyxjQUFBLFFBQ0ksT0FBQSxLQUFBLE1BQU0sR0FBRyxLQUFDO0FBREssZ0JBQUEsUUFBQTtBQURWLGdCQUFBLE9BQXFCOztRQUc5QjtBQUNKLGVBQUFBO01BQUEsRUFMZ0MsS0FBSzs7QUFBeEIsWUFBQSxhQUFBO0FBT2IsUUFBQTs7TUFBQSxTQUFBLFFBQUE7QUFBbUMsa0JBQUFDLGdCQUFBLE1BQUE7QUFFL0IsaUJBQUFBLGVBQW1CLE9BQWUsS0FBWTtBQUE5QyxjQUFBLFFBQ0ksT0FBQSxLQUFBLE1BQU0sR0FBRyxLQUFDO0FBREssZ0JBQUEsUUFBQTtBQURWLGdCQUFBLE9BQXdCOztRQUdqQztBQUNKLGVBQUFBO01BQUEsRUFMbUMsS0FBSzs7QUFBM0IsWUFBQSxnQkFBQTtBQU9BLFlBQUEscUJBQXFCO01BQzlCLEtBQUs7TUFDTCxLQUFLO01BQ0wsS0FBSztNQUNMLE9BQU87O0FBNEJYLGFBQWdCLE9BQU8sTUFBVyxLQUFXO0FBQ3pDLFVBQU0sUUFBUSxLQUFLLEdBQUc7QUFDdEIsYUFBTyxVQUFVLFFBQVEsVUFBVTtJQUN2QztBQUhBLFlBQUEsU0FBQTtBQUtBLGFBQWdCLFlBQVksUUFBbUIsUUFBbUI7QUFBbkIsVUFBQSxXQUFBLFFBQUE7QUFBQSxpQkFBQTtNQUFtQjtBQUM5RCxhQUFPLE9BQU8sS0FBSyxNQUFNLEVBQ3BCLElBQUksU0FBQSxLQUFHO0FBQUksZUFBQSxxQkFBcUIsS0FBSyxPQUFPLEdBQUcsR0FBRyxNQUFNO01BQTdDLENBQThDLEVBQ3pELE9BQU8sU0FBQSxNQUFJO0FBQUksZUFBQSxLQUFLLFNBQVM7TUFBZCxDQUFlLEVBQzlCLEtBQUssR0FBRztJQUNqQjtBQUxBLFlBQUEsY0FBQTtBQU9BLGFBQVMscUJBQXFCLEtBQWEsT0FBbUosV0FBc0I7QUFBdEIsVUFBQSxjQUFBLFFBQUE7QUFBQSxvQkFBQTtNQUFzQjtBQUNoTixVQUFNLFVBQVUsYUFBYSxVQUFVLFNBQVMsSUFBQSxPQUFJLEtBQUcsR0FBQSxJQUFNO0FBQzdELFVBQUksaUJBQWlCLE9BQU87QUFDeEIsWUFBTSxhQUFhLE1BQU0sSUFBSSxTQUFBLGFBQVc7QUFBSSxpQkFBQSxtQkFBbUIsT0FBTyxXQUFXLENBQUM7UUFBdEMsQ0FBdUMsRUFDOUUsS0FBSyxJQUFBLE9BQUksbUJBQW1CLE9BQU8sR0FBQyxHQUFBLENBQUc7QUFDNUMsZUFBTyxHQUFBLE9BQUcsbUJBQW1CLE9BQU8sR0FBQyxHQUFBLEVBQUEsT0FBSSxVQUFVOztBQUV2RCxVQUFJLGlCQUFpQixLQUFLO0FBQ3RCLFlBQU0sZUFBZSxNQUFNLEtBQUssS0FBSztBQUNyQyxlQUFPLHFCQUFxQixLQUFLLGNBQWMsU0FBUzs7QUFFNUQsVUFBSSxpQkFBaUIsTUFBTTtBQUN2QixlQUFPLEdBQUEsT0FBRyxtQkFBbUIsT0FBTyxHQUFDLEdBQUEsRUFBQSxPQUFJLG1CQUFtQixNQUFNLFlBQVcsQ0FBRSxDQUFDOztBQUVwRixVQUFJLGlCQUFpQixRQUFRO0FBQ3pCLGVBQU8sWUFBWSxPQUFvQixPQUFPOztBQUVsRCxhQUFPLEdBQUEsT0FBRyxtQkFBbUIsT0FBTyxHQUFDLEdBQUEsRUFBQSxPQUFJLG1CQUFtQixPQUFPLEtBQUssQ0FBQyxDQUFDO0lBQzlFO0FBRUEsYUFBZ0IsVUFBVSxNQUFXLElBQXNCO0FBQ3pELGFBQU8sT0FBTyxLQUFLLElBQUksRUFBRSxPQUN2QixTQUFDLEtBQUssS0FBRzs7QUFBSyxlQUFBLFNBQUEsU0FBQSxDQUFBLEdBQU0sR0FBRyxJQUFBSixNQUFBLENBQUEsR0FBQUEsSUFBRyxHQUFHLElBQUcsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFDQSxJQUFBO01BQS9CLEdBQ2QsQ0FBQSxDQUFFO0lBRU47QUFMQSxZQUFBLFlBQUE7QUFPQSxhQUFnQixlQUFlLFVBQW1CO0FBQzlDLGVBQXNCLEtBQUEsR0FBQSxhQUFBLFVBQUEsS0FBQSxXQUFBLFFBQUEsTUFBVTtBQUEzQixZQUFNLFVBQU8sV0FBQSxFQUFBO0FBQ2QsWUFBSSwwQkFBMEIsUUFBUSxhQUFhO0FBQy9DLGlCQUFPOzs7QUFHZixhQUFPO0lBQ1g7QUFQQSxZQUFBLGlCQUFBO0FBaURBLFFBQUE7O01BQUEsV0FBQTtBQUNJLGlCQUFBSyxpQkFBbUIsS0FBdUIsYUFBbUU7QUFBbkUsY0FBQSxnQkFBQSxRQUFBO0FBQUEsMEJBQUEsU0FBdUMsV0FBYztBQUFLLHFCQUFBO1lBQUE7VUFBUztBQUExRixlQUFBLE1BQUE7QUFBdUIsZUFBQSxjQUFBO1FBQXNFO0FBRTFHLFFBQUFBLGlCQUFBLFVBQUEsUUFBTixXQUFBOzs7Ozs7QUFDVyxrQkFBQUwsTUFBQSxLQUFLO0FBQVkseUJBQUEsQ0FBQSxHQUFNLEtBQUssSUFBSSxLQUFJLENBQUU7O0FBQTdDLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxNQUFBLE1BQUksQ0FBYSxHQUFBLEtBQUEsQ0FBcUIsQ0FBQSxDQUFDOzs7OztBQUV0RCxlQUFBSztNQUFBLEVBTkE7O0FBQWEsWUFBQSxrQkFBQTtBQVFiLFFBQUE7O01BQUEsV0FBQTtBQUNJLGlCQUFBQyxpQkFBbUIsS0FBYTtBQUFiLGVBQUEsTUFBQTtRQUFnQjtBQUU3QixRQUFBQSxpQkFBQSxVQUFBLFFBQU4sV0FBQTs7O0FBQ0kscUJBQUEsQ0FBQSxHQUFPLE1BQVM7Ozs7QUFFeEIsZUFBQUE7TUFBQSxFQU5BOztBQUFhLFlBQUEsa0JBQUE7QUFRYixRQUFBOztNQUFBLFdBQUE7QUFDSSxpQkFBQUMsaUJBQW1CLEtBQWE7QUFBYixlQUFBLE1BQUE7UUFBZ0I7QUFFN0IsUUFBQUEsaUJBQUEsVUFBQSxRQUFOLFdBQUE7Ozs7O0FBQ1cseUJBQUEsQ0FBQSxHQUFNLEtBQUssSUFBSSxLQUFJLENBQUU7O0FBQTVCLHlCQUFBLENBQUEsR0FBT1AsSUFBQSxLQUFBLENBQXFCOzs7OztBQUMvQjtBQUNMLGVBQUFPO01BQUEsRUFOQTs7QUFBYSxZQUFBLGtCQUFBO0FBUWIsUUFBQTs7TUFBQSxXQUFBO0FBQ0ksaUJBQUFDLGlCQUFtQixLQUFhO0FBQWIsZUFBQSxNQUFBO1FBQWdCO0FBRTdCLFFBQUFBLGlCQUFBLFVBQUEsUUFBTixXQUFBOzs7OztBQUNXLHlCQUFBLENBQUEsR0FBTSxLQUFLLElBQUksS0FBSSxDQUFFOztBQUE1Qix5QkFBQSxDQUFBLEdBQU9SLElBQUEsS0FBQSxDQUFxQjs7Ozs7QUFDL0I7QUFDTCxlQUFBUTtNQUFBLEVBTkE7O0FBQWEsWUFBQSxrQkFBQTs7Ozs7Ozs7OztBQ2xZYixRQUFBLFlBQUE7QUF3QkEsYUFBZ0IsNkJBQTZCLE9BQWE7QUFDdEQsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsK0JBQUE7QUFNQSxhQUFnQiwyQkFBMkIsTUFBUztBQUNoRCxhQUFPLGdDQUFnQyxNQUFNLEtBQUs7SUFDdEQ7QUFGQSxZQUFBLDZCQUFBO0FBSUEsYUFBZ0IsZ0NBQWdDLE1BQVcscUJBQTRCO0FBQ25GLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxTQUFTLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7UUFDNUQsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFROztJQUVyRTtBQVRBLFlBQUEsa0NBQUE7QUFXQSxhQUFnQix5QkFBeUIsT0FBaUM7QUFDdEUsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxVQUFVLE1BQU07UUFDaEIsVUFBVSxNQUFNOztJQUV4QjtBQVpBLFlBQUEsMkJBQUE7Ozs7Ozs7Ozs7QUM3Q0EsUUFBQSxZQUFBO0FBOEJBLGFBQWdCLHlCQUF5QixPQUFhO0FBQ2xELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLDJCQUFBO0FBTUEsYUFBZ0IsdUJBQXVCLE1BQVM7QUFDNUMsYUFBTyw0QkFBNEIsTUFBTSxLQUFLO0lBQ2xEO0FBRkEsWUFBQSx5QkFBQTtBQUlBLGFBQWdCLDRCQUE0QixNQUFXLHFCQUE0QjtBQUMvRSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sTUFBTSxJQUFJLFNBQVksS0FBSyxNQUFNO1FBQ3ZELFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxVQUFVLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7O0lBRXJFO0FBVkEsWUFBQSw4QkFBQTtBQVlBLGFBQWdCLHFCQUFxQixPQUE2QjtBQUM5RCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFFBQVEsTUFBTTtRQUNkLFFBQVEsTUFBTTtRQUNkLFVBQVUsTUFBTTs7SUFFeEI7QUFiQSxZQUFBLHVCQUFBOzs7Ozs7Ozs7O0FDNUJBLGFBQWdCLGtDQUFrQyxPQUFhO0FBQzNELFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLFVBQVU7QUFDckMsbUJBQWEsY0FBYyxZQUFZO0FBRXZDLGFBQU87SUFDWDtBQU5BLFlBQUEsb0NBQUE7QUFRQSxhQUFnQixnQ0FBZ0MsTUFBUztBQUNyRCxhQUFPLHFDQUFxQyxNQUFNLEtBQUs7SUFDM0Q7QUFGQSxZQUFBLGtDQUFBO0FBSUEsYUFBZ0IscUNBQXFDLE1BQVcscUJBQTRCO0FBQ3hGLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxRQUFRLEtBQUssTUFBTTtRQUNuQixVQUFVLEtBQUssUUFBUTs7SUFFL0I7QUFUQSxZQUFBLHVDQUFBO0FBV0EsYUFBZ0IsOEJBQThCLE9BQXNDO0FBQ2hGLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxNQUFNO1FBQ2QsVUFBVSxNQUFNOztJQUV4QjtBQVpBLFlBQUEsZ0NBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQ0EsUUFBQSx1QkFBQTtBQWVBLGFBQWdCLGlDQUFpQyxNQUFTO0FBQ3RELGFBQU8sc0NBQXNDLE1BQU0sS0FBSztJQUM1RDtBQUZBLFlBQUEsbUNBQUE7QUFJQSxhQUFnQixzQ0FBc0MsTUFBVyxxQkFBNEI7QUFDekYsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBQSxTQUFBLENBQUEsSUFBWSxHQUFBLHFCQUFBLGlDQUFnQyxNQUFNLElBQUksQ0FBQztJQUMzRDtBQUxBLFlBQUEsd0NBQUE7QUFPQSxhQUFnQiwrQkFBK0IsT0FBdUM7QUFDbEYsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUdYLFdBQUksR0FBQSxxQkFBQSw4QkFBNkIsS0FBSyxHQUFHO0FBQ3JDLGdCQUFPLEdBQUEscUJBQUEsMEJBQXlCLEtBQTJCOztBQUcvRCxhQUFPLENBQUE7SUFDWDtBQWJBLFlBQUEsaUNBQUE7Ozs7Ozs7Ozs7QUMxQkEsUUFBQSxZQUFBO0FBRUEsUUFBQSw2QkFBQTtBQXdGQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxVQUFVO0FBQ3JDLG1CQUFhLGNBQWMsZUFBZTtBQUUxQyxhQUFPO0lBQ1g7QUFOQSxZQUFBLDBCQUFBO0FBUUEsYUFBZ0Isc0JBQXNCLE1BQVM7QUFDM0MsYUFBTywyQkFBMkIsTUFBTSxLQUFLO0lBQ2pEO0FBRkEsWUFBQSx3QkFBQTtBQUlBLGFBQWdCLDJCQUEyQixNQUFXLHFCQUE0QjtBQUM5RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxLQUFLLE1BQU07UUFDbkIsYUFBYSxLQUFLLFdBQVc7UUFDN0IsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sWUFBWSxJQUFJLFNBQVksS0FBSyxZQUFZO1FBQ3hFLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTtRQUM3RCxRQUFRLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxNQUFNLElBQUksU0FBWSxLQUFLLE1BQU07UUFDdkQsWUFBWSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sVUFBVSxJQUFJLFNBQVksS0FBSyxVQUFVO1FBQ25FLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTtRQUM3RCxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxVQUFVLElBQUksU0FBWSxLQUFLLFVBQVU7UUFDbEUsZUFBZSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sY0FBYyxJQUFJLFVBQVksR0FBQSwyQkFBQSxrQ0FBaUMsS0FBSyxjQUFjLENBQUM7UUFDaEgsa0JBQWtCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxpQkFBaUIsSUFBSSxTQUFZLEtBQUssaUJBQWlCO1FBQ3ZGLG9CQUFvQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sbUJBQW1CLElBQUksU0FBWSxLQUFLLG1CQUFtQjs7SUFFckc7QUFsQkEsWUFBQSw2QkFBQTtBQW9CQSxhQUFnQixvQkFBb0IsT0FBNEI7QUFDNUQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxRQUFRLE1BQU07UUFDZCxhQUFhLE1BQU07UUFDbkIsY0FBYyxNQUFNO1FBQ3BCLFVBQVUsTUFBTTtRQUNoQixRQUFRLE1BQU07UUFDZCxZQUFZLE1BQU07UUFDbEIsVUFBVSxNQUFNO1FBQ2hCLFlBQVksTUFBTTtRQUNsQixpQkFBZ0IsR0FBQSwyQkFBQSxnQ0FBK0IsTUFBTSxXQUFXO1FBQ2hFLG1CQUFtQixNQUFNO1FBQ3pCLHFCQUFxQixNQUFNOztJQUVuQztBQXJCQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7O0FDMUhBLFFBQUEsWUFBQTtBQXNDQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwwQkFBQTtBQU1BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILE9BQU8sRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLEtBQUssSUFBSSxTQUFZLEtBQUssS0FBSztRQUNwRCxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7UUFDdEUsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXO1FBQ3RFLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTs7SUFFckU7QUFYQSxZQUFBLDZCQUFBO0FBYUEsYUFBZ0Isb0JBQW9CLE9BQTRCO0FBQzVELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsT0FBTyxNQUFNO1FBQ2IsYUFBYSxNQUFNO1FBQ25CLGFBQWEsTUFBTTtRQUNuQixVQUFVLE1BQU07O0lBRXhCO0FBZEEsWUFBQSxzQkFBQTs7Ozs7Ozs7OztBQzdEQSxRQUFBLFlBQUE7QUFvQkEsYUFBZ0Isb0NBQW9DLE9BQWE7QUFDN0QsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsc0NBQUE7QUFNQSxhQUFnQixrQ0FBa0MsTUFBUztBQUN2RCxhQUFPLHVDQUF1QyxNQUFNLEtBQUs7SUFDN0Q7QUFGQSxZQUFBLG9DQUFBO0FBSUEsYUFBZ0IsdUNBQXVDLE1BQVcscUJBQTRCO0FBQzFGLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxVQUFVLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxRQUFRLElBQUksU0FBWSxLQUFLLFFBQVE7O0lBRXJFO0FBUkEsWUFBQSx5Q0FBQTtBQVVBLGFBQWdCLGdDQUFnQyxPQUF3QztBQUNwRixVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFVBQVUsTUFBTTs7SUFFeEI7QUFYQSxZQUFBLGtDQUFBOzs7Ozs7Ozs7O0FDeENBLFFBQUEsWUFBQTtBQW1CQSxhQUFnQiwyQkFBMkIsT0FBYTtBQUNwRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSw2QkFBQTtBQU1BLGFBQWdCLHlCQUF5QixNQUFTO0FBQzlDLGFBQU8sOEJBQThCLE1BQU0sS0FBSztJQUNwRDtBQUZBLFlBQUEsMkJBQUE7QUFJQSxhQUFnQiw4QkFBOEIsTUFBVyxxQkFBNEI7QUFDakYsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGVBQWUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGFBQWEsSUFBSSxTQUFZLEtBQUssYUFBYTs7SUFFcEY7QUFSQSxZQUFBLGdDQUFBO0FBVUEsYUFBZ0IsdUJBQXVCLE9BQStCO0FBQ2xFLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsZUFBZSxNQUFNOztJQUU3QjtBQVhBLFlBQUEseUJBQUE7Ozs7Ozs7Ozs7QUN2Q0EsUUFBQSxZQUFBO0FBRUEsUUFBQSxxQkFBQTtBQTJDQSxhQUFnQixxQ0FBcUMsT0FBYTtBQUM5RCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSx1Q0FBQTtBQU1BLGFBQWdCLG1DQUFtQyxNQUFTO0FBQ3hELGFBQU8sd0NBQXdDLE1BQU0sS0FBSztJQUM5RDtBQUZBLFlBQUEscUNBQUE7QUFJQSxhQUFnQix3Q0FBd0MsTUFBVyxxQkFBNEI7QUFDM0YsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGNBQWMsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFlBQVksSUFBSSxVQUFhLEdBQUEsVUFBQSxXQUFVLEtBQUssWUFBWSxHQUFHLG1CQUFBLHdCQUF3QjtRQUMvRyxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7UUFDdEUsaUJBQWlCLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxlQUFlLElBQUksU0FBWSxLQUFLLGVBQWU7UUFDbEYsb0JBQW9CLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxrQkFBa0IsSUFBSSxTQUFZLEtBQUssa0JBQWtCOztJQUVuRztBQVhBLFlBQUEsMENBQUE7QUFhQSxhQUFnQixpQ0FBaUMsT0FBeUM7QUFDdEYsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxjQUFjLE1BQU0sZUFBZSxTQUFZLFVBQWEsR0FBQSxVQUFBLFdBQVUsTUFBTSxZQUFZLG1CQUFBLHNCQUFzQjtRQUM5RyxhQUFhLE1BQU07UUFDbkIsaUJBQWlCLE1BQU07UUFDdkIsb0JBQW9CLE1BQU07O0lBRWxDO0FBZEEsWUFBQSxtQ0FBQTs7Ozs7Ozs7OztBQzVDQSxhQUFnQix1QkFBdUIsT0FBYTtBQUNoRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxhQUFhO0FBQ3hDLG1CQUFhLGNBQWMsWUFBWTtBQUV2QyxhQUFPO0lBQ1g7QUFOQSxZQUFBLHlCQUFBO0FBUUEsYUFBZ0IscUJBQXFCLE1BQVM7QUFDMUMsYUFBTywwQkFBMEIsTUFBTSxLQUFLO0lBQ2hEO0FBRkEsWUFBQSx1QkFBQTtBQUlBLGFBQWdCLDBCQUEwQixNQUFXLHFCQUE0QjtBQUM3RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBVyxLQUFLLFNBQVM7UUFDekIsVUFBVSxLQUFLLFFBQVE7O0lBRS9CO0FBVEEsWUFBQSw0QkFBQTtBQVdBLGFBQWdCLG1CQUFtQixPQUEyQjtBQUMxRCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsTUFBTTtRQUNqQixVQUFVLE1BQU07O0lBRXhCO0FBWkEsWUFBQSxxQkFBQTs7Ozs7Ozs7OztBQy9DQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlCQUFBO0FBeUNBLGFBQWdCLGlCQUFpQixPQUFhO0FBQzFDLFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLFFBQVE7QUFDbkMsbUJBQWEsY0FBYyxZQUFZO0FBRXZDLGFBQU87SUFDWDtBQU5BLFlBQUEsbUJBQUE7QUFRQSxhQUFnQixlQUFlLE1BQVM7QUFDcEMsYUFBTyxvQkFBb0IsTUFBTSxLQUFLO0lBQzFDO0FBRkEsWUFBQSxpQkFBQTtBQUlBLGFBQWdCLG9CQUFvQixNQUFXLHFCQUE0QjtBQUN2RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxLQUFLLElBQUk7UUFDZixVQUFVLEtBQUssUUFBUTtRQUN2QixnQkFBZ0IsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGNBQWMsSUFBSSxVQUFZLEdBQUEsZUFBQSxzQkFBcUIsS0FBSyxjQUFjLENBQUM7UUFDckcsWUFBWSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sVUFBVSxJQUFJLFNBQVksS0FBSyxVQUFVOztJQUUzRTtBQVhBLFlBQUEsc0JBQUE7QUFhQSxhQUFnQixhQUFhLE9BQXFCO0FBQzlDLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxNQUFNO1FBQ1osVUFBVSxNQUFNO1FBQ2hCLGlCQUFnQixHQUFBLGVBQUEsb0JBQW1CLE1BQU0sWUFBWTtRQUNyRCxZQUFZLE1BQU07O0lBRTFCO0FBZEEsWUFBQSxlQUFBOzs7Ozs7Ozs7O0FDcEVBLFFBQUEsWUFBQTtBQUVBLFFBQUEsV0FBQTtBQTZCQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwwQkFBQTtBQU1BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxVQUFhLEdBQUEsVUFBQSxXQUFVLEtBQUssU0FBUyxHQUFHLFNBQUEsY0FBYztRQUM1RixhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7O0lBRTlFO0FBVEEsWUFBQSw2QkFBQTtBQVdBLGFBQWdCLG9CQUFvQixPQUE0QjtBQUM1RCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsTUFBTSxZQUFZLFNBQVksVUFBYSxHQUFBLFVBQUEsV0FBVSxNQUFNLFNBQVMsU0FBQSxZQUFZO1FBQzNGLGFBQWEsTUFBTTs7SUFFM0I7QUFaQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7O0FDcERBLFFBQUEsWUFBQTtBQW9DQSxhQUFnQixxQkFBcUIsT0FBYTtBQUM5QyxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSx1QkFBQTtBQU1BLGFBQWdCLG1CQUFtQixNQUFTO0FBQ3hDLGFBQU8sd0JBQXdCLE1BQU0sS0FBSztJQUM5QztBQUZBLFlBQUEscUJBQUE7QUFJQSxhQUFnQix3QkFBd0IsTUFBVyxxQkFBNEI7QUFDM0UsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGtCQUFrQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0saUJBQWlCLElBQUksU0FBWSxLQUFLLGlCQUFpQjtRQUN2RixNQUFNLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxJQUFJLElBQUksU0FBWSxLQUFLLElBQUk7UUFDakQsS0FBSyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sR0FBRyxJQUFJLFNBQVksS0FBSyxHQUFHO1FBQzlDLGVBQWUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGNBQWMsSUFBSSxTQUFZLEtBQUssY0FBYzs7SUFFdEY7QUFYQSxZQUFBLDBCQUFBO0FBYUEsYUFBZ0IsaUJBQWlCLE9BQXlCO0FBQ3RELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsbUJBQW1CLE1BQU07UUFDekIsTUFBTSxNQUFNO1FBQ1osS0FBSyxNQUFNO1FBQ1gsZ0JBQWdCLE1BQU07O0lBRTlCO0FBZEEsWUFBQSxtQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNEQSxRQUFBLHVCQUFBO0FBZUEsYUFBZ0IscUNBQXFDLE1BQVM7QUFDMUQsYUFBTywwQ0FBMEMsTUFBTSxLQUFLO0lBQ2hFO0FBRkEsWUFBQSx1Q0FBQTtBQUlBLGFBQWdCLDBDQUEwQyxNQUFXLHFCQUE0QjtBQUM3RixVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFBLFNBQUEsQ0FBQSxJQUFZLEdBQUEscUJBQUEsaUNBQWdDLE1BQU0sSUFBSSxDQUFDO0lBQzNEO0FBTEEsWUFBQSw0Q0FBQTtBQU9BLGFBQWdCLG1DQUFtQyxPQUEyQztBQUMxRixVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBR1gsV0FBSSxHQUFBLHFCQUFBLDhCQUE2QixLQUFLLEdBQUc7QUFDckMsZ0JBQU8sR0FBQSxxQkFBQSwwQkFBeUIsS0FBMkI7O0FBRy9ELGFBQU8sQ0FBQTtJQUNYO0FBYkEsWUFBQSxxQ0FBQTs7Ozs7Ozs7OztBQzFCQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlDQUFBO0FBOEVBLGFBQWdCLDRCQUE0QixPQUFhO0FBQ3JELFVBQUksYUFBYTtBQUVqQixhQUFPO0lBQ1g7QUFKQSxZQUFBLDhCQUFBO0FBTUEsYUFBZ0IsMEJBQTBCLE1BQVM7QUFDL0MsYUFBTywrQkFBK0IsTUFBTSxLQUFLO0lBQ3JEO0FBRkEsWUFBQSw0QkFBQTtBQUlBLGFBQWdCLCtCQUErQixNQUFXLHFCQUE0QjtBQUNsRixVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sTUFBTSxJQUFJLFNBQVksS0FBSyxNQUFNO1FBQ3ZELGFBQWEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFdBQVcsSUFBSSxTQUFZLEtBQUssV0FBVztRQUN0RSxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxZQUFZLElBQUksU0FBWSxLQUFLLFlBQVk7UUFDeEUsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxZQUFZLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxVQUFVLElBQUksU0FBWSxLQUFLLFVBQVU7UUFDbkUsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFVBQVUsSUFBSSxTQUFZLEtBQUssVUFBVTtRQUNsRSxlQUFlLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxjQUFjLElBQUksVUFBWSxHQUFBLCtCQUFBLHNDQUFxQyxLQUFLLGNBQWMsQ0FBQztRQUNwSCxrQkFBa0IsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGlCQUFpQixJQUFJLFNBQVksS0FBSyxpQkFBaUI7O0lBRS9GO0FBakJBLFlBQUEsaUNBQUE7QUFtQkEsYUFBZ0Isd0JBQXdCLE9BQWdDO0FBQ3BFLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsUUFBUSxNQUFNO1FBQ2QsYUFBYSxNQUFNO1FBQ25CLGNBQWMsTUFBTTtRQUNwQixVQUFVLE1BQU07UUFDaEIsUUFBUSxNQUFNO1FBQ2QsWUFBWSxNQUFNO1FBQ2xCLFVBQVUsTUFBTTtRQUNoQixZQUFZLE1BQU07UUFDbEIsaUJBQWdCLEdBQUEsK0JBQUEsb0NBQW1DLE1BQU0sV0FBVztRQUNwRSxtQkFBbUIsTUFBTTs7SUFFakM7QUFwQkEsWUFBQSwwQkFBQTs7Ozs7Ozs7OztBQzdHQSxRQUFBLFlBQUE7QUF5QmEsWUFBQSwyQkFBMkI7TUFDcEMsY0FBYztNQUNkLFdBQVc7TUFDWCxhQUFhO01BQ2IsYUFBYTtNQUNiLE9BQU87O0FBUVgsYUFBZ0IsMEJBQTBCLE9BQWE7QUFDbkQsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsNEJBQUE7QUFNQSxhQUFnQix3QkFBd0IsTUFBUztBQUM3QyxhQUFPLDZCQUE2QixNQUFNLEtBQUs7SUFDbkQ7QUFGQSxZQUFBLDBCQUFBO0FBSUEsYUFBZ0IsNkJBQTZCLE1BQVcscUJBQTRCO0FBQ2hGLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxTQUFTLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxPQUFPLElBQUksU0FBWSxLQUFLLE9BQU87UUFDMUQsU0FBUyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sT0FBTyxJQUFJLFNBQVksS0FBSyxPQUFPOztJQUVsRTtBQVRBLFlBQUEsK0JBQUE7QUFXQSxhQUFnQixzQkFBc0IsT0FBOEI7QUFDaEUsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxTQUFTLE1BQU07UUFDZixTQUFTLE1BQU07O0lBRXZCO0FBWkEsWUFBQSx3QkFBQTs7Ozs7Ozs7OztBQzNEQSxRQUFBLFlBQUE7QUFFQSxRQUFBLHNCQUFBO0FBTUEsUUFBQSxvQkFBQTtBQTZCQSxhQUFnQixvQkFBb0IsT0FBYTtBQUM3QyxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSxzQkFBQTtBQU1BLGFBQWdCLGtCQUFrQixNQUFTO0FBQ3ZDLGFBQU8sdUJBQXVCLE1BQU0sS0FBSztJQUM3QztBQUZBLFlBQUEsb0JBQUE7QUFJQSxhQUFnQix1QkFBdUIsTUFBVyxxQkFBNEI7QUFDMUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFlBQVksRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFVBQVUsSUFBSSxVQUFZLEdBQUEsb0JBQUEsMkJBQTBCLEtBQUssVUFBVSxDQUFDO1FBQzlGLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxVQUFZLEdBQUEsa0JBQUEseUJBQXdCLEtBQUssUUFBUSxDQUFDOztJQUU5RjtBQVRBLFlBQUEseUJBQUE7QUFXQSxhQUFnQixnQkFBZ0IsT0FBd0I7QUFDcEQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxhQUFZLEdBQUEsb0JBQUEseUJBQXdCLE1BQU0sUUFBUTtRQUNsRCxXQUFVLEdBQUEsa0JBQUEsdUJBQXNCLE1BQU0sTUFBTTs7SUFFcEQ7QUFaQSxZQUFBLGtCQUFBOzs7Ozs7Ozs7O0FDMURBLFFBQUEsWUFBQTtBQXdCQSxhQUFnQix1QkFBdUIsT0FBYTtBQUNoRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSx5QkFBQTtBQU1BLGFBQWdCLHFCQUFxQixNQUFTO0FBQzFDLGFBQU8sMEJBQTBCLE1BQU0sS0FBSztJQUNoRDtBQUZBLFlBQUEsdUJBQUE7QUFJQSxhQUFnQiwwQkFBMEIsTUFBVyxxQkFBNEI7QUFDN0UsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFlBQVksRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFVBQVUsSUFBSSxTQUFZLEtBQUssVUFBVTtRQUNuRSxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxVQUFVLElBQUksU0FBWSxLQUFLLFVBQVU7O0lBRTFFO0FBVEEsWUFBQSw0QkFBQTtBQVdBLGFBQWdCLG1CQUFtQixPQUEyQjtBQUMxRCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFlBQVksTUFBTTtRQUNsQixZQUFZLE1BQU07O0lBRTFCO0FBWkEsWUFBQSxxQkFBQTs7Ozs7Ozs7OztBQzdDQSxRQUFBLFlBQUE7QUF3QkEsYUFBZ0Isc0JBQXNCLE9BQWE7QUFDL0MsVUFBSSxhQUFhO0FBRWpCLGFBQU87SUFDWDtBQUpBLFlBQUEsd0JBQUE7QUFNQSxhQUFnQixvQkFBb0IsTUFBUztBQUN6QyxhQUFPLHlCQUF5QixNQUFNLEtBQUs7SUFDL0M7QUFGQSxZQUFBLHNCQUFBO0FBSUEsYUFBZ0IseUJBQXlCLE1BQVcscUJBQTRCO0FBQzVFLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxTQUFTLElBQUksU0FBWSxLQUFLLFNBQVM7UUFDaEUsU0FBUyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sT0FBTyxJQUFJLFNBQVksS0FBSyxPQUFPOztJQUVsRTtBQVRBLFlBQUEsMkJBQUE7QUFXQSxhQUFnQixrQkFBa0IsT0FBMEI7QUFDeEQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxXQUFXLE1BQU07UUFDakIsU0FBUyxNQUFNOztJQUV2QjtBQVpBLFlBQUEsb0JBQUE7Ozs7Ozs7Ozs7QUNuQ2EsWUFBQSxvQkFBb0I7TUFDN0IsV0FBVzs7QUFLZixhQUFnQiwwQkFBMEIsTUFBUztBQUMvQyxhQUFPLCtCQUErQixNQUFNLEtBQUs7SUFDckQ7QUFGQSxZQUFBLDRCQUFBO0FBSUEsYUFBZ0IsK0JBQStCLE1BQVcscUJBQTRCO0FBQ2xGLGFBQU87SUFDWDtBQUZBLFlBQUEsaUNBQUE7QUFJQSxhQUFnQix3QkFBd0IsT0FBZ0M7QUFDcEUsYUFBTztJQUNYO0FBRkEsWUFBQSwwQkFBQTs7Ozs7Ozs7OztBQ3hCQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlCQUFBO0FBK0NBLGFBQWdCLHNCQUFzQixPQUFhO0FBQy9DLFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLFlBQVk7QUFFdkMsYUFBTztJQUNYO0FBTEEsWUFBQSx3QkFBQTtBQU9BLGFBQWdCLG9CQUFvQixNQUFTO0FBQ3pDLGFBQU8seUJBQXlCLE1BQU0sS0FBSztJQUMvQztBQUZBLFlBQUEsc0JBQUE7QUFJQSxhQUFnQix5QkFBeUIsTUFBVyxxQkFBNEI7QUFDNUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFVBQVUsS0FBSyxRQUFRO1FBQ3ZCLGdCQUFnQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sY0FBYyxJQUFJLFVBQVksR0FBQSxlQUFBLHNCQUFxQixLQUFLLGNBQWMsQ0FBQztRQUNyRyxRQUFRLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxNQUFNLElBQUksU0FBWSxLQUFLLE1BQU07UUFDdkQsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXO1FBQ3RFLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTs7SUFFckU7QUFaQSxZQUFBLDJCQUFBO0FBY0EsYUFBZ0Isa0JBQWtCLE9BQTBCO0FBQ3hELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsVUFBVSxNQUFNO1FBQ2hCLGlCQUFnQixHQUFBLGVBQUEsb0JBQW1CLE1BQU0sWUFBWTtRQUNyRCxRQUFRLE1BQU07UUFDZCxhQUFhLE1BQU07UUFDbkIsVUFBVSxNQUFNOztJQUV4QjtBQWZBLFlBQUEsb0JBQUE7Ozs7Ozs7Ozs7QUMxRUEsUUFBQSxZQUFBO0FBRUEsUUFBQSxnQkFBQTtBQU1BLFFBQUEsaUJBQUE7QUF3RUEsYUFBZ0IsdUJBQXVCLE9BQWE7QUFDaEQsVUFBSSxhQUFhO0FBQ2pCLG1CQUFhLGNBQWMsVUFBVTtBQUVyQyxhQUFPO0lBQ1g7QUFMQSxZQUFBLHlCQUFBO0FBT0EsYUFBZ0IscUJBQXFCLE1BQVM7QUFDMUMsYUFBTywwQkFBMEIsTUFBTSxLQUFLO0lBQ2hEO0FBRkEsWUFBQSx1QkFBQTtBQUlBLGFBQWdCLDBCQUEwQixNQUFXLHFCQUE0QjtBQUM3RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsYUFBYSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVksS0FBSyxXQUFXO1FBQ3RFLFFBQVEsS0FBSyxNQUFNO1FBQ25CLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTtRQUM3RCxpQkFBaUIsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGVBQWUsSUFBSSxTQUFZLEtBQUssZUFBZTtRQUNsRixtQkFBbUIsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGlCQUFpQixJQUFJLFNBQVksS0FBSyxpQkFBaUI7UUFDeEYsV0FBVyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sU0FBUyxJQUFJLFNBQWMsS0FBSyxTQUFTLEVBQWlCLElBQUksY0FBQSxtQkFBbUI7UUFDMUcsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELGdCQUFnQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sY0FBYyxJQUFJLFVBQVksR0FBQSxlQUFBLHNCQUFxQixLQUFLLGNBQWMsQ0FBQztRQUNyRyxNQUFNLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxJQUFJLElBQUksU0FBWSxLQUFLLElBQUk7O0lBRXpEO0FBaEJBLFlBQUEsNEJBQUE7QUFrQkEsYUFBZ0IsbUJBQW1CLE9BQTJCO0FBQzFELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsYUFBYSxNQUFNO1FBQ25CLFFBQVEsTUFBTTtRQUNkLFVBQVUsTUFBTTtRQUNoQixpQkFBaUIsTUFBTTtRQUN2QixtQkFBbUIsTUFBTTtRQUN6QixXQUFXLE1BQU0sWUFBWSxTQUFZLFNBQWMsTUFBTSxRQUF1QixJQUFJLGNBQUEsaUJBQWlCO1FBQ3pHLFVBQVUsTUFBTTtRQUNoQixpQkFBZ0IsR0FBQSxlQUFBLG9CQUFtQixNQUFNLFlBQVk7UUFDckQsTUFBTSxNQUFNOztJQUVwQjtBQW5CQSxZQUFBLHFCQUFBOzs7Ozs7Ozs7O0FDN0dBLFFBQUEsWUFBQTtBQUVBLFFBQUEsaUJBQUE7QUErQ0EsYUFBZ0IsdUJBQXVCLE9BQWE7QUFDaEQsVUFBSSxhQUFhO0FBQ2pCLG1CQUFhLGNBQWMsUUFBUTtBQUVuQyxhQUFPO0lBQ1g7QUFMQSxZQUFBLHlCQUFBO0FBT0EsYUFBZ0IscUJBQXFCLE1BQVM7QUFDMUMsYUFBTywwQkFBMEIsTUFBTSxLQUFLO0lBQ2hEO0FBRkEsWUFBQSx1QkFBQTtBQUlBLGFBQWdCLDBCQUEwQixNQUFXLHFCQUE0QjtBQUM3RSxVQUFLLFNBQVMsVUFBZSxTQUFTLE1BQU87QUFDekMsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxLQUFLLElBQUk7UUFDZixTQUFTLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxPQUFPLElBQUksU0FBWSxLQUFLLE9BQU87UUFDMUQsVUFBVSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sUUFBUSxJQUFJLFNBQVksS0FBSyxRQUFRO1FBQzdELGdCQUFnQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sY0FBYyxJQUFJLFVBQVksR0FBQSxlQUFBLHNCQUFxQixLQUFLLGNBQWMsQ0FBQztRQUNyRyxZQUFZLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxVQUFVLElBQUksU0FBWSxLQUFLLFVBQVU7O0lBRTNFO0FBWkEsWUFBQSw0QkFBQTtBQWNBLGFBQWdCLG1CQUFtQixPQUEyQjtBQUMxRCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILE1BQU0sTUFBTTtRQUNaLFNBQVMsTUFBTTtRQUNmLFVBQVUsTUFBTTtRQUNoQixpQkFBZ0IsR0FBQSxlQUFBLG9CQUFtQixNQUFNLFlBQVk7UUFDckQsWUFBWSxNQUFNOztJQUUxQjtBQWZBLFlBQUEscUJBQUE7Ozs7Ozs7Ozs7QUMxRUEsUUFBQSxZQUFBO0FBRUEsUUFBQSxpQkFBQTtBQTZCQSxhQUFnQiw2QkFBNkIsT0FBYTtBQUN0RCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwrQkFBQTtBQU1BLGFBQWdCLDJCQUEyQixNQUFTO0FBQ2hELGFBQU8sZ0NBQWdDLE1BQU0sS0FBSztJQUN0RDtBQUZBLFlBQUEsNkJBQUE7QUFJQSxhQUFnQixnQ0FBZ0MsTUFBVyxxQkFBNEI7QUFDbkYsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxTQUFjLEtBQUssU0FBUyxFQUFpQixJQUFJLGVBQUEsb0JBQW9CO1FBQzNHLGFBQWEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFdBQVcsSUFBSSxTQUFZLEtBQUssV0FBVzs7SUFFOUU7QUFUQSxZQUFBLGtDQUFBO0FBV0EsYUFBZ0IseUJBQXlCLE9BQWlDO0FBQ3RFLFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBVyxNQUFNLFlBQVksU0FBWSxTQUFjLE1BQU0sUUFBdUIsSUFBSSxlQUFBLGtCQUFrQjtRQUMxRyxhQUFhLE1BQU07O0lBRTNCO0FBWkEsWUFBQSwyQkFBQTs7Ozs7Ozs7OztBQ3BEQSxRQUFBLFlBQUE7QUFFQSxRQUFBLGlCQUFBO0FBTUEsUUFBQSx1QkFBQTtBQW9DQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwwQkFBQTtBQU1BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFNBQVMsSUFBSSxTQUFjLEtBQUssU0FBUyxFQUFpQixJQUFJLHFCQUFBLDBCQUEwQjtRQUNqSCxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxTQUFTLElBQUksU0FBYyxLQUFLLFNBQVMsRUFBaUIsSUFBSSxlQUFBLG9CQUFvQjtRQUMzRyxhQUFhLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxXQUFXLElBQUksU0FBWSxLQUFLLFdBQVc7O0lBRTlFO0FBVkEsWUFBQSw2QkFBQTtBQVlBLGFBQWdCLG9CQUFvQixPQUE0QjtBQUM1RCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQVcsTUFBTSxZQUFZLFNBQVksU0FBYyxNQUFNLFFBQXVCLElBQUkscUJBQUEsd0JBQXdCO1FBQ2hILFdBQVcsTUFBTSxZQUFZLFNBQVksU0FBYyxNQUFNLFFBQXVCLElBQUksZUFBQSxrQkFBa0I7UUFDMUcsYUFBYSxNQUFNOztJQUUzQjtBQWJBLFlBQUEsc0JBQUE7Ozs7Ozs7Ozs7QUNsRUEsUUFBQSxZQUFBO0FBRUEsUUFBQSxnQkFBQTtBQW1DQSxhQUFnQixvQkFBb0IsT0FBYTtBQUM3QyxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSxzQkFBQTtBQU1BLGFBQWdCLGtCQUFrQixNQUFTO0FBQ3ZDLGFBQU8sdUJBQXVCLE1BQU0sS0FBSztJQUM3QztBQUZBLFlBQUEsb0JBQUE7QUFJQSxhQUFnQix1QkFBdUIsTUFBVyxxQkFBNEI7QUFDMUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFFBQVEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLE1BQU0sSUFBSSxTQUFZLEtBQUssTUFBTTtRQUN2RCxXQUFXLEVBQUMsR0FBQSxVQUFBLFFBQU8sTUFBTSxTQUFTLElBQUksU0FBWSxLQUFLLFNBQVM7UUFDaEUsV0FBVyxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sU0FBUyxJQUFJLFNBQWMsS0FBSyxTQUFTLEVBQWlCLElBQUksY0FBQSxtQkFBbUI7O0lBRWxIO0FBVkEsWUFBQSx5QkFBQTtBQVlBLGFBQWdCLGdCQUFnQixPQUF3QjtBQUNwRCxVQUFJLFVBQVUsUUFBVztBQUNyQixlQUFPOztBQUVYLFVBQUksVUFBVSxNQUFNO0FBQ2hCLGVBQU87O0FBRVgsYUFBTztRQUVILFFBQVEsTUFBTTtRQUNkLFdBQVcsTUFBTTtRQUNqQixXQUFXLE1BQU0sWUFBWSxTQUFZLFNBQWMsTUFBTSxRQUF1QixJQUFJLGNBQUEsaUJBQWlCOztJQUVqSDtBQWJBLFlBQUEsa0JBQUE7Ozs7Ozs7Ozs7QUMzREEsUUFBQSxZQUFBO0FBRUEsUUFBQSxpQkFBQTtBQStDQSxhQUFnQix3QkFBd0IsT0FBYTtBQUNqRCxVQUFJLGFBQWE7QUFDakIsbUJBQWEsY0FBYyxRQUFRO0FBRW5DLGFBQU87SUFDWDtBQUxBLFlBQUEsMEJBQUE7QUFPQSxhQUFnQixzQkFBc0IsTUFBUztBQUMzQyxhQUFPLDJCQUEyQixNQUFNLEtBQUs7SUFDakQ7QUFGQSxZQUFBLHdCQUFBO0FBSUEsYUFBZ0IsMkJBQTJCLE1BQVcscUJBQTRCO0FBQzlFLFVBQUssU0FBUyxVQUFlLFNBQVMsTUFBTztBQUN6QyxlQUFPOztBQUVYLGFBQU87UUFFSCxNQUFNLEtBQUssSUFBSTtRQUNmLFVBQVUsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFFBQVEsSUFBSSxTQUFZLEtBQUssUUFBUTtRQUM3RCxnQkFBZ0IsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLGNBQWMsSUFBSSxVQUFZLEdBQUEsZUFBQSxzQkFBcUIsS0FBSyxjQUFjLENBQUM7UUFDckcsZUFBZSxFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sYUFBYSxJQUFJLFNBQVksS0FBSyxhQUFhO1FBQzVFLGFBQWEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFdBQVcsSUFBSSxTQUFZLEtBQUssV0FBVzs7SUFFOUU7QUFaQSxZQUFBLDZCQUFBO0FBY0EsYUFBZ0Isb0JBQW9CLE9BQTRCO0FBQzVELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsTUFBTSxNQUFNO1FBQ1osVUFBVSxNQUFNO1FBQ2hCLGlCQUFnQixHQUFBLGVBQUEsb0JBQW1CLE1BQU0sWUFBWTtRQUNyRCxlQUFlLE1BQU07UUFDckIsYUFBYSxNQUFNOztJQUUzQjtBQWZBLFlBQUEsc0JBQUE7Ozs7Ozs7Ozs7QUMxRUEsUUFBQSxZQUFBO0FBRUEsUUFBQSxXQUFBO0FBNkJBLGFBQWdCLHdCQUF3QixPQUFhO0FBQ2pELFVBQUksYUFBYTtBQUNqQixtQkFBYSxjQUFjLGFBQWE7QUFFeEMsYUFBTztJQUNYO0FBTEEsWUFBQSwwQkFBQTtBQU9BLGFBQWdCLHNCQUFzQixNQUFTO0FBQzNDLGFBQU8sMkJBQTJCLE1BQU0sS0FBSztJQUNqRDtBQUZBLFlBQUEsd0JBQUE7QUFJQSxhQUFnQiwyQkFBMkIsTUFBVyxxQkFBNEI7QUFDOUUsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILFdBQWEsS0FBSyxTQUFTLEVBQWlCLElBQUksU0FBQSxjQUFjO1FBQzlELGFBQWEsRUFBQyxHQUFBLFVBQUEsUUFBTyxNQUFNLFdBQVcsSUFBSSxTQUFZLEtBQUssV0FBVzs7SUFFOUU7QUFUQSxZQUFBLDZCQUFBO0FBV0EsYUFBZ0Isb0JBQW9CLE9BQTRCO0FBQzVELFVBQUksVUFBVSxRQUFXO0FBQ3JCLGVBQU87O0FBRVgsVUFBSSxVQUFVLE1BQU07QUFDaEIsZUFBTzs7QUFFWCxhQUFPO1FBRUgsV0FBYSxNQUFNLFFBQXVCLElBQUksU0FBQSxZQUFZO1FBQzFELGFBQWEsTUFBTTs7SUFFM0I7QUFaQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7O0FDckRBLFFBQUEsWUFBQTtBQWtCQSxhQUFnQix5QkFBeUIsT0FBYTtBQUNsRCxVQUFJLGFBQWE7QUFFakIsYUFBTztJQUNYO0FBSkEsWUFBQSwyQkFBQTtBQU1BLGFBQWdCLHVCQUF1QixNQUFTO0FBQzVDLGFBQU8sNEJBQTRCLE1BQU0sS0FBSztJQUNsRDtBQUZBLFlBQUEseUJBQUE7QUFJQSxhQUFnQiw0QkFBNEIsTUFBVyxxQkFBNEI7QUFDL0UsVUFBSyxTQUFTLFVBQWUsU0FBUyxNQUFPO0FBQ3pDLGVBQU87O0FBRVgsYUFBTztRQUVILGlCQUFpQixFQUFDLEdBQUEsVUFBQSxRQUFPLE1BQU0sZUFBZSxJQUFJLFNBQVksS0FBSyxlQUFlOztJQUUxRjtBQVJBLFlBQUEsOEJBQUE7QUFVQSxhQUFnQixxQkFBcUIsT0FBNkI7QUFDOUQsVUFBSSxVQUFVLFFBQVc7QUFDckIsZUFBTzs7QUFFWCxVQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFPOztBQUVYLGFBQU87UUFFSCxpQkFBaUIsTUFBTTs7SUFFL0I7QUFYQSxZQUFBLHVCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQSxpQkFBQSwrQkFBQSxPQUFBO0FBQ0EsaUJBQUEsMkJBQUEsT0FBQTtBQUNBLGlCQUFBLG9DQUFBLE9BQUE7QUFDQSxpQkFBQSwwQkFBQSxPQUFBO0FBQ0EsaUJBQUEscUNBQUEsT0FBQTtBQUNBLGlCQUFBLDBCQUFBLE9BQUE7QUFDQSxpQkFBQSxzQ0FBQSxPQUFBO0FBQ0EsaUJBQUEsdUNBQUEsT0FBQTtBQUNBLGlCQUFBLDBCQUFBLE9BQUE7QUFDQSxpQkFBQSx1QkFBQSxPQUFBO0FBQ0EsaUJBQUEsc0JBQUEsT0FBQTtBQUNBLGlCQUFBLDhCQUFBLE9BQUE7QUFDQSxpQkFBQSx5Q0FBQSxPQUFBO0FBQ0EsaUJBQUEsNEJBQUEsT0FBQTtBQUNBLGlCQUFBLDZCQUFBLE9BQUE7QUFDQSxpQkFBQSx5QkFBQSxPQUFBO0FBQ0EsaUJBQUEsd0JBQUEsT0FBQTtBQUNBLGlCQUFBLDhCQUFBLE9BQUE7QUFDQSxpQkFBQSx5QkFBQSxPQUFBO0FBQ0EsaUJBQUEsMEJBQUEsT0FBQTtBQUNBLGlCQUFBLHdCQUFBLE9BQUE7QUFDQSxpQkFBQSxzQkFBQSxPQUFBO0FBQ0EsaUJBQUEseUJBQUEsT0FBQTtBQUNBLGlCQUFBLCtCQUFBLE9BQUE7QUFDQSxpQkFBQSx5QkFBQSxPQUFBO0FBQ0EsaUJBQUEsMEJBQUEsT0FBQTtBQUNBLGlCQUFBLDBCQUFBLE9BQUE7QUFDQSxpQkFBQSwyQkFBQSxPQUFBO0FBQ0EsaUJBQUEsbUJBQUEsT0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZBLFFBQUEsVUFBQSxhQUFBLGtCQUFBO0FBUUEsUUFBQSxXQUFBO0FBNkNBLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQXdDLGtCQUFBQyxxQkFBQSxNQUFBO0FBQXhDLGlCQUFBQSxzQkFBQTs7UUE2U0E7QUF4U1UsUUFBQUEsb0JBQUEsVUFBQSxvQkFBTixTQUF3QixtQkFBMEMsZUFBMEQ7Ozs7OztBQUN4SCxzQkFBSSxrQkFBa0IsY0FBYyxRQUFRLGtCQUFrQixjQUFjLFFBQVc7QUFDbkYsMEJBQU0sSUFBSSxRQUFRLGNBQWMsYUFBYSxtR0FBbUc7O0FBRzlJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLG1DQUFpQixjQUFjLElBQUk7QUFFbkMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNLHlCQUF5QixRQUFRLElBQUEsT0FBSSxhQUFXLEdBQUEsR0FBSyxtQkFBbUIsT0FBTyxrQkFBa0IsU0FBUyxDQUFDLENBQUM7b0JBQ2xILFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO29CQUNQLE9BQU0sR0FBQSxTQUFBLG9CQUFtQixrQkFBa0IsWUFBWTtxQkFDeEQsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsUUFBUSxDQUFROzs7OztBQU1qRCxRQUFBRCxvQkFBQSxVQUFBLGlCQUFOLFNBQXFCLG1CQUEwQyxlQUEwRDs7Ozs7O0FBQ3BHLHlCQUFBLENBQUEsR0FBTSxLQUFLLGtCQUFrQixtQkFBbUIsYUFBYSxDQUFDOztBQUF6RSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxzQkFBTixTQUEwQixtQkFBcUQsZUFBMEQ7Ozs7OztBQUMvSCxvQ0FBdUIsQ0FBQTtBQUV2QixxQ0FBd0MsQ0FBQTtBQUU5QyxtQ0FBaUIsY0FBYyxJQUFJO0FBRW5DLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztvQkFDUCxPQUFNLEdBQUEsU0FBQSwrQkFBOEIsa0JBQWtCLHVCQUF1QjtxQkFDOUUsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsUUFBUSxDQUFROzs7OztBQU1qRCxRQUFBRCxvQkFBQSxVQUFBLG1CQUFOLFNBQXVCLG1CQUEwRCxlQUEwRDtBQUFwSCxjQUFBLHNCQUFBLFFBQUE7QUFBQSxnQ0FBQSxDQUFBO1VBQXdEOzs7Ozs7QUFDMUQseUJBQUEsQ0FBQSxHQUFNLEtBQUssb0JBQW9CLG1CQUFtQixhQUFhLENBQUM7O0FBQTNFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU0zQixRQUFBRCxvQkFBQSxVQUFBLGlCQUFOLFNBQXFCLG1CQUF1QyxlQUEwRDs7Ozs7O0FBQzVHLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLG1DQUFpQixjQUFjLElBQUk7QUFFbkMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO29CQUNQLE9BQU0sR0FBQSxTQUFBLHFCQUFvQixrQkFBa0IsYUFBYTtxQkFDMUQsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsUUFBUSxDQUFROzs7OztBQU1qRCxRQUFBRCxvQkFBQSxVQUFBLGNBQU4sU0FBa0IsbUJBQTRDLGVBQTBEO0FBQXRHLGNBQUEsc0JBQUEsUUFBQTtBQUFBLGdDQUFBLENBQUE7VUFBMEM7Ozs7OztBQUN2Qyx5QkFBQSxDQUFBLEdBQU0sS0FBSyxlQUFlLG1CQUFtQixhQUFhLENBQUM7O0FBQXRFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU0zQixRQUFBRCxvQkFBQSxVQUFBLHNCQUFOLFNBQTBCLG1CQUE0QyxlQUEwRDs7Ozs7O0FBQzVILHNCQUFJLGtCQUFrQixtQkFBbUIsUUFBUSxrQkFBa0IsbUJBQW1CLFFBQVc7QUFDN0YsMEJBQU0sSUFBSSxRQUFRLGNBQWMsa0JBQWtCLDBHQUEwRzs7QUFHMUosb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNLGdDQUFnQyxRQUFRLElBQUEsT0FBSSxrQkFBZ0IsR0FBQSxHQUFLLG1CQUFtQixPQUFPLGtCQUFrQixjQUFjLENBQUMsQ0FBQztvQkFDbkksUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87cUJBQ1IsYUFBYSxDQUFDOztBQUxYLDZCQUFXQyxJQUFBLEtBQUE7QUFPakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsUUFBUSxDQUFROzs7OztBQU1qRCxRQUFBRCxvQkFBQSxVQUFBLG1CQUFOLFNBQXVCLG1CQUE0QyxlQUEwRDs7Ozs7O0FBQ3hHLHlCQUFBLENBQUEsR0FBTSxLQUFLLG9CQUFvQixtQkFBbUIsYUFBYSxDQUFDOztBQUEzRSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxpQkFBTixTQUFxQixtQkFBdUMsZUFBMEQ7Ozs7OztBQUNsSCxzQkFBSSxrQkFBa0IsY0FBYyxRQUFRLGtCQUFrQixjQUFjLFFBQVc7QUFDbkYsMEJBQU0sSUFBSSxRQUFRLGNBQWMsYUFBYSxnR0FBZ0c7O0FBRzNJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTSx5QkFBeUIsUUFBUSxJQUFBLE9BQUksYUFBVyxHQUFBLEdBQUssbUJBQW1CLE9BQU8sa0JBQWtCLFNBQVMsQ0FBQyxDQUFDO29CQUNsSCxRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixRQUFRLENBQVE7Ozs7O0FBTWpELFFBQUFELG9CQUFBLFVBQUEsY0FBTixTQUFrQixtQkFBdUMsZUFBMEQ7Ozs7OztBQUM5Rix5QkFBQSxDQUFBLEdBQU0sS0FBSyxlQUFlLG1CQUFtQixhQUFhLENBQUM7O0FBQXRFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU0zQixRQUFBRCxvQkFBQSxVQUFBLHdCQUFOLFNBQTRCLG1CQUE4QyxlQUEwRDs7Ozs7O0FBQ2hJLHNCQUFJLGtCQUFrQixtQkFBbUIsUUFBUSxrQkFBa0IsbUJBQW1CLFFBQVc7QUFDN0YsMEJBQU0sSUFBSSxRQUFRLGNBQWMsa0JBQWtCLDRHQUE0Rzs7QUFHNUosb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNLGdDQUFnQyxRQUFRLElBQUEsT0FBSSxrQkFBZ0IsR0FBQSxHQUFLLG1CQUFtQixPQUFPLGtCQUFrQixjQUFjLENBQUMsQ0FBQztvQkFDbkksUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87cUJBQ1IsYUFBYSxDQUFDOztBQUxYLDZCQUFXQyxJQUFBLEtBQUE7QUFPakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsVUFBVSxTQUFDLFdBQVM7QUFBSyw0QkFBQSxHQUFBLFNBQUEsd0JBQXVCLFNBQVM7a0JBQWhDLENBQWlDLENBQUM7Ozs7O0FBTTVGLFFBQUFELG9CQUFBLFVBQUEscUJBQU4sU0FBeUIsbUJBQThDLGVBQTBEOzs7Ozs7QUFDNUcseUJBQUEsQ0FBQSxHQUFNLEtBQUssc0JBQXNCLG1CQUFtQixhQUFhLENBQUM7O0FBQTdFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU0zQixRQUFBRCxvQkFBQSxVQUFBLG1CQUFOLFNBQXVCLG1CQUF5QyxlQUEwRDs7Ozs7O0FBQ3RILHNCQUFJLGtCQUFrQixjQUFjLFFBQVEsa0JBQWtCLGNBQWMsUUFBVztBQUNuRiwwQkFBTSxJQUFJLFFBQVEsY0FBYyxhQUFhLGtHQUFrRzs7QUFHN0ksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNLHlCQUF5QixRQUFRLElBQUEsT0FBSSxhQUFXLEdBQUEsR0FBSyxtQkFBbUIsT0FBTyxrQkFBa0IsU0FBUyxDQUFDLENBQUM7b0JBQ2xILFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO3FCQUNSLGFBQWEsQ0FBQzs7QUFMWCw2QkFBV0MsSUFBQSxLQUFBO0FBT2pCLHlCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFVBQVUsU0FBQyxXQUFTO0FBQUssNEJBQUEsR0FBQSxTQUFBLG1CQUFrQixTQUFTO2tCQUEzQixDQUE0QixDQUFDOzs7OztBQU12RixRQUFBRCxvQkFBQSxVQUFBLGdCQUFOLFNBQW9CLG1CQUF5QyxlQUEwRDs7Ozs7O0FBQ2xHLHlCQUFBLENBQUEsR0FBTSxLQUFLLGlCQUFpQixtQkFBbUIsYUFBYSxDQUFDOztBQUF4RSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxxQkFBTixTQUF5QixlQUEwRDs7Ozs7O0FBQ3pFLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFxQixRQUFRLENBQUM7Ozs7O0FBTS9DLFFBQUFELG9CQUFBLFVBQUEsa0JBQU4sU0FBc0IsZUFBMEQ7Ozs7OztBQUMzRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxtQkFBbUIsYUFBYSxDQUFDOztBQUF2RCw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFNM0IsUUFBQUQsb0JBQUEsVUFBQSxpQkFBTixTQUFxQixlQUEwRDs7Ozs7O0FBQ3JFLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFxQixRQUFRLENBQUM7Ozs7O0FBTS9DLFFBQUFELG9CQUFBLFVBQUEsY0FBTixTQUFrQixlQUEwRDs7Ozs7O0FBQ3ZELHlCQUFBLENBQUEsR0FBTSxLQUFLLGVBQWUsYUFBYSxDQUFDOztBQUFuRCw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFHckMsZUFBQUQ7TUFBQSxFQTdTd0MsUUFBUSxPQUFPOztBQUExQyxZQUFBLHFCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckRiLFFBQUEsVUFBQSxhQUFBLGtCQUFBO0FBYUEsUUFBQSxXQUFBO0FBeURBLFFBQUE7O01BQUEsU0FBQSxRQUFBO0FBQXlDLGtCQUFBRSxzQkFBQSxNQUFBO0FBQXpDLGlCQUFBQSx1QkFBQTs7UUE2VEE7QUF2VFUsUUFBQUEscUJBQUEsVUFBQSxhQUFOLFNBQWlCLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQ2xILHNCQUFJLGtCQUFrQixrQkFBa0IsUUFBUSxrQkFBa0Isa0JBQWtCLFFBQVc7QUFDM0YsMEJBQU0sSUFBSSxRQUFRLGNBQWMsaUJBQWlCLGdHQUFnRzs7QUFHL0ksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFNBQUEscUJBQW9CLGtCQUFrQixhQUFhO3FCQUMxRCxhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFxQixRQUFRLENBQUM7Ozs7O0FBTy9DLFFBQUFELHFCQUFBLFVBQUEsVUFBTixTQUFjLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQzlGLHlCQUFBLENBQUEsR0FBTSxLQUFLLFdBQVcsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBbEUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTzNCLFFBQUFELHFCQUFBLFVBQUEsYUFBTixTQUFpQixtQkFBbUMsZUFBMEQ7Ozs7OztBQUNwRyxvQ0FBdUIsQ0FBQTtBQUU3QixzQkFBSSxrQkFBa0IsS0FBSztBQUN2QixvQ0FBZ0IsS0FBSyxJQUFJLGtCQUFrQjs7QUFHL0Msc0JBQUksa0JBQWtCLGNBQWMsUUFBVztBQUMzQyxvQ0FBZ0IsV0FBVyxJQUFJLGtCQUFrQjs7QUFHckQsc0JBQUksa0JBQWtCLGNBQWMsUUFBVztBQUMzQyxvQ0FBZ0IsV0FBVyxJQUFJLGtCQUFrQjs7QUFHL0MscUNBQXdDLENBQUE7QUFFOUMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO3FCQUNSLGFBQWEsQ0FBQzs7QUFMWCw2QkFBV0MsSUFBQSxLQUFBO0FBT2pCLHlCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQXFCLFFBQVEsQ0FBQzs7Ozs7QUFPL0MsUUFBQUQscUJBQUEsVUFBQSxVQUFOLFNBQWMsbUJBQXdDLGVBQTBEO0FBQWxHLGNBQUEsc0JBQUEsUUFBQTtBQUFBLGdDQUFBLENBQUE7VUFBc0M7Ozs7OztBQUMvQix5QkFBQSxDQUFBLEdBQU0sS0FBSyxXQUFXLG1CQUFtQixhQUFhLENBQUM7O0FBQWxFLDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU8zQixRQUFBRCxxQkFBQSxVQUFBLHdCQUFOLFNBQTRCLG1CQUF1RCxlQUEwRDs7Ozs7O0FBQ3pJLHNCQUFJLGtCQUFrQiw4QkFBOEIsUUFBUSxrQkFBa0IsOEJBQThCLFFBQVc7QUFDbkgsMEJBQU0sSUFBSSxRQUFRLGNBQWMsNkJBQTZCLHVIQUF1SDs7QUFHbEwsb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFNBQUEsaUNBQWdDLGtCQUFrQix5QkFBeUI7cUJBQ2xGLGFBQWEsQ0FBQzs7QUFOWCw2QkFBV0MsSUFBQSxLQUFBO0FBUWpCLHlCQUFBLENBQUEsR0FBTyxJQUFJLFFBQVEsZ0JBQWdCLFVBQVUsU0FBQyxXQUFTO0FBQUssNEJBQUEsR0FBQSxTQUFBLG9DQUFtQyxTQUFTO2tCQUE1QyxDQUE2QyxDQUFDOzs7OztBQU94RyxRQUFBRCxxQkFBQSxVQUFBLHFCQUFOLFNBQXlCLG1CQUF1RCxlQUEwRDs7Ozs7O0FBQ3JILHlCQUFBLENBQUEsR0FBTSxLQUFLLHNCQUFzQixtQkFBbUIsYUFBYSxDQUFDOztBQUE3RSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFPM0IsUUFBQUQscUJBQUEsVUFBQSx5QkFBTixTQUE2QixlQUEwRDs7Ozs7O0FBQzdFLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLHNCQUFJLEtBQUssaUJBQWlCLEtBQUssY0FBYyxRQUFRO0FBQ2pELHFDQUFpQixTQUFTLElBQUksS0FBSyxjQUFjLE9BQU8sU0FBUzs7QUFHcEQseUJBQUEsQ0FBQSxHQUFNLEtBQUssUUFBUTtvQkFDaEMsTUFBTTtvQkFDTixRQUFRO29CQUNSLFNBQVM7b0JBQ1QsT0FBTztxQkFDUixhQUFhLENBQUM7O0FBTFgsNkJBQVdDLElBQUEsS0FBQTtBQU9qQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixVQUFVLFNBQUMsV0FBUztBQUFLLDRCQUFBLEdBQUEsU0FBQSxvQ0FBbUMsU0FBUztrQkFBNUMsQ0FBNkMsQ0FBQzs7Ozs7QUFPeEcsUUFBQUQscUJBQUEsVUFBQSxzQkFBTixTQUEwQixlQUEwRDs7Ozs7O0FBQy9ELHlCQUFBLENBQUEsR0FBTSxLQUFLLHVCQUF1QixhQUFhLENBQUM7O0FBQTNELDZCQUFXQyxJQUFBLEtBQUE7QUFDVix5QkFBQSxDQUFBLEdBQU0sU0FBUyxNQUFLLENBQUU7O0FBQTdCLHlCQUFBLENBQUEsR0FBT0EsSUFBQSxLQUFBLENBQXNCOzs7OztBQU8zQixRQUFBRCxxQkFBQSxVQUFBLFdBQU4sU0FBZSxtQkFBaUMsZUFBMEQ7Ozs7OztBQUN0RyxzQkFBSSxrQkFBa0IsUUFBUSxRQUFRLGtCQUFrQixRQUFRLFFBQVc7QUFDdkUsMEJBQU0sSUFBSSxRQUFRLGNBQWMsT0FBTyxvRkFBb0Y7O0FBR3pILG9DQUF1QixDQUFBO0FBRTdCLHNCQUFJLGtCQUFrQixLQUFLO0FBQ3ZCLG9DQUFnQixLQUFLLElBQUksa0JBQWtCOztBQUcvQyxzQkFBSSxrQkFBa0IsY0FBYyxRQUFXO0FBQzNDLG9DQUFnQixXQUFXLElBQUksa0JBQWtCOztBQUcvQyxxQ0FBd0MsQ0FBQTtBQUU5QyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87cUJBQ1IsYUFBYSxDQUFDOztBQUxYLDZCQUFXQyxJQUFBLEtBQUE7QUFPakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsVUFBVSxTQUFDLFdBQVM7QUFBSyw0QkFBQSxHQUFBLFNBQUEsdUJBQXNCLFNBQVM7a0JBQS9CLENBQWdDLENBQUM7Ozs7O0FBTzNGLFFBQUFELHFCQUFBLFVBQUEsUUFBTixTQUFZLG1CQUFpQyxlQUEwRDs7Ozs7O0FBQ2xGLHlCQUFBLENBQUEsR0FBTSxLQUFLLFNBQVMsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBaEUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTzNCLFFBQUFELHFCQUFBLFVBQUEsV0FBTixTQUFlLG1CQUEwQyxlQUEwRDs7Ozs7O0FBQy9HLHNCQUFJLGtCQUFrQixpQkFBaUIsUUFBUSxrQkFBa0IsaUJBQWlCLFFBQVc7QUFDekYsMEJBQU0sSUFBSSxRQUFRLGNBQWMsZ0JBQWdCLDZGQUE2Rjs7QUFHM0ksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFNBQUEsb0JBQW1CLGtCQUFrQixZQUFZO3FCQUN4RCxhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFnQixVQUFVLFNBQUMsV0FBUztBQUFLLDRCQUFBLEdBQUEsU0FBQSx1QkFBc0IsU0FBUztrQkFBL0IsQ0FBZ0MsQ0FBQzs7Ozs7QUFPM0YsUUFBQUQscUJBQUEsVUFBQSxRQUFOLFNBQVksbUJBQTBDLGVBQTBEOzs7Ozs7QUFDM0YseUJBQUEsQ0FBQSxHQUFNLEtBQUssU0FBUyxtQkFBbUIsYUFBYSxDQUFDOztBQUFoRSw2QkFBV0MsSUFBQSxLQUFBO0FBQ1YseUJBQUEsQ0FBQSxHQUFNLFNBQVMsTUFBSyxDQUFFOztBQUE3Qix5QkFBQSxDQUFBLEdBQU9BLElBQUEsS0FBQSxDQUFzQjs7Ozs7QUFPM0IsUUFBQUQscUJBQUEsVUFBQSxZQUFOLFNBQWdCLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQ2pILHNCQUFJLGtCQUFrQixrQkFBa0IsUUFBUSxrQkFBa0Isa0JBQWtCLFFBQVc7QUFDM0YsMEJBQU0sSUFBSSxRQUFRLGNBQWMsaUJBQWlCLCtGQUErRjs7QUFHOUksb0NBQXVCLENBQUE7QUFFdkIscUNBQXdDLENBQUE7QUFFOUMsbUNBQWlCLGNBQWMsSUFBSTtBQUVuQyxzQkFBSSxLQUFLLGlCQUFpQixLQUFLLGNBQWMsUUFBUTtBQUNqRCxxQ0FBaUIsU0FBUyxJQUFJLEtBQUssY0FBYyxPQUFPLFNBQVM7O0FBR3BELHlCQUFBLENBQUEsR0FBTSxLQUFLLFFBQVE7b0JBQ2hDLE1BQU07b0JBQ04sUUFBUTtvQkFDUixTQUFTO29CQUNULE9BQU87b0JBQ1AsT0FBTSxHQUFBLFNBQUEscUJBQW9CLGtCQUFrQixhQUFhO3FCQUMxRCxhQUFhLENBQUM7O0FBTlgsNkJBQVdDLElBQUEsS0FBQTtBQVFqQix5QkFBQSxDQUFBLEdBQU8sSUFBSSxRQUFRLGdCQUFxQixRQUFRLENBQUM7Ozs7O0FBTy9DLFFBQUFELHFCQUFBLFVBQUEsU0FBTixTQUFhLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQzdGLHlCQUFBLENBQUEsR0FBTSxLQUFLLFVBQVUsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBakUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBTzNCLFFBQUFELHFCQUFBLFVBQUEsWUFBTixTQUFnQixtQkFBMkMsZUFBMEQ7Ozs7OztBQUNqSCxzQkFBSSxrQkFBa0Isa0JBQWtCLFFBQVEsa0JBQWtCLGtCQUFrQixRQUFXO0FBQzNGLDBCQUFNLElBQUksUUFBUSxjQUFjLGlCQUFpQiwrRkFBK0Y7O0FBRzlJLG9DQUF1QixDQUFBO0FBRXZCLHFDQUF3QyxDQUFBO0FBRTlDLG1DQUFpQixjQUFjLElBQUk7QUFFbkMsc0JBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFFBQVE7QUFDakQscUNBQWlCLFNBQVMsSUFBSSxLQUFLLGNBQWMsT0FBTyxTQUFTOztBQUdwRCx5QkFBQSxDQUFBLEdBQU0sS0FBSyxRQUFRO29CQUNoQyxNQUFNO29CQUNOLFFBQVE7b0JBQ1IsU0FBUztvQkFDVCxPQUFPO29CQUNQLE9BQU0sR0FBQSxTQUFBLHFCQUFvQixrQkFBa0IsYUFBYTtxQkFDMUQsYUFBYSxDQUFDOztBQU5YLDZCQUFXQyxJQUFBLEtBQUE7QUFRakIseUJBQUEsQ0FBQSxHQUFPLElBQUksUUFBUSxnQkFBZ0IsVUFBVSxTQUFDLFdBQVM7QUFBSyw0QkFBQSxHQUFBLFNBQUEsd0JBQXVCLFNBQVM7a0JBQWhDLENBQWlDLENBQUM7Ozs7O0FBTzVGLFFBQUFELHFCQUFBLFVBQUEsU0FBTixTQUFhLG1CQUEyQyxlQUEwRDs7Ozs7O0FBQzdGLHlCQUFBLENBQUEsR0FBTSxLQUFLLFVBQVUsbUJBQW1CLGFBQWEsQ0FBQzs7QUFBakUsNkJBQVdDLElBQUEsS0FBQTtBQUNWLHlCQUFBLENBQUEsR0FBTSxTQUFTLE1BQUssQ0FBRTs7QUFBN0IseUJBQUEsQ0FBQSxHQUFPQSxJQUFBLEtBQUEsQ0FBc0I7Ozs7O0FBR3JDLGVBQUFEO01BQUEsRUE3VHlDLFFBQVEsT0FBTzs7QUFBM0MsWUFBQSxzQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRmIsaUJBQUEsK0JBQUEsT0FBQTtBQUNBLGlCQUFBLGdDQUFBLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDREEsaUJBQUEsb0JBQUEsT0FBQTtBQUNBLGlCQUFBLGlCQUFBLE9BQUE7QUFDQSxpQkFBQSxtQkFBQSxPQUFBOzs7OztBQ0pBO0FBQUE7QUFBQSxLQUFDLFNBQVNFLE9BQU07QUFFaEIsVUFBSSxhQUFjLFNBQVVDLFVBQVM7QUFFbkMsWUFBSSxVQUFVO0FBQUEsVUFDWixjQUFjLHFCQUFxQkQ7QUFBQSxVQUNuQyxVQUFVLFlBQVlBLFNBQVEsY0FBYztBQUFBLFVBQzVDLE1BQ0UsZ0JBQWdCQSxTQUNoQixVQUFVQSxTQUNULFdBQVc7QUFDVixnQkFBSTtBQUNGLGtCQUFJLEtBQUs7QUFDVCxxQkFBTztBQUFBLFlBQ1QsU0FBUyxHQUFQO0FBQ0EscUJBQU87QUFBQSxZQUNUO0FBQUEsVUFDRixFQUFHO0FBQUEsVUFDTCxVQUFVLGNBQWNBO0FBQUEsVUFDeEIsYUFBYSxpQkFBaUJBO0FBQUEsUUFDaEM7QUFFQSxpQkFBUyxXQUFXLEtBQUs7QUFDdkIsaUJBQU8sT0FBTyxTQUFTLFVBQVUsY0FBYyxHQUFHO0FBQUEsUUFDcEQ7QUFFQSxZQUFJLFFBQVEsYUFBYTtBQUN2QixjQUFJLGNBQWM7QUFBQSxZQUNoQjtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUVBLGNBQUksb0JBQ0YsWUFBWSxVQUNaLFNBQVMsS0FBSztBQUNaLG1CQUFPLE9BQU8sWUFBWSxRQUFRLE9BQU8sVUFBVSxTQUFTLEtBQUssR0FBRyxDQUFDLElBQUk7QUFBQSxVQUMzRTtBQUFBLFFBQ0o7QUFFQSxpQkFBUyxjQUFjLE1BQU07QUFDM0IsY0FBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixtQkFBTyxPQUFPLElBQUk7QUFBQSxVQUNwQjtBQUNBLGNBQUksNEJBQTRCLEtBQUssSUFBSSxHQUFHO0FBQzFDLGtCQUFNLElBQUksVUFBVSx3Q0FBd0M7QUFBQSxVQUM5RDtBQUNBLGlCQUFPLEtBQUssWUFBWTtBQUFBLFFBQzFCO0FBRUEsaUJBQVMsZUFBZSxPQUFPO0FBQzdCLGNBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0Isb0JBQVEsT0FBTyxLQUFLO0FBQUEsVUFDdEI7QUFDQSxpQkFBTztBQUFBLFFBQ1Q7QUFHQSxpQkFBUyxZQUFZLE9BQU87QUFDMUIsY0FBSSxXQUFXO0FBQUEsWUFDYixNQUFNLFdBQVc7QUFDZixrQkFBSSxRQUFRLE1BQU0sTUFBTTtBQUN4QixxQkFBTyxFQUFDLE1BQU0sVUFBVSxRQUFXLE1BQVk7QUFBQSxZQUNqRDtBQUFBLFVBQ0Y7QUFFQSxjQUFJLFFBQVEsVUFBVTtBQUNwQixxQkFBUyxPQUFPLFFBQVEsSUFBSSxXQUFXO0FBQ3JDLHFCQUFPO0FBQUEsWUFDVDtBQUFBLFVBQ0Y7QUFFQSxpQkFBTztBQUFBLFFBQ1Q7QUFFQSxpQkFBU0UsU0FBUSxTQUFTO0FBQ3hCLGVBQUssTUFBTSxDQUFDO0FBRVosY0FBSSxtQkFBbUJBLFVBQVM7QUFDOUIsb0JBQVEsUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUNwQyxtQkFBSyxPQUFPLE1BQU0sS0FBSztBQUFBLFlBQ3pCLEdBQUcsSUFBSTtBQUFBLFVBQ1QsV0FBVyxNQUFNLFFBQVEsT0FBTyxHQUFHO0FBQ2pDLG9CQUFRLFFBQVEsU0FBUyxRQUFRO0FBQy9CLG1CQUFLLE9BQU8sT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7QUFBQSxZQUNsQyxHQUFHLElBQUk7QUFBQSxVQUNULFdBQVcsU0FBUztBQUNsQixtQkFBTyxvQkFBb0IsT0FBTyxFQUFFLFFBQVEsU0FBUyxNQUFNO0FBQ3pELG1CQUFLLE9BQU8sTUFBTSxRQUFRLElBQUksQ0FBQztBQUFBLFlBQ2pDLEdBQUcsSUFBSTtBQUFBLFVBQ1Q7QUFBQSxRQUNGO0FBRUEsUUFBQUEsU0FBUSxVQUFVLFNBQVMsU0FBUyxNQUFNLE9BQU87QUFDL0MsaUJBQU8sY0FBYyxJQUFJO0FBQ3pCLGtCQUFRLGVBQWUsS0FBSztBQUM1QixjQUFJLFdBQVcsS0FBSyxJQUFJLElBQUk7QUFDNUIsZUFBSyxJQUFJLElBQUksSUFBSSxXQUFXLFdBQVcsT0FBTyxRQUFRO0FBQUEsUUFDeEQ7QUFFQSxRQUFBQSxTQUFRLFVBQVUsUUFBUSxJQUFJLFNBQVMsTUFBTTtBQUMzQyxpQkFBTyxLQUFLLElBQUksY0FBYyxJQUFJLENBQUM7QUFBQSxRQUNyQztBQUVBLFFBQUFBLFNBQVEsVUFBVSxNQUFNLFNBQVMsTUFBTTtBQUNyQyxpQkFBTyxjQUFjLElBQUk7QUFDekIsaUJBQU8sS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJO0FBQUEsUUFDM0M7QUFFQSxRQUFBQSxTQUFRLFVBQVUsTUFBTSxTQUFTLE1BQU07QUFDckMsaUJBQU8sS0FBSyxJQUFJLGVBQWUsY0FBYyxJQUFJLENBQUM7QUFBQSxRQUNwRDtBQUVBLFFBQUFBLFNBQVEsVUFBVSxNQUFNLFNBQVMsTUFBTSxPQUFPO0FBQzVDLGVBQUssSUFBSSxjQUFjLElBQUksQ0FBQyxJQUFJLGVBQWUsS0FBSztBQUFBLFFBQ3REO0FBRUEsUUFBQUEsU0FBUSxVQUFVLFVBQVUsU0FBUyxVQUFVLFNBQVM7QUFDdEQsbUJBQVMsUUFBUSxLQUFLLEtBQUs7QUFDekIsZ0JBQUksS0FBSyxJQUFJLGVBQWUsSUFBSSxHQUFHO0FBQ2pDLHVCQUFTLEtBQUssU0FBUyxLQUFLLElBQUksSUFBSSxHQUFHLE1BQU0sSUFBSTtBQUFBLFlBQ25EO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFFQSxRQUFBQSxTQUFRLFVBQVUsT0FBTyxXQUFXO0FBQ2xDLGNBQUksUUFBUSxDQUFDO0FBQ2IsZUFBSyxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ2pDLGtCQUFNLEtBQUssSUFBSTtBQUFBLFVBQ2pCLENBQUM7QUFDRCxpQkFBTyxZQUFZLEtBQUs7QUFBQSxRQUMxQjtBQUVBLFFBQUFBLFNBQVEsVUFBVSxTQUFTLFdBQVc7QUFDcEMsY0FBSSxRQUFRLENBQUM7QUFDYixlQUFLLFFBQVEsU0FBUyxPQUFPO0FBQzNCLGtCQUFNLEtBQUssS0FBSztBQUFBLFVBQ2xCLENBQUM7QUFDRCxpQkFBTyxZQUFZLEtBQUs7QUFBQSxRQUMxQjtBQUVBLFFBQUFBLFNBQVEsVUFBVSxVQUFVLFdBQVc7QUFDckMsY0FBSSxRQUFRLENBQUM7QUFDYixlQUFLLFFBQVEsU0FBUyxPQUFPLE1BQU07QUFDakMsa0JBQU0sS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDO0FBQUEsVUFDMUIsQ0FBQztBQUNELGlCQUFPLFlBQVksS0FBSztBQUFBLFFBQzFCO0FBRUEsWUFBSSxRQUFRLFVBQVU7QUFDcEIsVUFBQUEsU0FBUSxVQUFVLE9BQU8sUUFBUSxJQUFJQSxTQUFRLFVBQVU7QUFBQSxRQUN6RDtBQUVBLGlCQUFTLFNBQVMsTUFBTTtBQUN0QixjQUFJLEtBQUssVUFBVTtBQUNqQixtQkFBTyxRQUFRLE9BQU8sSUFBSSxVQUFVLGNBQWMsQ0FBQztBQUFBLFVBQ3JEO0FBQ0EsZUFBSyxXQUFXO0FBQUEsUUFDbEI7QUFFQSxpQkFBUyxnQkFBZ0IsUUFBUTtBQUMvQixpQkFBTyxJQUFJLFFBQVEsU0FBUyxTQUFTLFFBQVE7QUFDM0MsbUJBQU8sU0FBUyxXQUFXO0FBQ3pCLHNCQUFRLE9BQU8sTUFBTTtBQUFBLFlBQ3ZCO0FBQ0EsbUJBQU8sVUFBVSxXQUFXO0FBQzFCLHFCQUFPLE9BQU8sS0FBSztBQUFBLFlBQ3JCO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUVBLGlCQUFTLHNCQUFzQixNQUFNO0FBQ25DLGNBQUksU0FBUyxJQUFJLFdBQVc7QUFDNUIsY0FBSSxVQUFVLGdCQUFnQixNQUFNO0FBQ3BDLGlCQUFPLGtCQUFrQixJQUFJO0FBQzdCLGlCQUFPO0FBQUEsUUFDVDtBQUVBLGlCQUFTLGVBQWUsTUFBTTtBQUM1QixjQUFJLFNBQVMsSUFBSSxXQUFXO0FBQzVCLGNBQUksVUFBVSxnQkFBZ0IsTUFBTTtBQUNwQyxpQkFBTyxXQUFXLElBQUk7QUFDdEIsaUJBQU87QUFBQSxRQUNUO0FBRUEsaUJBQVMsc0JBQXNCLEtBQUs7QUFDbEMsY0FBSSxPQUFPLElBQUksV0FBVyxHQUFHO0FBQzdCLGNBQUksUUFBUSxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBRWpDLG1CQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLGtCQUFNLENBQUMsSUFBSSxPQUFPLGFBQWEsS0FBSyxDQUFDLENBQUM7QUFBQSxVQUN4QztBQUNBLGlCQUFPLE1BQU0sS0FBSyxFQUFFO0FBQUEsUUFDdEI7QUFFQSxpQkFBUyxZQUFZLEtBQUs7QUFDeEIsY0FBSSxJQUFJLE9BQU87QUFDYixtQkFBTyxJQUFJLE1BQU0sQ0FBQztBQUFBLFVBQ3BCLE9BQU87QUFDTCxnQkFBSSxPQUFPLElBQUksV0FBVyxJQUFJLFVBQVU7QUFDeEMsaUJBQUssSUFBSSxJQUFJLFdBQVcsR0FBRyxDQUFDO0FBQzVCLG1CQUFPLEtBQUs7QUFBQSxVQUNkO0FBQUEsUUFDRjtBQUVBLGlCQUFTLE9BQU87QUFDZCxlQUFLLFdBQVc7QUFFaEIsZUFBSyxZQUFZLFNBQVMsTUFBTTtBQUM5QixpQkFBSyxZQUFZO0FBQ2pCLGdCQUFJLENBQUMsTUFBTTtBQUNULG1CQUFLLFlBQVk7QUFBQSxZQUNuQixXQUFXLE9BQU8sU0FBUyxVQUFVO0FBQ25DLG1CQUFLLFlBQVk7QUFBQSxZQUNuQixXQUFXLFFBQVEsUUFBUSxLQUFLLFVBQVUsY0FBYyxJQUFJLEdBQUc7QUFDN0QsbUJBQUssWUFBWTtBQUFBLFlBQ25CLFdBQVcsUUFBUSxZQUFZLFNBQVMsVUFBVSxjQUFjLElBQUksR0FBRztBQUNyRSxtQkFBSyxnQkFBZ0I7QUFBQSxZQUN2QixXQUFXLFFBQVEsZ0JBQWdCLGdCQUFnQixVQUFVLGNBQWMsSUFBSSxHQUFHO0FBQ2hGLG1CQUFLLFlBQVksS0FBSyxTQUFTO0FBQUEsWUFDakMsV0FBVyxRQUFRLGVBQWUsUUFBUSxRQUFRLFdBQVcsSUFBSSxHQUFHO0FBQ2xFLG1CQUFLLG1CQUFtQixZQUFZLEtBQUssTUFBTTtBQUUvQyxtQkFBSyxZQUFZLElBQUksS0FBSyxDQUFDLEtBQUssZ0JBQWdCLENBQUM7QUFBQSxZQUNuRCxXQUFXLFFBQVEsZ0JBQWdCLFlBQVksVUFBVSxjQUFjLElBQUksS0FBSyxrQkFBa0IsSUFBSSxJQUFJO0FBQ3hHLG1CQUFLLG1CQUFtQixZQUFZLElBQUk7QUFBQSxZQUMxQyxPQUFPO0FBQ0wsbUJBQUssWUFBWSxPQUFPLE9BQU8sVUFBVSxTQUFTLEtBQUssSUFBSTtBQUFBLFlBQzdEO0FBRUEsZ0JBQUksQ0FBQyxLQUFLLFFBQVEsSUFBSSxjQUFjLEdBQUc7QUFDckMsa0JBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIscUJBQUssUUFBUSxJQUFJLGdCQUFnQiwwQkFBMEI7QUFBQSxjQUM3RCxXQUFXLEtBQUssYUFBYSxLQUFLLFVBQVUsTUFBTTtBQUNoRCxxQkFBSyxRQUFRLElBQUksZ0JBQWdCLEtBQUssVUFBVSxJQUFJO0FBQUEsY0FDdEQsV0FBVyxRQUFRLGdCQUFnQixnQkFBZ0IsVUFBVSxjQUFjLElBQUksR0FBRztBQUNoRixxQkFBSyxRQUFRLElBQUksZ0JBQWdCLGlEQUFpRDtBQUFBLGNBQ3BGO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFFQSxjQUFJLFFBQVEsTUFBTTtBQUNoQixpQkFBSyxPQUFPLFdBQVc7QUFDckIsa0JBQUksV0FBVyxTQUFTLElBQUk7QUFDNUIsa0JBQUksVUFBVTtBQUNaLHVCQUFPO0FBQUEsY0FDVDtBQUVBLGtCQUFJLEtBQUssV0FBVztBQUNsQix1QkFBTyxRQUFRLFFBQVEsS0FBSyxTQUFTO0FBQUEsY0FDdkMsV0FBVyxLQUFLLGtCQUFrQjtBQUNoQyx1QkFBTyxRQUFRLFFBQVEsSUFBSSxLQUFLLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQUEsY0FDMUQsV0FBVyxLQUFLLGVBQWU7QUFDN0Isc0JBQU0sSUFBSSxNQUFNLHNDQUFzQztBQUFBLGNBQ3hELE9BQU87QUFDTCx1QkFBTyxRQUFRLFFBQVEsSUFBSSxLQUFLLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQztBQUFBLGNBQ25EO0FBQUEsWUFDRjtBQUVBLGlCQUFLLGNBQWMsV0FBVztBQUM1QixrQkFBSSxLQUFLLGtCQUFrQjtBQUN6Qix1QkFBTyxTQUFTLElBQUksS0FBSyxRQUFRLFFBQVEsS0FBSyxnQkFBZ0I7QUFBQSxjQUNoRSxPQUFPO0FBQ0wsdUJBQU8sS0FBSyxLQUFLLEVBQUUsS0FBSyxxQkFBcUI7QUFBQSxjQUMvQztBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBRUEsZUFBSyxPQUFPLFdBQVc7QUFDckIsZ0JBQUksV0FBVyxTQUFTLElBQUk7QUFDNUIsZ0JBQUksVUFBVTtBQUNaLHFCQUFPO0FBQUEsWUFDVDtBQUVBLGdCQUFJLEtBQUssV0FBVztBQUNsQixxQkFBTyxlQUFlLEtBQUssU0FBUztBQUFBLFlBQ3RDLFdBQVcsS0FBSyxrQkFBa0I7QUFDaEMscUJBQU8sUUFBUSxRQUFRLHNCQUFzQixLQUFLLGdCQUFnQixDQUFDO0FBQUEsWUFDckUsV0FBVyxLQUFLLGVBQWU7QUFDN0Isb0JBQU0sSUFBSSxNQUFNLHNDQUFzQztBQUFBLFlBQ3hELE9BQU87QUFDTCxxQkFBTyxRQUFRLFFBQVEsS0FBSyxTQUFTO0FBQUEsWUFDdkM7QUFBQSxVQUNGO0FBRUEsY0FBSSxRQUFRLFVBQVU7QUFDcEIsaUJBQUssV0FBVyxXQUFXO0FBQ3pCLHFCQUFPLEtBQUssS0FBSyxFQUFFLEtBQUssTUFBTTtBQUFBLFlBQ2hDO0FBQUEsVUFDRjtBQUVBLGVBQUssT0FBTyxXQUFXO0FBQ3JCLG1CQUFPLEtBQUssS0FBSyxFQUFFLEtBQUssS0FBSyxLQUFLO0FBQUEsVUFDcEM7QUFFQSxpQkFBTztBQUFBLFFBQ1Q7QUFHQSxZQUFJLFVBQVUsQ0FBQyxVQUFVLE9BQU8sUUFBUSxXQUFXLFFBQVEsS0FBSztBQUVoRSxpQkFBUyxnQkFBZ0IsUUFBUTtBQUMvQixjQUFJLFVBQVUsT0FBTyxZQUFZO0FBQ2pDLGlCQUFPLFFBQVEsUUFBUSxPQUFPLElBQUksS0FBSyxVQUFVO0FBQUEsUUFDbkQ7QUFFQSxpQkFBU0MsU0FBUSxPQUFPLFNBQVM7QUFDL0Isb0JBQVUsV0FBVyxDQUFDO0FBQ3RCLGNBQUksT0FBTyxRQUFRO0FBRW5CLGNBQUksaUJBQWlCQSxVQUFTO0FBQzVCLGdCQUFJLE1BQU0sVUFBVTtBQUNsQixvQkFBTSxJQUFJLFVBQVUsY0FBYztBQUFBLFlBQ3BDO0FBQ0EsaUJBQUssTUFBTSxNQUFNO0FBQ2pCLGlCQUFLLGNBQWMsTUFBTTtBQUN6QixnQkFBSSxDQUFDLFFBQVEsU0FBUztBQUNwQixtQkFBSyxVQUFVLElBQUlELFNBQVEsTUFBTSxPQUFPO0FBQUEsWUFDMUM7QUFDQSxpQkFBSyxTQUFTLE1BQU07QUFDcEIsaUJBQUssT0FBTyxNQUFNO0FBQ2xCLGlCQUFLLFNBQVMsTUFBTTtBQUNwQixnQkFBSSxDQUFDLFFBQVEsTUFBTSxhQUFhLE1BQU07QUFDcEMscUJBQU8sTUFBTTtBQUNiLG9CQUFNLFdBQVc7QUFBQSxZQUNuQjtBQUFBLFVBQ0YsT0FBTztBQUNMLGlCQUFLLE1BQU0sT0FBTyxLQUFLO0FBQUEsVUFDekI7QUFFQSxlQUFLLGNBQWMsUUFBUSxlQUFlLEtBQUssZUFBZTtBQUM5RCxjQUFJLFFBQVEsV0FBVyxDQUFDLEtBQUssU0FBUztBQUNwQyxpQkFBSyxVQUFVLElBQUlBLFNBQVEsUUFBUSxPQUFPO0FBQUEsVUFDNUM7QUFDQSxlQUFLLFNBQVMsZ0JBQWdCLFFBQVEsVUFBVSxLQUFLLFVBQVUsS0FBSztBQUNwRSxlQUFLLE9BQU8sUUFBUSxRQUFRLEtBQUssUUFBUTtBQUN6QyxlQUFLLFNBQVMsUUFBUSxVQUFVLEtBQUs7QUFDckMsZUFBSyxXQUFXO0FBRWhCLGVBQUssS0FBSyxXQUFXLFNBQVMsS0FBSyxXQUFXLFdBQVcsTUFBTTtBQUM3RCxrQkFBTSxJQUFJLFVBQVUsMkNBQTJDO0FBQUEsVUFDakU7QUFDQSxlQUFLLFVBQVUsSUFBSTtBQUFBLFFBQ3JCO0FBRUEsUUFBQUMsU0FBUSxVQUFVLFFBQVEsV0FBVztBQUNuQyxpQkFBTyxJQUFJQSxTQUFRLE1BQU0sRUFBQyxNQUFNLEtBQUssVUFBUyxDQUFDO0FBQUEsUUFDakQ7QUFFQSxpQkFBUyxPQUFPLE1BQU07QUFDcEIsY0FBSSxPQUFPLElBQUksU0FBUztBQUN4QixlQUNHLEtBQUssRUFDTCxNQUFNLEdBQUcsRUFDVCxRQUFRLFNBQVMsT0FBTztBQUN2QixnQkFBSSxPQUFPO0FBQ1Qsa0JBQUksUUFBUSxNQUFNLE1BQU0sR0FBRztBQUMzQixrQkFBSSxPQUFPLE1BQU0sTUFBTSxFQUFFLFFBQVEsT0FBTyxHQUFHO0FBQzNDLGtCQUFJLFFBQVEsTUFBTSxLQUFLLEdBQUcsRUFBRSxRQUFRLE9BQU8sR0FBRztBQUM5QyxtQkFBSyxPQUFPLG1CQUFtQixJQUFJLEdBQUcsbUJBQW1CLEtBQUssQ0FBQztBQUFBLFlBQ2pFO0FBQUEsVUFDRixDQUFDO0FBQ0gsaUJBQU87QUFBQSxRQUNUO0FBRUEsaUJBQVMsYUFBYSxZQUFZO0FBQ2hDLGNBQUksVUFBVSxJQUFJRCxTQUFRO0FBRzFCLGNBQUksc0JBQXNCLFdBQVcsUUFBUSxnQkFBZ0IsR0FBRztBQUNoRSw4QkFBb0IsTUFBTSxPQUFPLEVBQUUsUUFBUSxTQUFTLE1BQU07QUFDeEQsZ0JBQUksUUFBUSxLQUFLLE1BQU0sR0FBRztBQUMxQixnQkFBSSxNQUFNLE1BQU0sTUFBTSxFQUFFLEtBQUs7QUFDN0IsZ0JBQUksS0FBSztBQUNQLGtCQUFJLFFBQVEsTUFBTSxLQUFLLEdBQUcsRUFBRSxLQUFLO0FBQ2pDLHNCQUFRLE9BQU8sS0FBSyxLQUFLO0FBQUEsWUFDM0I7QUFBQSxVQUNGLENBQUM7QUFDRCxpQkFBTztBQUFBLFFBQ1Q7QUFFQSxhQUFLLEtBQUtDLFNBQVEsU0FBUztBQUUzQixpQkFBU0MsVUFBUyxVQUFVLFNBQVM7QUFDbkMsY0FBSSxDQUFDLFNBQVM7QUFDWixzQkFBVSxDQUFDO0FBQUEsVUFDYjtBQUVBLGVBQUssT0FBTztBQUNaLGVBQUssU0FBUyxRQUFRLFdBQVcsU0FBWSxNQUFNLFFBQVE7QUFDM0QsZUFBSyxLQUFLLEtBQUssVUFBVSxPQUFPLEtBQUssU0FBUztBQUM5QyxlQUFLLGFBQWEsZ0JBQWdCLFVBQVUsUUFBUSxhQUFhO0FBQ2pFLGVBQUssVUFBVSxJQUFJRixTQUFRLFFBQVEsT0FBTztBQUMxQyxlQUFLLE1BQU0sUUFBUSxPQUFPO0FBQzFCLGVBQUssVUFBVSxRQUFRO0FBQUEsUUFDekI7QUFFQSxhQUFLLEtBQUtFLFVBQVMsU0FBUztBQUU1QixRQUFBQSxVQUFTLFVBQVUsUUFBUSxXQUFXO0FBQ3BDLGlCQUFPLElBQUlBLFVBQVMsS0FBSyxXQUFXO0FBQUEsWUFDbEMsUUFBUSxLQUFLO0FBQUEsWUFDYixZQUFZLEtBQUs7QUFBQSxZQUNqQixTQUFTLElBQUlGLFNBQVEsS0FBSyxPQUFPO0FBQUEsWUFDakMsS0FBSyxLQUFLO0FBQUEsVUFDWixDQUFDO0FBQUEsUUFDSDtBQUVBLFFBQUFFLFVBQVMsUUFBUSxXQUFXO0FBQzFCLGNBQUksV0FBVyxJQUFJQSxVQUFTLE1BQU0sRUFBQyxRQUFRLEdBQUcsWUFBWSxHQUFFLENBQUM7QUFDN0QsbUJBQVMsT0FBTztBQUNoQixpQkFBTztBQUFBLFFBQ1Q7QUFFQSxZQUFJLG1CQUFtQixDQUFDLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRztBQUUvQyxRQUFBQSxVQUFTLFdBQVcsU0FBUyxLQUFLLFFBQVE7QUFDeEMsY0FBSSxpQkFBaUIsUUFBUSxNQUFNLE1BQU0sSUFBSTtBQUMzQyxrQkFBTSxJQUFJLFdBQVcscUJBQXFCO0FBQUEsVUFDNUM7QUFFQSxpQkFBTyxJQUFJQSxVQUFTLE1BQU0sRUFBQyxRQUFnQixTQUFTLEVBQUMsVUFBVSxJQUFHLEVBQUMsQ0FBQztBQUFBLFFBQ3RFO0FBRUEsUUFBQUgsU0FBUSxlQUFlRCxNQUFLO0FBQzVCLFlBQUk7QUFDRixjQUFJQyxTQUFRLGFBQWE7QUFBQSxRQUMzQixTQUFTLEtBQVA7QUFDQSxVQUFBQSxTQUFRLGVBQWUsU0FBUyxTQUFTLE1BQU07QUFDN0MsaUJBQUssVUFBVTtBQUNmLGlCQUFLLE9BQU87QUFDWixnQkFBSSxRQUFRLE1BQU0sT0FBTztBQUN6QixpQkFBSyxRQUFRLE1BQU07QUFBQSxVQUNyQjtBQUNBLFVBQUFBLFNBQVEsYUFBYSxZQUFZLE9BQU8sT0FBTyxNQUFNLFNBQVM7QUFDOUQsVUFBQUEsU0FBUSxhQUFhLFVBQVUsY0FBY0EsU0FBUTtBQUFBLFFBQ3ZEO0FBRUEsaUJBQVNJLE9BQU0sT0FBTyxNQUFNO0FBQzFCLGlCQUFPLElBQUksUUFBUSxTQUFTLFNBQVMsUUFBUTtBQUMzQyxnQkFBSSxVQUFVLElBQUlGLFNBQVEsT0FBTyxJQUFJO0FBRXJDLGdCQUFJLFFBQVEsVUFBVSxRQUFRLE9BQU8sU0FBUztBQUM1QyxxQkFBTyxPQUFPLElBQUlGLFNBQVEsYUFBYSxXQUFXLFlBQVksQ0FBQztBQUFBLFlBQ2pFO0FBRUEsZ0JBQUksTUFBTSxJQUFJLGVBQWU7QUFFN0IscUJBQVMsV0FBVztBQUNsQixrQkFBSSxNQUFNO0FBQUEsWUFDWjtBQUVBLGdCQUFJLFNBQVMsV0FBVztBQUN0QixrQkFBSSxVQUFVO0FBQUEsZ0JBQ1osUUFBUSxJQUFJO0FBQUEsZ0JBQ1osWUFBWSxJQUFJO0FBQUEsZ0JBQ2hCLFNBQVMsYUFBYSxJQUFJLHNCQUFzQixLQUFLLEVBQUU7QUFBQSxjQUN6RDtBQUNBLHNCQUFRLE1BQU0saUJBQWlCLE1BQU0sSUFBSSxjQUFjLFFBQVEsUUFBUSxJQUFJLGVBQWU7QUFDMUYsa0JBQUksT0FBTyxjQUFjLE1BQU0sSUFBSSxXQUFXLElBQUk7QUFDbEQsc0JBQVEsSUFBSUcsVUFBUyxNQUFNLE9BQU8sQ0FBQztBQUFBLFlBQ3JDO0FBRUEsZ0JBQUksVUFBVSxXQUFXO0FBQ3ZCLHFCQUFPLElBQUksVUFBVSx3QkFBd0IsQ0FBQztBQUFBLFlBQ2hEO0FBRUEsZ0JBQUksWUFBWSxXQUFXO0FBQ3pCLHFCQUFPLElBQUksVUFBVSx3QkFBd0IsQ0FBQztBQUFBLFlBQ2hEO0FBRUEsZ0JBQUksVUFBVSxXQUFXO0FBQ3ZCLHFCQUFPLElBQUlILFNBQVEsYUFBYSxXQUFXLFlBQVksQ0FBQztBQUFBLFlBQzFEO0FBRUEsZ0JBQUksS0FBSyxRQUFRLFFBQVEsUUFBUSxLQUFLLElBQUk7QUFFMUMsZ0JBQUksUUFBUSxnQkFBZ0IsV0FBVztBQUNyQyxrQkFBSSxrQkFBa0I7QUFBQSxZQUN4QixXQUFXLFFBQVEsZ0JBQWdCLFFBQVE7QUFDekMsa0JBQUksa0JBQWtCO0FBQUEsWUFDeEI7QUFFQSxnQkFBSSxrQkFBa0IsT0FBTyxRQUFRLE1BQU07QUFDekMsa0JBQUksZUFBZTtBQUFBLFlBQ3JCO0FBRUEsb0JBQVEsUUFBUSxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQzVDLGtCQUFJLGlCQUFpQixNQUFNLEtBQUs7QUFBQSxZQUNsQyxDQUFDO0FBRUQsZ0JBQUksUUFBUSxRQUFRO0FBQ2xCLHNCQUFRLE9BQU8saUJBQWlCLFNBQVMsUUFBUTtBQUVqRCxrQkFBSSxxQkFBcUIsV0FBVztBQUVsQyxvQkFBSSxJQUFJLGVBQWUsR0FBRztBQUN4QiwwQkFBUSxPQUFPLG9CQUFvQixTQUFTLFFBQVE7QUFBQSxnQkFDdEQ7QUFBQSxjQUNGO0FBQUEsWUFDRjtBQUVBLGdCQUFJLEtBQUssT0FBTyxRQUFRLGNBQWMsY0FBYyxPQUFPLFFBQVEsU0FBUztBQUFBLFVBQzlFLENBQUM7QUFBQSxRQUNIO0FBRUEsUUFBQUksT0FBTSxXQUFXO0FBRWpCLFlBQUksQ0FBQ0wsTUFBSyxPQUFPO0FBQ2YsVUFBQUEsTUFBSyxRQUFRSztBQUNiLFVBQUFMLE1BQUssVUFBVUU7QUFDZixVQUFBRixNQUFLLFVBQVVHO0FBQ2YsVUFBQUgsTUFBSyxXQUFXSTtBQUFBLFFBQ2xCO0FBRUEsUUFBQUgsU0FBUSxVQUFVQztBQUNsQixRQUFBRCxTQUFRLFVBQVVFO0FBQ2xCLFFBQUFGLFNBQVEsV0FBV0c7QUFDbkIsUUFBQUgsU0FBUSxRQUFRSTtBQUVoQixlQUFPLGVBQWVKLFVBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSyxDQUFDO0FBRTVELGVBQU9BO0FBQUEsTUFFVCxFQUFHLENBQUMsQ0FBQztBQUFBLElBQ0wsR0FBRyxPQUFPLFNBQVMsY0FBYyxPQUFPLE9BQUk7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuaEI1QyxRQUFBLGdDQUFBO0FBT0E7QUFDQSxRQUFBLFVBQUE7QUFRQSxRQUFBOztNQUFBLFNBQUEsUUFBQTtBQUE0QixrQkFBQUssZ0JBQUEsTUFBQTtBQUMxQixpQkFBQUEsZUFBWSxTQUFlOztBQUEzQixjQUFBLFFBQ0UsT0FBQSxLQUFBLE1BQU0sT0FBTyxLQUFDO0FBQ2QsZ0JBQUssT0FBTztBQUNaLGlCQUFPLGVBQWUsT0FBTSxXQUFXLFNBQVM7QUFDaEQsZ0JBQUssUUFBUTs7UUFDZjtBQUNGLGVBQUFBO01BQUEsRUFQNEIsS0FBSzs7QUFTakMsYUFBZSxvQkFDYixRQUFrQzs7Ozs7O0FBRTlCLHVCQUFTLElBQUksV0FBVyxDQUFDO0FBQ3ZCLHVCQUFTLE9BQU8sVUFBUzs7OztBQUNwQix1QkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUVlLHFCQUFBLENBQUEsR0FBTSxPQUFPLEtBQUksQ0FBRTs7QUFBckMsY0FBQUMsTUFBa0IsR0FBQSxLQUFBLEdBQWhCLE9BQUlBLElBQUEsTUFBRSxRQUFLQSxJQUFBO0FBQ25CLGtCQUFJLE1BQU07QUFDUix1QkFBQSxDQUFBLEdBQUEsQ0FBQTs7QUFHRixrQkFBSSxPQUFPO0FBQ0gsNEJBQVksSUFBSSxXQUFXLE9BQU8sU0FBUyxNQUFNLE1BQU07QUFDN0QsMEJBQVUsSUFBSSxNQUFNO0FBQ3BCLDBCQUFVLElBQUksT0FBTyxPQUFPLE1BQU07QUFDbEMseUJBQVM7Ozs7QUFHYixxQkFBQSxDQUFBLEdBQU8sTUFBTTs7Ozs7QUFHZixhQUFlLFFBQVEsTUFBZ0IsTUFBUzs7Ozs7Ozs7QUFFckMscUJBQUEsQ0FBQSxHQUFNLEtBQUssSUFBSSxDQUFDOztBQUF2QixxQkFBQSxDQUFBLEdBQU8sR0FBQSxLQUFBLENBQWdCOzs7QUFFakIsc0JBQVE7b0JBQ1YsU0FBUyxNQUFNO0FBQWYsdUJBQUEsQ0FBQSxHQUFBLENBQUE7QUFDSSxzQkFBT0EsTUFBQSxNQUFNLGNBQVEsUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUU7QUFDZCxtQkFBQTs7QUFBQSx1QkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUFTLHFCQUFBLENBQUEsR0FBTSxvQkFBb0IsSUFBSSxDQUFDOztBQUFoQyxtQkFBQyxHQUFBLEtBQUE7OztBQUFsQix1QkFBTTtBQUNOLHFCQUFPLFVBQVUsSUFBSSxZQUFXLEVBQUcsT0FBTyxNQUFNO0FBQ3RELGtCQUFJO0FBRUksdUJBQU8sUUFBUSxLQUFLLE1BQU0sSUFBSTtBQUNwQyx1QkFBQSxDQUFBLEdBQU8sUUFBUSxPQUFPLElBQUksY0FBYyxHQUFBLE9BQUcsU0FBSSxRQUFKLFNBQUksU0FBQSxTQUFKLEtBQU0sT0FBTyxDQUFFLENBQUMsQ0FBQzt1QkFDckQsR0FBUDtBQUNBLHVCQUFBLENBQUEsR0FBTyxRQUFRLE9BQ2IsSUFBSSxjQUNGLGlDQUFBLE9BQWlDLEtBQUssS0FBSyxRQUN6QyxVQUNBLEVBQUUsR0FDSCxJQUFBLEVBQUEsT0FBSyxJQUFJLENBQUUsQ0FDYixDQUNGOzs7O0FBR0gscUJBQUEsQ0FBQSxHQUFPLFFBQVEsT0FDYixJQUFJLGNBQ0YsaUNBQUEsT0FBaUMsS0FBSyxLQUFLLFFBQ3pDLFVBQ0EsRUFBRSxHQUNILElBQUEsRUFBQSxPQUFLLEtBQUssQ0FBRSxDQUNkLENBQ0Y7Ozs7Ozs7Ozs7OztBQUtQLGFBQVMsY0FBYyxVQUFlLFFBQXNCO0FBQTVELFVBQUEsUUFBQTs2QkFDYUMsT0FBSTtBQUNiLFlBQUksYUFBYSxTQUFTQSxLQUFJO0FBQzlCLFlBQ0UsY0FDQSxPQUFPLGVBQWUsY0FDdEJBLFVBQVMsZUFDVDtBQUVBLGlCQUFPQSxLQUFJLElBQUksU0FBTyxNQUFLO0FBQUEsbUJBQUEsVUFBQSxPQUFBLFFBQUEsUUFBQSxXQUFBOzs7QUFDekIsdUJBQU8sZUFBZSxZQUFZLFFBQVEsRUFBRSxPQUFPQSxNQUFJLENBQUU7QUFDckQsZ0NBQTBCLFdBQVcsS0FBSyxRQUFRO0FBRXRELHVCQUFBLENBQUEsR0FBTyxRQUFRLGVBQWUsSUFBSSxDQUFDOzs7Ozs7QUFaekMsZUFBbUIsS0FBQSxHQUFBRCxNQUFBLE9BQU8sS0FBSyxPQUFPLGVBQWUsUUFBUSxDQUFDLEdBQTNDLEtBQUFBLElBQUEsUUFBQSxNQUE0QztBQUExRCxZQUFNLE9BQUlBLElBQUEsRUFBQTtnQkFBSixJQUFJOztJQWdCakI7QUFFQSxhQUFTLGNBQWMsVUFBNkI7QUFBcEQsVUFBQSxRQUFBOzZCQUNhQyxPQUFJO0FBQ2IsWUFBSSxhQUFhLFNBQVNBLEtBQUk7QUFDOUIsWUFDRSxjQUNBLE9BQU8sZUFBZSxjQUN0QkEsVUFBUyxlQUNUO0FBRUEsbUJBQVNBLEtBQUksSUFBSSxTQUFPLE1BQUs7QUFBQSxtQkFBQSxVQUFBLE9BQUEsUUFBQSxRQUFBLFdBQUE7OztBQUMzQix1QkFBTyxlQUFlLFlBQVksUUFBUSxFQUFFLE9BQU9BLE1BQUksQ0FBRTtBQUNyRCxnQ0FBMEIsV0FBVyxLQUFLLFFBQVE7QUFDdEQsdUJBQUEsQ0FBQSxHQUFPLFFBQVEsZUFBZSxJQUFJLENBQUM7Ozs7OztBQVh6QyxlQUFtQixLQUFBLEdBQUFELE1BQUEsT0FBTyxLQUFLLE9BQU8sZUFBZSxRQUFRLENBQUMsR0FBM0MsS0FBQUEsSUFBQSxRQUFBLE1BQTRDO0FBQTFELFlBQU0sT0FBSUEsSUFBQSxFQUFBO2dCQUFKLElBQUk7O0FBZWYsYUFBTztJQUNUO0FBU0EsUUFBQTs7TUFBQSxXQUFBO0FBQUEsaUJBQUFFLGtCQUFBO0FBQ0UsZUFBQSxTQUF3QjtBQUN4QixlQUFBLGNBQTZCO0FBQzdCLGVBQUEsY0FBNkI7UUFpRi9CO0FBL0VnQixRQUFBQSxnQkFBQSxVQUFBLGlCQUFkLFNBQTZCLGdCQUF3QixRQUFjOzs7Ozs7QUFDM0QsMkJBQVMsR0FBQSxPQUFHLGdCQUFjLGlCQUFBO0FBQzFCLDRCQUFVO29CQUNkLFFBQVE7b0JBQ1IsU0FBUztzQkFDUCxnQkFBZ0I7c0JBQ2hCLFdBQVc7Ozs7OztBQUtGLHlCQUFBLENBQUEsR0FBTSxNQUFNLFFBQVEsT0FBTyxDQUFDOztBQUF2Qyw2QkFBV0YsSUFBQSxLQUFBO3dCQUNQLFNBQVMsV0FBVztBQUFwQiwyQkFBQSxDQUFBLEdBQUEsQ0FBQTtBQUNZLHlCQUFBLENBQUEsR0FBTSxTQUFTLEtBQUksQ0FBRTs7QUFBN0IsMEJBQVFBLElBQUEsS0FBQTtBQUNSLCtCQUFhLFNBQVM7QUFDNUIsd0JBQU0sSUFBSSxNQUFNLEdBQUEsT0FBRyxZQUFVLEtBQUEsRUFBQSxPQUFNLEtBQUssQ0FBRTs7QUFFakIseUJBQUEsQ0FBQSxHQUFNLFNBQVMsS0FBSSxDQUFFOztBQUF0QyxpQ0FBaUJBLElBQUEsS0FBQSxFQUFxQjtBQUM5Qyx5QkFBQSxDQUFBLEdBQU8sWUFBWTs7Ozs7QUFHckIsd0JBQU0sSUFBSSxjQUFjLGdDQUFBLE9BQWdDLE9BQUssQ0FBRTs7Ozs7Ozs7OztBQUl0RCxRQUFBRSxnQkFBQSxVQUFBLE9BQWIsU0FBa0IsZUFBMEM7Ozs7OztBQUNsRCxnQ0FBd0IsY0FBYSxhQUF4QixTQUFXLGNBQWE7QUFFN0MsdUJBQUssU0FBUztBQUNkLHVCQUFLLGNBQWM7QUFFYixtQ0FBaUIsc0JBQUEsT0FBc0IsYUFBVyxjQUFBOzs7O0FBRXRELGtCQUFBRixNQUFBO0FBQW1CLHlCQUFBLENBQUEsR0FBTSxLQUFLLGVBQWUsZ0JBQWdCLE1BQU0sQ0FBQzs7QUFBcEUsa0JBQUFBLElBQUssY0FBYyxHQUFBLEtBQUE7Ozs7QUFFbkIsd0JBQU07O0FBR0Ysc0RBQTZEO29CQUNqRSxVQUFVO29CQUNWO29CQUNBLHNCQUFvQixRQUFBO29CQUNwQixTQUFTO3NCQUNQLGVBQWMsR0FBQSxRQUFBLGdCQUFlLElBQUk7OztBQUkvQiw0Q0FBMEIsSUFBSSw4QkFBQSxjQUNsQyxpQ0FBaUM7QUFFN0Isb0NBQWtCLElBQUksOEJBQUEsbUJBQW1CLHVCQUF1QjtBQUN0RSxnQ0FBYyxpQkFBaUIsSUFBc0I7Ozs7Ozs7OztBQUdoRCxRQUFBRSxnQkFBQSxVQUFBLFFBQVAsU0FBYSxPQUFhO0FBQ3hCLGNBQUksQ0FBQyxLQUFLO0FBQ1Isa0JBQU0sSUFBSSxNQUFNLHFEQUFxRDtBQUN2RSxjQUFJLENBQUMsS0FBSztBQUNSLGtCQUFNLElBQUksTUFDUiwwREFBMEQ7QUFFOUQsY0FBSSxDQUFDLEtBQUs7QUFDUixrQkFBTSxJQUFJLE1BQ1IseURBQXlEO0FBRzdELGNBQU0sK0JBQXdEO1lBQzVELFVBQVUsV0FBQSxPQUFXLE9BQUssR0FBQSxFQUFBLE9BQUksS0FBSyxhQUFXLE9BQUEsRUFBQSxPQUFRLEtBQUssYUFBVyxjQUFBO1lBQ3RFLFFBQVEsS0FBSztZQUNiLHNCQUFvQixRQUFBO1lBQ3BCLFNBQVM7Y0FDUCxlQUFjLEdBQUEsUUFBQSxnQkFBZSxJQUFJOzs7QUFJckMsY0FBTSxxQkFBcUIsSUFBSSw4QkFBQSxjQUFjLDRCQUE0QjtBQUN6RSxjQUFNLG1CQUFtQixJQUFJLDhCQUFBLG9CQUFvQixrQkFBa0I7QUFDbkUsaUJBQU8sY0FBYyxnQkFBZ0I7UUFDdkM7QUFDRixlQUFBQTtNQUFBLEVBcEZBOztBQXNGUyxZQUFBLGlCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFNVCxRQUFNLHdCQUF3QixTQUM1QixRQUNBLFdBQ0EsU0FBbUI7QUFBbkIsVUFBQSxZQUFBLFFBQUE7QUFBQSxrQkFBQTtNQUFtQjs7Ozs7Ozs7QUFHaUIscUJBQUEsQ0FBQSxHQUFNLE9BQU8sY0FBYyxFQUFFLFVBQVMsQ0FBRSxDQUFDOztBQUF2RSxpQ0FBOEIsR0FBQSxLQUFBO21CQUM5QixHQUFDQyxNQUFBLGlCQUFpQixZQUFNLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFO0FBQTFCLHVCQUFBLENBQUEsR0FBQSxDQUFBO0FBQ0YscUJBQUEsQ0FBQSxHQUFNLElBQUksUUFBUSxTQUFDLEdBQUM7QUFBSyx1QkFBQSxXQUFXLEdBQUcsR0FBSTtjQUFsQixDQUFtQixDQUFDOztBQUE3QyxpQkFBQSxLQUFBO0FBQ0EscUJBQUEsQ0FBQSxHQUFNLHNCQUFzQixRQUFRLFdBQVcsVUFBVSxDQUFDLENBQUM7O0FBQTNELGlCQUFBLEtBQUE7OztBQUVBLHNCQUFRLElBQUkscUJBQUEsT0FBcUIsU0FBTyxVQUFBLENBQVU7QUFDbEQscUJBQUE7Z0JBQUE7O2NBQUE7Ozs7O0FBR0Ysc0JBQVEsTUFBTSxzQ0FBc0MsR0FBQzs7Ozs7Ozs7Ozs7QUFPekQsUUFBTSx5QkFBeUIsU0FDN0IsUUFDQSxXQUNBLFdBQWlCO0FBQUEsYUFBQSxVQUFBLFFBQUEsUUFBQSxRQUFBLFdBQUE7Ozs7OztBQUdHLHFCQUFBLENBQUEsR0FBTSxPQUFPLFlBQVcsQ0FBRTs7QUFBdEMsMEJBQVlBLElBQUEsS0FBQTttQkFDZCxDQUFDLFVBQVUsU0FBUyxTQUFTO0FBQTdCLHVCQUFBLENBQUEsR0FBQSxDQUFBO0FBQ0Ysc0JBQVEsSUFBSSxrQkFBa0IsU0FBUztBQUN2QyxxQkFBQSxDQUFBLEdBQU0sT0FBTyxZQUFZO2dCQUN2QixlQUFlO2tCQUNiLE1BQU07a0JBQ047O2VBRUgsQ0FBQzs7QUFMRixjQUFBQSxJQUFBLEtBQUE7QUFNQSxzQkFBUSxJQUFJLGlDQUFpQztBQUM3QyxxQkFBQSxDQUFBLEdBQU0sc0JBQXNCLFFBQVEsU0FBUyxDQUFDOztBQUE5QyxjQUFBQSxJQUFBLEtBQUE7QUFDQSxzQkFBUSxJQUFJLGlCQUFpQjs7Ozs7O0FBRy9CLHNCQUFRLE1BQU0sd0JBQXdCLEdBQUM7Ozs7Ozs7Ozs7O0FBSTNDLFFBQU0sa0JBQWtCLFNBQUksS0FBVSxXQUFpQjtBQUNyRCxhQUFPLE1BQU0sS0FBSyxFQUFFLFFBQVEsS0FBSyxLQUFLLElBQUksU0FBUyxTQUFTLEVBQUMsR0FBSSxTQUFDLEdBQUcsR0FBQztBQUNwRSxlQUFBLElBQUksTUFBTSxJQUFJLFlBQVksSUFBSSxLQUFLLFNBQVM7TUFBNUMsQ0FBNkM7SUFFakQ7QUFLQSxRQUFNLGdCQUFnQixTQUNwQixPQUNBLFNBQ0EsV0FDQSxXQUFjO0FBQWQsVUFBQSxjQUFBLFFBQUE7QUFBQSxvQkFBQTtNQUFjOzs7Ozs7QUFHUix1QkFBUyxnQkFBd0IsU0FBUyxTQUFTOzs7O0FBSXZELHFCQUFBLENBQUEsR0FBTSxRQUFRLFdBQ1osT0FBTyxJQUFJLFNBQU8sT0FBSztBQUFBLHVCQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsV0FBQTs7Ozs7O0FBRW5CLCtCQUFBLENBQUEsR0FBTSxNQUFNLE9BQU87MEJBQ2pCLGVBQWU7NEJBQ2IsU0FBUzs0QkFDVDs7eUJBRUgsQ0FBQzs7QUFMRix3QkFBQUEsSUFBQSxLQUFBOzs7O0FBT0EsZ0NBQVEsSUFBSSx5QkFBeUIsR0FBQzs7Ozs7Ozs7OztlQUV6QyxDQUFDLENBQ0g7O0FBYkQsY0FBQUEsSUFBQSxLQUFBO0FBZUEscUJBQUEsQ0FBQSxHQUFPLElBQUk7OztBQUVYLG9CQUFNLElBQUksTUFBTSx1Q0FBQSxPQUF1QyxHQUFDLENBQUU7Ozs7Ozs7Ozs7QUFJOUQsUUFBTSxRQUFRO01BQ1o7TUFDQTtNQUNBOztBQUdPLFlBQUEsUUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekdULFFBQUEsYUFBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLFlBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxXQUFBO0lBQVEsRUFBQSxDQUFBO0FBQ2pCLFFBQUEsU0FBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLFNBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxPQUFBO0lBQUssRUFBQSxDQUFBO0FBRWQsWUFBQSxTQUFBLGFBQUEsZ0JBQUE7QUFnREEsUUFBQSxPQUFBO0FBQVMsV0FBQSxlQUFBLFNBQUEsa0JBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxLQUFBO0lBQWMsRUFBQSxDQUFBO0FBQ3ZCLFFBQUEsVUFBQTtBQUFTLFdBQUEsZUFBQSxTQUFBLFNBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFBQSxRQUFBO0lBQUssRUFBQSxDQUFBOzs7OztBQ3BEZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBWU87QUFFUCxJQUFBQyxtQkFBeUI7QUFHekIsa0JBQTZCOzs7QUNGN0IsSUFBTSxnQkFBTixNQUFvQjtBQUFBLEVBR25CLGNBQWM7QUFBQSxFQUFDO0FBQUEsRUFFZixLQUFLQyxNQUFVO0FBQ2QsU0FBSyxNQUFNQTtBQUFBLEVBQ1o7QUFBQSxFQUVBLFdBQVcsU0FBa0I7QUFDNUIsU0FBSyxVQUFVO0FBQUEsRUFDaEI7QUFBQSxFQUVBLGFBQWE7QUFDWixRQUFJLENBQUMsS0FBSyxTQUFTO0FBQ2xCLGFBQU87QUFBQTtBQUFBLFFBRU4sVUFBVSxLQUFLLElBQUksUUFBUSxRQUFRLFVBQVUsRUFBRTtBQUFBO0FBQUEsUUFFL0MsYUFBYSxLQUFLLElBQUksUUFBUSxRQUFRLGVBQWUsRUFBRTtBQUFBLFFBQ3ZELFFBQVEsS0FBSyxJQUFJLFFBQVEsUUFBUSx3QkFBd0IsRUFDdkQ7QUFBQSxNQUNIO0FBQUEsSUFDRDtBQUNBLFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFDRDtBQUVBLElBQU0sZ0JBQWdCLElBQUksY0FBYztBQUV4QyxJQUFPLHlCQUFROzs7QUMxQ2YsZUFBc0IsWUFBWSxNQUFhQyxNQUFVO0FBQ3hELFFBQU1BLEtBQUksWUFBWTtBQUFBLElBQ3JCO0FBQUEsSUFDQSxLQUFLLEtBQUssTUFBTSxRQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsS0FBSztBQUFBLEVBQ3BDO0FBQ0Q7QUFDQSxlQUFzQixjQUFjLE1BQWFBLE1BQVU7QUFDMUQsUUFBTUEsS0FBSSxZQUFZO0FBQUEsSUFDckI7QUFBQSxJQUNBLEtBQUssS0FBSyxNQUFNLGNBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxLQUFLO0FBQUEsRUFDckM7QUFDRDtBQUNBLGVBQXNCLFNBQVMsTUFBYUEsTUFBVTtBQUNyRCxNQUFJLEtBQUssS0FBSyxTQUFTLFFBQUc7QUFBRztBQUM3QixRQUFNQSxLQUFJLFlBQVk7QUFBQSxJQUNyQjtBQUFBLElBQ0EsS0FBSyxLQUFLLE1BQU0sS0FBSyxFQUFFLENBQUMsRUFBRSxLQUFLLElBQUk7QUFBQSxFQUNwQztBQUNEO0FBQ0EsZUFBc0IsV0FBVyxNQUFhQSxNQUFVO0FBQ3ZELE1BQUksS0FBSyxLQUFLLFNBQVMsY0FBSTtBQUFHO0FBQzlCLFFBQU1BLEtBQUksWUFBWTtBQUFBLElBQ3JCO0FBQUEsSUFDQSxLQUFLLEtBQUssTUFBTSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSTtBQUFBLEVBQ3BDO0FBQ0Q7QUFFQSxlQUFzQixjQUFjLE1BQWFBLE1BQVUsTUFBYztBQUN4RSxNQUFJLEtBQUssS0FBSyxTQUFTLElBQUk7QUFBRztBQUM5QixRQUFNQSxLQUFJLFlBQVk7QUFBQSxJQUNyQjtBQUFBLElBQ0EsS0FBSyxLQUFLLE1BQU0sS0FBSyxFQUFFLENBQUMsRUFBRSxLQUFLLElBQUksSUFBSTtBQUFBLEVBQ3hDO0FBQ0Q7QUFFQSxlQUFzQixtQkFBbUIsTUFBYUEsTUFBVSxNQUFjO0FBQzdFLE1BQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJO0FBQUc7QUFDL0IsUUFBTUEsS0FBSSxZQUFZO0FBQUEsSUFDckI7QUFBQSxJQUNBLEtBQUssS0FBSyxNQUFNLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxLQUFLO0FBQUEsRUFDckM7QUFDRDtBQUVBLGVBQXNCLFdBQVcsTUFBYSxpQkFBeUI7QUE5Q3ZFLE1BQUFDLEtBQUE7QUErQ0MsUUFBTUQsT0FBTSx1QkFBYztBQUUxQixRQUFNLEVBQUUsZUFBZSxNQUFNLElBQUlBO0FBQ2pDLFFBQU0sWUFBVyxNQUFBQyxNQUFBLGNBQWMsYUFBYSxJQUFJLE1BQS9CLGdCQUFBQSxJQUFrQyxhQUFsQyxZQUE4QyxDQUFDO0FBQ2hFLE1BQUksT0FBTyxNQUFNLE1BQU0sV0FBVyxJQUFJO0FBQ3RDLFFBQU0sT0FBTyxTQUFTO0FBQUEsSUFDckIsQ0FBQyxFQUFFLFFBQVEsTUFBVyxZQUFZO0FBQUEsRUFDbkM7QUFDQSxNQUFJLFNBQVMsSUFBSTtBQUNoQixXQUFPO0FBQUEsRUFDUixPQUFPO0FBQ04sV0FBTyxLQUNMLE1BQU0sSUFBSSxFQUNWO0FBQUEsTUFDQSxTQUFTLElBQUksRUFBRSxTQUFTLE1BQU0sT0FBTztBQUFBLE9BQ3JDLDBCQUFTLE9BQU8sQ0FBQyxNQUFqQixtQkFBb0IsYUFBcEIsbUJBQThCLFVBQTlCLG1CQUFxQztBQUFBLElBQ3RDLEVBQ0MsS0FBSyxJQUFJLEVBQ1QsS0FBSztBQUFBLEVBQ1I7QUFFQSxVQUFRLElBQUksSUFBSTtBQUVoQixTQUFPO0FBQ1I7QUFFQSxlQUFzQiwyQkFDckIsTUFDQSxpQkFDQSxVQUNBLFNBQW1CLENBQUMsR0FDcEIsYUFBdUIsQ0FBQyxHQUNGO0FBL0V2QixNQUFBQSxLQUFBO0FBZ0ZDLE1BQUksQ0FBQztBQUFVLGVBQVc7QUFDMUIsUUFBTUQsT0FBTSx1QkFBYztBQUUxQixRQUFNLEVBQUUsZUFBZSxNQUFNLElBQUlBO0FBQ2pDLFFBQU0sUUFBUSxjQUFjLGFBQWEsSUFBSTtBQUM3QyxRQUFNLFlBQVdDLE1BQUEsK0JBQU8sYUFBUCxPQUFBQSxNQUFtQixDQUFDO0FBQ3JDLFFBQU0sWUFBVyxvQ0FBTyxhQUFQLFlBQW1CLENBQUM7QUFDckMsTUFBSSxPQUFPLE1BQU0sTUFBTSxLQUFLLElBQUk7QUFDaEMsTUFBSSxVQUFVLEtBQUs7QUFFbkIsUUFBTSxVQUFVLFNBQVM7QUFBQSxJQUN4QixDQUFDLEVBQUUsU0FBQUMsU0FBUSxNQUFXQSxhQUFZO0FBQUEsRUFDbkM7QUFDQSxNQUFJLENBQUMsU0FBUztBQUNiLFlBQVEsSUFBSSxrQkFBa0I7QUFDOUIsV0FBTyxDQUFDLFFBQVEsVUFBVTtBQUFBLEVBQzNCO0FBRUEsUUFBTSxPQUFPLFNBQVM7QUFBQSxJQUNyQixDQUFDLEVBQUUsU0FBUyxNQUNYLFNBQVMsSUFBSSxXQUFXLFFBQVEsU0FBUyxJQUFJO0FBQUEsRUFDL0M7QUFHQSxRQUFNLGNBQWMsaUNBQVEsT0FBTyxDQUFDLEtBQUssTUFBTSxRQUFRO0FBQ3RELFFBQUksY0FBYyxRQUFRLFNBQVMsTUFBTSxRQUFRLFdBQVcsR0FBRyxHQUFHO0FBQ2pFLGFBQU8sTUFBTTtBQUFBLElBQ2Q7QUFDQSxXQUFPO0FBQUEsRUFDUixHQUFHO0FBRUgsTUFBSSxDQUFDLFNBQVMsT0FBTyxDQUFDLEtBQUssU0FBUyxPQUFPLENBQUMsRUFBRSxTQUFTLFdBQVc7QUFDakUsWUFBUSxJQUFJLE1BQU07QUFFbEIsV0FDQyxLQUFLLE1BQU0sR0FBRyxRQUFRLFNBQVMsSUFBSSxTQUFTLFdBQVcsSUFDdkQsV0FDQSxLQUFLLE1BQU0sUUFBUSxTQUFTLElBQUksU0FBUyxXQUFXO0FBQUEsRUFDdEQsT0FBTztBQUVOLFdBQ0MsS0FBSyxNQUFNLEdBQUcsUUFBUSxTQUFTLElBQUksU0FBUyxXQUFXLElBQ3ZELFdBQ0EsS0FBSztBQUFBLE1BQ0osU0FBUyxPQUFPLENBQUMsRUFBRSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQUEsSUFDOUM7QUFBQSxFQUNGO0FBRUEsUUFBTUYsS0FBSSxNQUFNLE9BQU8sTUFBTSxJQUFJO0FBR2pDLFNBQU8sS0FBSyxLQUFLLFNBQVMsT0FBTztBQUNqQywyQ0FBWSxLQUFLLFFBQVEsU0FBUyxNQUFNO0FBRXhDLFNBQU8sQ0FBQyxRQUFRLFVBQVU7QUFDM0I7OztBQ3ZJTyxJQUFNLFVBQVU7OztBQ0F2Qjs7Ozs7Ozs7Ozs7Ozs7OztBQUlNLElBQU8sY0FBUCxjQUEyQixNQUFLOztBQUVoQyxJQUFPLFdBQVAsY0FBd0IsWUFBVztFQVN2QyxZQUNFLFFBQ0EsT0FDQSxTQUNBLFNBQTRCO0FBRTVCLFVBQU0sR0FBRyxVQUFVLFNBQVMsWUFBWSxPQUFPLE9BQU8sR0FBRztBQUN6RCxTQUFLLFNBQVM7QUFDZCxTQUFLLFVBQVU7QUFFZixVQUFNLE9BQU87QUFDYixTQUFLLFFBQVE7QUFDYixTQUFLLE9BQU8sU0FBSSxRQUFKLFNBQUksU0FBQSxTQUFKLEtBQU8sTUFBTTtBQUN6QixTQUFLLFFBQVEsU0FBSSxRQUFKLFNBQUksU0FBQSxTQUFKLEtBQU8sT0FBTztBQUMzQixTQUFLLE9BQU8sU0FBSSxRQUFKLFNBQUksU0FBQSxTQUFKLEtBQU8sTUFBTTtFQUMzQjtFQUVRLE9BQU8sWUFBWSxPQUFZLFNBQTJCO0FBQ2hFLFlBQ0UsVUFBSyxRQUFMLFVBQUssU0FBQSxTQUFMLE1BQU8sV0FDTCxPQUFPLE1BQU0sWUFBWSxXQUFXLE1BQU0sVUFDeEMsS0FBSyxVQUFVLE1BQU0sT0FBTyxJQUM5QixRQUFRLEtBQUssVUFBVSxLQUFLLElBQzVCLFdBQVc7RUFFakI7RUFFQSxPQUFPLFNBQ0wsUUFDQSxlQUNBLFNBQ0EsU0FBNEI7QUFFNUIsUUFBSSxDQUFDLFFBQVE7QUFDWCxhQUFPLElBQUksbUJBQW1CLEVBQUUsT0FBTyxZQUFZLGFBQWEsRUFBQyxDQUFFOztBQUdyRSxVQUFNLFFBQVMsa0JBQXFDLFFBQXJDLGtCQUFhLFNBQUEsU0FBYixjQUF3QyxPQUFPO0FBRTlELFFBQUksV0FBVyxLQUFLO0FBQ2xCLGFBQU8sSUFBSSxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsT0FBTzs7QUFHNUQsUUFBSSxXQUFXLEtBQUs7QUFDbEIsYUFBTyxJQUFJLG9CQUFvQixRQUFRLE9BQU8sU0FBUyxPQUFPOztBQUdoRSxRQUFJLFdBQVcsS0FBSztBQUNsQixhQUFPLElBQUksc0JBQXNCLFFBQVEsT0FBTyxTQUFTLE9BQU87O0FBR2xFLFFBQUksV0FBVyxLQUFLO0FBQ2xCLGFBQU8sSUFBSSxjQUFjLFFBQVEsT0FBTyxTQUFTLE9BQU87O0FBRzFELFFBQUksV0FBVyxLQUFLO0FBQ2xCLGFBQU8sSUFBSSxjQUFjLFFBQVEsT0FBTyxTQUFTLE9BQU87O0FBRzFELFFBQUksV0FBVyxLQUFLO0FBQ2xCLGFBQU8sSUFBSSx5QkFBeUIsUUFBUSxPQUFPLFNBQVMsT0FBTzs7QUFHckUsUUFBSSxXQUFXLEtBQUs7QUFDbEIsYUFBTyxJQUFJLGVBQWUsUUFBUSxPQUFPLFNBQVMsT0FBTzs7QUFHM0QsUUFBSSxVQUFVLEtBQUs7QUFDakIsYUFBTyxJQUFJLG9CQUFvQixRQUFRLE9BQU8sU0FBUyxPQUFPOztBQUdoRSxXQUFPLElBQUksU0FBUyxRQUFRLE9BQU8sU0FBUyxPQUFPO0VBQ3JEOztBQUdJLElBQU8sb0JBQVAsY0FBaUMsU0FBUTtFQUc3QyxZQUFZLEVBQUUsUUFBTyxJQUEyQixDQUFBLEdBQUU7QUFDaEQsVUFBTSxRQUFXLFFBQVcsV0FBVyx3QkFBd0IsTUFBUztBQUh4RCxTQUFBLFNBQW9CO0VBSXRDOztBQUdJLElBQU8scUJBQVAsY0FBa0MsU0FBUTtFQUc5QyxZQUFZLEVBQUUsU0FBUyxNQUFLLEdBQW1EO0FBQzdFLFVBQU0sUUFBVyxRQUFXLFdBQVcscUJBQXFCLE1BQVM7QUFIckQsU0FBQSxTQUFvQjtBQU1wQyxRQUFJO0FBQU8sV0FBSyxRQUFRO0VBQzFCOztBQUdJLElBQU8sNEJBQVAsY0FBeUMsbUJBQWtCO0VBQy9ELFlBQVksRUFBRSxRQUFPLElBQTJCLENBQUEsR0FBRTtBQUNoRCxVQUFNLEVBQUUsU0FBUyxZQUFPLFFBQVAsWUFBTyxTQUFQLFVBQVcscUJBQW9CLENBQUU7RUFDcEQ7O0FBR0ksSUFBTyxrQkFBUCxjQUErQixTQUFRO0VBQTdDLGNBQUE7O0FBQ29CLFNBQUEsU0FBYztFQUNsQzs7QUFFTSxJQUFPLHNCQUFQLGNBQW1DLFNBQVE7RUFBakQsY0FBQTs7QUFDb0IsU0FBQSxTQUFjO0VBQ2xDOztBQUVNLElBQU8sd0JBQVAsY0FBcUMsU0FBUTtFQUFuRCxjQUFBOztBQUNvQixTQUFBLFNBQWM7RUFDbEM7O0FBRU0sSUFBTyxnQkFBUCxjQUE2QixTQUFRO0VBQTNDLGNBQUE7O0FBQ29CLFNBQUEsU0FBYztFQUNsQzs7QUFFTSxJQUFPLGdCQUFQLGNBQTZCLFNBQVE7RUFBM0MsY0FBQTs7QUFDb0IsU0FBQSxTQUFjO0VBQ2xDOztBQUVNLElBQU8sMkJBQVAsY0FBd0MsU0FBUTtFQUF0RCxjQUFBOztBQUNvQixTQUFBLFNBQWM7RUFDbEM7O0FBRU0sSUFBTyxpQkFBUCxjQUE4QixTQUFRO0VBQTVDLGNBQUE7O0FBQ29CLFNBQUEsU0FBYztFQUNsQzs7QUFFTSxJQUFPLHNCQUFQLGNBQW1DLFNBQVE7Ozs7QUNwSTNDLElBQU8sU0FBUCxNQUFhO0VBTWpCLFlBQVksVUFBb0IsWUFBMkI7QUFDekQsU0FBSyxXQUFXO0FBQ2hCLFNBQUssYUFBYTtBQUNsQixTQUFLLFVBQVUsSUFBSSxXQUFVO0VBQy9CO0VBRVEsT0FBTyxlQUFZO0FBQ3pCLFFBQUksQ0FBQyxLQUFLLFNBQVMsTUFBTTtBQUN2QixXQUFLLFdBQVcsTUFBSztBQUNyQixZQUFNLElBQUksWUFBWSxtREFBbUQ7O0FBRTNFLFVBQU0sY0FBYyxJQUFJLFlBQVc7QUFFbkMsVUFBTSxPQUFPLDRCQUFtQyxLQUFLLFNBQVMsSUFBSTtBQUNsRSxxQkFBaUIsU0FBUyxNQUFNO0FBQzlCLGlCQUFXLFFBQVEsWUFBWSxPQUFPLEtBQUssR0FBRztBQUM1QyxjQUFNLE1BQU0sS0FBSyxRQUFRLE9BQU8sSUFBSTtBQUNwQyxZQUFJO0FBQUssZ0JBQU07OztBQUluQixlQUFXLFFBQVEsWUFBWSxNQUFLLEdBQUk7QUFDdEMsWUFBTSxNQUFNLEtBQUssUUFBUSxPQUFPLElBQUk7QUFDcEMsVUFBSTtBQUFLLGNBQU07O0VBRW5CO0VBRUEsUUFBUSxPQUFPLGFBQWEsSUFBQztBQUMzQixRQUFJLE9BQU87QUFDWCxRQUFJO0FBQ0YsdUJBQWlCLE9BQU8sS0FBSyxhQUFZLEdBQUk7QUFDM0MsWUFBSTtBQUFNO0FBRVYsWUFBSSxJQUFJLEtBQUssV0FBVyxRQUFRLEdBQUc7QUFDakMsaUJBQU87QUFDUDs7QUFHRixZQUFJLElBQUksVUFBVSxNQUFNO0FBQ3RCLGNBQUk7QUFDRixrQkFBTSxLQUFLLE1BQU0sSUFBSSxJQUFJO21CQUNsQixHQUFQO0FBQ0Esb0JBQVEsTUFBTSxzQ0FBc0MsSUFBSSxJQUFJO0FBQzVELG9CQUFRLE1BQU0sZUFBZSxJQUFJLEdBQUc7QUFDcEMsa0JBQU07Ozs7QUFJWixhQUFPO2FBQ0EsR0FBUDtBQUVBLFVBQUksYUFBYSxTQUFTLEVBQUUsU0FBUztBQUFjO0FBQ25ELFlBQU07O0FBR04sVUFBSSxDQUFDO0FBQU0sYUFBSyxXQUFXLE1BQUs7O0VBRXBDOztBQUdGLElBQU0sYUFBTixNQUFnQjtFQUtkLGNBQUE7QUFDRSxTQUFLLFFBQVE7QUFDYixTQUFLLE9BQU8sQ0FBQTtBQUNaLFNBQUssU0FBUyxDQUFBO0VBQ2hCO0VBRUEsT0FBTyxNQUFZO0FBQ2pCLFFBQUksS0FBSyxTQUFTLElBQUksR0FBRztBQUN2QixhQUFPLEtBQUssVUFBVSxHQUFHLEtBQUssU0FBUyxDQUFDOztBQUcxQyxRQUFJLENBQUMsTUFBTTtBQUVULFVBQUksQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLEtBQUs7QUFBUSxlQUFPO0FBRTdDLFlBQU0sTUFBdUI7UUFDM0IsT0FBTyxLQUFLO1FBQ1osTUFBTSxLQUFLLEtBQUssS0FBSyxJQUFJO1FBQ3pCLEtBQUssS0FBSzs7QUFHWixXQUFLLFFBQVE7QUFDYixXQUFLLE9BQU8sQ0FBQTtBQUNaLFdBQUssU0FBUyxDQUFBO0FBRWQsYUFBTzs7QUFHVCxTQUFLLE9BQU8sS0FBSyxJQUFJO0FBRXJCLFFBQUksS0FBSyxXQUFXLEdBQUcsR0FBRztBQUN4QixhQUFPOztBQUdULFFBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxJQUFJLFVBQVUsTUFBTSxHQUFHO0FBRS9DLFFBQUksTUFBTSxXQUFXLEdBQUcsR0FBRztBQUN6QixjQUFRLE1BQU0sVUFBVSxDQUFDOztBQUczQixRQUFJLGNBQWMsU0FBUztBQUN6QixXQUFLLFFBQVE7ZUFDSixjQUFjLFFBQVE7QUFDL0IsV0FBSyxLQUFLLEtBQUssS0FBSzs7QUFHdEIsV0FBTztFQUNUOztBQVNGLElBQU0sY0FBTixNQUFpQjtFQVNmLGNBQUE7QUFDRSxTQUFLLFNBQVMsQ0FBQTtBQUNkLFNBQUssYUFBYTtFQUNwQjtFQUVBLE9BQU8sT0FBWTtBQUNqQixRQUFJLE9BQU8sS0FBSyxXQUFXLEtBQUs7QUFFaEMsUUFBSSxLQUFLLFlBQVk7QUFDbkIsYUFBTyxPQUFPO0FBQ2QsV0FBSyxhQUFhOztBQUVwQixRQUFJLEtBQUssU0FBUyxJQUFJLEdBQUc7QUFDdkIsV0FBSyxhQUFhO0FBQ2xCLGFBQU8sS0FBSyxNQUFNLEdBQUcsRUFBRTs7QUFHekIsUUFBSSxDQUFDLE1BQU07QUFDVCxhQUFPLENBQUE7O0FBR1QsVUFBTSxrQkFBa0IsWUFBWSxjQUFjLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQyxLQUFLLEVBQUU7QUFDakYsUUFBSSxRQUFRLEtBQUssTUFBTSxZQUFZLGNBQWM7QUFFakQsUUFBSSxNQUFNLFdBQVcsS0FBSyxDQUFDLGlCQUFpQjtBQUMxQyxXQUFLLE9BQU8sS0FBSyxNQUFNLENBQUMsQ0FBRTtBQUMxQixhQUFPLENBQUE7O0FBR1QsUUFBSSxLQUFLLE9BQU8sU0FBUyxHQUFHO0FBQzFCLGNBQVEsQ0FBQyxLQUFLLE9BQU8sS0FBSyxFQUFFLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLE1BQU0sQ0FBQyxDQUFDO0FBQzNELFdBQUssU0FBUyxDQUFBOztBQUdoQixRQUFJLENBQUMsaUJBQWlCO0FBQ3BCLFdBQUssU0FBUyxDQUFDLE1BQU0sSUFBRyxLQUFNLEVBQUU7O0FBR2xDLFdBQU87RUFDVDtFQUVBLFdBQVcsT0FBWTs7QUFDckIsUUFBSSxTQUFTO0FBQU0sYUFBTztBQUMxQixRQUFJLE9BQU8sVUFBVTtBQUFVLGFBQU87QUFHdEMsUUFBSSxPQUFPLFdBQVcsYUFBYTtBQUNqQyxVQUFJLGlCQUFpQixRQUFRO0FBQzNCLGVBQU8sTUFBTSxTQUFROztBQUV2QixVQUFJLGlCQUFpQixZQUFZO0FBQy9CLGVBQU8sT0FBTyxLQUFLLEtBQUssRUFBRSxTQUFROztBQUdwQyxZQUFNLElBQUksWUFDUix3Q0FBd0MsTUFBTSxZQUFZLHVJQUF1STs7QUFLck0sUUFBSSxPQUFPLGdCQUFnQixhQUFhO0FBQ3RDLFVBQUksaUJBQWlCLGNBQWMsaUJBQWlCLGFBQWE7QUFDL0QsU0FBQUcsTUFBQSxLQUFLLGlCQUFXLFFBQUFBLFFBQUEsU0FBQUEsTUFBaEIsS0FBSyxjQUFnQixJQUFJLFlBQVksTUFBTTtBQUMzQyxlQUFPLEtBQUssWUFBWSxPQUFPLEtBQUs7O0FBR3RDLFlBQU0sSUFBSSxZQUNSLG9EQUNHLE1BQWMsWUFBWSxvREFDbUI7O0FBSXBELFVBQU0sSUFBSSxZQUNSLGdHQUFnRztFQUVwRztFQUVBLFFBQUs7QUFDSCxRQUFJLENBQUMsS0FBSyxPQUFPLFVBQVUsQ0FBQyxLQUFLLFlBQVk7QUFDM0MsYUFBTyxDQUFBOztBQUdULFVBQU0sUUFBUSxDQUFDLEtBQUssT0FBTyxLQUFLLEVBQUUsQ0FBQztBQUNuQyxTQUFLLFNBQVMsQ0FBQTtBQUNkLFNBQUssYUFBYTtBQUNsQixXQUFPO0VBQ1Q7O0FBOUZPLFlBQUEsZ0JBQWdCLG9CQUFJLElBQUksQ0FBQyxNQUFNLE1BQU0sTUFBUSxNQUFRLEtBQVEsS0FBUSxLQUFRLFFBQVEsVUFBVSxRQUFRLENBQUM7QUFDeEcsWUFBQSxpQkFBaUI7QUFnRzFCLFNBQVMsVUFBVSxLQUFhLFdBQWlCO0FBQy9DLFFBQU0sUUFBUSxJQUFJLFFBQVEsU0FBUztBQUNuQyxNQUFJLFVBQVUsSUFBSTtBQUNoQixXQUFPLENBQUMsSUFBSSxVQUFVLEdBQUcsS0FBSyxHQUFHLFdBQVcsSUFBSSxVQUFVLFFBQVEsVUFBVSxNQUFNLENBQUM7O0FBR3JGLFNBQU8sQ0FBQyxLQUFLLElBQUksRUFBRTtBQUNyQjtBQVFBLFNBQVMsNEJBQStCLFFBQVc7QUFDakQsTUFBSSxPQUFPLE9BQU8sYUFBYTtBQUFHLFdBQU87QUFFekMsUUFBTSxTQUFTLE9BQU8sVUFBUztBQUMvQixTQUFPO0lBQ0wsTUFBTSxPQUFJO0FBQ1IsVUFBSTtBQUNGLGNBQU0sU0FBUyxNQUFNLE9BQU8sS0FBSTtBQUNoQyxZQUFJLFdBQU0sUUFBTixXQUFNLFNBQUEsU0FBTixPQUFRO0FBQU0saUJBQU8sWUFBVztBQUNwQyxlQUFPO2VBQ0EsR0FBUDtBQUNBLGVBQU8sWUFBVztBQUNsQixjQUFNOztJQUVWO0lBQ0EsTUFBTSxTQUFNO0FBQ1YsWUFBTSxnQkFBZ0IsT0FBTyxPQUFNO0FBQ25DLGFBQU8sWUFBVztBQUNsQixZQUFNO0FBQ04sYUFBTyxFQUFFLE1BQU0sTUFBTSxPQUFPLE9BQVM7SUFDdkM7SUFDQSxDQUFDLE9BQU8sYUFBYSxJQUFDO0FBQ3BCLGFBQU87SUFDVDs7QUFFSjs7O0FDNVBPLElBQUksT0FBTztBQUNYLElBQUksT0FBa0M7QUFDdEMsSUFBSUMsU0FBb0M7QUFDeEMsSUFBSUMsV0FBd0M7QUFDNUMsSUFBSUMsWUFBMEM7QUFDOUMsSUFBSUMsV0FBd0M7QUFDNUMsSUFBSUMsWUFBMEM7QUFDOUMsSUFBSUMsUUFBa0M7QUFDdEMsSUFBSUMsUUFBa0M7QUFDdEMsSUFBSSw2QkFBOEU7QUFDbEYsSUFBSSxrQkFBd0Q7QUFDNUQsSUFBSSxlQUFrRDtBQUN0RCxJQUFJLGlCQUFzRDtBQUUzRCxTQUFVLFNBQVMsT0FBYyxVQUE2QixFQUFFLE1BQU0sTUFBSyxHQUFFO0FBQ2pGLE1BQUksTUFBTTtBQUNSLFVBQU0sSUFBSSxNQUNSLG1DQUFtQyxNQUFNLG9EQUFvRDs7QUFHakcsTUFBSSxNQUFNO0FBQ1IsVUFBTSxJQUFJLE1BQU0sZ0NBQWdDLE1BQU0sd0NBQXdDLFNBQVM7O0FBRXpHLFNBQU8sUUFBUTtBQUNmLFNBQU8sTUFBTTtBQUNiLEVBQUFOLFNBQVEsTUFBTTtBQUNkLEVBQUFDLFdBQVUsTUFBTTtBQUNoQixFQUFBQyxZQUFXLE1BQU07QUFDakIsRUFBQUMsV0FBVSxNQUFNO0FBQ2hCLEVBQUFDLFlBQVcsTUFBTTtBQUNqQixFQUFBQyxRQUFPLE1BQU07QUFDYixFQUFBQyxRQUFPLE1BQU07QUFDYiwrQkFBNkIsTUFBTTtBQUNuQyxvQkFBa0IsTUFBTTtBQUN4QixpQkFBZSxNQUFNO0FBQ3JCLG1CQUFpQixNQUFNO0FBQ3pCOzs7QUMxRE0sSUFBTyxnQkFBUCxNQUFvQjtFQUN4QixZQUFtQixNQUFTO0FBQVQsU0FBQSxPQUFBO0VBQVk7RUFDL0IsS0FBSyxPQUFPLFdBQVcsSUFBQztBQUN0QixXQUFPO0VBQ1Q7Ozs7QUNBSSxTQUFVLFdBQVcsRUFBRSxpQkFBZ0IsSUFBcUMsQ0FBQSxHQUFFO0FBQ2xGLFFBQU0saUJBQ0osbUJBQ0Usa0NBQ0E7Ozs7QUFLSixNQUFJLFFBQVEsVUFBVSxXQUFXO0FBQ2pDLE1BQUk7QUFFRixhQUFTO0FBRVQsZUFBVztBQUVYLGdCQUFZO0FBRVosZUFBVztXQUNKLE9BQVA7QUFDQSxVQUFNLElBQUksTUFDUixpRUFDRyxNQUFjLFlBQ1osZ0JBQWdCOztBQUl6QixTQUFPO0lBQ0wsTUFBTTtJQUNOLE9BQU87SUFDUCxTQUFTO0lBQ1QsVUFBVTtJQUNWLFNBQVM7SUFDVDs7TUFFRSxPQUFPLGFBQWEsY0FBYyxXQUNoQyxNQUFNLFNBQVE7O1FBRVosY0FBQTtBQUNFLGdCQUFNLElBQUksTUFDUixxRkFBcUYsZ0JBQWdCO1FBRXpHOzs7SUFHTixNQUNFLE9BQU8sU0FBUyxjQUFjLE9BQzVCLE1BQU0sS0FBSTtNQUNSLGNBQUE7QUFDRSxjQUFNLElBQUksTUFDUixpRkFBaUYsZ0JBQWdCO01BRXJHOztJQUdOOztNQUVFLE9BQU8sU0FBUyxjQUFjLE9BQzVCLE1BQU0sS0FBSTs7UUFFUixjQUFBO0FBQ0UsZ0JBQU0sSUFBSSxNQUNSLGlGQUFpRixnQkFBZ0I7UUFFckc7OztJQUdOLDRCQUE0QixPQUUxQixNQUNBLFVBQ2dDO01BQ2hDLEdBQUc7TUFDSCxNQUFNLElBQUksY0FBYyxJQUFJOztJQUU5QixpQkFBaUIsQ0FBQyxRQUFnQjtJQUNsQyxjQUFjLE1BQUs7QUFDakIsWUFBTSxJQUFJLE1BQ1IsZ0pBQWdKO0lBRXBKO0lBQ0EsZ0JBQWdCLENBQUMsVUFBZTs7QUFFcEM7OztBQ3JGQSxJQUFJLENBQU87QUFBTSxFQUFNLFNBQWMsV0FBVyxHQUFHLEVBQUUsTUFBTSxLQUFLLENBQUM7OztBQ3VEMUQsSUFBTSxpQkFBaUIsQ0FBQyxVQUM3QixTQUFTLFFBQ1QsT0FBTyxVQUFVLFlBQ2pCLE9BQU8sTUFBTSxRQUFRLFlBQ3JCLE9BQU8sTUFBTSxTQUFTO0FBRWpCLElBQU0sYUFBYSxDQUFDLFVBQ3pCLFNBQVMsUUFDVCxPQUFPLFVBQVUsWUFDakIsT0FBTyxNQUFNLFNBQVMsWUFDdEIsT0FBTyxNQUFNLGlCQUFpQixZQUM5QixXQUFXLEtBQUs7QUFNWCxJQUFNLGFBQWEsQ0FBQyxVQUN6QixTQUFTLFFBQ1QsT0FBTyxVQUFVLFlBQ2pCLE9BQU8sTUFBTSxTQUFTLFlBQ3RCLE9BQU8sTUFBTSxTQUFTLFlBQ3RCLE9BQU8sTUFBTSxTQUFTLGNBQ3RCLE9BQU8sTUFBTSxVQUFVLGNBQ3ZCLE9BQU8sTUFBTSxnQkFBZ0I7QUFFeEIsSUFBTSxlQUFlLENBQUMsVUFBbUM7QUFDOUQsU0FBTyxXQUFXLEtBQUssS0FBSyxlQUFlLEtBQUssS0FBSyxlQUFlLEtBQUs7QUFDM0U7QUFhQSxlQUFzQixPQUNwQixPQUNBLE1BQ0EsVUFBdUMsQ0FBQSxHQUFFOztBQUd6QyxVQUFRLE1BQU07QUFFZCxNQUFJLGVBQWUsS0FBSyxHQUFHO0FBQ3pCLFVBQU0sT0FBTyxNQUFNLE1BQU0sS0FBSTtBQUM3QixhQUFBLFFBQVNDLE1BQUEsSUFBSSxJQUFJLE1BQU0sR0FBRyxFQUFFLFNBQVMsTUFBTSxPQUFPLEVBQUUsSUFBRyxPQUFFLFFBQUFBLFFBQUEsU0FBQUEsTUFBSTtBQUU3RCxXQUFPLElBQUlDLE1BQUssQ0FBQyxJQUFXLEdBQUcsTUFBTSxPQUFPOztBQUc5QyxRQUFNLE9BQU8sTUFBTSxTQUFTLEtBQUs7QUFFakMsV0FBQSxRQUFTLEtBQUEsUUFBUSxLQUFLLE9BQUMsUUFBQSxPQUFBLFNBQUEsS0FBSTtBQUUzQixNQUFJLENBQUMsUUFBUSxNQUFNO0FBQ2pCLFVBQU0sUUFBTyxLQUFDLEtBQUssQ0FBQyxPQUFTLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRTtBQUMvQixRQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLGdCQUFVLEVBQUUsR0FBRyxTQUFTLEtBQUk7OztBQUloQyxTQUFPLElBQUlBLE1BQUssTUFBTSxNQUFNLE9BQU87QUFDckM7QUFFQSxlQUFlLFNBQVMsT0FBa0I7O0FBQ3hDLE1BQUksUUFBeUIsQ0FBQTtBQUM3QixNQUNFLE9BQU8sVUFBVSxZQUNqQixZQUFZLE9BQU8sS0FBSztFQUN4QixpQkFBaUIsYUFDakI7QUFDQSxVQUFNLEtBQUssS0FBSzthQUNQLFdBQVcsS0FBSyxHQUFHO0FBQzVCLFVBQU0sS0FBSyxNQUFNLE1BQU0sWUFBVyxDQUFFO2FBRXBDLHdCQUF3QixLQUFLLEdBQzdCO0FBQ0EscUJBQWlCLFNBQVMsT0FBTztBQUMvQixZQUFNLEtBQUssS0FBaUI7O1NBRXpCO0FBQ0wsVUFBTSxJQUFJLE1BQ1IseUJBQXlCLE9BQU8sd0JBQzlCRCxNQUFBLFVBQUssUUFBTCxVQUFLLFNBQUEsU0FBTCxNQUFPLGlCQUFXLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFLGdCQUNWLGNBQWMsS0FBSyxHQUFHOztBQUl0QyxTQUFPO0FBQ1Q7QUFFQSxTQUFTLGNBQWMsT0FBVTtBQUMvQixRQUFNLFFBQVEsT0FBTyxvQkFBb0IsS0FBSztBQUM5QyxTQUFPLElBQUksTUFBTSxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRSxLQUFLLElBQUk7QUFDakQ7QUFFQSxTQUFTLFFBQVEsT0FBVTs7QUFDekIsU0FDRSx5QkFBeUIsTUFBTSxJQUFJLEtBQ25DLHlCQUF5QixNQUFNLFFBQVE7SUFFdkNBLE1BQUEseUJBQXlCLE1BQU0sSUFBSSxPQUFDLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFFLE1BQU0sT0FBTyxFQUFFLElBQUc7QUFFNUQ7QUFFQSxJQUFNLDJCQUEyQixDQUFDLE1BQW9EO0FBQ3BGLE1BQUksT0FBTyxNQUFNO0FBQVUsV0FBTztBQUNsQyxNQUFJLE9BQU8sV0FBVyxlQUFlLGFBQWE7QUFBUSxXQUFPLE9BQU8sQ0FBQztBQUN6RSxTQUFPO0FBQ1Q7QUFFQSxJQUFNLDBCQUEwQixDQUFDLFVBQy9CLFNBQVMsUUFBUSxPQUFPLFVBQVUsWUFBWSxPQUFPLE1BQU0sT0FBTyxhQUFhLE1BQU07QUFFaEYsSUFBTSxrQkFBa0IsQ0FBQyxTQUM5QixRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssUUFBUSxLQUFLLE9BQU8sV0FBVyxNQUFNO0FBZXpFLElBQU0sOEJBQThCLE9BQ3pDLFNBQzhDO0FBQzlDLFFBQU0sT0FBTyxNQUFNLFdBQVcsS0FBSyxJQUFJO0FBQ3ZDLFNBQU8sMkJBQTJCLE1BQU0sSUFBSTtBQUM5QztBQUVPLElBQU0sYUFBYSxPQUFvQyxTQUEwQztBQUN0RyxRQUFNLE9BQU8sSUFBSUUsVUFBUTtBQUN6QixRQUFNLFFBQVEsSUFBSSxPQUFPLFFBQVEsUUFBUSxDQUFBLENBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssTUFBTSxhQUFhLE1BQU0sS0FBSyxLQUFLLENBQUMsQ0FBQztBQUNsRyxTQUFPO0FBQ1Q7QUFhQSxJQUFNLGVBQWUsT0FBTyxNQUFnQixLQUFhLFVBQWlDO0FBQ3hGLE1BQUksVUFBVTtBQUFXO0FBQ3pCLE1BQUksU0FBUyxNQUFNO0FBQ2pCLFVBQU0sSUFBSSxVQUNSLHNCQUFzQixnRUFBZ0U7O0FBSzFGLE1BQUksT0FBTyxVQUFVLFlBQVksT0FBTyxVQUFVLFlBQVksT0FBTyxVQUFVLFdBQVc7QUFDeEYsU0FBSyxPQUFPLEtBQUssT0FBTyxLQUFLLENBQUM7YUFDckIsYUFBYSxLQUFLLEdBQUc7QUFDOUIsVUFBTSxPQUFPLE1BQU0sT0FBTyxLQUFLO0FBQy9CLFNBQUssT0FBTyxLQUFLLElBQVk7YUFDcEIsTUFBTSxRQUFRLEtBQUssR0FBRztBQUMvQixVQUFNLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQyxVQUFVLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxDQUFDLENBQUM7YUFDcEUsT0FBTyxVQUFVLFVBQVU7QUFDcEMsVUFBTSxRQUFRLElBQ1osT0FBTyxRQUFRLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksTUFBTSxhQUFhLE1BQU0sR0FBRyxPQUFPLFNBQVMsSUFBSSxDQUFDLENBQUM7U0FFckY7QUFDTCxVQUFNLElBQUksVUFDUix3R0FBd0csZUFBZTs7QUFHN0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeE5BLElBQU0sY0FBYztBQVlwQixlQUFlLHFCQUF3QixPQUF1QjtBQUM1RCxRQUFNLEVBQUUsU0FBUSxJQUFLO0FBQ3JCLE1BQUksTUFBTSxRQUFRLFFBQVE7QUFHeEIsV0FBTyxJQUFJLE9BQU8sVUFBVSxNQUFNLFVBQVU7O0FBRzlDLFFBQU0sY0FBYyxTQUFTLFFBQVEsSUFBSSxjQUFjO0FBQ3ZELE1BQUksZ0JBQVcsUUFBWCxnQkFBVyxTQUFBLFNBQVgsWUFBYSxTQUFTLGtCQUFrQixHQUFHO0FBQzdDLFVBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSTtBQUVoQyxVQUFNLFlBQVksU0FBUyxRQUFRLFNBQVMsS0FBSyxTQUFTLFNBQVMsSUFBSTtBQUV2RSxXQUFPOztBQUlULFFBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSTtBQUNoQyxRQUFNLFlBQVksU0FBUyxRQUFRLFNBQVMsS0FBSyxTQUFTLFNBQVMsSUFBSTtBQUN2RSxTQUFPO0FBQ1Q7QUFNTSxJQUFPLGFBQVAsY0FBNkIsUUFBVTtFQUczQyxZQUNVLGlCQUNBLGdCQUFnRSxzQkFBb0I7QUFFNUYsVUFBTSxDQUFDLFlBQVc7QUFJaEIsY0FBUSxJQUFXO0lBQ3JCLENBQUM7QUFSTyxTQUFBLGtCQUFBO0FBQ0EsU0FBQSxnQkFBQTtFQVFWO0VBRUEsWUFBZSxXQUF5QjtBQUN0QyxXQUFPLElBQUksV0FBVyxLQUFLLGlCQUFpQixPQUFPLFVBQVUsVUFBVSxNQUFNLEtBQUssY0FBYyxLQUFLLENBQUMsQ0FBQztFQUN6Rzs7Ozs7Ozs7Ozs7Ozs7RUFlQSxhQUFVO0FBQ1IsV0FBTyxLQUFLLGdCQUFnQixLQUFLLENBQUMsTUFBTSxFQUFFLFFBQVE7RUFDcEQ7Ozs7Ozs7Ozs7Ozs7O0VBY0EsTUFBTSxlQUFZO0FBQ2hCLFVBQU0sQ0FBQyxNQUFNLFFBQVEsSUFBSSxNQUFNLFFBQVEsSUFBSSxDQUFDLEtBQUssTUFBSyxHQUFJLEtBQUssV0FBVSxDQUFFLENBQUM7QUFDNUUsV0FBTyxFQUFFLE1BQU0sU0FBUTtFQUN6QjtFQUVRLFFBQUs7QUFDWCxRQUFJLENBQUMsS0FBSyxlQUFlO0FBQ3ZCLFdBQUssZ0JBQWdCLEtBQUssZ0JBQWdCLEtBQUssS0FBSyxhQUFhOztBQUVuRSxXQUFPLEtBQUs7RUFDZDtFQUVTLEtBQ1AsYUFDQSxZQUFtRjtBQUVuRixXQUFPLEtBQUssTUFBSyxFQUFHLEtBQUssYUFBYSxVQUFVO0VBQ2xEO0VBRVMsTUFDUCxZQUFpRjtBQUVqRixXQUFPLEtBQUssTUFBSyxFQUFHLE1BQU0sVUFBVTtFQUN0QztFQUVTLFFBQVEsV0FBMkM7QUFDMUQsV0FBTyxLQUFLLE1BQUssRUFBRyxRQUFRLFNBQVM7RUFDdkM7O0FBR0ksSUFBZ0IsWUFBaEIsTUFBeUI7RUFTN0IsWUFBWTtJQUNWO0lBQ0E7SUFDQSxVQUFVOztJQUNWO0lBQ0EsT0FBTztFQUFjLEdBT3RCO0FBQ0MsU0FBSyxVQUFVO0FBQ2YsU0FBSyxhQUFhLHdCQUF3QixjQUFjLGVBQVUsUUFBVixlQUFVLFNBQVYsYUFBYyxXQUFXO0FBQ2pGLFNBQUssVUFBVSx3QkFBd0IsV0FBVyxPQUFPO0FBQ3pELFNBQUssWUFBWTtBQUVqQixTQUFLLFFBQVEsbUJBQWMsUUFBZCxtQkFBYyxTQUFkLGlCQUFrQkM7RUFDakM7RUFFVSxZQUFZLE1BQXlCO0FBQzdDLFdBQU8sQ0FBQTtFQUNUOzs7Ozs7Ozs7RUFVVSxlQUFlLE1BQXlCO0FBQ2hELFdBQU87TUFDTCxRQUFRO01BQ1IsZ0JBQWdCO01BQ2hCLGNBQWMsS0FBSyxhQUFZO01BQy9CLEdBQUcsbUJBQWtCO01BQ3JCLEdBQUcsS0FBSyxZQUFZLElBQUk7O0VBRTVCOzs7O0VBT1UsZ0JBQWdCLFNBQWtCLGVBQXNCO0VBQUc7RUFFM0Qsd0JBQXFCO0FBQzdCLFdBQU8sd0JBQXdCLE1BQUs7RUFDdEM7RUFFQSxJQUF5QixNQUFjLE1BQTBDO0FBQy9FLFdBQU8sS0FBSyxjQUFjLE9BQU8sTUFBTSxJQUFJO0VBQzdDO0VBRUEsS0FBMEIsTUFBYyxNQUEwQztBQUNoRixXQUFPLEtBQUssY0FBYyxRQUFRLE1BQU0sSUFBSTtFQUM5QztFQUVBLE1BQTJCLE1BQWMsTUFBMEM7QUFDakYsV0FBTyxLQUFLLGNBQWMsU0FBUyxNQUFNLElBQUk7RUFDL0M7RUFFQSxJQUF5QixNQUFjLE1BQTBDO0FBQy9FLFdBQU8sS0FBSyxjQUFjLE9BQU8sTUFBTSxJQUFJO0VBQzdDO0VBRUEsT0FBNEIsTUFBYyxNQUEwQztBQUNsRixXQUFPLEtBQUssY0FBYyxVQUFVLE1BQU0sSUFBSTtFQUNoRDtFQUVRLGNBQ04sUUFDQSxNQUNBLE1BQTBDO0FBRTFDLFdBQU8sS0FBSyxRQUFRLFFBQVEsUUFBUSxJQUFJLEVBQUUsS0FBSyxDQUFDQyxXQUFVLEVBQUUsUUFBUSxNQUFNLEdBQUdBLE1BQUksRUFBRyxDQUFDO0VBQ3ZGO0VBRUEsV0FDRSxNQUNBQyxPQUNBLE1BQTBCO0FBRTFCLFdBQU8sS0FBSyxlQUFlQSxPQUFNLEVBQUUsUUFBUSxPQUFPLE1BQU0sR0FBRyxLQUFJLENBQUU7RUFDbkU7RUFFUSx1QkFBdUIsTUFBYTtBQUMxQyxRQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLFVBQUksT0FBTyxXQUFXLGFBQWE7QUFDakMsZUFBTyxPQUFPLFdBQVcsTUFBTSxNQUFNLEVBQUUsU0FBUTs7QUFHakQsVUFBSSxPQUFPLGdCQUFnQixhQUFhO0FBQ3RDLGNBQU0sVUFBVSxJQUFJLFlBQVc7QUFDL0IsY0FBTSxVQUFVLFFBQVEsT0FBTyxJQUFJO0FBQ25DLGVBQU8sUUFBUSxPQUFPLFNBQVE7OztBQUlsQyxXQUFPO0VBQ1Q7RUFFQSxhQUNFLFNBQWlDOztBQUVqQyxVQUFNLEVBQUUsUUFBUSxNQUFNLE9BQU8sVUFBbUIsQ0FBQSxFQUFFLElBQUs7QUFFdkQsVUFBTSxPQUNKLGdCQUFnQixRQUFRLElBQUksSUFBSSxRQUFRLEtBQUssT0FDM0MsUUFBUSxPQUFPLEtBQUssVUFBVSxRQUFRLE1BQU0sTUFBTSxDQUFDLElBQ25EO0FBQ0osVUFBTSxnQkFBZ0IsS0FBSyx1QkFBdUIsSUFBSTtBQUV0RCxVQUFNLE1BQU0sS0FBSyxTQUFTLE1BQU8sS0FBSztBQUN0QyxRQUFJLGFBQWE7QUFBUyw4QkFBd0IsV0FBVyxRQUFRLE9BQU87QUFDNUUsVUFBTSxXQUFVQyxNQUFBLFFBQVEsYUFBTyxRQUFBQSxRQUFBLFNBQUFBLE1BQUksS0FBSztBQUN4QyxVQUFNLGFBQVksTUFBQSxLQUFBLFFBQVEsZUFBUyxRQUFBLE9BQUEsU0FBQSxLQUFJLEtBQUssZUFBUyxRQUFBLE9BQUEsU0FBQSxLQUFJLGdCQUFnQixHQUFHO0FBQzVFLFVBQU0sa0JBQWtCLFVBQVU7QUFDbEMsUUFDRSxTQUFPLEtBQUMsY0FBaUIsUUFBakIsY0FBUyxTQUFBLFNBQVQsVUFBbUIsYUFBTyxRQUFBLE9BQUEsU0FBQSxTQUFBLEdBQUUsYUFBWSxZQUNoRCxvQkFBbUIsS0FBQyxVQUFrQixRQUFRLGFBQU8sUUFBQSxPQUFBLFNBQUEsS0FBSSxJQUN6RDtBQUtDLGdCQUFrQixRQUFRLFVBQVU7O0FBR3ZDLFFBQUksS0FBSyxxQkFBcUIsV0FBVyxPQUFPO0FBQzlDLFVBQUksQ0FBQyxRQUFRO0FBQWdCLGdCQUFRLGlCQUFpQixLQUFLLHNCQUFxQjtBQUNoRixjQUFRLEtBQUssaUJBQWlCLElBQUksUUFBUTs7QUFHNUMsVUFBTSxhQUFxQztNQUN6QyxHQUFJLGlCQUFpQixFQUFFLGtCQUFrQixjQUFhO01BQ3RELEdBQUcsS0FBSyxlQUFlLE9BQU87TUFDOUIsR0FBRzs7QUFHTCxRQUFJLGdCQUFnQixRQUFRLElBQUksS0FBSyxTQUFjLFFBQVE7QUFDekQsYUFBTyxXQUFXLGNBQWM7O0FBSWxDLFdBQU8sS0FBSyxVQUFVLEVBQUUsUUFBUSxDQUFDLFFBQVEsV0FBVyxHQUFHLE1BQU0sUUFBUSxPQUFPLFdBQVcsR0FBRyxDQUFDO0FBRTNGLFVBQU0sTUFBbUI7TUFDdkI7TUFDQSxHQUFJLFFBQVEsRUFBRSxLQUFpQjtNQUMvQixTQUFTO01BQ1QsR0FBSSxhQUFhLEVBQUUsT0FBTyxVQUFTOzs7TUFHbkMsU0FBUSxLQUFBLFFBQVEsWUFBTSxRQUFBLE9BQUEsU0FBQSxLQUFJOztBQUc1QixTQUFLLGdCQUFnQixZQUFZLE9BQU87QUFFeEMsV0FBTyxFQUFFLEtBQUssS0FBSyxRQUFPO0VBQzVCOzs7Ozs7O0VBUVUsTUFBTSxlQUNkLFNBQ0EsRUFBRSxLQUFLLFFBQU8sR0FBaUQ7RUFDL0M7RUFFUixhQUFhLFNBQXVDO0FBQzVELFdBQ0UsQ0FBQyxVQUFVLENBQUEsSUFDVCxPQUFPLFlBQVksVUFDbkIsT0FBTyxZQUFZLE1BQU0sS0FBSyxPQUE2QixFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxJQUN6RixFQUFFLEdBQUcsUUFBTztFQUVsQjtFQUVVLGdCQUNSLFFBQ0EsT0FDQSxTQUNBLFNBQTRCO0FBRTVCLFdBQU8sU0FBUyxTQUFTLFFBQVEsT0FBTyxTQUFTLE9BQU87RUFDMUQ7RUFFQSxRQUNFLFNBQ0EsbUJBQWtDLE1BQUk7QUFFdEMsV0FBTyxJQUFJLFdBQVcsS0FBSyxZQUFZLFNBQVMsZ0JBQWdCLENBQUM7RUFDbkU7RUFFUSxNQUFNLFlBQ1osY0FDQSxrQkFBK0I7O0FBRS9CLFVBQU0sVUFBVSxNQUFNO0FBQ3RCLFFBQUksb0JBQW9CLE1BQU07QUFDNUIsMEJBQW1CQSxNQUFBLFFBQVEsZ0JBQVUsUUFBQUEsUUFBQSxTQUFBQSxNQUFJLEtBQUs7O0FBR2hELFVBQU0sRUFBRSxLQUFLLEtBQUssUUFBTyxJQUFLLEtBQUssYUFBYSxPQUFPO0FBRXZELFVBQU0sS0FBSyxlQUFlLEtBQUssRUFBRSxLQUFLLFFBQU8sQ0FBRTtBQUUvQyxVQUFNLFdBQVcsS0FBSyxTQUFTLElBQUksT0FBTztBQUUxQyxTQUFJLEtBQUEsUUFBUSxZQUFNLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRSxTQUFTO0FBQzNCLFlBQU0sSUFBSSxrQkFBaUI7O0FBRzdCLFVBQU0sYUFBYSxJQUFJLGdCQUFlO0FBQ3RDLFVBQU0sV0FBVyxNQUFNLEtBQUssaUJBQWlCLEtBQUssS0FBSyxTQUFTLFVBQVUsRUFBRSxNQUFNLFdBQVc7QUFFN0YsUUFBSSxvQkFBb0IsT0FBTztBQUM3QixXQUFJLEtBQUEsUUFBUSxZQUFNLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRSxTQUFTO0FBQzNCLGNBQU0sSUFBSSxrQkFBaUI7O0FBRTdCLFVBQUksa0JBQWtCO0FBQ3BCLGVBQU8sS0FBSyxhQUFhLFNBQVMsZ0JBQWdCOztBQUVwRCxVQUFJLFNBQVMsU0FBUyxjQUFjO0FBQ2xDLGNBQU0sSUFBSSwwQkFBeUI7O0FBRXJDLFlBQU0sSUFBSSxtQkFBbUIsRUFBRSxPQUFPLFNBQVEsQ0FBRTs7QUFHbEQsVUFBTSxrQkFBa0Isc0JBQXNCLFNBQVMsT0FBTztBQUU5RCxRQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLFVBQUksb0JBQW9CLEtBQUssWUFBWSxRQUFRLEdBQUc7QUFDbEQsZUFBTyxLQUFLLGFBQWEsU0FBUyxrQkFBa0IsZUFBZTs7QUFHckUsWUFBTSxVQUFVLE1BQU0sU0FBUyxLQUFJLEVBQUcsTUFBTSxDQUFDLE1BQU0sWUFBWSxDQUFDLEVBQUUsT0FBTztBQUN6RSxZQUFNLFVBQVUsU0FBUyxPQUFPO0FBQ2hDLFlBQU0sYUFBYSxVQUFVLFNBQVk7QUFFekMsWUFBTSxZQUFZLFNBQVMsUUFBUSxLQUFLLGlCQUFpQixVQUFVO0FBRW5FLFlBQU0sTUFBTSxLQUFLLGdCQUFnQixTQUFTLFFBQVEsU0FBUyxZQUFZLGVBQWU7QUFDdEYsWUFBTTs7QUFHUixXQUFPLEVBQUUsVUFBVSxTQUFTLFdBQVU7RUFDeEM7RUFFQSxlQUNFRCxPQUNBLFNBQTRCO0FBRTVCLFVBQU0sVUFBVSxLQUFLLFlBQVksU0FBUyxJQUFJO0FBQzlDLFdBQU8sSUFBSSxZQUE2QixNQUFNLFNBQVNBLEtBQUk7RUFDN0Q7RUFFQSxTQUE4QyxNQUFjLE9BQTZCO0FBQ3ZGLFVBQU0sTUFDSixjQUFjLElBQUksSUFDaEIsSUFBSSxJQUFJLElBQUksSUFDWixJQUFJLElBQUksS0FBSyxXQUFXLEtBQUssUUFBUSxTQUFTLEdBQUcsS0FBSyxLQUFLLFdBQVcsR0FBRyxJQUFJLEtBQUssTUFBTSxDQUFDLElBQUksS0FBSztBQUV0RyxVQUFNLGVBQWUsS0FBSyxhQUFZO0FBQ3RDLFFBQUksQ0FBQyxXQUFXLFlBQVksR0FBRztBQUM3QixjQUFRLEVBQUUsR0FBRyxjQUFjLEdBQUcsTUFBSzs7QUFHckMsUUFBSSxPQUFPO0FBQ1QsVUFBSSxTQUFTLEtBQUssZUFBZSxLQUFLOztBQUd4QyxXQUFPLElBQUksU0FBUTtFQUNyQjtFQUVVLGVBQWUsT0FBOEI7QUFDckQsV0FBTyxPQUFPLFFBQVEsS0FBSyxFQUN4QixPQUFPLENBQUMsQ0FBQyxHQUFHLEtBQUssTUFBTSxPQUFPLFVBQVUsV0FBVyxFQUNuRCxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssTUFBSztBQUNwQixVQUFJLE9BQU8sVUFBVSxZQUFZLE9BQU8sVUFBVSxZQUFZLE9BQU8sVUFBVSxXQUFXO0FBQ3hGLGVBQU8sR0FBRyxtQkFBbUIsR0FBRyxLQUFLLG1CQUFtQixLQUFLOztBQUUvRCxVQUFJLFVBQVUsTUFBTTtBQUNsQixlQUFPLEdBQUcsbUJBQW1CLEdBQUc7O0FBRWxDLFlBQU0sSUFBSSxZQUNSLHlCQUF5QixPQUFPLHdRQUF3UTtJQUU1UyxDQUFDLEVBQ0EsS0FBSyxHQUFHO0VBQ2I7RUFFQSxNQUFNLGlCQUNKLEtBQ0EsTUFDQSxJQUNBLFlBQTJCO0FBRTNCLFVBQU0sRUFBRSxRQUFRLEdBQUcsUUFBTyxJQUFLLFFBQVEsQ0FBQTtBQUN2QyxRQUFJO0FBQVEsYUFBTyxpQkFBaUIsU0FBUyxNQUFNLFdBQVcsTUFBSyxDQUFFO0FBRXJFLFVBQU0sVUFBVSxXQUFXLE1BQU0sV0FBVyxNQUFLLEdBQUksRUFBRTtBQUV2RCxXQUNFLEtBQUssaUJBQWdCLEVBRWxCLE1BQU0sS0FBSyxRQUFXLEtBQUssRUFBRSxRQUFRLFdBQVcsUUFBZSxHQUFHLFFBQU8sQ0FBRSxFQUMzRSxRQUFRLE1BQUs7QUFDWixtQkFBYSxPQUFPO0lBQ3RCLENBQUM7RUFFUDtFQUVVLG1CQUFnQjtBQUN4QixXQUFPLEVBQUUsT0FBTyxLQUFLLE1BQUs7RUFDNUI7RUFFUSxZQUFZLFVBQWtCO0FBRXBDLFVBQU0sb0JBQW9CLFNBQVMsUUFBUSxJQUFJLGdCQUFnQjtBQUcvRCxRQUFJLHNCQUFzQjtBQUFRLGFBQU87QUFDekMsUUFBSSxzQkFBc0I7QUFBUyxhQUFPO0FBRzFDLFFBQUksU0FBUyxXQUFXO0FBQUssYUFBTztBQUdwQyxRQUFJLFNBQVMsV0FBVztBQUFLLGFBQU87QUFHcEMsUUFBSSxTQUFTLFdBQVc7QUFBSyxhQUFPO0FBR3BDLFFBQUksU0FBUyxVQUFVO0FBQUssYUFBTztBQUVuQyxXQUFPO0VBQ1Q7RUFFUSxNQUFNLGFBQ1osU0FDQSxrQkFDQSxpQkFBcUM7O0FBRXJDLHdCQUFvQjtBQUdwQixRQUFJO0FBQ0osVUFBTSxtQkFBbUIsb0JBQWUsUUFBZixvQkFBZSxTQUFBLFNBQWYsZ0JBQWtCLGFBQWE7QUFDeEQsUUFBSSxrQkFBa0I7QUFDcEIsWUFBTSxpQkFBaUIsU0FBUyxnQkFBZ0I7QUFDaEQsVUFBSSxDQUFDLE9BQU8sTUFBTSxjQUFjLEdBQUc7QUFDakMsd0JBQWdCLGlCQUFpQjthQUM1QjtBQUNMLHdCQUFnQixLQUFLLE1BQU0sZ0JBQWdCLElBQUksS0FBSyxJQUFHOzs7QUFNM0QsUUFDRSxDQUFDLGlCQUNELENBQUMsT0FBTyxVQUFVLGFBQWEsS0FDL0IsaUJBQWlCLEtBQ2pCLGdCQUFnQixLQUFLLEtBQ3JCO0FBQ0EsWUFBTSxjQUFhQyxNQUFBLFFBQVEsZ0JBQVUsUUFBQUEsUUFBQSxTQUFBQSxNQUFJLEtBQUs7QUFDOUMsc0JBQWdCLEtBQUssbUNBQW1DLGtCQUFrQixVQUFVOztBQUV0RixVQUFNLE1BQU0sYUFBYTtBQUV6QixXQUFPLEtBQUssWUFBWSxTQUFTLGdCQUFnQjtFQUNuRDtFQUVRLG1DQUFtQyxrQkFBMEIsWUFBa0I7QUFDckYsVUFBTSxvQkFBb0I7QUFDMUIsVUFBTSxnQkFBZ0I7QUFFdEIsVUFBTSxhQUFhLGFBQWE7QUFHaEMsVUFBTSxlQUFlLEtBQUssSUFBSSxvQkFBb0IsS0FBSyxJQUFJLGFBQWEsR0FBRyxDQUFDLEdBQUcsYUFBYTtBQUc1RixVQUFNLFNBQVMsS0FBSyxPQUFNLElBQUs7QUFFL0IsWUFBUSxlQUFlLFVBQVU7RUFDbkM7RUFFUSxlQUFZO0FBQ2xCLFdBQU8sR0FBRyxLQUFLLFlBQVksV0FBVztFQUN4Qzs7QUEwQkksSUFBZ0IsZUFBaEIsTUFBNEI7RUFPaEMsWUFBWSxRQUFtQixVQUFvQixNQUFlLFNBQTRCO0FBTjlGLHlCQUFBLElBQUEsTUFBQSxNQUFBO0FBT0UsMkJBQUEsTUFBSSxzQkFBVyxRQUFNLEdBQUE7QUFDckIsU0FBSyxVQUFVO0FBQ2YsU0FBSyxXQUFXO0FBQ2hCLFNBQUssT0FBTztFQUNkO0VBVUEsY0FBVztBQUNULFVBQU0sUUFBUSxLQUFLLGtCQUFpQjtBQUNwQyxRQUFJLENBQUMsTUFBTTtBQUFRLGFBQU87QUFDMUIsV0FBTyxLQUFLLGFBQVksS0FBTTtFQUNoQztFQUVBLE1BQU0sY0FBVztBQUNmLFVBQU0sV0FBVyxLQUFLLGFBQVk7QUFDbEMsUUFBSSxDQUFDLFVBQVU7QUFDYixZQUFNLElBQUksWUFDUix1RkFBdUY7O0FBRzNGLFVBQU0sY0FBYyxFQUFFLEdBQUcsS0FBSyxRQUFPO0FBQ3JDLFFBQUksWUFBWSxVQUFVO0FBQ3hCLGtCQUFZLFFBQVEsRUFBRSxHQUFHLFlBQVksT0FBTyxHQUFHLFNBQVMsT0FBTTtlQUNyRCxTQUFTLFVBQVU7QUFDNUIsWUFBTSxTQUFTLENBQUMsR0FBRyxPQUFPLFFBQVEsWUFBWSxTQUFTLENBQUEsQ0FBRSxHQUFHLEdBQUcsU0FBUyxJQUFJLGFBQWEsUUFBTyxDQUFFO0FBQ2xHLGlCQUFXLENBQUMsS0FBSyxLQUFLLEtBQUssUUFBUTtBQUNqQyxpQkFBUyxJQUFJLGFBQWEsSUFBSSxLQUFLLEtBQVk7O0FBRWpELGtCQUFZLFFBQVE7QUFDcEIsa0JBQVksT0FBTyxTQUFTLElBQUksU0FBUTs7QUFFMUMsV0FBTyxNQUFNLHVCQUFBLE1BQUksc0JBQUEsR0FBQSxFQUFTLGVBQWUsS0FBSyxhQUFvQixXQUFXO0VBQy9FO0VBRUEsT0FBTyxZQUFTO0FBRWQsUUFBSSxPQUEyQjtBQUMvQixVQUFNO0FBQ04sV0FBTyxLQUFLLFlBQVcsR0FBSTtBQUN6QixhQUFPLE1BQU0sS0FBSyxZQUFXO0FBQzdCLFlBQU07O0VBRVY7RUFFQSxTQUFPLHVCQUFBLG9CQUFBLFFBQUEsR0FBQyxPQUFPLGNBQWEsSUFBQztBQUMzQixxQkFBaUIsUUFBUSxLQUFLLFVBQVMsR0FBSTtBQUN6QyxpQkFBVyxRQUFRLEtBQUssa0JBQWlCLEdBQUk7QUFDM0MsY0FBTTs7O0VBR1o7O0FBWUksSUFBTyxjQUFQLGNBSUksV0FBcUI7RUFHN0IsWUFDRSxRQUNBLFNBQ0FDLE9BQTRFO0FBRTVFLFVBQ0UsU0FDQSxPQUFPLFVBQVUsSUFBSUEsTUFBSyxRQUFRLE1BQU0sVUFBVSxNQUFNLHFCQUFxQixLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7RUFFdkc7Ozs7Ozs7O0VBU0EsUUFBUSxPQUFPLGFBQWEsSUFBQztBQUMzQixVQUFNLE9BQU8sTUFBTTtBQUNuQixxQkFBaUIsUUFBUSxNQUFNO0FBQzdCLFlBQU07O0VBRVY7O0FBR0ssSUFBTSx3QkFBd0IsQ0FDbkMsWUFDMEI7QUFDMUIsU0FBTyxJQUFJLE1BQ1QsT0FBTzs7SUFFTCxRQUFRLFFBQU87RUFBRSxHQUVuQjtJQUNFLElBQUksUUFBUSxNQUFJO0FBQ2QsWUFBTSxNQUFNLEtBQUssU0FBUTtBQUN6QixhQUFPLE9BQU8sSUFBSSxZQUFXLENBQUUsS0FBSyxPQUFPLEdBQUc7SUFDaEQ7R0FDRDtBQUVMO0FBMkJBLElBQU0scUJBQStDO0VBQ25ELFFBQVE7RUFDUixNQUFNO0VBQ04sT0FBTztFQUNQLE1BQU07RUFDTixTQUFTO0VBRVQsWUFBWTtFQUNaLFFBQVE7RUFDUixTQUFTO0VBQ1QsV0FBVztFQUNYLFFBQVE7RUFDUixnQkFBZ0I7O0FBR1gsSUFBTSxtQkFBbUIsQ0FBQyxRQUEyRTtBQUMxRyxTQUNFLE9BQU8sUUFBUSxZQUNmLFFBQVEsUUFDUixDQUFDLFdBQVcsR0FBRyxLQUNmLE9BQU8sS0FBSyxHQUFHLEVBQUUsTUFBTSxDQUFDLE1BQU0sT0FBTyxvQkFBb0IsQ0FBQyxDQUFDO0FBRS9EO0FBNkJBLElBQU0sd0JBQXdCLE1BQXlCO0FBQ3JELE1BQUksT0FBTyxTQUFTLGVBQWUsS0FBSyxTQUFTLE1BQU07QUFDckQsV0FBTztNQUNMLG9CQUFvQjtNQUNwQiwrQkFBK0I7TUFDL0Isa0JBQWtCLGtCQUFrQixLQUFLLE1BQU0sRUFBRTtNQUNqRCxvQkFBb0IsY0FBYyxLQUFLLE1BQU0sSUFBSTtNQUNqRCx1QkFBdUI7TUFDdkIsK0JBQStCLEtBQUs7OztBQUd4QyxNQUFJLE9BQU8sZ0JBQWdCLGFBQWE7QUFDdEMsV0FBTztNQUNMLG9CQUFvQjtNQUNwQiwrQkFBK0I7TUFDL0Isa0JBQWtCO01BQ2xCLG9CQUFvQixTQUFTO01BQzdCLHVCQUF1QjtNQUN2QiwrQkFBK0IsUUFBUTs7O0FBSTNDLE1BQUksT0FBTyxVQUFVLFNBQVMsS0FBSyxPQUFPLFlBQVksY0FBYyxVQUFVLENBQUMsTUFBTSxvQkFBb0I7QUFDdkcsV0FBTztNQUNMLG9CQUFvQjtNQUNwQiwrQkFBK0I7TUFDL0Isa0JBQWtCLGtCQUFrQixRQUFRLFFBQVE7TUFDcEQsb0JBQW9CLGNBQWMsUUFBUSxJQUFJO01BQzlDLHVCQUF1QjtNQUN2QiwrQkFBK0IsUUFBUTs7O0FBSTNDLFFBQU0sY0FBYyxlQUFjO0FBQ2xDLE1BQUksYUFBYTtBQUNmLFdBQU87TUFDTCxvQkFBb0I7TUFDcEIsK0JBQStCO01BQy9CLGtCQUFrQjtNQUNsQixvQkFBb0I7TUFDcEIsdUJBQXVCLFdBQVcsWUFBWTtNQUM5QywrQkFBK0IsWUFBWTs7O0FBSy9DLFNBQU87SUFDTCxvQkFBb0I7SUFDcEIsK0JBQStCO0lBQy9CLGtCQUFrQjtJQUNsQixvQkFBb0I7SUFDcEIsdUJBQXVCO0lBQ3ZCLCtCQUErQjs7QUFFbkM7QUFVQSxTQUFTLGlCQUFjO0FBQ3JCLE1BQUksT0FBTyxjQUFjLGVBQWUsQ0FBQyxXQUFXO0FBQ2xELFdBQU87O0FBSVQsUUFBTSxrQkFBa0I7SUFDdEIsRUFBRSxLQUFLLFFBQWlCLFNBQVMsdUNBQXNDO0lBQ3ZFLEVBQUUsS0FBSyxNQUFlLFNBQVMsdUNBQXNDO0lBQ3JFLEVBQUUsS0FBSyxNQUFlLFNBQVMsNkNBQTRDO0lBQzNFLEVBQUUsS0FBSyxVQUFtQixTQUFTLHlDQUF3QztJQUMzRSxFQUFFLEtBQUssV0FBb0IsU0FBUywwQ0FBeUM7SUFDN0UsRUFBRSxLQUFLLFVBQW1CLFNBQVMsb0VBQW1FOztBQUl4RyxhQUFXLEVBQUUsS0FBSyxRQUFPLEtBQU0saUJBQWlCO0FBQzlDLFVBQU0sUUFBUSxRQUFRLEtBQUssVUFBVSxTQUFTO0FBQzlDLFFBQUksT0FBTztBQUNULFlBQU0sUUFBUSxNQUFNLENBQUMsS0FBSztBQUMxQixZQUFNLFFBQVEsTUFBTSxDQUFDLEtBQUs7QUFDMUIsWUFBTSxRQUFRLE1BQU0sQ0FBQyxLQUFLO0FBRTFCLGFBQU8sRUFBRSxTQUFTLEtBQUssU0FBUyxHQUFHLFNBQVMsU0FBUyxRQUFPOzs7QUFJaEUsU0FBTztBQUNUO0FBRUEsSUFBTSxnQkFBZ0IsQ0FBQyxTQUFzQjtBQUszQyxNQUFJLFNBQVM7QUFBTyxXQUFPO0FBQzNCLE1BQUksU0FBUyxZQUFZLFNBQVM7QUFBTyxXQUFPO0FBQ2hELE1BQUksU0FBUztBQUFPLFdBQU87QUFDM0IsTUFBSSxTQUFTLGFBQWEsU0FBUztBQUFTLFdBQU87QUFDbkQsTUFBSTtBQUFNLFdBQU8sU0FBUztBQUMxQixTQUFPO0FBQ1Q7QUFFQSxJQUFNLG9CQUFvQixDQUFDLGFBQWtDO0FBTzNELGFBQVcsU0FBUyxZQUFXO0FBTS9CLE1BQUksU0FBUyxTQUFTLEtBQUs7QUFBRyxXQUFPO0FBQ3JDLE1BQUksYUFBYTtBQUFXLFdBQU87QUFDbkMsTUFBSSxhQUFhO0FBQVUsV0FBTztBQUNsQyxNQUFJLGFBQWE7QUFBUyxXQUFPO0FBQ2pDLE1BQUksYUFBYTtBQUFXLFdBQU87QUFDbkMsTUFBSSxhQUFhO0FBQVcsV0FBTztBQUNuQyxNQUFJLGFBQWE7QUFBUyxXQUFPO0FBQ2pDLE1BQUk7QUFBVSxXQUFPLFNBQVM7QUFDOUIsU0FBTztBQUNUO0FBRUEsSUFBSTtBQUNKLElBQU0scUJBQXFCLE1BQUs7QUFDOUIsU0FBUSxxQkFBZ0IsUUFBaEIscUJBQWdCLFNBQWhCLG1CQUFBLG1CQUFxQixzQkFBcUI7QUFDcEQ7QUFFTyxJQUFNLFdBQVcsQ0FBQyxTQUFnQjtBQUN2QyxNQUFJO0FBQ0YsV0FBTyxLQUFLLE1BQU0sSUFBSTtXQUNmLEtBQVA7QUFDQSxXQUFPOztBQUVYO0FBR0EsSUFBTSx5QkFBeUIsSUFBSSxPQUFPLG1CQUFtQixHQUFHO0FBQ2hFLElBQU0sZ0JBQWdCLENBQUMsUUFBd0I7QUFDN0MsU0FBTyx1QkFBdUIsS0FBSyxHQUFHO0FBQ3hDO0FBRU8sSUFBTSxRQUFRLENBQUMsT0FBZSxJQUFJLFFBQVEsQ0FBQyxZQUFZLFdBQVcsU0FBUyxFQUFFLENBQUM7QUFFckYsSUFBTSwwQkFBMEIsQ0FBQyxNQUFjLE1BQXNCO0FBQ25FLE1BQUksT0FBTyxNQUFNLFlBQVksQ0FBQyxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQ2pELFVBQU0sSUFBSSxZQUFZLEdBQUcseUJBQXlCOztBQUVwRCxNQUFJLElBQUksR0FBRztBQUNULFVBQU0sSUFBSSxZQUFZLEdBQUcsaUNBQWlDOztBQUU1RCxTQUFPO0FBQ1Q7QUFFTyxJQUFNLGNBQWMsQ0FBQyxRQUFtQjtBQUM3QyxNQUFJLGVBQWU7QUFBTyxXQUFPO0FBQ2pDLFNBQU8sSUFBSSxNQUFNLEdBQUc7QUFDdEI7QUFZTyxJQUFNLFVBQVUsQ0FBQyxRQUFtQzs7QUFDekQsTUFBSSxPQUFPLFlBQVksYUFBYTtBQUNsQyxZQUFPLE1BQUFDLE1BQUEsUUFBUSxTQUFHLFFBQUFBLFFBQUEsU0FBQSxTQUFBQSxJQUFHLEdBQUcsT0FBQyxRQUFBLE9BQUEsU0FBQSxLQUFJOztBQUUvQixNQUFJLE9BQU8sU0FBUyxhQUFhO0FBQy9CLFlBQU8sTUFBQSxLQUFBLEtBQUssU0FBRyxRQUFBLE9BQUEsU0FBQSxTQUFBLEdBQUUsU0FBRyxRQUFBLE9BQUEsU0FBQSxTQUFBLEdBQUEsS0FBQSxJQUFHLEdBQUc7O0FBRTVCLFNBQU87QUFDVDtBQTRDTSxTQUFVLFdBQVcsS0FBOEI7QUFDdkQsTUFBSSxDQUFDO0FBQUssV0FBTztBQUNqQixhQUFXLE1BQU07QUFBSyxXQUFPO0FBQzdCLFNBQU87QUFDVDtBQUdNLFNBQVUsT0FBTyxLQUFhLEtBQVc7QUFDN0MsU0FBTyxPQUFPLFVBQVUsZUFBZSxLQUFLLEtBQUssR0FBRztBQUN0RDtBQUVNLFNBQVUsTUFBTSxXQUFtQixNQUFXO0FBQ2xELE1BQUksT0FBTyxZQUFZLGVBQWUsUUFBUSxJQUFJLE9BQU8sTUFBTSxRQUFRO0FBQ3JFLFlBQVEsSUFBSSxnQkFBZ0IsVUFBVSxHQUFHLElBQUk7O0FBRWpEO0FBS0EsSUFBTSxRQUFRLE1BQUs7QUFDakIsU0FBTyx1Q0FBdUMsUUFBUSxTQUFTLENBQUMsTUFBSztBQUNuRSxVQUFNLElBQUssS0FBSyxPQUFNLElBQUssS0FBTTtBQUNqQyxVQUFNLElBQUksTUFBTSxNQUFNLElBQUssSUFBSSxJQUFPO0FBQ3RDLFdBQU8sRUFBRSxTQUFTLEVBQUU7RUFDdEIsQ0FBQztBQUNIO0FBRU8sSUFBTSxxQkFBcUIsTUFBSztBQUNyQzs7SUFFRSxPQUFPLFdBQVc7SUFFbEIsT0FBTyxPQUFPLGFBQWE7SUFFM0IsT0FBTyxjQUFjOztBQUV6Qjs7O0FDN2dDTSxJQUFPLE9BQVAsY0FBMEIsYUFBa0I7RUFLaEQsWUFBWSxRQUFtQixVQUFvQixNQUEwQixTQUE0QjtBQUN2RyxVQUFNLFFBQVEsVUFBVSxNQUFNLE9BQU87QUFFckMsU0FBSyxTQUFTLEtBQUs7QUFDbkIsU0FBSyxPQUFPLEtBQUs7RUFDbkI7RUFFQSxvQkFBaUI7QUFDZixXQUFPLEtBQUs7RUFDZDs7Ozs7O0VBT0EsaUJBQWM7QUFDWixXQUFPO0VBQ1Q7RUFFQSxlQUFZO0FBQ1YsV0FBTztFQUNUOztBQW1CSSxJQUFPLGFBQVAsY0FDSSxhQUFrQjtFQUsxQixZQUNFLFFBQ0EsVUFDQSxNQUNBLFNBQTRCO0FBRTVCLFVBQU0sUUFBUSxVQUFVLE1BQU0sT0FBTztBQUVyQyxTQUFLLE9BQU8sS0FBSztFQUNuQjtFQUVBLG9CQUFpQjtBQUNmLFdBQU8sS0FBSztFQUNkOztFQUdBLGlCQUFjO0FBQ1osVUFBTSxPQUFPLEtBQUssYUFBWTtBQUM5QixRQUFJLENBQUM7QUFBTSxhQUFPO0FBQ2xCLFFBQUksWUFBWTtBQUFNLGFBQU8sS0FBSztBQUNsQyxVQUFNLFNBQVMsT0FBTyxZQUFZLEtBQUssSUFBSSxZQUFZO0FBQ3ZELFFBQUksQ0FBQyxPQUFPLEtBQUssTUFBTSxFQUFFO0FBQVEsYUFBTztBQUN4QyxXQUFPO0VBQ1Q7RUFFQSxlQUFZOztBQUNWLFFBQUksR0FBQ0MsTUFBQSxLQUFLLFVBQUksUUFBQUEsUUFBQSxTQUFBLFNBQUFBLElBQUUsU0FBUTtBQUN0QixhQUFPOztBQUdULFVBQU0sUUFBTyxLQUFBLEtBQUssS0FBSyxLQUFLLEtBQUssU0FBUyxDQUFDLE9BQUMsUUFBQSxPQUFBLFNBQUEsU0FBQSxHQUFFO0FBQzlDLFFBQUksQ0FBQztBQUFNLGFBQU87QUFDbEIsV0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEtBQUksRUFBRTtFQUNsQzs7OztBQzlGSSxJQUFPLGNBQVAsTUFBa0I7RUFFdEIsWUFBWSxRQUFjO0FBQ3hCLFNBQUssU0FBUztBQUVkLFNBQUssTUFBTSxPQUFPLElBQUksS0FBSyxNQUFNO0FBQ2pDLFNBQUssT0FBTyxPQUFPLEtBQUssS0FBSyxNQUFNO0FBQ25DLFNBQUssUUFBUSxPQUFPLE1BQU0sS0FBSyxNQUFNO0FBQ3JDLFNBQUssTUFBTSxPQUFPLElBQUksS0FBSyxNQUFNO0FBQ2pDLFNBQUssU0FBUyxPQUFPLE9BQU8sS0FBSyxNQUFNO0FBQ3ZDLFNBQUssYUFBYSxPQUFPLFdBQVcsS0FBSyxNQUFNO0VBQ2pEOzs7O0FDUkksSUFBTyxpQkFBUCxjQUE4QixZQUFXOzs7O0VBSTdDLE9BQU8sTUFBaUMsU0FBNkI7QUFDbkUsV0FBTyxLQUFLLEtBQUsseUJBQXlCLDRCQUE0QixFQUFFLE1BQU0sR0FBRyxRQUFPLENBQUUsQ0FBQztFQUM3Rjs7Q0FrREYsU0FBaUJDLGlCQUFjO0FBRy9CLEdBSGlCLG1CQUFBLGlCQUFjLENBQUEsRUFBQTs7O0FDeER6QixJQUFPLGVBQVAsY0FBNEIsWUFBVzs7OztFQUkzQyxPQUFPLE1BQStCLFNBQTZCO0FBQ2pFLFdBQU8sS0FBSyxLQUFLLHVCQUF1Qiw0QkFBNEIsRUFBRSxNQUFNLEdBQUcsUUFBTyxDQUFFLENBQUM7RUFDM0Y7O0NBMkNGLFNBQWlCQyxlQUFZO0FBRzdCLEdBSGlCLGlCQUFBLGVBQVksQ0FBQSxFQUFBOzs7QUNqRHZCLElBQU8sUUFBUCxjQUFxQixZQUFXO0VBQXRDLGNBQUE7O0FBQ0UsU0FBQSxpQkFBaUMsSUFBSSxlQUFlLEtBQUssTUFBTTtBQUMvRCxTQUFBLGVBQTZCLElBQUksYUFBYSxLQUFLLE1BQU07RUFDM0Q7O0NBRUEsU0FBaUJDLFFBQUs7QUFDTixFQUFBQSxPQUFBLGlCQUFxQjtBQUlyQixFQUFBQSxPQUFBLGVBQW1CO0FBR25DLEdBUmlCLFVBQUEsUUFBSyxDQUFBLEVBQUE7OztBQ0hoQixJQUFPLGNBQVAsY0FBMkIsWUFBVztFQWdCMUMsT0FDRSxNQUNBLFNBQTZCOztBQUU3QixXQUFPLEtBQUssS0FBSyxxQkFBcUIsRUFBRSxNQUFNLEdBQUcsU0FBUyxTQUFRQyxNQUFBLEtBQUssWUFBTSxRQUFBQSxRQUFBLFNBQUFBLE1BQUksTUFBSyxDQUFFO0VBRzFGOztDQXVkRixTQUFpQkMsY0FBVztBQWE1QixHQWJpQixnQkFBQSxjQUFXLENBQUEsRUFBQTs7O0FDamZ0QixJQUFPLE9BQVAsY0FBb0IsWUFBVztFQUFyQyxjQUFBOztBQUNFLFNBQUEsY0FBMkIsSUFBSSxZQUFZLEtBQUssTUFBTTtFQUN4RDs7Q0FFQSxTQUFpQkMsT0FBSTtBQUNMLEVBQUFBLE1BQUEsY0FBa0I7QUFhbEMsR0FkaUIsU0FBQSxPQUFJLENBQUEsRUFBQTs7O0FDRmYsSUFBT0MsZUFBUCxjQUEyQixZQUFXO0VBYTFDLE9BQ0UsTUFDQSxTQUE2Qjs7QUFFN0IsV0FBTyxLQUFLLEtBQUssZ0JBQWdCLEVBQUUsTUFBTSxHQUFHLFNBQVMsU0FBUUMsTUFBQSxLQUFLLFlBQU0sUUFBQUEsUUFBQSxTQUFBQSxNQUFJLE1BQUssQ0FBRTtFQUdyRjs7Q0FzUkYsU0FBaUJELGNBQVc7QUFPNUIsR0FQaUJBLGlCQUFBQSxlQUFXLENBQUEsRUFBQTs7O0FDNVN0QixJQUFPLGFBQVAsY0FBMEIsWUFBVzs7OztFQUl6QyxPQUNFLE1BQ0EsU0FBNkI7QUFFN0IsV0FBTyxLQUFLLEtBQUssZUFBZSxFQUFFLE1BQU0sR0FBRyxRQUFPLENBQUU7RUFDdEQ7O0NBNEZGLFNBQWlCRSxhQUFVO0FBSTNCLEdBSmlCLGVBQUEsYUFBVSxDQUFBLEVBQUE7OztBQ3BHckIsSUFBTyxRQUFQLGNBQXFCLFlBQVc7Ozs7Ozs7O0VBUXBDLE9BQU8sTUFBd0IsU0FBNkI7QUFDMUQsV0FBTyxLQUFLLEtBQUssVUFBVSxFQUFFLE1BQU0sR0FBRyxRQUFPLENBQUU7RUFDakQ7O0NBd0ZGLFNBQWlCQyxRQUFLO0FBR3RCLEdBSGlCLFVBQUEsUUFBSyxDQUFBLEVBQUE7OztBQy9GaEIsSUFBTyxRQUFQLGNBQXFCLFlBQVc7Ozs7Ozs7RUFPcEMsT0FBTyxNQUF3QixTQUE2QjtBQUMxRCxXQUFPLEtBQUssS0FBSyxVQUFVLDRCQUE0QixFQUFFLE1BQU0sR0FBRyxRQUFPLENBQUUsQ0FBQztFQUM5RTs7OztFQUtBLFNBQVMsUUFBZ0IsU0FBNkI7QUFDcEQsV0FBTyxLQUFLLElBQUksVUFBVSxVQUFVLE9BQU87RUFDN0M7Ozs7RUFLQSxLQUFLLFNBQTZCO0FBQ2hDLFdBQU8sS0FBSyxXQUFXLFVBQVUsaUJBQWlCLE9BQU87RUFDM0Q7Ozs7RUFLQSxJQUFJLFFBQWdCLFNBQTZCO0FBQy9DLFdBQU8sS0FBSyxPQUFPLFVBQVUsVUFBVSxPQUFPO0VBQ2hEOzs7O0VBS0EsZ0JBQWdCLFFBQWdCLFNBQTZCO0FBQzNELFdBQU8sS0FBSyxJQUFJLFVBQVUsa0JBQWtCO01BQzFDLEdBQUc7TUFDSCxTQUFTLEVBQUUsUUFBUSxvQkFBb0IsR0FBRyxZQUFPLFFBQVAsWUFBTyxTQUFBLFNBQVAsUUFBUyxRQUFPO0tBQzNEO0VBQ0g7Ozs7RUFLQSxNQUFNLGtCQUNKLElBQ0EsRUFBRSxlQUFlLEtBQU0sVUFBVSxLQUFLLEtBQUssSUFBSSxJQUFrRCxDQUFBLEdBQUU7QUFFbkcsVUFBTSxrQkFBa0Isb0JBQUksSUFBSSxDQUFDLGFBQWEsU0FBUyxTQUFTLENBQUM7QUFFakUsVUFBTSxRQUFRLEtBQUssSUFBRztBQUN0QixRQUFJLE9BQU8sTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUVqQyxXQUFPLENBQUMsS0FBSyxVQUFVLENBQUMsZ0JBQWdCLElBQUksS0FBSyxNQUFNLEdBQUc7QUFDeEQsWUFBTSxNQUFNLFlBQVk7QUFFeEIsYUFBTyxNQUFNLEtBQUssU0FBUyxFQUFFO0FBQzdCLFVBQUksS0FBSyxJQUFHLElBQUssUUFBUSxTQUFTO0FBQ2hDLGNBQU0sSUFBSSwwQkFBMEI7VUFDbEMsU0FBUyxpQ0FBaUMsaUNBQWlDO1NBQzVFOzs7QUFJTCxXQUFPO0VBQ1Q7O0FBTUksSUFBTyxrQkFBUCxjQUErQixLQUFnQjs7Q0FnRnJELFNBQWlCQyxRQUFLO0FBTXRCLEdBTmlCLFVBQUEsUUFBSyxDQUFBLEVBQUE7OztBQ3hKaEIsSUFBTyxZQUFQLGNBQXlCLFlBQVc7Ozs7Ozs7OztFQVN4QyxPQUFPLE1BQTRCLFNBQTZCO0FBQzlELFdBQU8sS0FBSyxLQUFLLGVBQWUsRUFBRSxNQUFNLEdBQUcsUUFBTyxDQUFFO0VBQ3REOzs7Ozs7RUFPQSxTQUFTLFlBQW9CLFNBQTZCO0FBQ3hELFdBQU8sS0FBSyxJQUFJLGVBQWUsY0FBYyxPQUFPO0VBQ3REOzs7O0VBS0EsS0FBSyxTQUE2QjtBQUNoQyxXQUFPLEtBQUssV0FBVyxlQUFlLGVBQWUsT0FBTztFQUM5RDs7OztFQUtBLE9BQU8sWUFBb0IsU0FBNkI7QUFDdEQsV0FBTyxLQUFLLEtBQUssZUFBZSxxQkFBcUIsT0FBTztFQUM5RDtFQW9CQSxXQUNFLFlBQ0EsT0FDQSxTQUE2Qjs7QUFFN0IsV0FBTyxLQUFLLElBQUksZUFBZSxxQkFBcUI7TUFDbEQ7TUFDQSxTQUFTO01BQ1QsR0FBRztNQUNILFNBQVFDLE1BQUEsVUFBSyxRQUFMLFVBQUssU0FBQSxTQUFMLE1BQU8sWUFBTSxRQUFBQSxRQUFBLFNBQUFBLE1BQUk7S0FDMUI7RUFDSDs7QUFNSSxJQUFPLGdCQUFQLGNBQTZCLEtBQWM7O0NBK1RqRCxTQUFpQkMsWUFBUztBQVMxQixHQVRpQixjQUFBLFlBQVMsQ0FBQSxFQUFBOzs7QUN4WXBCLElBQU8sT0FBUCxjQUFvQixZQUFXOzs7Ozs7Ozs7RUFTbkMsT0FBTyxNQUF1QixTQUE2QjtBQUN6RCxXQUFPLEtBQUssS0FBSyxxQkFBcUIsRUFBRSxNQUFNLEdBQUcsUUFBTyxDQUFFO0VBQzVEOzs7Ozs7RUFPQSxTQUFTLGlCQUF5QixTQUE2QjtBQUM3RCxXQUFPLEtBQUssSUFBSSxxQkFBcUIsbUJBQW1CLE9BQU87RUFDakU7RUFVQSxLQUNFLFFBQTZDLENBQUEsR0FDN0MsU0FBNkI7QUFFN0IsUUFBSSxpQkFBaUIsS0FBSyxHQUFHO0FBQzNCLGFBQU8sS0FBSyxLQUFLLENBQUEsR0FBSSxLQUFLOztBQUU1QixXQUFPLEtBQUssV0FBVyxxQkFBcUIsb0JBQW9CLEVBQUUsT0FBTyxHQUFHLFFBQU8sQ0FBRTtFQUN2Rjs7OztFQUtBLE9BQU8saUJBQXlCLFNBQTZCO0FBQzNELFdBQU8sS0FBSyxLQUFLLHFCQUFxQiwwQkFBMEIsT0FBTztFQUN6RTtFQWNBLFdBQ0UsaUJBQ0EsUUFBbUQsQ0FBQSxHQUNuRCxTQUE2QjtBQUU3QixRQUFJLGlCQUFpQixLQUFLLEdBQUc7QUFDM0IsYUFBTyxLQUFLLFdBQVcsaUJBQWlCLENBQUEsR0FBSSxLQUFLOztBQUVuRCxXQUFPLEtBQUssV0FBVyxxQkFBcUIsMEJBQTBCLHlCQUF5QjtNQUM3RjtNQUNBLEdBQUc7S0FDSjtFQUNIOztBQUdJLElBQU8scUJBQVAsY0FBa0MsV0FBeUI7O0FBSTNELElBQU8sMEJBQVAsY0FBdUMsV0FBOEI7O0NBb04zRSxTQUFpQkMsT0FBSTtBQVFyQixHQVJpQixTQUFBLE9BQUksQ0FBQSxFQUFBOzs7QUNwU2YsSUFBTyxhQUFQLGNBQTBCLFlBQVc7RUFBM0MsY0FBQTs7QUFDRSxTQUFBLE9BQWEsSUFBSSxLQUFLLEtBQUssTUFBTTtFQUNuQzs7Q0FFQSxTQUFpQkMsYUFBVTtBQUNYLEVBQUFBLFlBQUEsT0FBVztBQUdYLEVBQUFBLFlBQUEscUJBQXlCO0FBQ3pCLEVBQUFBLFlBQUEsMEJBQThCO0FBSTlDLEdBVGlCLGVBQUEsYUFBVSxDQUFBLEVBQUE7OztBQ0hyQixJQUFPLFNBQVAsY0FBc0IsWUFBVzs7OztFQUlyQyxnQkFDRSxNQUNBLFNBQTZCO0FBRTdCLFdBQU8sS0FBSyxLQUFLLHNCQUFzQiw0QkFBNEIsRUFBRSxNQUFNLEdBQUcsUUFBTyxDQUFFLENBQUM7RUFDMUY7Ozs7RUFLQSxLQUFLLE1BQXVCLFNBQTZCO0FBQ3ZELFdBQU8sS0FBSyxLQUFLLGlCQUFpQiw0QkFBNEIsRUFBRSxNQUFNLEdBQUcsUUFBTyxDQUFFLENBQUM7RUFDckY7Ozs7RUFLQSxTQUFTLE1BQTJCLFNBQTZCO0FBQy9ELFdBQU8sS0FBSyxLQUFLLHVCQUF1QixFQUFFLE1BQU0sR0FBRyxRQUFPLENBQUU7RUFDOUQ7O0NBc0lGLFNBQWlCQyxTQUFNO0FBTXZCLEdBTmlCLFdBQUEsU0FBTSxDQUFBLEVBQUE7OztBQzdKakIsSUFBTyxTQUFQLGNBQXNCLFlBQVc7Ozs7O0VBS3JDLFNBQVMsT0FBZSxTQUE2QjtBQUNuRCxXQUFPLEtBQUssSUFBSSxXQUFXLFNBQVMsT0FBTztFQUM3Qzs7Ozs7RUFNQSxLQUFLLFNBQTZCO0FBQ2hDLFdBQU8sS0FBSyxXQUFXLFdBQVcsWUFBWSxPQUFPO0VBQ3ZEOzs7OztFQU1BLElBQUksT0FBZSxTQUE2QjtBQUM5QyxXQUFPLEtBQUssT0FBTyxXQUFXLFNBQVMsT0FBTztFQUNoRDs7QUFNSSxJQUFPLGFBQVAsY0FBMEIsS0FBVzs7Q0FxQzNDLFNBQWlCQyxTQUFNO0FBSXZCLEdBSmlCLFdBQUEsU0FBTSxDQUFBLEVBQUE7OztBQ25FakIsSUFBTyxjQUFQLGNBQTJCLFlBQVc7Ozs7RUFJMUMsT0FDRSxNQUNBLFNBQTZCO0FBRTdCLFdBQU8sS0FBSyxLQUFLLGdCQUFnQixFQUFFLE1BQU0sR0FBRyxRQUFPLENBQUU7RUFDdkQ7O0NBb01GLFNBQWlCQyxjQUFXO0FBSTVCLEdBSmlCLGdCQUFBLGNBQVcsQ0FBQSxFQUFBOzs7O0FDcEl0QixJQUFPLFNBQVAsY0FBMkIsVUFBUzs7Ozs7Ozs7Ozs7Ozs7O0VBb0J4QyxZQUFZLElBSVM7O1FBSlQsRUFDVixTQUFjLFFBQVEsZ0JBQWdCLEdBQ3RDLGdCQUFlLEtBQUssUUFBUSxlQUFlLE9BQUMsUUFBQSxPQUFBLFNBQUEsS0FBSSxNQUNoRCxHQUFHLEtBQUksSUFBQSxPQUFBLFNBQ1UsQ0FBQSxJQUFFO0FBQ25CLFFBQUksV0FBVyxRQUFXO0FBQ3hCLFlBQU0sSUFBVyxZQUNmLG1MQUFtTDs7QUFJdkwsVUFBTSxVQUF5QjtNQUM3QjtNQUNBO01BQ0EsR0FBRztNQUNILFVBQVMsS0FBQSxLQUFLLGFBQU8sUUFBQSxPQUFBLFNBQUEsS0FBSTs7QUFHM0IsUUFBSSxDQUFDLFFBQVEsMkJBQWdDLG1CQUFrQixHQUFJO0FBQ2pFLFlBQU0sSUFBVyxZQUNmLG9iQUFvYjs7QUFJeGIsVUFBTTtNQUNKLFNBQVMsUUFBUTtNQUNqQixVQUFTLEtBQUEsUUFBUSxhQUFPLFFBQUEsT0FBQSxTQUFBLEtBQUk7TUFDNUIsV0FBVyxRQUFRO01BQ25CLFlBQVksUUFBUTtNQUNwQixPQUFPLFFBQVE7S0FDaEI7QUFPSCxTQUFBLGNBQStCLElBQVFDLGFBQVksSUFBSTtBQUN2RCxTQUFBLE9BQWlCLElBQVEsS0FBSyxJQUFJO0FBQ2xDLFNBQUEsUUFBbUIsSUFBUSxNQUFNLElBQUk7QUFDckMsU0FBQSxhQUE2QixJQUFRLFdBQVcsSUFBSTtBQUNwRCxTQUFBLFFBQW1CLElBQVEsTUFBTSxJQUFJO0FBQ3JDLFNBQUEsU0FBcUIsSUFBUSxPQUFPLElBQUk7QUFDeEMsU0FBQSxRQUFtQixJQUFRLE1BQU0sSUFBSTtBQUNyQyxTQUFBLGNBQStCLElBQVEsWUFBWSxJQUFJO0FBQ3ZELFNBQUEsU0FBcUIsSUFBUSxPQUFPLElBQUk7QUFDeEMsU0FBQSxhQUE2QixJQUFRLFdBQVcsSUFBSTtBQUNwRCxTQUFBLFlBQTJCLElBQVEsVUFBVSxJQUFJO0FBaEIvQyxTQUFLLFdBQVc7QUFFaEIsU0FBSyxTQUFTO0FBQ2QsU0FBSyxlQUFlO0VBQ3RCO0VBY21CLGVBQVk7QUFDN0IsV0FBTyxLQUFLLFNBQVM7RUFDdkI7RUFFbUIsZUFBZSxNQUE4QjtBQUM5RCxXQUFPO01BQ0wsR0FBRyxNQUFNLGVBQWUsSUFBSTtNQUM1Qix1QkFBdUIsS0FBSztNQUM1QixHQUFHLEtBQUssU0FBUzs7RUFFckI7RUFFbUIsWUFBWSxNQUE4QjtBQUMzRCxXQUFPLEVBQUUsZUFBZSxVQUFVLEtBQUssU0FBUTtFQUNqRDs7O0FBRU8sT0FBQSxTQUFTO0FBRVQsT0FBQSxjQUFxQjtBQUNyQixPQUFBLFdBQWtCO0FBQ2xCLE9BQUEscUJBQTRCO0FBQzVCLE9BQUEsNEJBQW1DO0FBQ25DLE9BQUEsb0JBQTJCO0FBQzNCLE9BQUEsZ0JBQXVCO0FBQ3ZCLE9BQUEsZ0JBQXVCO0FBQ3ZCLE9BQUEsaUJBQXdCO0FBQ3hCLE9BQUEsa0JBQXlCO0FBQ3pCLE9BQUEsc0JBQTZCO0FBQzdCLE9BQUEsc0JBQTZCO0FBQzdCLE9BQUEsd0JBQStCO0FBQy9CLE9BQUEsMkJBQWtDO0FBR3BDLElBQU0sRUFDWCxhQUFBQyxjQUNBLFVBQUFDLFdBQ0Esb0JBQUFDLHFCQUNBLDJCQUFBQyw0QkFDQSxtQkFBQUMsb0JBQ0EsZUFBQUMsZ0JBQ0EsZUFBQUMsZ0JBQ0EsZ0JBQUFDLGlCQUNBLGlCQUFBQyxrQkFDQSxxQkFBQUMsc0JBQ0EscUJBQUFDLHNCQUNBLHVCQUFBQyx3QkFDQSwwQkFBQUMsMEJBQXdCLElBQ3RCO0NBS0osU0FBaUJDLFNBQU07QUFFUCxFQUFBQSxRQUFBLFNBQWlCO0FBQ2pCLEVBQUFBLFFBQUEsZUFBdUI7QUFJdkIsRUFBQUEsUUFBQSxPQUFrQjtBQUdsQixFQUFBQSxRQUFBLGFBQXdCO0FBSXhCLEVBQUFBLFFBQUEsY0FBa0JDO0FBUWxCLEVBQUFELFFBQUEsT0FBVztBQUVYLEVBQUFBLFFBQUEsUUFBWTtBQUlaLEVBQUFBLFFBQUEsYUFBaUI7QUFLakIsRUFBQUEsUUFBQSxRQUFZO0FBSVosRUFBQUEsUUFBQSxrQkFBc0I7QUFHdEIsRUFBQUEsUUFBQSxTQUFhO0FBT2IsRUFBQUEsUUFBQSxRQUFZO0FBRVosRUFBQUEsUUFBQSxjQUFrQjtBQUtsQixFQUFBQSxRQUFBLFNBQWE7QUFHYixFQUFBQSxRQUFBLGFBQWlCO0FBRWpCLEVBQUFBLFFBQUEsYUFBaUI7QUFFakIsRUFBQUEsUUFBQSxZQUFnQjtBQUloQixFQUFBQSxRQUFBLGdCQUFvQjtBQUtwQyxHQXRFaUIsV0FBQSxTQUFNLENBQUEsRUFBQTtBQXdFdkIsSUFBQSxpQkFBZTs7O0FDOVFmLHNCQUlPO0FBT1AsSUFBTSxXQUFXLElBQUkseUJBQVM7QUFBQSxFQUM3QixRQUFRO0FBQUEsRUFDUixhQUFhO0FBQ2QsQ0FBQztBQUVELElBQU0sU0FBUyxJQUFJLGVBQU87QUFBQSxFQUN6QixRQUFRO0FBQUE7QUFBQSxFQUNSLHlCQUF5QjtBQUMxQixDQUFDO0FBRUQsZUFBZSxpQkFBaUI7QUFBQSxFQUMvQjtBQUFBLEVBQ0E7QUFDRCxHQUdHO0FBN0JILE1BQUFFLEtBQUE7QUE4QkMsUUFBTSxFQUFFLGVBQWUsTUFBTSxJQUFJO0FBQ2pDLFFBQU0sT0FBTyxjQUFjLHFCQUFxQixNQUFNLEVBQUU7QUFDeEQsUUFBTSxZQUFXLE1BQUFBLE1BQUEsY0FBYyxhQUFhLElBQUksTUFBL0IsZ0JBQUFBLElBQWtDLGFBQWxDLFlBQThDLENBQUM7QUFDaEUsTUFBSSxPQUFPLE1BQU0sTUFBTSxXQUFXLElBQUk7QUFDdEMsTUFBSSxTQUFTO0FBQ1osVUFBTSxPQUFPLFNBQVM7QUFBQSxNQUNyQixDQUFDLEVBQUUsUUFBUSxNQUFXLFlBQVk7QUFBQSxJQUNuQztBQUNBLFFBQUksU0FBUyxJQUFJO0FBQ2hCLGFBQU87QUFBQSxJQUNSLE9BQU87QUFDTixhQUFPLEtBQ0wsTUFBTSxJQUFJLEVBQ1Y7QUFBQSxRQUNBLFNBQVMsSUFBSSxFQUFFLFNBQVMsTUFBTSxPQUFPO0FBQUEsU0FDckMsMEJBQVMsT0FBTyxDQUFDLE1BQWpCLG1CQUFvQixhQUFwQixtQkFBOEIsVUFBOUIsbUJBQXFDO0FBQUEsTUFDdEMsRUFDQyxLQUFLLEdBQUcsRUFDUixLQUFLO0FBQUEsSUFDUjtBQUFBLEVBQ0Q7QUFDQSxTQUFPLEtBQ0wsTUFBTSxJQUFJLEVBQ1YsSUFBSSxDQUFDLFNBQWlCLEtBQUssS0FBSyxDQUFDLEVBQ2pDLEtBQUssR0FBRztBQUNYO0FBRUEsZUFBc0IsZ0JBQWdCLE1BQWE7QUFDbEQsUUFBTSxFQUFFLFVBQVUsR0FBRyxJQUFJLHVCQUFjLFdBQVc7QUFDbEQsUUFBTUMsT0FBTSx1QkFBYztBQUUxQixRQUFNLFNBQVMsQ0FBQztBQUVoQixRQUFNLGtCQUFrQixLQUFLO0FBQUEsSUFDNUIsTUFBTUEsS0FBSSxNQUFNO0FBQUEsTUFDZkEsS0FBSSxjQUFjO0FBQUEsUUFDakI7QUFBQSxRQUNBO0FBQUEsTUFDRDtBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBR0EsUUFBTSxXQUFXLGdCQUFnQixNQUFNO0FBQUEsSUFBSyxDQUFDLFNBQzVDLEtBQUssS0FBSyxTQUFTLEtBQUssSUFBSTtBQUFBLEVBQzdCO0FBSUEsUUFBTSxlQUFlLGdCQUFnQixNQUFNO0FBQUEsSUFDMUMsQ0FBQyxTQUFjLEtBQUssYUFBYSxTQUFTO0FBQUEsRUFDM0M7QUFDQSxRQUFNLGlCQUFpQixnQkFBZ0IsTUFBTTtBQUFBLElBQzVDLENBQUMsU0FBYyxLQUFLLFdBQVcsU0FBUztBQUFBLEVBQ3pDO0FBRUEsUUFBTSxjQUFjLENBQUMsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUV2RCxXQUFTLGNBQWMsYUFBYTtBQUVuQyxVQUFNLE1BQU1BLEtBQUksY0FBYztBQUFBLE1BQzdCLFdBQVc7QUFBQSxNQUNYO0FBQUEsSUFDRDtBQUVBLFVBQU0sT0FBTyxnQkFBZ0IsTUFBTTtBQUFBLE1BQ2xDLENBQUNDLFVBQ0MsV0FBVyxhQUFhQSxNQUFLLE1BQzdCLFdBQVcsV0FBVyxTQUFTLE1BQy9CLFdBQVcsV0FBV0EsTUFBSyxNQUMzQixXQUFXLGFBQWEsU0FBUztBQUFBLElBQ3BDO0FBRUEsVUFBTSxXQUFXRCxLQUFJLGNBQWMscUJBQXFCLEtBQUssTUFBTSxFQUFFO0FBRXJFLFdBQU8sS0FBSztBQUFBLE1BQ1gsTUFBTSxLQUFLLElBQUksZUFBZTtBQUFBLE1BQzlCLEtBQUsscUNBQVU7QUFBQSxJQUNoQixDQUFDO0FBQUEsRUFDRjtBQUVBLFFBQU0sZ0JBQWdCLE9BQU8sU0FDMUIsT0FBTyxHQUFHLGNBQWMsQ0FBQyxrQkFBa0IsZUFBZSxHQUFHLE1BQU0sSUFDbkU7QUFDSCxTQUFPO0FBQ1I7QUFFQSxlQUFzQixXQUFXLE1BQWE7QUFySDlDLE1BQUFELEtBQUE7QUFzSEMsUUFBTSxFQUFFLFVBQVUsSUFBSSxPQUFPLElBQUksdUJBQWMsV0FBVztBQUMxRCxRQUFNQyxPQUFNLHVCQUFjO0FBRTFCLFFBQU0sUUFBUUEsS0FBSSxjQUFjLGFBQWEsSUFBYTtBQUUxRCxRQUFNLFFBQVEsR0FDWixNQUFNLElBQUksT0FBTyxTQUFTLGlDQUFpQyxFQUMzRCxNQUFNLENBQUMsU0FBYztBQUNyQixXQUFPLEtBQUssVUFBVSxLQUFLLE9BQU8sS0FBSyxTQUFTLEtBQUssSUFBSTtBQUFBLEVBQzFELENBQUMsRUFBRTtBQUVKLE1BQUksTUFBTSxXQUFXO0FBQUcsV0FBTztBQUcvQixRQUFNLGdCQUFlRCxNQUFBLCtCQUFPLGFBQVAsZ0JBQUFBLElBQWlCO0FBQUEsSUFDckMsQ0FBQyxNQUFNLEVBQUUsWUFBWTtBQUFBO0FBRXRCLFFBQU0scUJBQW9CLG9DQUFPLGFBQVAsbUJBQWlCO0FBQUEsSUFDMUMsQ0FBQyxZQUNBLFFBQVEsU0FBUyxNQUFNLFVBQVMsNkNBQWMsU0FBUyxNQUFNO0FBQUE7QUFHL0QsUUFBTSxXQUNMLE9BQ0EsR0FBRztBQUFBLElBQ0YsTUFBTTtBQUFBLE1BQ0wsQ0FBQyxTQUNBLEtBQUssS0FBSyxLQUFLLFFBQVEsS0FBSyxLQUFLLFVBQ2hDLEtBQUssV0FBVyxZQUFZLFlBQVE7QUFBQSxJQUV2QztBQUFBLEVBQ0Q7QUFFRCxTQUFPLDhCQUFZO0FBQ3BCO0FBRUEsZUFBc0IsbUJBQW1CLE1BQWE7QUFDckQsUUFBTSxFQUFFLFVBQVUsSUFBSSxPQUFPLElBQUksdUJBQWMsV0FBVztBQUMxRCxRQUFNQyxPQUFNLHVCQUFjO0FBRTFCLFFBQU0sUUFBUUEsS0FBSSxjQUFjLGFBQWEsSUFBYTtBQUUxRCxRQUFNLG1CQUFtQixHQUN2QixNQUFNLElBQUksT0FBTyxTQUFTLHlDQUF5QyxFQUNuRSxNQUFNLENBQUMsUUFBYTtBQWxLdkIsUUFBQUQ7QUFtS0csV0FBTyxJQUFJLFVBQVUsSUFBSSxZQUFVQSxNQUFBLCtCQUFPLGdCQUFQLGdCQUFBQSxJQUFvQjtBQUFBLEVBQ3hELENBQUMsRUFBRTtBQUVKLE1BQUksaUJBQWlCLFdBQVc7QUFBRyxXQUFPO0FBSTFDLFFBQU0sY0FBa0MsQ0FBQztBQUV6QyxhQUFXLE9BQU8sa0JBQWtCO0FBQ25DLFVBQU0sV0FBNkIsQ0FBQyxJQUFJLEVBQUU7QUFDMUMsYUFBUyxDQUFDLElBQUksTUFBTSxpQkFBaUI7QUFBQSxNQUNwQyxNQUFNLElBQUksS0FBSztBQUFBLE1BQ2YsU0FBUztBQUFBLElBQ1YsQ0FBQztBQUNELGFBQVMsQ0FBQyxJQUFJLE9BQU8sSUFBSSxLQUFLLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJO0FBQ3RELGdCQUFZLEtBQUssUUFBUTtBQUFBLEVBQzFCO0FBRUEsUUFBTSxlQUFlLENBQUMsZUFBZSxRQUFRO0FBRTdDLFFBQU0sZ0JBQWdCLE9BQU8sR0FBRyxjQUFjLGNBQWMsV0FBVztBQUN2RSxTQUFPLHdDQUFpQjtBQUN6QjtBQVNBLGVBQXNCLG9CQUNyQixLQUNDO0FBck1GLE1BQUFBLEtBQUE7QUEwTUMsTUFBSSxDQUFDO0FBQUs7QUFFVixRQUFNLGVBQWUsTUFBTSxTQUFTLE1BQU0sY0FBYyxFQUFFLE1BQU07QUFBQSxJQUMvRCxRQUFRLElBQUk7QUFBQSxJQUNaLE1BQU07QUFBQSxJQUNOLGlCQUFpQjtBQUFBLEVBQ2xCLENBQUM7QUFFRCxRQUFNLHNCQUFxQkEsTUFBQSxhQUFhLFlBQWIsZ0JBQUFBLElBQ3hCO0FBQUEsSUFDRCxDQUFDLFVBQU87QUFwTlgsVUFBQUEsS0FBQUc7QUFxTkksbUJBQU0sU0FDTixNQUFNLFFBQVEsT0FDZCxNQUFNLFFBQVEsVUFDZEgsTUFBQSxNQUFNLGFBQU4sZ0JBQUFBLElBQWdCLG1CQUFnQkcsTUFBQSxJQUFJLGFBQUosZ0JBQUFBLElBQWM7QUFBQTtBQUFBLElBRS9DO0FBQUEsSUFDQSxDQUFDLFVBQU87QUEzTlgsVUFBQUgsS0FBQUc7QUE0Tkksc0JBQ0FILE1BQUEsTUFBTSxhQUFOLGdCQUFBQSxJQUFnQixlQUNoQjtBQUFBLGNBQWdCRyxNQUFBLE1BQU0sYUFBTixnQkFBQUEsSUFBZ0I7QUFBQTtBQUFBLElBRWpDLEtBQUs7QUFFUCxNQUFJLENBQUMsc0JBQXNCLHVCQUF1QixJQUFJO0FBQ3JELFlBQVEsSUFBSSxvQkFBb0I7QUFDaEM7QUFBQSxFQUNEO0FBRUEsVUFBUSxJQUFJLGtCQUFrQjtBQUU5QixRQUFNLFNBQVM7QUFBQSxLQUNaLFNBQUksYUFBSixtQkFBYztBQUFBO0FBQUE7QUFBQSxJQUdkO0FBQUE7QUFBQTtBQUFBO0FBS0gsUUFBTSxTQUFTLE1BQU0sT0FBTyxLQUFLLFlBQVksT0FBTztBQUFBLElBQ25ELE9BQU87QUFBQSxJQUNQLFVBQVU7QUFBQSxNQUNUO0FBQUEsUUFDQyxNQUFNO0FBQUEsUUFDTixTQUFTO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJVjtBQUFBLE1BQ0E7QUFBQSxRQUNDLE1BQU07QUFBQSxRQUNOLFNBQVM7QUFBQSxNQUNWO0FBQUEsSUFDRDtBQUFBLEVBQ0QsQ0FBQztBQUVELFNBQU8sT0FBTyxRQUFRLENBQUMsRUFBRSxRQUFRO0FBQ2xDO0FBRUEsZUFBc0IsU0FBUyxPQUFtQixNQUF3QjtBQXRRMUUsTUFBQUgsS0FBQTtBQXdRQyxRQUFNLE9BQU87QUFBQSxJQUNWLE1BQU07QUFBQTtBQUFBO0FBQUEsSUFHTixNQUFNO0FBQUE7QUFBQTtBQUFBLElBR04sTUFBTTtBQUVULFFBQU0sT0FBT0EsT0FBQSxNQUFNLFNBQVMsTUFBTSxjQUFjLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQ2hFLFlBRFcsZ0JBQUFBLElBQ0QsTUFBTTtBQUtsQixRQUNDLGdDQUFLLGFBQUwsbUJBQWUsaUJBQWdCLE1BQU0sZUFDckMsSUFBSSxTQUFTLFdBQVcsTUFBTSxRQUM3QjtBQUNELFVBQUksZ0NBQUssYUFBTCxtQkFBZSxVQUFTLEtBQUssTUFBTTtBQUN0QyxZQUFNLFNBQ0osTUFBTSxjQUFjLEVBQ3BCLE9BQU8sRUFBRSxJQUFJLElBQUksSUFBSSxVQUFVLEVBQUUsTUFBTSxLQUFLLEtBQUssRUFBRSxDQUFDO0FBQ3RELGFBQU87QUFBQSxRQUNOLEdBQUc7QUFBQSxRQUNILFVBQVU7QUFBQSxVQUNULEdBQUcsSUFBSTtBQUFBLFVBQ1AsTUFBTSxLQUFLO0FBQUEsUUFDWjtBQUFBLE1BQ0Q7QUFBQSxJQUNELE9BQU87QUFDTixhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Q7QUFFQSxRQUFNLFlBQVksTUFBTSxPQUFPLFdBQVcsT0FBTztBQUFBLElBQ2hELE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxFQUNSLENBQUM7QUFFRCxRQUFNLFNBQVMsTUFBTSxjQUFjLEVBQUUsT0FBTztBQUFBLElBQzNDO0FBQUEsTUFDQyxJQUFJLE1BQU07QUFBQSxNQUNWLFFBQVEsVUFBVSxLQUFLLENBQUMsRUFBRTtBQUFBLE1BQzFCLFVBQVU7QUFBQSxRQUNULGFBQWEsTUFBTTtBQUFBLFFBQ25CLFFBQVEsTUFBTTtBQUFBLFFBQ2QsUUFBUSxNQUFNO0FBQUEsUUFDZCxNQUFNLEtBQUs7QUFBQSxNQUNaO0FBQUEsSUFDRDtBQUFBLEVBQ0QsQ0FBQztBQUVELFFBQU0sWUFBWSxZQUFNLFNBQVMsTUFBTSxjQUFjLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQ3JFLFlBRGdCLG1CQUNOLE1BQU07QUFFbEIsU0FBTztBQUNSOzs7QUMvVEEsc0JBQXlCO0FBU3pCLGVBQXNCLGVBQWUsTUFBMEI7QUFDOUQsUUFBTUksT0FBTSx1QkFBYztBQUMxQixRQUFNLEVBQUUsT0FBTyxJQUFJLHVCQUFjLFdBQVc7QUFFNUMsUUFBTSxzQkFBc0IsVUFBTTtBQUFBLElBQ2pDQSxLQUFJLE1BQU0sUUFBUSxZQUFZLElBQzdCO0FBQUEsRUFDRjtBQUdBLE1BQUksT0FBTyxvQkFDVCxTQUFTLEVBQ1QsUUFBUSxhQUFhLEtBQUssTUFBTSxFQUNoQyxRQUFRLGtCQUFrQixLQUFLLFdBQVcsRUFDMUMsUUFBUSxhQUFhLEtBQUssTUFBTTtBQUVsQyxNQUFJLENBQUMsS0FBSyxJQUFJO0FBQ2IsVUFBTSxrQkFBa0JBLEtBQUksTUFDMUIsU0FBUyxFQUNUO0FBQUEsTUFBTyxDQUFDLFNBQ1IsS0FBSyxTQUFTLFdBQVcsT0FBTyxLQUFLLFNBQVM7QUFBQSxJQUMvQyxFQUFFO0FBQ0gsU0FBSyxLQUFLLE9BQU8sS0FBSyxVQUFVLGtCQUFrQjtBQUFBLEVBQ25EO0FBRUEsTUFBSSxLQUFLLElBQUk7QUFDWixXQUFPLEtBQUssUUFBUSxTQUFTLEtBQUssR0FBRyxZQUFZLEVBQUUsUUFBUSxNQUFNLEdBQUcsQ0FBQztBQUFBLEVBQ3RFO0FBRUEsUUFBTSxXQUFXLE9BQU8sU0FBUztBQUVqQyxTQUFPLE1BQU1BLEtBQUksTUFBTTtBQUFBLElBQ3RCLFdBQVcsbUJBQW1CLEtBQUssS0FBSztBQUFBLElBQ3hDO0FBQUEsRUFDRDtBQUNEO0FBRUEsZUFBc0IsYUFBYTtBQUFBLEVBQ2xDO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQ0QsR0FLRztBQUNGLFFBQU1BLE9BQU0sdUJBQWM7QUFFMUIsUUFBTSxvQkFBb0IsVUFBTTtBQUFBLElBQy9CQSxLQUFJLE1BQU0sUUFBUSxZQUFZLElBQzdCO0FBQUEsRUFDRjtBQUdBLE1BQUksT0FBTyxrQkFBa0IsU0FBUyxFQUFFLFFBQVEsYUFBYSxNQUFNO0FBRW5FLE1BQUksSUFBSTtBQUNQLFdBQU8sS0FBSyxRQUFRLFNBQVMsR0FBRyxZQUFZLEVBQUUsUUFBUSxNQUFNLEdBQUcsQ0FBQztBQUFBLEVBQ2pFO0FBRUEsUUFBTUEsS0FBSSxNQUFNLGFBQWEsT0FBTyxNQUFNLFFBQVE7QUFFbEQsU0FBTyxNQUFNQSxLQUFJLE1BQU07QUFBQSxJQUN0QixPQUFPLE1BQU0sV0FBVyxNQUFNLFdBQVc7QUFBQSxJQUN6QztBQUFBLEVBQ0Q7QUFDRDtBQUVBLGVBQXNCLG1CQUFtQjtBQUFBLEVBQ3hDO0FBQUEsRUFDQTtBQUNELEdBR0c7QUF2RkgsTUFBQUMsS0FBQTtBQXdGQyxRQUFNRCxPQUFNLHVCQUFjO0FBQzFCLFFBQU0sZ0JBQWdCQSxLQUFJLGNBQWM7QUFBQSxJQUN2QztBQUFBLElBQ0E7QUFBQSxFQUNEO0FBQ0EsVUFBUSxJQUFJLGFBQWE7QUFDekIsTUFBSSxDQUFDO0FBQWUsVUFBTSxJQUFJLE1BQU0seUJBQXlCO0FBQzdELFFBQU0sSUFBSSxNQUFNQSxLQUFJLE1BQU0sV0FBVyxhQUFhO0FBQ2xELFFBQU0sV0FBVyxLQUFLLE1BQU0sQ0FBQztBQU03QixRQUFNLGVBQWMsTUFBQUMsTUFBQUQsS0FBSSxVQUN0QixRQUFRLEVBQ1IsYUFBYSxNQUZLLGdCQUFBQyxJQUdqQixJQUFJLHVCQUF1QixVQUFVLE9BSHBCLG1CQUlqQixhQUFhO0FBRWhCLFFBQU0sbUJBQWtCLDREQUNyQixNQUFNLGNBQWMsT0FEQyxtQkFFckIsTUFBTSxPQUFPLE9BRlEsbUJBR3JCLE1BQU0sWUFIZSxZQUdKLENBQUMsR0FBRyxDQUFDO0FBRXpCLFdBQVMsTUFBTSxLQUFLO0FBQUEsSUFDbkIsTUFBTSxjQUFjLFNBQVM7QUFBQSxJQUM3QixJQUFJLEtBQUssT0FBTyxFQUFFLFNBQVMsRUFBRSxFQUFFLFVBQVUsRUFBRTtBQUFBLElBQzNDLE1BQU0sS0FBSztBQUFBLElBQ1gsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJO0FBQUEsSUFDakMsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJO0FBQUEsSUFDakMsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsT0FBTyxLQUFLO0FBQUEsSUFDWixHQUFJLGNBQWMsRUFBRSxNQUFNLEtBQUssU0FBUyxJQUFJLENBQUM7QUFBQSxFQUM5QyxDQUFDO0FBRUQsUUFBTUQsS0FBSSxNQUFNLE9BQU8sZUFBZSxLQUFLLFVBQVUsUUFBUSxDQUFDO0FBQy9EOzs7QS9CekVBLElBQU0sbUJBQXFDO0FBQUEsRUFDMUMsV0FBVztBQUFBLEVBQ1gsMkJBQTJCO0FBQUEsRUFDM0IsZ0NBQWdDO0FBQUEsRUFDaEMsd0JBQXdCO0FBQ3pCO0FBRUEsSUFBcUIsV0FBckIsY0FBc0MsdUJBQU87QUFBQSxFQUc1QyxNQUFNLFNBQVM7QUFDZCxVQUFNLEtBQUssYUFBYTtBQUV4QixrQ0FBYSxPQUFPLEtBQUssUUFBUTtBQUNoQyxZQUFNLFNBQVMsSUFBSTtBQUNuQixjQUFRLElBQUksTUFBTTtBQUVsQixVQUFJLENBQUMsUUFBUTtBQUNaLFlBQUksSUFBSSxpQkFBaUI7QUFDekI7QUFBQSxNQUNEO0FBR0EsVUFBSSxVQUFVLEtBQUs7QUFBQSxRQUNsQiwrQkFBK0I7QUFBQSxRQUMvQixnQ0FBZ0M7QUFBQSxRQUNoQyxnQ0FDQztBQUFBLE1BQ0YsQ0FBQztBQUNELFlBQU0sT0FBTyxLQUFLLElBQUksTUFBTTtBQUFBLFFBQzNCO0FBQUEsTUFDRDtBQUNBLFlBQU0sWUFBWSxJQUFJO0FBQUEsUUFDckIsTUFBTSxLQUFLLElBQUksTUFBTSxXQUFXLElBQUk7QUFBQSxNQUNyQztBQUNBLFVBQUksSUFBSSxTQUFTO0FBQUEsSUFFbEIsQ0FBQyxFQUFFLE9BQU8sSUFBSTtBQUVkLDJCQUFjLEtBQUssS0FBSyxHQUFHO0FBRTNCLFNBQUssSUFBSSxVQUFVLGNBQWMsTUFBTTtBQUN0QyxjQUFRLElBQUksS0FBSyxJQUFJLFFBQVEsT0FBTztBQUNwQyw2QkFBYyxXQUFXO0FBQUE7QUFBQSxRQUV4QixVQUFVLEtBQUssSUFBSSxRQUFRLFFBQVEsVUFBVSxFQUFFO0FBQUE7QUFBQSxRQUUvQyxhQUFhLEtBQUssSUFBSSxRQUFRLFFBQVEsZUFBZSxFQUFFO0FBQUE7QUFBQSxRQUV2RCxRQUFRLEtBQUssSUFBSSxRQUFRLFFBQVEsd0JBQXdCO0FBQUEsTUFDMUQsQ0FBQztBQUFBLElBQ0YsQ0FBQztBQUVELFVBQU0sZUFBZSxLQUFLO0FBQUEsTUFDekI7QUFBQSxNQUNBO0FBQUEsTUFDQSxDQUFDLFFBQW9CO0FBRXBCLFlBQUksdUJBQU8sbUJBQW1CO0FBQUEsTUFDL0I7QUFBQSxJQUNEO0FBRUEsaUJBQWEsU0FBUyx3QkFBd0I7QUFHOUMsVUFBTSxrQkFBa0IsS0FBSyxpQkFBaUI7QUFDOUMsb0JBQWdCLFFBQVEsaUJBQWlCO0FBRXpDLFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBNUh6QixZQUFBRSxLQUFBO0FBNkhJLGNBQU0sY0FBYyxLQUFLLElBQUksVUFBVSxjQUFjO0FBRXJELFlBQUksQ0FBQyxhQUFhO0FBQ2pCLGNBQUksdUJBQU8sZ0NBQWdDO0FBQzNDO0FBQUEsUUFDRDtBQUVBLGNBQU0sVUFDTCxNQUFBQSxNQUFBLElBQUksY0FBYyxhQUFhLFdBQVcsTUFBMUMsZ0JBQUFBLElBQTZDLGdCQUE3QyxtQkFDRztBQUVKLFlBQUksQ0FBQyxRQUFRO0FBQ1osY0FBSSx1QkFBTyxnQ0FBZ0M7QUFDM0M7QUFBQSxRQUNEO0FBRUEsY0FBTSxpQkFBaUIsTUFBTSxlQUFlO0FBQUEsVUFDM0MsYUFBYTtBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1I7QUFBQSxRQUNELENBQUM7QUFHRCxZQUFJLFVBQ0Ysa0JBQWtCLElBQUksVUFBVSxRQUFRLEtBQUssQ0FBQyxFQUM5QyxTQUFTLGNBQWM7QUFBQSxNQUMxQjtBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ3JCLFlBQUkscUJBQXFCLEtBQUssS0FBSyxLQUFLLFFBQVEsRUFBRSxLQUFLO0FBQUEsTUFDeEQ7QUFBQSxJQUNELENBQUM7QUFFRCxTQUFLO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxRQUFRLElBQUksUUFBUTtBQXBLOUIsWUFBQUEsS0FBQTtBQXFLSSxjQUFNLFFBQVEsU0FBUyxjQUFjLFFBQVE7QUFDN0MsY0FBTSxLQUFLO0FBQ1gsV0FBRyxZQUFZLEtBQUs7QUFFcEIsY0FBTSxVQUFVLFVBQU07QUFBQSxVQUNyQixJQUFJLE1BQU0sUUFBUSxZQUFZLElBQzdCO0FBQUEsUUFDRjtBQUVBLGNBQU0sT0FBTUEsTUFBQSxNQUFNLGtCQUFOLGdCQUFBQSxJQUFxQjtBQUNqQyxtQ0FBSztBQUNMLG1DQUFLLE1BQU0sUUFBUSxTQUFTO0FBQzVCLG1DQUFLO0FBRUwsY0FBTSxNQUFNLFFBQVE7QUFDcEIsY0FBTSxNQUFNLFlBQVk7QUFFeEIsY0FBTSxJQUFJLFNBQVMsZUFBZSxVQUFVO0FBRTVDLGdCQUFFLGtCQUFGLG1CQUFpQixpQkFBaUIsUUFBUSxNQUFNO0FBeExwRCxjQUFBQTtBQTBMSyxXQUFBQSxNQUFBLEVBQUUsa0JBQUYsZ0JBQUFBLElBQWlCLFlBQVksTUFBTTtBQUFBLFFBQ3BDO0FBQUEsTUFDRDtBQUFBLElBQ0Q7QUFHQSxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLGdCQUFnQixDQUFDLFFBQWdCLFNBQXVCO0FBQ3ZELGdCQUFRLElBQUksT0FBTyxhQUFhLENBQUM7QUFDakMsZUFBTyxpQkFBaUIsdUJBQXVCO0FBQUEsTUFDaEQ7QUFBQSxJQUNELENBQUM7QUFHRCxTQUFLLGNBQWMsSUFBSSxpQkFBaUIsS0FBSyxLQUFLLElBQUksQ0FBQztBQWF2RCxTQUFLLElBQUksVUFBVSxHQUFHLGFBQWEsTUFBTTtBQUN4QyxZQUFNLFdBQVcsS0FBSyxJQUFJLFVBQVUsY0FBYztBQUNsRCxVQUFJLENBQUM7QUFBVTtBQUVmLFVBQUksU0FBUyxjQUFjO0FBQzFCLGFBQUssSUFBSSxVQUFVO0FBQUEsVUFBYyxNQUNoQyxhQUFhLFVBQVUsSUFBSTtBQUFBLFFBQzVCO0FBQUEsZUFHQSxTQUFTLGNBQWMsUUFDdkIsU0FBUyxLQUFLO0FBQUEsUUFDYixLQUFLLFNBQVM7QUFBQSxNQUNmLEtBQ0EsQ0FBQyxTQUFTLEtBQUssU0FBUyxjQUFjLEdBQ3JDO0FBQ0QsZ0JBQVEsSUFBSSxlQUFlO0FBQzNCLGFBQUssSUFBSSxVQUFVLGNBQWMsTUFBTTtBQUN0Qyx1QkFBYSxRQUFRO0FBQUEsUUFDdEIsQ0FBQztBQUFBLE1BRUYsV0FDQyxTQUFTLGNBQWMsUUFDdkIsU0FBUyxLQUFLLFNBQVMsS0FBSyxTQUFTLHNCQUFzQixHQUMxRDtBQUNELGdCQUFRLElBQUksWUFBWTtBQUN4QixhQUFLLElBQUksVUFBVSxjQUFjLE1BQU07QUFDdEMsMEJBQWdCLFFBQVE7QUFBQSxRQUN6QixDQUFDO0FBQUEsTUFDRixXQUNDLFNBQVMsY0FBYyxRQUN2QixTQUFTLEtBQUssU0FBUyxjQUFjLEtBQ3JDLFNBQVMsYUFBYSxnQkFDckI7QUFDRCxnQkFBUSxJQUFJLHNCQUFzQjtBQUNsQywwQkFBa0IsVUFBVSxLQUFLLEdBQUc7QUFBQSxNQUNyQztBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssSUFBSSxVQUFVLEdBQUcsYUFBYSxPQUFPLFNBQVM7QUFDbEQsVUFBSSxDQUFDO0FBQU07QUFDWCxVQUFJLEtBQUssY0FBYyxNQUFNO0FBRTVCLGNBQU0sS0FBSyx1QkFBYyxXQUFXLEVBQUU7QUFDdEMsY0FBTSxRQUFRLENBQUMsR0FBRyxHQUFHLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUMsZ0JBQVEsSUFBSSxLQUFLO0FBQ2pCLFlBQUksQ0FBQztBQUFPO0FBQ1osY0FBTSxZQUFZLE9BQU8sUUFBUSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLE1BQU07QUFDMUQsaUJBQU8sS0FBSyxLQUFLLFNBQVMsS0FBSztBQUFBLFFBQ2hDLENBQUM7QUFFRCxZQUFJLGFBQWEsVUFBVSxDQUFDLEVBQUUsTUFBTSxTQUFTLGFBQWEsR0FBRztBQUM1RCxnQkFBTSxrQkFBa0IsTUFBTSxHQUFHO0FBQUEsUUFDbEM7QUFBQSxNQUNEO0FBQUEsSUFDRCxDQUFDO0FBRUQsVUFBTSxnQkFBeUMsQ0FBQztBQXlCaEQsU0FBSyxJQUFJLGNBQWMsR0FBRyxZQUFZLFlBQVk7QUFDakQsZUFBUyxJQUFJLEdBQUcsSUFBSSxjQUFjLFFBQVEsS0FBSztBQUM5QyxjQUFNLGNBQWMsQ0FBQyxFQUFFO0FBQUEsTUFDeEI7QUFBQSxJQUNELENBQUM7QUFBQSxFQUNGO0FBQUEsRUFFQSxXQUFXO0FBQUEsRUFBQztBQUFBLEVBRVosTUFBTSxlQUFlO0FBQ3BCLFNBQUssV0FBVyxPQUFPO0FBQUEsTUFDdEIsQ0FBQztBQUFBLE1BQ0Q7QUFBQSxNQUNBLE1BQU0sS0FBSyxTQUFTO0FBQUEsSUFDckI7QUFBQSxFQUNEO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbEM7QUFDRDtBQUVBLGVBQWUsYUFBYSxZQUFtQixRQUFrQjtBQUNoRSxRQUFNQyxPQUFNLHVCQUFjO0FBRTFCLFFBQU0sZ0JBQWdCLE1BQU1BLEtBQUksTUFBTSxLQUFLLFVBQVU7QUFDckQsUUFBTSxhQUFhLEtBQUssTUFBTSxhQUFhO0FBRTNDLE1BQUksV0FBVyxhQUFhO0FBQWtCO0FBRTlDLFFBQU0sUUFBUSxTQUFTLHVCQUF1QixhQUFhO0FBRTNELFFBQU0sS0FBSyxLQUFLLEVBQUUsUUFBUSxDQUFDLFNBQVM7QUFDbkMscUJBQWlCLElBQUk7QUFBQSxFQUN0QixDQUFDO0FBRUQsUUFBTSxRQUFRLFdBQVc7QUFFekIsUUFBTTtBQUFBLElBQ0wsQ0FDQyxNQUdBLFFBQ0k7QUFDSixVQUFJLENBQUMsS0FBSyxPQUFPO0FBQ2hCLG1CQUFXLE1BQU0sR0FBRyxFQUFFLFFBQVE7QUFBQSxNQUMvQjtBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBQ0EsUUFBTUEsS0FBSSxNQUFNLE9BQU8sWUFBWSxLQUFLLFVBQVUsVUFBVSxDQUFDO0FBRTdELFFBQU0sWUFBbUIsQ0FBQztBQUMxQixRQUFNLGlCQUVGLENBQUM7QUFDTCxRQUFNLFdBQVcsTUFBTTtBQUFBLElBQ3RCLFNBQVMsdUJBQXVCLG1CQUFtQjtBQUFBLEVBQ3BEO0FBQ0EsUUFBTSxRQUFRLENBQUMsTUFBVyxRQUFnQixZQUFZLE1BQU0sR0FBRyxDQUFDO0FBQ2hFLFFBQU1BLEtBQUksTUFBTSxPQUFPLFlBQVksS0FBSyxVQUFVLFVBQVUsQ0FBQztBQUU3RCxRQUFNLE1BQU0sTUFBTSx1QkFDaEIsV0FBVyxFQUNYLFNBQVMsTUFBTSxJQUFJLE9BQU8sU0FBUyx5QkFBeUI7QUFDOUQsTUFBSSxRQUFRLE9BQU8sTUFBVztBQUM3QixVQUFNLHVCQUNKLFdBQVcsRUFDWCxZQUFZLFdBQVcsRUFBRSxLQUFLLE1BQU07QUFBQSxNQUNwQyxFQUFFLE1BQU0sZUFBZSxTQUFTLEVBQUUsT0FBTyxHQUFHLEVBQUU7QUFBQSxJQUMvQyxDQUFDO0FBQUEsRUFDSCxDQUFDO0FBR0QsU0FBTyxRQUFRLGNBQWMsRUFBRSxRQUFRLE9BQU8sQ0FBQyxNQUFNLFdBQVcsTUFBTTtBQUNyRSxVQUFNLFlBQVlBLEtBQUksY0FBYyxTQUFTLElBQUk7QUFDakQsUUFDQyxhQUNBLFVBQVUsZUFDVixVQUFVLFlBQVksYUFDckI7QUFDRCxZQUFNLHVCQUFjLFdBQVcsRUFBRSxZQUFZLFdBQVcsTUFBTTtBQUFBLFFBQzdEO0FBQUEsVUFDQyxNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsWUFDUixPQUFPLFlBQ0wsSUFBSSxDQUFDLE1BQWM7QUFBQSxLQUFRLEVBQUUsS0FBSyxHQUFHLEVBQ3JDLEtBQUssRUFBRTtBQUFBLFVBQ1Y7QUFBQSxRQUNEO0FBQUEsTUFDRCxDQUFDO0FBQUEsSUFDRjtBQUFBLEVBQ0QsQ0FBQztBQUVELGlCQUFlLGlCQUFpQixNQUFlO0FBdlloRCxRQUFBRDtBQXdZRSxRQUFJLFVBQVU7QUFFZCxRQUFJLEtBQUssVUFBVSxTQUFTLG1CQUFtQjtBQUFHLGdCQUFVO0FBRzVELFNBQUssVUFBVSxJQUFJLHVCQUF1QjtBQUMxQyxVQUFNLGdCQUFlQSxNQUFBLEtBQUssV0FBVyxDQUFDLE1BQWpCLGdCQUFBQSxJQUFvQixXQUFXO0FBQ3BELFVBQU0sYUFBYSxLQUFLLFdBQVcsQ0FBQztBQUVwQyxVQUFNLFdBQVcsVUFDZCx5Q0FBWSxjQUNaLDZDQUFjO0FBRWpCLFFBQUksQ0FBQztBQUFVO0FBRWYsVUFBTSxXQUFXQyxLQUFJLGNBQWMscUJBQXFCLFVBQVUsRUFBRTtBQUVwRSxRQUFJLENBQUM7QUFBVTtBQUVmLFFBQUksS0FBSyxVQUFVLFNBQVMsc0JBQXNCO0FBQUc7QUFDckQsV0FBTyxpQkFBaUIsTUFBcUIsWUFBWSxNQUFNO0FBQzlELFVBQUksWUFBWSxTQUFTLGNBQWMsTUFBTTtBQUM1QyxRQUFBQSxLQUFJLFVBQVUsYUFBYSxTQUFTLE1BQU0sSUFBSSxJQUFJO0FBQUEsTUFDbkQ7QUFBQSxJQUNELENBQUM7QUFFRCxTQUFLLFVBQVUsSUFBSSxzQkFBc0I7QUFFekMsUUFBSSxTQUFTO0FBRWIsYUFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLE1BQU0sUUFBUSxLQUFLO0FBQ2pELFVBQ0MsV0FBVyxNQUFNLENBQUMsRUFBRSxVQUFVLFlBQzlCLFdBQVcsTUFBTSxDQUFDLEVBQUUsVUFBUyxxQ0FBVSxPQUN0QztBQUNELGlCQUFTO0FBQ1QsbUJBQVcsTUFBTSxDQUFDLEVBQUUsT0FBTyxxQ0FBVTtBQUNyQztBQUFBLE1BQ0Q7QUFBQSxJQUNEO0FBQ0EsY0FDRSxNQUFNQSxLQUFJLE1BQU0sT0FBTyxZQUFZLEtBQUssVUFBVSxVQUFVLENBQUM7QUFHL0QsUUFBSSxTQUFTO0FBQ1osYUFBTztBQUFBLFFBQWlCO0FBQUEsUUFBMkI7QUFBQSxRQUFZLE1BQzlELGlCQUFpQixJQUFJO0FBQUEsTUFDdEI7QUFBQSxJQUNELE9BQU87QUFDTixhQUFPO0FBQUEsUUFDTjtBQUFBLFFBQ0E7QUFBQSxRQUNBLE1BQU0saUJBQWlCLElBQUk7QUFBQSxNQUM1QjtBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBRUEsaUJBQWUsWUFDZCxVQU9BLE9BQ0M7QUExY0gsUUFBQUQsS0FBQTtBQTJjRSxVQUFNLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRSxLQUFLLENBQUNFLFVBQVM7QUEzY25ELFVBQUFGO0FBNGNHLGFBQ0MsU0FBUyxZQUFVQSxNQUFBRSxNQUFLLFdBQVcsQ0FBQyxNQUFqQixnQkFBQUYsSUFBb0IsZ0JBQ3ZDLENBQUMsVUFBVSxTQUFTRSxLQUFJO0FBQUEsSUFFMUIsQ0FBQztBQUVELFFBQUksQ0FBQztBQUFNO0FBSVgsVUFBTSxZQUFXRixNQUFBLEtBQUssV0FBVyxDQUFDLE1BQWpCLGdCQUFBQSxJQUFvQjtBQUVyQyxRQUFJLENBQUMsWUFBWSxTQUFTLFVBQVUsR0FBRztBQUN0QyxpQkFBVyxNQUFNLEtBQUssRUFBRSxRQUFRO0FBQ2hDO0FBQUEsSUFDRDtBQUVBLFFBQUksWUFBWTtBQUVoQixXQUFPLFFBQVFDLEtBQUksTUFBTSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUMsTUFBTSxJQUFJLE1BQU07QUFDM0QsVUFBSSxLQUFLLFNBQVMsS0FBSyxHQUFHO0FBQ3pCLFlBQ0MsS0FBSyxTQUNILFlBQVksRUFDWixTQUFTLHFDQUFVLGFBQWEsS0FDbEMsS0FBSyxTQUFTLFNBQVMsVUFBVSxRQUNoQztBQUNELHNCQUFZLEtBQUs7QUFBQSxRQUNsQjtBQUFBLE1BQ0Q7QUFBQSxJQUNELENBQUM7QUFFRCxVQUFNLFdBQVcsV0FDZEEsS0FBSSxjQUFjLHFCQUFxQixXQUFXLEVBQUUsSUFDcEQ7QUFFSCxRQUFJLENBQUMsWUFBWSxTQUFTLGNBQWM7QUFBTTtBQUU5QyxRQUFJLENBQUMsS0FBSyxVQUFVLFNBQVMsc0JBQXNCLEdBQUc7QUFDckQsYUFBTyxpQkFBaUIsTUFBcUIsWUFBWSxNQUFNO0FBQzlELFFBQUFBLEtBQUksVUFBVSxhQUFhLFNBQVMsTUFBTSxJQUFJLElBQUk7QUFBQSxNQUNuRCxDQUFDO0FBRUQsV0FBSyxVQUFVLElBQUksc0JBQXNCO0FBQUEsSUFDMUM7QUFHQSxVQUFNLFdBQVcsV0FBVyxNQUFNLEtBQUssQ0FBQyxTQUFjO0FBQ3JELGFBQU8sS0FBSyxPQUFPLFNBQVM7QUFBQSxJQUM3QixDQUFDLEVBQUU7QUFDSCxVQUFNLFNBQVMsV0FBVyxNQUFNLEtBQUssQ0FBQyxTQUFjO0FBQ25ELGFBQU8sS0FBSyxPQUFPLFNBQVM7QUFBQSxJQUM3QixDQUFDLEVBQUU7QUFHSCxVQUFNLFdBQVdBLEtBQUksY0FBYyxxQkFBcUIsVUFBVSxFQUFFO0FBQ3BFLFVBQU1FLFVBQVNGLEtBQUksY0FBYyxxQkFBcUIsUUFBUSxFQUFFO0FBR2hFLFVBQU0sa0JBQWlCLFdBQUFBLEtBQUksY0FBYyxhQUFhLFFBQWUsTUFBOUMsbUJBQ3BCLGdCQURvQixtQkFDUDtBQUNoQixVQUFNLGdCQUFlLFdBQUFBLEtBQUksY0FBYyxhQUFhRSxPQUFhLE1BQTVDLG1CQUNsQixnQkFEa0IsbUJBQ0w7QUFFaEIsUUFBSSxVQUFVO0FBRWIsWUFBTSxnQkFBZ0JGLEtBQUksY0FBYyxTQUFTLFNBQVMsSUFBSTtBQUM5RCxVQUNDLGlCQUNBLGNBQWMsZUFDZCxjQUFjLFlBQVksYUFDekI7QUFDRCxZQUFJLENBQUMsZUFBZSxTQUFTLElBQUksR0FBRztBQUNuQyx5QkFBZSxTQUFTLElBQUksSUFBSSxDQUFDO0FBQUEsUUFDbEM7QUFDQSx1QkFBZSxTQUFTLElBQUksRUFBRTtBQUFBLFVBQzdCLEdBQUcsc0JBQXNCO0FBQUEsUUFDMUI7QUFBQSxNQUNEO0FBQUEsSUFDRDtBQUVBLGVBQVcsTUFBTSxLQUFLLEVBQUUsUUFBUSxTQUFTO0FBQ3pDLGNBQVUsS0FBSyxJQUFJO0FBQUEsRUFDcEI7QUFDRDtBQUVBLGVBQWUsYUFBYSxNQUFhO0FBbGlCekMsTUFBQUQsS0FBQTtBQW1pQkMsTUFBSSxDQUFDO0FBQU07QUFFWCxRQUFNLEVBQUUsWUFBWSxJQUFJLHVCQUFjLFdBQVc7QUFDakQsUUFBTSxVQUFTLE1BQUFBLE1BQUEsSUFBSSxjQUFjLGFBQWEsSUFBSSxNQUFuQyxnQkFBQUEsSUFBc0MsZ0JBQXRDLG1CQUFtRDtBQUNsRSxRQUFNLFNBQVEsZUFBSSxjQUFjLGFBQWEsSUFBSSxNQUFuQyxtQkFBc0MsZ0JBQXRDLG1CQUFtRDtBQUVqRSxRQUFNLFlBQVksV0FBVyxNQUFNO0FBQUEsSUFDbEM7QUFBQSxNQUNDLE1BQU07QUFBQSxNQUNOLFNBQVM7QUFBQSxRQUNSLE9BQ0MsU0FDQSxPQUNDLE1BQU0sQ0FBQyxJQUNMLE1BQU0sQ0FBQyxFQUFFLFlBQVksRUFBRSxLQUFLLElBQzVCLEtBQUssU0FDSixRQUFRLGNBQWMsRUFBRSxFQUN4QixZQUFZLEVBQ1osS0FBSyxFQUNMLFFBQVEsTUFBTSxHQUFHO0FBQUEsTUFDdkI7QUFBQSxJQUNEO0FBQUEsRUFDRCxDQUFDO0FBRUQsTUFBSSxRQUFRO0FBRVosaUJBQWUsd0JBQXdCLFFBQWU7QUFDckQsUUFBSSxXQUFXO0FBQU07QUFFckIsWUFBUSxJQUFJLCtCQUErQixLQUFLO0FBRWhELFlBQVEsT0FBTztBQUFBLE1BQ2QsS0FBSztBQUNKLGNBQU0sT0FBTyxNQUFNLG1CQUFtQixJQUFJO0FBQzFDLGNBQU0sMkJBQTJCLE1BQU0sZ0JBQWdCLElBQUk7QUFDM0Q7QUFBQSxNQUNELEtBQUs7QUFDSixjQUFNLE9BQU8sTUFBTSxXQUFXLElBQUk7QUFDbEMsY0FBTSwyQkFBMkIsTUFBTSxTQUFTLElBQUk7QUFDcEQ7QUFBQSxNQUVELEtBQUs7QUFDSixjQUFNLE9BQU8sTUFBTSxnQkFBZ0IsSUFBSTtBQUN2QyxjQUFNLDJCQUEyQixNQUFNLGNBQWMsSUFBSTtBQUN6RDtBQUFBLE1BRUQ7QUFDQztBQUFBLElBQ0Y7QUFDQTtBQUVBLFFBQUksUUFBUTtBQUNYLFVBQUksY0FBYyxJQUFJLFdBQVcsdUJBQXVCO0FBQUEsRUFDMUQ7QUFFQSxNQUFJLGNBQWMsR0FBRyxXQUFXLHVCQUF1QjtBQUN4RDtBQUVBLGVBQWUsZ0JBQWdCLE1BQWE7QUE3bEI1QyxNQUFBQTtBQThsQkMsUUFBTSxFQUFFLGVBQWUsTUFBTSxJQUFJO0FBQ2pDLFFBQU0sTUFBS0EsTUFBQSxjQUFjLGFBQWEsSUFBSSxNQUEvQixnQkFBQUEsSUFBa0M7QUFJN0MsTUFBSSxDQUFDLEdBQUc7QUFBTTtBQUVkLE1BQUksR0FBRyxLQUFLLFNBQVMsWUFBWSxHQUFHO0FBQ25DLFVBQU0sY0FBYyxNQUFNLEtBQUssUUFBRztBQUFBLEVBQ25DLE9BQU87QUFDTixVQUFNLG1CQUFtQixNQUFNLEtBQUssUUFBRztBQUFBLEVBQ3hDO0FBQ0EsTUFBSSxHQUFHLEtBQUssU0FBUyxZQUFZLEdBQUc7QUFDbkMsVUFBTSxjQUFjLE1BQU0sS0FBSyxpQkFBSztBQUFBLEVBQ3JDLE9BQU87QUFDTixVQUFNLG1CQUFtQixNQUFNLEtBQUssaUJBQUs7QUFBQSxFQUMxQztBQUNBLE1BQUksR0FBRyxLQUFLLFNBQVMsVUFBVSxHQUFHO0FBQ2pDLFVBQU0sY0FBYyxNQUFNLEtBQUssV0FBSTtBQUFBLEVBQ3BDLE9BQU87QUFDTixVQUFNLG1CQUFtQixNQUFNLEtBQUssV0FBSTtBQUFBLEVBQ3pDO0FBQ0Q7QUFFQSxlQUFlLGtCQUFrQixNQUFhQyxNQUFVO0FBdG5CeEQsTUFBQUQsS0FBQTtBQTJuQkMsUUFBTSxFQUFFLGVBQWUsTUFBTSxJQUFJQztBQUNqQyxRQUFNLFlBQVcsTUFBQUQsTUFBQSxjQUFjLGFBQWEsSUFBSSxNQUEvQixnQkFBQUEsSUFBa0MsYUFBbEMsWUFBOEMsQ0FBQztBQUNoRSxNQUFJLE9BQU8sTUFBTSxNQUFNLFdBQVcsSUFBSTtBQUl0QyxRQUFNLE9BQU8sU0FBUztBQUFBLElBQ3JCLENBQUMsRUFBRSxRQUFRLE1BQW9CLFlBQVk7QUFBQSxFQUM1QztBQUVBLFFBQU0sT0FBTyxTQUFTO0FBQUEsSUFDckIsQ0FBQyxFQUFFLFFBQVEsTUFBb0IsWUFBWTtBQUFBLEVBQzVDO0FBQ0EsTUFBSSxTQUFTLElBQUk7QUFDaEIsV0FBTztBQUVQLFVBQU0sV0FBVyxNQUFNQyxJQUFHO0FBQUEsRUFDM0IsT0FBTztBQUNOLFdBQU8sS0FDTCxNQUFNLElBQUksRUFDVjtBQUFBLE1BQ0EsU0FBUyxJQUFJLEVBQUUsU0FBUyxNQUFNLE9BQU87QUFBQSxPQUNyQywwQkFBUyxPQUFPLENBQUMsTUFBakIsbUJBQW9CLGFBQXBCLG1CQUE4QixVQUE5QixtQkFBcUM7QUFBQSxJQUN0QyxFQUNDLEtBQUssSUFBSSxFQUNULEtBQUs7QUFFUCxRQUFJLFNBQVMsSUFBSTtBQUNoQixZQUFNLFdBQVcsTUFBTUEsSUFBRztBQUFBLElBQzNCLE9BQU87QUFDTixZQUFNLGNBQWMsTUFBTUEsSUFBRztBQUFBLElBQzlCO0FBQUEsRUFDRDtBQUVBLFFBQU0sUUFBUSxNQUFNLE1BQU0sV0FBVyxJQUFJO0FBQ3pDLFFBQU0sU0FBUztBQUFBLElBQ2QsSUFBSSxLQUFLLFNBQVMsUUFBUSxjQUFjLEVBQUUsRUFBRSxLQUFLO0FBQUEsSUFDakQsYUFBYSxNQUNYLE1BQU0sSUFBSSxFQUNWO0FBQUEsTUFDQSxTQUFTLElBQUksRUFBRSxTQUFTLE1BQU0sT0FBTztBQUFBLE9BQ3JDLDBCQUFTLE9BQU8sQ0FBQyxNQUFqQixtQkFBb0IsYUFBcEIsbUJBQThCLFVBQTlCLG1CQUFxQztBQUFBLElBQ3RDLEVBQ0MsS0FBSyxJQUFJLEVBQ1QsS0FBSztBQUFBLElBQ1AsUUFBUSxNQUNOLE1BQU0sSUFBSSxFQUNWO0FBQUEsTUFDQSxTQUFTLElBQUksRUFBRSxTQUFTLE1BQU0sT0FBTztBQUFBLE9BQ3JDLDBCQUFTLE9BQU8sQ0FBQyxNQUFqQixtQkFBb0IsYUFBcEIsbUJBQThCLFVBQTlCLG1CQUFxQztBQUFBLElBQ3RDLEVBQ0MsS0FBSyxJQUFJLEVBQ1QsS0FBSztBQUFBLElBQ1AsU0FDQywrQkFBYyxhQUFhLElBQUksTUFBL0IsbUJBQWtDLGdCQUFsQyxtQkFBK0MsV0FBL0MsWUFDQTtBQUFBLEVBQ0Y7QUFFQSxXQUFTLFFBQVEsSUFBSSxFQUFFLEtBQUssT0FBTyxRQUFRO0FBQzFDLFVBQU0sT0FBTyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUk7QUFHdkMsVUFBTSxTQUFTLE1BQU0sb0JBQW9CLEdBQUc7QUFDNUMsVUFBTSxFQUFFLFlBQVksSUFBSSx1QkFBYyxXQUFXO0FBQ2pELFlBQVEsSUFBSSxNQUFNO0FBRWxCLFFBQUksaUNBQVEsU0FBUyxRQUFRO0FBQzVCLFlBQU0sVUFBVSxLQUFLO0FBQUEsUUFDcEIsTUFBTSxXQUFXLE1BQU0sVUFBVTtBQUFBLFFBQ2pDO0FBQUEsTUFDRDtBQUNBLFlBQU0sS0FBSyxJQUFJLE1BQU0sT0FBTyxNQUFNLE9BQU87QUFDekMsWUFBTSxTQUFTLE1BQU0sS0FBSyxHQUFHO0FBRTdCLFlBQU1BLEtBQUksTUFBTSxPQUFPLE1BQU0sVUFBVSxHQUFHLFFBQVE7QUFFbEQsa0JBQVksV0FBVyxNQUFNO0FBQUEsUUFDNUI7QUFBQSxVQUNDLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxZQUNSLE9BQU87QUFBQSxVQUNSO0FBQUEsUUFDRDtBQUFBLFFBQ0E7QUFBQSxVQUNDLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxZQUNSLE9BQU8sT0FBTztBQUFBLGNBQ2IsT0FBTyxRQUFRLElBQUksSUFBSTtBQUFBLGNBQ3ZCLE9BQU8sUUFBUSxJQUFJO0FBQUEsWUFDcEI7QUFBQSxVQUNEO0FBQUEsUUFDRDtBQUFBLE1BQ0QsQ0FBQztBQUFBLElBQ0YsT0FBTztBQUNOLFlBQU0sWUFBWSxNQUFNLEtBQUssR0FBRztBQUNoQyxZQUFNLEtBQUssSUFBSSxNQUFNO0FBQUEsUUFDcEI7QUFBQSxRQUNBLEtBQUssUUFBUSxNQUFNLFdBQVcsTUFBTSxVQUFVLEdBQUcsRUFBRTtBQUFBLE1BQ3BEO0FBRUEsa0JBQVksV0FBVyxNQUFNO0FBQUEsUUFDNUI7QUFBQSxVQUNDLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxZQUNSLE9BQU87QUFBQSxVQUNSO0FBQUEsUUFDRDtBQUFBLFFBQ0E7QUFBQSxVQUNDLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxZQUNSLE9BQU87QUFBQSxVQUNSO0FBQUEsUUFDRDtBQUFBLE1BQ0QsQ0FBQztBQUFBLElBQ0Y7QUFBQSxFQUNELENBQUM7QUFFRCxRQUFNLElBQUksUUFBUSxDQUFDLFlBQVksV0FBVyxTQUFTLEdBQUksQ0FBQztBQUd6RDtBQUVBLElBQU0sdUJBQU4sY0FBbUMsc0JBQU07QUFBQSxFQUV4QyxZQUFZQSxNQUFVLFVBQTRCO0FBQ2pELFVBQU1BLElBQUc7QUFDVCxTQUFLLFdBQVc7QUFBQSxFQUNqQjtBQUFBLEVBRUEsU0FBUztBQUNSLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsVUFBTUEsT0FBTSxLQUFLO0FBQ2pCLFVBQU0sY0FBYyxLQUFLLElBQUksVUFBVSxjQUFjO0FBRXJELGNBQVUsWUFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVdEIsVUFBTSxTQUFTLFVBQVUsY0FBYyxtQkFBbUI7QUFDMUQsVUFBTSxRQUFRLFVBQVU7QUFBQSxNQUN2QjtBQUFBLElBQ0Q7QUFDQSxVQUFNLGNBQWMsVUFBVTtBQUFBLE1BQzdCO0FBQUEsSUFDRDtBQUVBLFVBQU0sWUFBVywyQ0FBYSxlQUFjO0FBRTVDLG1CQUFlLGVBQWU7QUFDN0IsVUFBSSxDQUFDLE1BQU07QUFBTztBQUNsQixZQUFNLE9BQU8sTUFBTTtBQUVuQixVQUFJLENBQUMsYUFBYTtBQUNqQixZQUFJLHVCQUFPLGdDQUFnQztBQUMzQztBQUFBLE1BQ0Q7QUFDQSxVQUFJLFdBQVcsWUFBWSxLQUFLLE1BQU0sWUFBWSxJQUFJLEVBQUUsQ0FBQztBQUN6RCxVQUFJLFVBQVU7QUFDYixtQkFBVyxLQUFLLFNBQVM7QUFBQSxNQUMxQjtBQUVBLFlBQU0sZUFBZSxNQUFNLGFBQWE7QUFBQSxRQUN2QyxRQUFRO0FBQUEsUUFDUixNQUFNO0FBQUEsUUFDTixVQUFVO0FBQUEsTUFDWCxDQUFDO0FBRUQsWUFBTSxtQkFBbUI7QUFBQSxRQUN4QixNQUFNO0FBQUEsUUFDTixhQUFhLFlBQVk7QUFBQSxNQUMxQixDQUFDO0FBR0QsTUFBQUEsS0FBSSxVQUNGLGtCQUFrQkEsS0FBSSxVQUFVLFFBQVEsQ0FBQyxFQUN6QyxTQUFTLFlBQVk7QUFFdkIsV0FBSyxNQUFNO0FBQUEsSUFDWjtBQUVBLHFDQUFRLGlCQUFpQixTQUFTLGFBQWEsS0FBSyxJQUFJO0FBQ3hELGNBQVUsaUJBQWlCLFlBQVksQ0FBQyxNQUFNO0FBQzdDLFVBQUksRUFBRSxRQUFRLFNBQVM7QUFDdEIscUJBQWEsS0FBSyxJQUFJLEVBQUU7QUFBQSxNQUN6QjtBQUFBLElBQ0QsQ0FBQztBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDVCxVQUFNLEVBQUUsVUFBVSxJQUFJO0FBQ3RCLGNBQVUsTUFBTTtBQUFBLEVBQ2pCO0FBQ0Q7QUFFQSxJQUFNLG1CQUFOLGNBQStCLGlDQUFpQjtBQUFBLEVBRy9DLFlBQVlBLE1BQVUsUUFBa0I7QUFDdkMsVUFBTUEsTUFBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2Y7QUFBQSxFQUVBLFVBQWdCO0FBQ2YsVUFBTSxFQUFFLFlBQVksSUFBSTtBQUV4QixnQkFBWSxNQUFNO0FBRWxCLFFBQUksd0JBQVEsV0FBVyxFQUNyQixRQUFRLFlBQVksRUFDcEIsUUFBUSxlQUFlLEVBQ3ZCO0FBQUEsTUFBUSxDQUFDLFNBQ1QsS0FDRSxlQUFlLG1CQUFtQixFQUNsQyxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsYUFBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxjQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsTUFDaEMsQ0FBQztBQUFBLElBQ0g7QUFFRCxRQUFJLHdCQUFRLFdBQVcsRUFDckIsUUFBUSw0QkFBNEIsRUFDcEMsUUFBUSxzREFBc0QsRUFDOUQ7QUFBQSxNQUFRLENBQUMsU0FDVCxLQUNFLGVBQWUsdUJBQXVCLEVBQ3RDLFNBQVMsa0JBQWtCLEVBQzNCLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGFBQUssT0FBTyxTQUFTLDRCQUE0QjtBQUNqRCxjQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsTUFDaEMsQ0FBQztBQUFBLElBQ0g7QUFHRCxRQUFJLHdCQUFRLFdBQVcsRUFDckIsUUFBUSxtQkFBbUIsRUFDM0IsUUFBUSx1Q0FBdUMsRUFDL0M7QUFBQSxNQUFRLENBQUMsU0FDVCxLQUNFLGVBQWUsdUJBQXVCLEVBQ3RDLFNBQVMsdUJBQXVCLEVBQ2hDLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGFBQUssT0FBTyxTQUFTLGlDQUNwQjtBQUNELGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxNQUNoQyxDQUFDO0FBQUEsSUFDSDtBQUdELFFBQUksd0JBQVEsV0FBVyxFQUNyQixRQUFRLHdCQUF3QixFQUNoQyxRQUFRLDRDQUE0QyxFQUNwRDtBQUFBLE1BQVEsQ0FBQyxTQUNULEtBQ0UsZUFBZSx1QkFBdUIsRUFDdEMsU0FBUyxlQUFlLEVBQ3hCLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGFBQUssT0FBTyxTQUFTLHlCQUF5QjtBQUM5QyxjQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsTUFDaEMsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQ0Q7IiwKICAibmFtZXMiOiBbIkNvbmZpZ3VyYXRpb24iLCAiX2EiLCAiQmFzZUFQSSIsICJSZXNwb25zZUVycm9yIiwgIkZldGNoRXJyb3IiLCAiUmVxdWlyZWRFcnJvciIsICJKU09OQXBpUmVzcG9uc2UiLCAiVm9pZEFwaVJlc3BvbnNlIiwgIkJsb2JBcGlSZXNwb25zZSIsICJUZXh0QXBpUmVzcG9uc2UiLCAiSW5kZXhPcGVyYXRpb25zQXBpIiwgIl9hIiwgIlZlY3Rvck9wZXJhdGlvbnNBcGkiLCAiX2EiLCAiQmFzZVBpbmVjb25lRXJyb3IiLCAiUGluZWNvbmVDb25maWd1cmF0aW9uRXJyb3IiLCAiUGluZWNvbmVVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsICJQaW5lY29uZUVudmlyb25tZW50VmFyc05vdFN1cHBvcnRlZEVycm9yIiwgIlBpbmVjb25lVW5rbm93blJlcXVlc3RGYWlsdXJlIiwgIlBpbmVjb25lQmFkUmVxdWVzdEVycm9yIiwgIlBpbmVjb25lQXV0aG9yaXphdGlvbkVycm9yIiwgIlBpbmVjb25lTm90Rm91bmRFcnJvciIsICJQaW5lY29uZUNvbmZsaWN0RXJyb3IiLCAiUGluZWNvbmVJbnRlcm5hbFNlcnZlckVycm9yIiwgIlBpbmVjb25lTm90SW1wbGVtZW50ZWRFcnJvciIsICJQaW5lY29uZVVubWFwcGVkSHR0cEVycm9yIiwgIlBpbmVjb25lQ29ubmVjdGlvbkVycm9yIiwgIlBpbmVjb25lQXJndW1lbnRFcnJvciIsICJfYSIsICJfYSIsICJQaW5lY29uZUJhdGNoVXBzZXJ0RXJyb3IiLCAiX2EiLCAiVXNlZFZhbHVlU3RhdGUiLCAiX2EiLCAiX2EiLCAic2VsZiIsICJUeXBlIiwgImFkZEVycm9yIiwgInNlbGYiLCAiX2EiLCAiRGF0YVR5cGUiLCAiX2EiLCAic2VsZiIsICJtb2R1bGUiLCAibW9kdWxlIiwgImJhc2VJZCIsICJzZWxmIiwgIl9hIiwgIm1vZHVsZSIsICJtZXJnZSIsICJzZXRzIiwgImxlbmd0aCIsICJzbGljZSIsICJ4bCIsICJ4IiwgImpvaW4iLCAic3ViZXhwIiwgInN0ciIsICJ0eXBlT2YiLCAibyIsICJ1bmRlZmluZWQiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNwbGl0IiwgInBvcCIsICJzaGlmdCIsICJ0b0xvd2VyQ2FzZSIsICJ0b1VwcGVyQ2FzZSIsICJ0b0FycmF5IiwgIm9iaiIsICJBcnJheSIsICJzZXRJbnRlcnZhbCIsICJhc3NpZ24iLCAidGFyZ2V0IiwgInNvdXJjZSIsICJrZXkiLCAiYnVpbGRFeHBzIiwgImlzSVJJIiwgIkFMUEhBJCQiLCAiQ1IkIiwgIkRJR0lUJCQiLCAiRFFVT1RFJCQiLCAiSEVYRElHJCQiLCAiU1AkJCIsICJQQ1RfRU5DT0RFRCQiLCAiU1VCX0RFTElNUyQkIiwgIlJFU0VSVkVEJCQiLCAiR0VOX0RFTElNUyQkIiwgIlVDU0NIQVIkJCIsICJTQ0hFTUUkIiwgIlVTRVJJTkZPJCIsICJVTlJFU0VSVkVEJCQiLCAiREVDX09DVEVUJCIsICJERUNfT0NURVRfUkVMQVhFRCQiLCAiSDE2JCIsICJMUzMyJCIsICJJUFY0QUREUkVTUyQiLCAiSVBWNkFERFJFU1MxJCIsICJJUFY2QUREUkVTUzIkIiwgIklQVjZBRERSRVNTMyQiLCAiSVBWNkFERFJFU1M0JCIsICJJUFY2QUREUkVTUzUkIiwgIklQVjZBRERSRVNTNiQiLCAiSVBWNkFERFJFU1M3JCIsICJJUFY2QUREUkVTUzgkIiwgIklQVjZBRERSRVNTOSQiLCAiWk9ORUlEJCIsICJJUFY2QUREUkVTUyQiLCAiSVBfTElURVJBTCQiLCAiSVBWNkFERFJaX1JFTEFYRUQkIiwgIklQVkZVVFVSRSQiLCAiSE9TVCQiLCAiUkVHX05BTUUkIiwgIlBPUlQkIiwgIkFVVEhPUklUWSQiLCAiUENIQVIkIiwgIlNFR01FTlQkIiwgIlNFR01FTlRfTlokIiwgIlNFR01FTlRfTlpfTkMkIiwgIlBBVEhfQUJFTVBUWSQiLCAiUEFUSF9BQlNPTFVURSQiLCAiUEFUSCQiLCAiUEFUSF9OT1NDSEVNRSQiLCAiUEFUSF9ST09UTEVTUyQiLCAiUEFUSF9FTVBUWSQiLCAiUVVFUlkkIiwgIklQUklWQVRFJCQiLCAiRlJBR01FTlQkIiwgIkhJRVJfUEFSVCQiLCAiVVJJJCIsICJSRUxBVElWRV9QQVJUJCIsICJSRUxBVElWRSQiLCAiVVJJX1JFRkVSRU5DRSQiLCAiQUJTT0xVVEVfVVJJJCIsICJHRU5FUklDX1JFRiQiLCAiUkVMQVRJVkVfUkVGJCIsICJBQlNPTFVURV9SRUYkIiwgIlNBTUVET0NfUkVGJCIsICJBVVRIT1JJVFlfUkVGJCIsICJSZWdFeHAiLCAibWF4SW50IiwgImJhc2UiLCAidE1pbiIsICJ0TWF4IiwgInNrZXciLCAiZGFtcCIsICJpbml0aWFsQmlhcyIsICJpbml0aWFsTiIsICJkZWxpbWl0ZXIiLCAicmVnZXhQdW55Y29kZSIsICJyZWdleE5vbkFTQ0lJIiwgInJlZ2V4U2VwYXJhdG9ycyIsICJlcnJvcnMiLCAiYmFzZU1pbnVzVE1pbiIsICJmbG9vciIsICJNYXRoIiwgInN0cmluZ0Zyb21DaGFyQ29kZSIsICJTdHJpbmciLCAiZnJvbUNoYXJDb2RlIiwgImVycm9yIiwgInR5cGUiLCAiUmFuZ2VFcnJvciIsICJtYXAiLCAiYXJyYXkiLCAiZm4iLCAicmVzdWx0IiwgIm1hcERvbWFpbiIsICJzdHJpbmciLCAicGFydHMiLCAicmVwbGFjZSIsICJsYWJlbHMiLCAiZW5jb2RlZCIsICJ1Y3MyZGVjb2RlIiwgIm91dHB1dCIsICJjb3VudGVyIiwgInZhbHVlIiwgImNoYXJDb2RlQXQiLCAiZXh0cmEiLCAicHVzaCIsICJ1Y3MyZW5jb2RlIiwgImZyb21Db2RlUG9pbnQiLCAiYmFzaWNUb0RpZ2l0IiwgImNvZGVQb2ludCIsICJkaWdpdFRvQmFzaWMiLCAiZGlnaXQiLCAiZmxhZyIsICJhZGFwdCIsICJkZWx0YSIsICJudW1Qb2ludHMiLCAiZmlyc3RUaW1lIiwgImsiLCAiZGVjb2RlIiwgImlucHV0IiwgImlucHV0TGVuZ3RoIiwgImkiLCAibiIsICJiaWFzIiwgImJhc2ljIiwgImxhc3RJbmRleE9mIiwgImoiLCAiaW5kZXgiLCAib2xkaSIsICJ3IiwgInQiLCAiYmFzZU1pbnVzVCIsICJvdXQiLCAic3BsaWNlIiwgImVuY29kZSIsICJjdXJyZW50VmFsdWUiLCAiYmFzaWNMZW5ndGgiLCAiaGFuZGxlZENQQ291bnQiLCAibSIsICJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCAicSIsICJxTWludXNUIiwgInRvVW5pY29kZSIsICJ0ZXN0IiwgInRvQVNDSUkiLCAicHVueWNvZGUiLCAiU0NIRU1FUyIsICJwY3RFbmNDaGFyIiwgImNociIsICJjIiwgImUiLCAicGN0RGVjQ2hhcnMiLCAibmV3U3RyIiwgImlsIiwgInBhcnNlSW50IiwgInN1YnN0ciIsICJjMiIsICJjMyIsICJfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmciLCAiY29tcG9uZW50cyIsICJwcm90b2NvbCIsICJkZWNvZGVVbnJlc2VydmVkIiwgImRlY1N0ciIsICJtYXRjaCIsICJVTlJFU0VSVkVEIiwgInNjaGVtZSIsICJQQ1RfRU5DT0RFRCIsICJOT1RfU0NIRU1FIiwgInVzZXJpbmZvIiwgIk5PVF9VU0VSSU5GTyIsICJob3N0IiwgIk5PVF9IT1NUIiwgInBhdGgiLCAiTk9UX1BBVEgiLCAiTk9UX1BBVEhfTk9TQ0hFTUUiLCAicXVlcnkiLCAiTk9UX1FVRVJZIiwgImZyYWdtZW50IiwgIk5PVF9GUkFHTUVOVCIsICJfc3RyaXBMZWFkaW5nWmVyb3MiLCAiX25vcm1hbGl6ZUlQdjQiLCAibWF0Y2hlcyIsICJJUFY0QUREUkVTUyIsICJhZGRyZXNzIiwgIl9ub3JtYWxpemVJUHY2IiwgIklQVjZBRERSRVNTIiwgInpvbmUiLCAicmV2ZXJzZSIsICJsYXN0IiwgImZpcnN0IiwgImZpcnN0RmllbGRzIiwgImxhc3RGaWVsZHMiLCAiaXNMYXN0RmllbGRJUHY0QWRkcmVzcyIsICJmaWVsZENvdW50IiwgImxhc3RGaWVsZHNTdGFydCIsICJmaWVsZHMiLCAiYWxsWmVyb0ZpZWxkcyIsICJyZWR1Y2UiLCAiYWNjIiwgImZpZWxkIiwgImxhc3RMb25nZXN0IiwgImxvbmdlc3RaZXJvRmllbGRzIiwgInNvcnQiLCAiYSIsICJiIiwgIm5ld0hvc3QiLCAibmV3Rmlyc3QiLCAibmV3TGFzdCIsICJVUklfUEFSU0UiLCAiTk9fTUFUQ0hfSVNfVU5ERUZJTkVEIiwgInBhcnNlIiwgInVyaVN0cmluZyIsICJvcHRpb25zIiwgImlyaSIsICJJUklfUFJPVE9DT0wiLCAiVVJJX1BST1RPQ09MIiwgInJlZmVyZW5jZSIsICJwb3J0IiwgImlzTmFOIiwgImluZGV4T2YiLCAic2NoZW1lSGFuZGxlciIsICJ1bmljb2RlU3VwcG9ydCIsICJkb21haW5Ib3N0IiwgIl9yZWNvbXBvc2VBdXRob3JpdHkiLCAidXJpVG9rZW5zIiwgIl8iLCAiJDEiLCAiJDIiLCAiUkRTMSIsICJSRFMyIiwgIlJEUzMiLCAiUkRTNSIsICJyZW1vdmVEb3RTZWdtZW50cyIsICJpbSIsICJzIiwgIkVycm9yIiwgInNlcmlhbGl6ZSIsICJhdXRob3JpdHkiLCAiY2hhckF0IiwgImFic29sdXRlUGF0aCIsICJyZXNvbHZlQ29tcG9uZW50cyIsICJyZWxhdGl2ZSIsICJza2lwTm9ybWFsaXphdGlvbiIsICJ0b2xlcmFudCIsICJyZXNvbHZlIiwgImJhc2VVUkkiLCAicmVsYXRpdmVVUkkiLCAic2NoZW1lbGVzc09wdGlvbnMiLCAibm9ybWFsaXplIiwgInVyaSIsICJlcXVhbCIsICJ1cmlBIiwgInVyaUIiLCAiZXNjYXBlQ29tcG9uZW50IiwgIkVTQ0FQRSIsICJ1bmVzY2FwZUNvbXBvbmVudCIsICJoYW5kbGVyIiwgInNlY3VyZSIsICJodHRwIiwgImlzU2VjdXJlIiwgIndzQ29tcG9uZW50cyIsICJyZXNvdXJjZU5hbWUiLCAid3MiLCAiTyIsICJBVEVYVCQkIiwgIlFURVhUJCQiLCAiVkNIQVIkJCIsICJTT01FX0RFTElNUyQkIiwgIk5PVF9MT0NBTF9QQVJUIiwgIk5PVF9IRk5BTUUiLCAiTk9UX0hGVkFMVUUiLCAibWFpbHRvQ29tcG9uZW50cyIsICJ0byIsICJ1bmtub3duSGVhZGVycyIsICJoZWFkZXJzIiwgImhmaWVsZHMiLCAiaGZpZWxkIiwgInRvQWRkcnMiLCAic3ViamVjdCIsICJib2R5IiwgImFkZHIiLCAidG9BZGRyIiwgImF0SWR4IiwgImxvY2FsUGFydCIsICJkb21haW4iLCAibmFtZSIsICJVUk5fUEFSU0UiLCAidXJuQ29tcG9uZW50cyIsICJuaWQiLCAibnNzIiwgInVyblNjaGVtZSIsICJ1cmlDb21wb25lbnRzIiwgIlVVSUQiLCAidXVpZENvbXBvbmVudHMiLCAidXVpZCIsICJodHRwcyIsICJ3c3MiLCAibWFpbHRvIiwgInVybiIsICJfYSIsICJzZWxmIiwgIl9hIiwgInNlbGYiLCAiRGlzY3JFcnJvciIsICJfYSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInZhbGlkYXRpb25FcnJvcnMiLCAiZXJyb3IiLCAiX2EiLCAiX2EiLCAiVHlwZVJlZ2lzdHJ5IiwgImtpbmQiLCAiU2V0IiwgIkZvcm1hdFJlZ2lzdHJ5IiwgIlR5cGVHdWFyZCIsICJzY2hlbWEiLCAiRXh0ZW5kc1VuZGVmaW5lZCIsICJUeXBlRXh0ZW5kc1Jlc3VsdCIsICJUeXBlRXh0ZW5kcyIsICJBcnJheSIsICJCb29sZWFuIiwgIkRhdGUiLCAiRnVuY3Rpb24iLCAiTnVtYmVyIiwgIk9iamVjdCIsICJQcm9taXNlIiwgIlN0cmluZyIsICJTeW1ib2wiLCAiVWludDhBcnJheSIsICJUeXBlQ2xvbmUiLCAidmFsdWUiLCAiSW5kZXhlZEFjY2Vzc29yIiwgIk9iamVjdE1hcCIsICJNYXAiLCAiS2V5UmVzb2x2ZXIiLCAiS2V5QXJyYXlSZXNvbHZlciIsICJVbmlvblJlc29sdmVyIiwgIlRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4iLCAiVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIiLCAiVGVtcGxhdGVMaXRlcmFsUGFyc2VyIiwgInJhbmdlIiwgInBhdHRlcm4iLCAiVGVtcGxhdGVMaXRlcmFsRmluaXRlIiwgIlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciIsICJUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIiLCAia2V5IiwgIl9hIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiZ2xvYmFsIiwgInNlbGYiLCAiZXhwb3J0cyIsICJIZWFkZXJzIiwgIlJlcXVlc3QiLCAiUmVzcG9uc2UiLCAiZmV0Y2giLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiVXBzZXJ0Q29tbWFuZCIsICJfYSIsICJGZXRjaENvbW1hbmQiLCAiX2EiLCAiVXBkYXRlQ29tbWFuZCIsICJfYSIsICJRdWVyeUNvbW1hbmQiLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiX2EiLCAiZmV0Y2giLCAiX2EiLCAiVmVjdG9yT3BlcmF0aW9uc1Byb3ZpZGVyIiwgIl9hIiwgIkluZGV4IiwgIl9hIiwgIlBpbmVjb25lIiwgIl9hIiwgIkNvbmZpZ3VyYXRpb24iLCAiX2EiLCAiQmFzZUFQSSIsICJSZXNwb25zZUVycm9yIiwgIkZldGNoRXJyb3IiLCAiUmVxdWlyZWRFcnJvciIsICJKU09OQXBpUmVzcG9uc2UiLCAiVm9pZEFwaVJlc3BvbnNlIiwgIkJsb2JBcGlSZXNwb25zZSIsICJUZXh0QXBpUmVzcG9uc2UiLCAiSW5kZXhPcGVyYXRpb25zQXBpIiwgIl9hIiwgIlZlY3Rvck9wZXJhdGlvbnNBcGkiLCAiX2EiLCAic2VsZiIsICJleHBvcnRzIiwgIkhlYWRlcnMiLCAiUmVxdWVzdCIsICJSZXNwb25zZSIsICJmZXRjaCIsICJQaW5lY29uZUVycm9yIiwgIl9hIiwgInByb3AiLCAiUGluZWNvbmVDbGllbnQiLCAiX2EiLCAiaW1wb3J0X3Byb21pc2VzIiwgImFwcCIsICJhcHAiLCAiX2EiLCAiaGVhZGluZyIsICJfYSIsICJmZXRjaCIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgIkhlYWRlcnMiLCAiRm9ybURhdGEiLCAiQmxvYiIsICJGaWxlIiwgIl9hIiwgIkZpbGUiLCAiRm9ybURhdGEiLCAiZmV0Y2giLCAib3B0cyIsICJQYWdlIiwgIl9hIiwgIlBhZ2UiLCAiX2EiLCAiX2EiLCAiVHJhbnNjcmlwdGlvbnMiLCAiVHJhbnNsYXRpb25zIiwgIkF1ZGlvIiwgIl9hIiwgIkNvbXBsZXRpb25zIiwgIkNoYXQiLCAiQ29tcGxldGlvbnMiLCAiX2EiLCAiRW1iZWRkaW5ncyIsICJFZGl0cyIsICJGaWxlcyIsICJfYSIsICJGaW5lVHVuZXMiLCAiSm9icyIsICJGaW5lVHVuaW5nIiwgIkltYWdlcyIsICJNb2RlbHMiLCAiTW9kZXJhdGlvbnMiLCAiQ29tcGxldGlvbnMiLCAiT3BlbkFJRXJyb3IiLCAiQVBJRXJyb3IiLCAiQVBJQ29ubmVjdGlvbkVycm9yIiwgIkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IiLCAiQVBJVXNlckFib3J0RXJyb3IiLCAiTm90Rm91bmRFcnJvciIsICJDb25mbGljdEVycm9yIiwgIlJhdGVMaW1pdEVycm9yIiwgIkJhZFJlcXVlc3RFcnJvciIsICJBdXRoZW50aWNhdGlvbkVycm9yIiwgIkludGVybmFsU2VydmVyRXJyb3IiLCAiUGVybWlzc2lvbkRlbmllZEVycm9yIiwgIlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciIsICJPcGVuQUkiLCAiQ29tcGxldGlvbnMiLCAiX2EiLCAiYXBwIiwgIm5vZGUiLCAiX2IiLCAiYXBwIiwgIl9hIiwgIl9hIiwgImFwcCIsICJlZGdlIiwgInRvRmlsZSJdCn0K
