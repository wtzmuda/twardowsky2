/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/runtime.js
var require_runtime = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/runtime.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
    exports.BASE_PATH = "https://unknown-unknown.svc.unknown.pinecone.io".replace(/\/+$/, "");
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(configuration) {
          if (configuration === void 0) {
            configuration = {};
          }
          this.configuration = configuration;
        }
        Object.defineProperty(Configuration2.prototype, "config", {
          set: function(configuration) {
            this.configuration = configuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "basePath", {
          get: function() {
            return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fetchApi", {
          get: function() {
            return this.configuration.fetchApi;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "middleware", {
          get: function() {
            return this.configuration.middleware || [];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
          get: function() {
            return this.configuration.queryParamsStringify || querystring;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "username", {
          get: function() {
            return this.configuration.username;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "password", {
          get: function() {
            return this.configuration.password;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "apiKey", {
          get: function() {
            var apiKey = this.configuration.apiKey;
            if (apiKey) {
              return typeof apiKey === "function" ? apiKey : function() {
                return apiKey;
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "accessToken", {
          get: function() {
            var _this = this;
            var accessToken = this.configuration.accessToken;
            if (accessToken) {
              return typeof accessToken === "function" ? accessToken : function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    return [2, accessToken];
                  });
                });
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "headers", {
          get: function() {
            return this.configuration.headers;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "credentials", {
          get: function() {
            return this.configuration.credentials;
          },
          enumerable: false,
          configurable: true
        });
        return Configuration2;
      }()
    );
    exports.Configuration = Configuration;
    exports.DefaultConfig = new Configuration();
    var BaseAPI = (
      /** @class */
      function() {
        function BaseAPI2(configuration) {
          if (configuration === void 0) {
            configuration = exports.DefaultConfig;
          }
          var _this = this;
          this.configuration = configuration;
          this.fetchApi = function(url, init) {
            return __awaiter(_this, void 0, void 0, function() {
              var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
              return __generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    fetchParams = { url, init };
                    _i = 0, _a2 = this.middleware;
                    _f.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    middleware = _a2[_i];
                    if (!middleware.pre)
                      return [3, 3];
                    return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
                  case 2:
                    fetchParams = _f.sent() || fetchParams;
                    _f.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    response = void 0;
                    _f.label = 5;
                  case 5:
                    _f.trys.push([5, 7, , 12]);
                    return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
                  case 6:
                    response = _f.sent();
                    return [3, 12];
                  case 7:
                    e_1 = _f.sent();
                    _b = 0, _c = this.middleware;
                    _f.label = 8;
                  case 8:
                    if (!(_b < _c.length))
                      return [3, 11];
                    middleware = _c[_b];
                    if (!middleware.onError)
                      return [3, 10];
                    return [4, middleware.onError({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      error: e_1,
                      response: response ? response.clone() : void 0
                    })];
                  case 9:
                    response = _f.sent() || response;
                    _f.label = 10;
                  case 10:
                    _b++;
                    return [3, 8];
                  case 11:
                    if (response === void 0) {
                      if (e_1 instanceof Error) {
                        throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                      } else {
                        throw e_1;
                      }
                    }
                    return [3, 12];
                  case 12:
                    _d = 0, _e = this.middleware;
                    _f.label = 13;
                  case 13:
                    if (!(_d < _e.length))
                      return [3, 16];
                    middleware = _e[_d];
                    if (!middleware.post)
                      return [3, 15];
                    return [4, middleware.post({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      response: response.clone()
                    })];
                  case 14:
                    response = _f.sent() || response;
                    _f.label = 15;
                  case 15:
                    _d++;
                    return [3, 13];
                  case 16:
                    return [2, response];
                }
              });
            });
          };
          this.middleware = configuration.middleware;
        }
        BaseAPI2.prototype.withMiddleware = function() {
          var _a2;
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
          }
          var next = this.clone();
          next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
          return next;
        };
        BaseAPI2.prototype.withPreMiddleware = function() {
          var preMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            preMiddlewares[_i] = arguments[_i];
          }
          var middlewares = preMiddlewares.map(function(pre) {
            return { pre };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.withPostMiddleware = function() {
          var postMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            postMiddlewares[_i] = arguments[_i];
          }
          var middlewares = postMiddlewares.map(function(post) {
            return { post };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.isJsonMime = function(mime) {
          if (!mime) {
            return false;
          }
          return BaseAPI2.jsonRegex.test(mime);
        };
        BaseAPI2.prototype.request = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var _a2, url, init, response;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.createFetchParams(context, initOverrides)];
                case 1:
                  _a2 = _b.sent(), url = _a2.url, init = _a2.init;
                  return [4, this.fetchApi(url, init)];
                case 2:
                  response = _b.sent();
                  if (response && (response.status >= 200 && response.status < 300)) {
                    return [2, response];
                  }
                  throw new ResponseError(response, "Response returned an error code");
              }
            });
          });
        };
        BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var url, headers, initOverrideFn, initParams, overriddenInit, _a2, body, init;
            var _this = this;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  url = this.configuration.basePath + context.path;
                  if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
                    url += "?" + this.configuration.queryParamsStringify(context.query);
                  }
                  headers = Object.assign({}, this.configuration.headers, context.headers);
                  Object.keys(headers).forEach(function(key) {
                    return headers[key] === void 0 ? delete headers[key] : {};
                  });
                  initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a3) {
                        return [2, initOverrides];
                      });
                    });
                  };
                  initParams = {
                    method: context.method,
                    headers,
                    body: context.body,
                    credentials: this.configuration.credentials
                  };
                  _a2 = [__assign({}, initParams)];
                  return [4, initOverrideFn({
                    init: initParams,
                    context
                  })];
                case 1:
                  overriddenInit = __assign.apply(void 0, _a2.concat([_b.sent()]));
                  if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
                    body = overriddenInit.body;
                  } else if (this.isJsonMime(headers["Content-Type"])) {
                    body = JSON.stringify(overriddenInit.body);
                  } else {
                    body = overriddenInit.body;
                  }
                  init = __assign(__assign({}, overriddenInit), { body });
                  return [2, { url, init }];
              }
            });
          });
        };
        BaseAPI2.prototype.clone = function() {
          var constructor = this.constructor;
          var next = new constructor(this.configuration);
          next.middleware = this.middleware.slice();
          return next;
        };
        BaseAPI2.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
        return BaseAPI2;
      }()
    );
    exports.BaseAPI = BaseAPI;
    function isBlob(value) {
      return typeof Blob !== "undefined" && value instanceof Blob;
    }
    function isFormData(value) {
      return typeof FormData !== "undefined" && value instanceof FormData;
    }
    var ResponseError = (
      /** @class */
      function(_super) {
        __extends(ResponseError2, _super);
        function ResponseError2(response, msg) {
          var _this = _super.call(this, msg) || this;
          _this.response = response;
          _this.name = "ResponseError";
          return _this;
        }
        return ResponseError2;
      }(Error)
    );
    exports.ResponseError = ResponseError;
    var FetchError = (
      /** @class */
      function(_super) {
        __extends(FetchError2, _super);
        function FetchError2(cause, msg) {
          var _this = _super.call(this, msg) || this;
          _this.cause = cause;
          _this.name = "FetchError";
          return _this;
        }
        return FetchError2;
      }(Error)
    );
    exports.FetchError = FetchError;
    var RequiredError = (
      /** @class */
      function(_super) {
        __extends(RequiredError2, _super);
        function RequiredError2(field, msg) {
          var _this = _super.call(this, msg) || this;
          _this.field = field;
          _this.name = "RequiredError";
          return _this;
        }
        return RequiredError2;
      }(Error)
    );
    exports.RequiredError = RequiredError;
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    function exists(json, key) {
      var value = json[key];
      return value !== null && value !== void 0;
    }
    exports.exists = exists;
    function querystring(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.querystring = querystring;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (value instanceof Array) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return querystring(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
    function mapValues(data, fn) {
      return Object.keys(data).reduce(function(acc, key) {
        var _a2;
        return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
      }, {});
    }
    exports.mapValues = mapValues;
    function canConsumeForm(consumes) {
      for (var _i = 0, consumes_1 = consumes; _i < consumes_1.length; _i++) {
        var consume = consumes_1[_i];
        if ("multipart/form-data" === consume.contentType) {
          return true;
        }
      }
      return false;
    }
    exports.canConsumeForm = canConsumeForm;
    var JSONApiResponse = (
      /** @class */
      function() {
        function JSONApiResponse2(raw, transformer) {
          if (transformer === void 0) {
            transformer = function(jsonValue) {
              return jsonValue;
            };
          }
          this.raw = raw;
          this.transformer = transformer;
        }
        JSONApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a2 = this.transformer;
                  return [4, this.raw.json()];
                case 1:
                  return [2, _a2.apply(this, [_b.sent()])];
              }
            });
          });
        };
        return JSONApiResponse2;
      }()
    );
    exports.JSONApiResponse = JSONApiResponse;
    var VoidApiResponse = (
      /** @class */
      function() {
        function VoidApiResponse2(raw) {
          this.raw = raw;
        }
        VoidApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, void 0];
            });
          });
        };
        return VoidApiResponse2;
      }()
    );
    exports.VoidApiResponse = VoidApiResponse;
    var BlobApiResponse = (
      /** @class */
      function() {
        function BlobApiResponse2(raw) {
          this.raw = raw;
        }
        BlobApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.blob()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return BlobApiResponse2;
      }()
    );
    exports.BlobApiResponse = BlobApiResponse;
    var TextApiResponse = (
      /** @class */
      function() {
        function TextApiResponse2(raw) {
          this.raw = raw;
        }
        TextApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.text()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return TextApiResponse2;
      }()
    );
    exports.TextApiResponse = TextApiResponse;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ApproximatedConfig.js
var require_ApproximatedConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ApproximatedConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApproximatedConfigToJSON = exports.ApproximatedConfigFromJSONTyped = exports.ApproximatedConfigFromJSON = exports.instanceOfApproximatedConfig = void 0;
    var runtime_1 = require_runtime();
    function instanceOfApproximatedConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfApproximatedConfig = instanceOfApproximatedConfig;
    function ApproximatedConfigFromJSON(json) {
      return ApproximatedConfigFromJSONTyped(json, false);
    }
    exports.ApproximatedConfigFromJSON = ApproximatedConfigFromJSON;
    function ApproximatedConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "kBits": !(0, runtime_1.exists)(json, "k_bits") ? void 0 : json["k_bits"],
        "hybrid": !(0, runtime_1.exists)(json, "hybrid") ? void 0 : json["hybrid"]
      };
    }
    exports.ApproximatedConfigFromJSONTyped = ApproximatedConfigFromJSONTyped;
    function ApproximatedConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "k_bits": value.kBits,
        "hybrid": value.hybrid
      };
    }
    exports.ApproximatedConfigToJSON = ApproximatedConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionMeta.js
var require_CollectionMeta = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionMetaToJSON = exports.CollectionMetaFromJSONTyped = exports.CollectionMetaFromJSON = exports.instanceOfCollectionMeta = void 0;
    var runtime_1 = require_runtime();
    function instanceOfCollectionMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCollectionMeta = instanceOfCollectionMeta;
    function CollectionMetaFromJSON(json) {
      return CollectionMetaFromJSONTyped(json, false);
    }
    exports.CollectionMetaFromJSON = CollectionMetaFromJSON;
    function CollectionMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "size": !(0, runtime_1.exists)(json, "size") ? void 0 : json["size"],
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : json["status"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "vectorCount": !(0, runtime_1.exists)(json, "vector_count") ? void 0 : json["vector_count"]
      };
    }
    exports.CollectionMetaFromJSONTyped = CollectionMetaFromJSONTyped;
    function CollectionMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "size": value.size,
        "status": value.status,
        "dimension": value.dimension,
        "vector_count": value.vectorCount
      };
    }
    exports.CollectionMetaToJSON = CollectionMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js
var require_CreateCollectionRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = void 0;
    function instanceOfCreateCollectionRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "source" in value;
      return isInstance;
    }
    exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
    function CreateCollectionRequestFromJSON(json) {
      return CreateCollectionRequestFromJSONTyped(json, false);
    }
    exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
    function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "source": json["source"]
      };
    }
    exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
    function CreateCollectionRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "source": value.source
      };
    }
    exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js
var require_CreateRequestIndexConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestIndexConfigToJSON = exports.CreateRequestIndexConfigFromJSONTyped = exports.CreateRequestIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig();
    function CreateRequestIndexConfigFromJSON(json) {
      return CreateRequestIndexConfigFromJSONTyped(json, false);
    }
    exports.CreateRequestIndexConfigFromJSON = CreateRequestIndexConfigFromJSON;
    function CreateRequestIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.CreateRequestIndexConfigFromJSONTyped = CreateRequestIndexConfigFromJSONTyped;
    function CreateRequestIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.CreateRequestIndexConfigToJSON = CreateRequestIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequest.js
var require_CreateRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestToJSON = exports.CreateRequestFromJSONTyped = exports.CreateRequestFromJSON = exports.instanceOfCreateRequest = void 0;
    var runtime_1 = require_runtime();
    var CreateRequestIndexConfig_1 = require_CreateRequestIndexConfig();
    function instanceOfCreateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "dimension" in value;
      return isInstance;
    }
    exports.instanceOfCreateRequest = instanceOfCreateRequest;
    function CreateRequestFromJSON(json) {
      return CreateRequestFromJSONTyped(json, false);
    }
    exports.CreateRequestFromJSON = CreateRequestFromJSON;
    function CreateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "dimension": json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"],
        "sourceCollection": !(0, runtime_1.exists)(json, "source_collection") ? void 0 : json["source_collection"]
      };
    }
    exports.CreateRequestFromJSONTyped = CreateRequestFromJSONTyped;
    function CreateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig,
        "source_collection": value.sourceCollection
      };
    }
    exports.CreateRequestToJSON = CreateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DeleteRequest.js
var require_DeleteRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DeleteRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfDeleteRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
    function DeleteRequestFromJSON(json) {
      return DeleteRequestFromJSONTyped(json, false);
    }
    exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
    function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ids": !(0, runtime_1.exists)(json, "ids") ? void 0 : json["ids"],
        "deleteAll": !(0, runtime_1.exists)(json, "deleteAll") ? void 0 : json["deleteAll"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
    function DeleteRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ids": value.ids,
        "deleteAll": value.deleteAll,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.DeleteRequestToJSON = DeleteRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js
var require_DescribeIndexStatsRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfDescribeIndexStatsRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
    function DescribeIndexStatsRequestFromJSON(json) {
      return DescribeIndexStatsRequestFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
    function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
    function DescribeIndexStatsRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "filter": value.filter
      };
    }
    exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/NamespaceSummary.js
var require_NamespaceSummary = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/NamespaceSummary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = void 0;
    var runtime_1 = require_runtime();
    function instanceOfNamespaceSummary(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
    function NamespaceSummaryFromJSON(json) {
      return NamespaceSummaryFromJSONTyped(json, false);
    }
    exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
    function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectorCount": !(0, runtime_1.exists)(json, "vectorCount") ? void 0 : json["vectorCount"]
      };
    }
    exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
    function NamespaceSummaryToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectorCount": value.vectorCount
      };
    }
    exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js
var require_DescribeIndexStatsResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsResponseToJSON = exports.DescribeIndexStatsResponseFromJSONTyped = exports.DescribeIndexStatsResponseFromJSON = exports.instanceOfDescribeIndexStatsResponse = void 0;
    var runtime_1 = require_runtime();
    var NamespaceSummary_1 = require_NamespaceSummary();
    function instanceOfDescribeIndexStatsResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsResponse = instanceOfDescribeIndexStatsResponse;
    function DescribeIndexStatsResponseFromJSON(json) {
      return DescribeIndexStatsResponseFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsResponseFromJSON = DescribeIndexStatsResponseFromJSON;
    function DescribeIndexStatsResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespaces": !(0, runtime_1.exists)(json, "namespaces") ? void 0 : (0, runtime_1.mapValues)(json["namespaces"], NamespaceSummary_1.NamespaceSummaryFromJSON),
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexFullness": !(0, runtime_1.exists)(json, "indexFullness") ? void 0 : json["indexFullness"],
        "totalVectorCount": !(0, runtime_1.exists)(json, "totalVectorCount") ? void 0 : json["totalVectorCount"]
      };
    }
    exports.DescribeIndexStatsResponseFromJSONTyped = DescribeIndexStatsResponseFromJSONTyped;
    function DescribeIndexStatsResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespaces": value.namespaces === void 0 ? void 0 : (0, runtime_1.mapValues)(value.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
        "dimension": value.dimension,
        "indexFullness": value.indexFullness,
        "totalVectorCount": value.totalVectorCount
      };
    }
    exports.DescribeIndexStatsResponseToJSON = DescribeIndexStatsResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SparseValues.js
var require_SparseValues = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SparseValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = void 0;
    function instanceOfSparseValues(value) {
      var isInstance = true;
      isInstance = isInstance && "indices" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfSparseValues = instanceOfSparseValues;
    function SparseValuesFromJSON(json) {
      return SparseValuesFromJSONTyped(json, false);
    }
    exports.SparseValuesFromJSON = SparseValuesFromJSON;
    function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indices": json["indices"],
        "values": json["values"]
      };
    }
    exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
    function SparseValuesToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indices": value.indices,
        "values": value.values
      };
    }
    exports.SparseValuesToJSON = SparseValuesToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Vector.js
var require_Vector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfVector = instanceOfVector;
    function VectorFromJSON(json) {
      return VectorFromJSONTyped(json, false);
    }
    exports.VectorFromJSON = VectorFromJSON;
    function VectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.VectorFromJSONTyped = VectorFromJSONTyped;
    function VectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.VectorToJSON = VectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/FetchResponse.js
var require_FetchResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/FetchResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = void 0;
    var runtime_1 = require_runtime();
    var Vector_1 = require_Vector();
    function instanceOfFetchResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfFetchResponse = instanceOfFetchResponse;
    function FetchResponseFromJSON(json) {
      return FetchResponseFromJSONTyped(json, false);
    }
    exports.FetchResponseFromJSON = FetchResponseFromJSON;
    function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": !(0, runtime_1.exists)(json, "vectors") ? void 0 : (0, runtime_1.mapValues)(json["vectors"], Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
    function FetchResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors === void 0 ? void 0 : (0, runtime_1.mapValues)(value.vectors, Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.FetchResponseToJSON = FetchResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/HnswConfig.js
var require_HnswConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/HnswConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HnswConfigToJSON = exports.HnswConfigFromJSONTyped = exports.HnswConfigFromJSON = exports.instanceOfHnswConfig = void 0;
    var runtime_1 = require_runtime();
    function instanceOfHnswConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfHnswConfig = instanceOfHnswConfig;
    function HnswConfigFromJSON(json) {
      return HnswConfigFromJSONTyped(json, false);
    }
    exports.HnswConfigFromJSON = HnswConfigFromJSON;
    function HnswConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "efConstruction": !(0, runtime_1.exists)(json, "ef_construction") ? void 0 : json["ef_construction"],
        "ef": !(0, runtime_1.exists)(json, "ef") ? void 0 : json["ef"],
        "m": !(0, runtime_1.exists)(json, "M") ? void 0 : json["M"],
        "maxElements": !(0, runtime_1.exists)(json, "max_elements") ? void 0 : json["max_elements"]
      };
    }
    exports.HnswConfigFromJSONTyped = HnswConfigFromJSONTyped;
    function HnswConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ef_construction": value.efConstruction,
        "ef": value.ef,
        "M": value.m,
        "max_elements": value.maxElements
      };
    }
    exports.HnswConfigToJSON = HnswConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js
var require_IndexMetaDatabaseIndexConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseIndexConfigToJSON = exports.IndexMetaDatabaseIndexConfigFromJSONTyped = exports.IndexMetaDatabaseIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig();
    function IndexMetaDatabaseIndexConfigFromJSON(json) {
      return IndexMetaDatabaseIndexConfigFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseIndexConfigFromJSON = IndexMetaDatabaseIndexConfigFromJSON;
    function IndexMetaDatabaseIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.IndexMetaDatabaseIndexConfigFromJSONTyped = IndexMetaDatabaseIndexConfigFromJSONTyped;
    function IndexMetaDatabaseIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.IndexMetaDatabaseIndexConfigToJSON = IndexMetaDatabaseIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js
var require_IndexMetaDatabase = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseToJSON = exports.IndexMetaDatabaseFromJSONTyped = exports.IndexMetaDatabaseFromJSON = exports.instanceOfIndexMetaDatabase = void 0;
    var runtime_1 = require_runtime();
    var IndexMetaDatabaseIndexConfig_1 = require_IndexMetaDatabaseIndexConfig();
    function instanceOfIndexMetaDatabase(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaDatabase = instanceOfIndexMetaDatabase;
    function IndexMetaDatabaseFromJSON(json) {
      return IndexMetaDatabaseFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseFromJSON = IndexMetaDatabaseFromJSON;
    function IndexMetaDatabaseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"]
      };
    }
    exports.IndexMetaDatabaseFromJSONTyped = IndexMetaDatabaseFromJSONTyped;
    function IndexMetaDatabaseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig
      };
    }
    exports.IndexMetaDatabaseToJSON = IndexMetaDatabaseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaStatus.js
var require_IndexMetaStatus = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMetaStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaStatusToJSON = exports.IndexMetaStatusFromJSONTyped = exports.IndexMetaStatusFromJSON = exports.instanceOfIndexMetaStatus = exports.IndexMetaStatusStateEnum = void 0;
    var runtime_1 = require_runtime();
    exports.IndexMetaStatusStateEnum = {
      Initializing: "Initializing",
      InitializationFailed: "InitializationFailed",
      ScalingUp: "ScalingUp",
      ScalingDown: "ScalingDown",
      ScalingUpPodSize: "ScalingUpPodSize",
      ScalingDownPodSize: "ScalingDownPodSize",
      Terminating: "Terminating",
      Ready: "Ready"
    };
    function instanceOfIndexMetaStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaStatus = instanceOfIndexMetaStatus;
    function IndexMetaStatusFromJSON(json) {
      return IndexMetaStatusFromJSONTyped(json, false);
    }
    exports.IndexMetaStatusFromJSON = IndexMetaStatusFromJSON;
    function IndexMetaStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ready": !(0, runtime_1.exists)(json, "ready") ? void 0 : json["ready"],
        "state": !(0, runtime_1.exists)(json, "state") ? void 0 : json["state"],
        "host": !(0, runtime_1.exists)(json, "host") ? void 0 : json["host"],
        "port": !(0, runtime_1.exists)(json, "port") ? void 0 : json["port"]
      };
    }
    exports.IndexMetaStatusFromJSONTyped = IndexMetaStatusFromJSONTyped;
    function IndexMetaStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ready": value.ready,
        "state": value.state,
        "host": value.host,
        "port": value.port
      };
    }
    exports.IndexMetaStatusToJSON = IndexMetaStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMeta.js
var require_IndexMeta = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaToJSON = exports.IndexMetaFromJSONTyped = exports.IndexMetaFromJSON = exports.instanceOfIndexMeta = void 0;
    var runtime_1 = require_runtime();
    var IndexMetaDatabase_1 = require_IndexMetaDatabase();
    var IndexMetaStatus_1 = require_IndexMetaStatus();
    function instanceOfIndexMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMeta = instanceOfIndexMeta;
    function IndexMetaFromJSON(json) {
      return IndexMetaFromJSONTyped(json, false);
    }
    exports.IndexMetaFromJSON = IndexMetaFromJSON;
    function IndexMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "database": !(0, runtime_1.exists)(json, "database") ? void 0 : (0, IndexMetaDatabase_1.IndexMetaDatabaseFromJSON)(json["database"]),
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : (0, IndexMetaStatus_1.IndexMetaStatusFromJSON)(json["status"])
      };
    }
    exports.IndexMetaFromJSONTyped = IndexMetaFromJSONTyped;
    function IndexMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "database": (0, IndexMetaDatabase_1.IndexMetaDatabaseToJSON)(value.database),
        "status": (0, IndexMetaStatus_1.IndexMetaStatusToJSON)(value.status)
      };
    }
    exports.IndexMetaToJSON = IndexMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PatchRequest.js
var require_PatchRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PatchRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatchRequestToJSON = exports.PatchRequestFromJSONTyped = exports.PatchRequestFromJSON = exports.instanceOfPatchRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfPatchRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfPatchRequest = instanceOfPatchRequest;
    function PatchRequestFromJSON(json) {
      return PatchRequestFromJSONTyped(json, false);
    }
    exports.PatchRequestFromJSON = PatchRequestFromJSON;
    function PatchRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"]
      };
    }
    exports.PatchRequestFromJSONTyped = PatchRequestFromJSONTyped;
    function PatchRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "replicas": value.replicas,
        "pod_type": value.podType
      };
    }
    exports.PatchRequestToJSON = PatchRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufAny.js
var require_ProtobufAny = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufAny.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = void 0;
    var runtime_1 = require_runtime();
    function instanceOfProtobufAny(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfProtobufAny = instanceOfProtobufAny;
    function ProtobufAnyFromJSON(json) {
      return ProtobufAnyFromJSONTyped(json, false);
    }
    exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
    function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "typeUrl": !(0, runtime_1.exists)(json, "typeUrl") ? void 0 : json["typeUrl"],
        "value": !(0, runtime_1.exists)(json, "value") ? void 0 : json["value"]
      };
    }
    exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
    function ProtobufAnyToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "typeUrl": value.typeUrl,
        "value": value.value
      };
    }
    exports.ProtobufAnyToJSON = ProtobufAnyToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufNullValue.js
var require_ProtobufNullValue = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufNullValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = void 0;
    exports.ProtobufNullValue = {
      NullValue: "NULL_VALUE"
    };
    function ProtobufNullValueFromJSON(json) {
      return ProtobufNullValueFromJSONTyped(json, false);
    }
    exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
    function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
      return json;
    }
    exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
    function ProtobufNullValueToJSON(value) {
      return value;
    }
    exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryVector.js
var require_QueryVector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfQueryVector(value) {
      var isInstance = true;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfQueryVector = instanceOfQueryVector;
    function QueryVectorFromJSON(json) {
      return QueryVectorFromJSONTyped(json, false);
    }
    exports.QueryVectorFromJSON = QueryVectorFromJSON;
    function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "topK": !(0, runtime_1.exists)(json, "topK") ? void 0 : json["topK"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
    function QueryVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "topK": value.topK,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.QueryVectorToJSON = QueryVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryRequest.js
var require_QueryRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = void 0;
    var runtime_1 = require_runtime();
    var QueryVector_1 = require_QueryVector();
    var SparseValues_1 = require_SparseValues();
    function instanceOfQueryRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "topK" in value;
      return isInstance;
    }
    exports.instanceOfQueryRequest = instanceOfQueryRequest;
    function QueryRequestFromJSON(json) {
      return QueryRequestFromJSONTyped(json, false);
    }
    exports.QueryRequestFromJSON = QueryRequestFromJSON;
    function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "topK": json["topK"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"],
        "includeValues": !(0, runtime_1.exists)(json, "includeValues") ? void 0 : json["includeValues"],
        "includeMetadata": !(0, runtime_1.exists)(json, "includeMetadata") ? void 0 : json["includeMetadata"],
        "queries": !(0, runtime_1.exists)(json, "queries") ? void 0 : json["queries"].map(QueryVector_1.QueryVectorFromJSON),
        "vector": !(0, runtime_1.exists)(json, "vector") ? void 0 : json["vector"],
        "sparseVector": !(0, runtime_1.exists)(json, "sparseVector") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseVector"]),
        "id": !(0, runtime_1.exists)(json, "id") ? void 0 : json["id"]
      };
    }
    exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
    function QueryRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespace": value.namespace,
        "topK": value.topK,
        "filter": value.filter,
        "includeValues": value.includeValues,
        "includeMetadata": value.includeMetadata,
        "queries": value.queries === void 0 ? void 0 : value.queries.map(QueryVector_1.QueryVectorToJSON),
        "vector": value.vector,
        "sparseVector": (0, SparseValues_1.SparseValuesToJSON)(value.sparseVector),
        "id": value.id
      };
    }
    exports.QueryRequestToJSON = QueryRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ScoredVector.js
var require_ScoredVector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ScoredVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfScoredVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfScoredVector = instanceOfScoredVector;
    function ScoredVectorFromJSON(json) {
      return ScoredVectorFromJSONTyped(json, false);
    }
    exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
    function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "score": !(0, runtime_1.exists)(json, "score") ? void 0 : json["score"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
    function ScoredVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "score": value.score,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.ScoredVectorToJSON = ScoredVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SingleQueryResults.js
var require_SingleQueryResults = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SingleQueryResults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = void 0;
    var runtime_1 = require_runtime();
    var ScoredVector_1 = require_ScoredVector();
    function instanceOfSingleQueryResults(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
    function SingleQueryResultsFromJSON(json) {
      return SingleQueryResultsFromJSONTyped(json, false);
    }
    exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
    function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
    function SingleQueryResultsToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryResponse.js
var require_QueryResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = void 0;
    var runtime_1 = require_runtime();
    var ScoredVector_1 = require_ScoredVector();
    var SingleQueryResults_1 = require_SingleQueryResults();
    function instanceOfQueryResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfQueryResponse = instanceOfQueryResponse;
    function QueryResponseFromJSON(json) {
      return QueryResponseFromJSONTyped(json, false);
    }
    exports.QueryResponseFromJSON = QueryResponseFromJSON;
    function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "results": !(0, runtime_1.exists)(json, "results") ? void 0 : json["results"].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
    function QueryResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "results": value.results === void 0 ? void 0 : value.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.QueryResponseToJSON = QueryResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/RpcStatus.js
var require_RpcStatus = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/RpcStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = void 0;
    var runtime_1 = require_runtime();
    var ProtobufAny_1 = require_ProtobufAny();
    function instanceOfRpcStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfRpcStatus = instanceOfRpcStatus;
    function RpcStatusFromJSON(json) {
      return RpcStatusFromJSONTyped(json, false);
    }
    exports.RpcStatusFromJSON = RpcStatusFromJSON;
    function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "code": !(0, runtime_1.exists)(json, "code") ? void 0 : json["code"],
        "message": !(0, runtime_1.exists)(json, "message") ? void 0 : json["message"],
        "details": !(0, runtime_1.exists)(json, "details") ? void 0 : json["details"].map(ProtobufAny_1.ProtobufAnyFromJSON)
      };
    }
    exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
    function RpcStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "code": value.code,
        "message": value.message,
        "details": value.details === void 0 ? void 0 : value.details.map(ProtobufAny_1.ProtobufAnyToJSON)
      };
    }
    exports.RpcStatusToJSON = RpcStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpdateRequest.js
var require_UpdateRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpdateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfUpdateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
    function UpdateRequestFromJSON(json) {
      return UpdateRequestFromJSONTyped(json, false);
    }
    exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
    function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "setMetadata": !(0, runtime_1.exists)(json, "setMetadata") ? void 0 : json["setMetadata"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
    function UpdateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "setMetadata": value.setMetadata,
        "namespace": value.namespace
      };
    }
    exports.UpdateRequestToJSON = UpdateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertRequest.js
var require_UpsertRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = void 0;
    var runtime_1 = require_runtime();
    var Vector_1 = require_Vector();
    function instanceOfUpsertRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "vectors" in value;
      return isInstance;
    }
    exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
    function UpsertRequestFromJSON(json) {
      return UpsertRequestFromJSONTyped(json, false);
    }
    exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
    function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": json["vectors"].map(Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
    function UpsertRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors.map(Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.UpsertRequestToJSON = UpsertRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertResponse.js
var require_UpsertResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = void 0;
    var runtime_1 = require_runtime();
    function instanceOfUpsertResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
    function UpsertResponseFromJSON(json) {
      return UpsertResponseFromJSONTyped(json, false);
    }
    exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
    function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "upsertedCount": !(0, runtime_1.exists)(json, "upsertedCount") ? void 0 : json["upsertedCount"]
      };
    }
    exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
    function UpsertResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "upsertedCount": value.upsertedCount
      };
    }
    exports.UpsertResponseToJSON = UpsertResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/index.js
var require_models = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApproximatedConfig(), exports);
    __exportStar(require_CollectionMeta(), exports);
    __exportStar(require_CreateCollectionRequest(), exports);
    __exportStar(require_CreateRequest(), exports);
    __exportStar(require_CreateRequestIndexConfig(), exports);
    __exportStar(require_DeleteRequest(), exports);
    __exportStar(require_DescribeIndexStatsRequest(), exports);
    __exportStar(require_DescribeIndexStatsResponse(), exports);
    __exportStar(require_FetchResponse(), exports);
    __exportStar(require_HnswConfig(), exports);
    __exportStar(require_IndexMeta(), exports);
    __exportStar(require_IndexMetaDatabase(), exports);
    __exportStar(require_IndexMetaDatabaseIndexConfig(), exports);
    __exportStar(require_IndexMetaStatus(), exports);
    __exportStar(require_NamespaceSummary(), exports);
    __exportStar(require_PatchRequest(), exports);
    __exportStar(require_ProtobufAny(), exports);
    __exportStar(require_ProtobufNullValue(), exports);
    __exportStar(require_QueryRequest(), exports);
    __exportStar(require_QueryResponse(), exports);
    __exportStar(require_QueryVector(), exports);
    __exportStar(require_RpcStatus(), exports);
    __exportStar(require_ScoredVector(), exports);
    __exportStar(require_SingleQueryResults(), exports);
    __exportStar(require_SparseValues(), exports);
    __exportStar(require_UpdateRequest(), exports);
    __exportStar(require_UpsertRequest(), exports);
    __exportStar(require_UpsertResponse(), exports);
    __exportStar(require_Vector(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js
var require_IndexOperationsApi = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexOperationsApi = void 0;
    var runtime = __importStar(require_runtime());
    var index_1 = require_models();
    var IndexOperationsApi = (
      /** @class */
      function(_super) {
        __extends(IndexOperationsApi2, _super);
        function IndexOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        IndexOperationsApi2.prototype.configureIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling configureIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "PATCH",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.PatchRequestToJSON)(requestParameters.patchRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.configureIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.configureIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollection = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.CreateRequestToJSON)(requestParameters.createRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndex = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.CollectionMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling describeIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.IndexMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollectionsRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollections = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listCollectionsRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexesRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexes = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listIndexesRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return IndexOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.IndexOperationsApi = IndexOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js
var require_VectorOperationsApi = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorOperationsApi = void 0;
    var runtime = __importStar(require_runtime());
    var index_1 = require_models();
    var VectorOperationsApi = (
      /** @class */
      function(_super) {
        __extends(VectorOperationsApi2, _super);
        function VectorOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        VectorOperationsApi2.prototype._deleteRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === void 0) {
                    throw new runtime.RequiredError("deleteRequest", "Required parameter requestParameters.deleteRequest was null or undefined when calling _delete.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype._delete = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._deleteRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1Raw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.deleteAll !== void 0) {
                    queryParameters["deleteAll"] = requestParameters.deleteAll;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1 = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.delete1Raw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStatsRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === void 0) {
                    throw new runtime.RequiredError("describeIndexStatsRequest", "Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStatsRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1Raw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1 = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStats1Raw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetchRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.ids === null || requestParameters.ids === void 0) {
                    throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling fetch.");
                  }
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/fetch",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.FetchResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetch = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetchRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.queryRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.queryRequest === null || requestParameters.queryRequest === void 0) {
                    throw new runtime.RequiredError("queryRequest", "Required parameter requestParameters.queryRequest was null or undefined when calling query.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/query",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.QueryRequestToJSON)(requestParameters.queryRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.QueryResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.query = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.queryRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.updateRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.updateRequest === null || requestParameters.updateRequest === void 0) {
                    throw new runtime.RequiredError("updateRequest", "Required parameter requestParameters.updateRequest was null or undefined when calling update.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/update",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.UpdateRequestToJSON)(requestParameters.updateRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.update = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.updateRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsertRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === void 0) {
                    throw new runtime.RequiredError("upsertRequest", "Required parameter requestParameters.upsertRequest was null or undefined when calling upsert.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/upsert",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.UpsertResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsert = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.upsertRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return VectorOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.VectorOperationsApi = VectorOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/index.js
var require_apis = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndexOperationsApi(), exports);
    __exportStar(require_VectorOperationsApi(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/index.js
var require_pinecone_generated_ts_fetch = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_runtime(), exports);
    __exportStar(require_apis(), exports);
    __exportStar(require_models(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/base.js
var require_base = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/base.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasePineconeError = void 0;
    var BasePineconeError = (
      /** @class */
      function(_super) {
        __extends(BasePineconeError2, _super);
        function BasePineconeError2(message) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget);
          }
          _this.name = _this.constructor.name;
          return _this;
        }
        return BasePineconeError2;
      }(Error)
    );
    exports.BasePineconeError = BasePineconeError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/config.js
var require_config = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/config.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeUnknownRequestFailure = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
    var base_1 = require_base();
    var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
    var PineconeConfigurationError = (
      /** @class */
      function(_super) {
        __extends(PineconeConfigurationError2, _super);
        function PineconeConfigurationError2(message) {
          var _this = _super.call(this, "".concat(message, " ").concat(CONFIG_HELP)) || this;
          _this.name = "PineconeConfigurationError";
          return _this;
        }
        return PineconeConfigurationError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConfigurationError = PineconeConfigurationError;
    var PineconeUnexpectedResponseError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnexpectedResponseError2, _super);
        function PineconeUnexpectedResponseError2(url, status, body, message) {
          var _this = _super.call(this, "Unexpected response while calling ".concat(url, ". ").concat(message ? message + " " : "", "Status: ").concat(status, ". Body: ").concat(body)) || this;
          _this.name = "PineconeUnexpectedResponseError";
          return _this;
        }
        return PineconeUnexpectedResponseError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnexpectedResponseError = PineconeUnexpectedResponseError;
    var PineconeEnvironmentVarsNotSupportedError = (
      /** @class */
      function(_super) {
        __extends(PineconeEnvironmentVarsNotSupportedError2, _super);
        function PineconeEnvironmentVarsNotSupportedError2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = "PineconeEnvironmentVarsNotSupportedError";
          return _this;
        }
        return PineconeEnvironmentVarsNotSupportedError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeEnvironmentVarsNotSupportedError = PineconeEnvironmentVarsNotSupportedError;
    var PineconeUnknownRequestFailure = (
      /** @class */
      function(_super) {
        __extends(PineconeUnknownRequestFailure2, _super);
        function PineconeUnknownRequestFailure2(url, underlyingError) {
          var _this = this;
          var message = "Something went wrong while attempting to call ".concat(url, ". Please check your configuration and try again later. Underlying error was ").concat(JSON.stringify(underlyingError.message));
          _this = _super.call(this, message) || this;
          _this.name = "PineconeUnknownRequestFailure";
          return _this;
        }
        return PineconeUnknownRequestFailure2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnknownRequestFailure = PineconeUnknownRequestFailure;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/http.js
var require_http = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/http.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHttpStatusError = exports.PineconeUnmappedHttpError = exports.PineconeNotImplementedError = exports.PineconeInternalServerError = exports.PineconeConflictError = exports.PineconeNotFoundError = exports.PineconeAuthorizationError = exports.PineconeBadRequestError = void 0;
    var base_1 = require_base();
    var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
    var PineconeBadRequestError = (
      /** @class */
      function(_super) {
        __extends(PineconeBadRequestError2, _super);
        function PineconeBadRequestError2(failedRequest) {
          var _this = this;
          var message = failedRequest.message;
          _this = _super.call(this, message) || this;
          _this.name = "PineconeBadRequestError";
          return _this;
        }
        return PineconeBadRequestError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeBadRequestError = PineconeBadRequestError;
    var PineconeAuthorizationError = (
      /** @class */
      function(_super) {
        __extends(PineconeAuthorizationError2, _super);
        function PineconeAuthorizationError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url;
          if (url) {
            _this = _super.call(this, "The API key you provided was rejected while calling ".concat(url, ". Please check your configuration values and try again. ").concat(CONFIG_HELP)) || this;
          } else {
            _this = _super.call(this, "The API key you provided was rejected. Please check your configuration values and try again. ".concat(CONFIG_HELP)) || this;
          }
          _this.name = "PineconeAuthorizationError";
          return _this;
        }
        return PineconeAuthorizationError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeAuthorizationError = PineconeAuthorizationError;
    var PineconeNotFoundError = (
      /** @class */
      function(_super) {
        __extends(PineconeNotFoundError2, _super);
        function PineconeNotFoundError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, message = failedRequest.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 404. ").concat(message ? message : "")) || this;
          } else if (message) {
            _this = _super.call(this, message) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeNotFoundError";
          return _this;
        }
        return PineconeNotFoundError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeNotFoundError = PineconeNotFoundError;
    var PineconeConflictError = (
      /** @class */
      function(_super) {
        __extends(PineconeConflictError2, _super);
        function PineconeConflictError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, message = failedRequest.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 409. ").concat(message ? message : "")) || this;
          } else if (message) {
            _this = _super.call(this, message) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeConflictError";
          return _this;
        }
        return PineconeConflictError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConflictError = PineconeConflictError;
    var PineconeInternalServerError = (
      /** @class */
      function(_super) {
        __extends(PineconeInternalServerError2, _super);
        function PineconeInternalServerError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, body = failedRequest.body;
          var intro = url ? "An internal server error occured while calling the ".concat(url, " endpoint.") : "";
          var help = "To see overall service health and learn whether this seems like a large-scale problem or one specific to your request, please go to https://status.pinecone.io/ to view our status page. If you believe the error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client";
          var bodyMessage = body ? "Body: ".concat(body) : "";
          _this = _super.call(this, [intro, help, bodyMessage].join(" ").trim()) || this;
          _this.name = "PineconeInternalServerError";
          return _this;
        }
        return PineconeInternalServerError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeInternalServerError = PineconeInternalServerError;
    var PineconeNotImplementedError = (
      /** @class */
      function(_super) {
        __extends(PineconeNotImplementedError2, _super);
        function PineconeNotImplementedError2(requestInfo) {
          var _this = this;
          var url = requestInfo.url, message = requestInfo.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 501. ").concat(message ? message : "")) || this;
          } else if (message) {
            _this = _super.call(this, message) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeNotImplementedError";
          return _this;
        }
        return PineconeNotImplementedError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeNotImplementedError = PineconeNotImplementedError;
    var PineconeUnmappedHttpError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnmappedHttpError2, _super);
        function PineconeUnmappedHttpError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, status = failedRequest.status, body = failedRequest.body, message = failedRequest.message;
          var intro = url ? "An unexpected error occured while calling the ".concat(url, " endpoint. ") : "";
          var statusMsg = status ? "Status: ".concat(status, ". ") : "";
          var bodyMsg = body ? "Body: ".concat(body) : "";
          _this = _super.call(this, [intro, message, statusMsg, bodyMsg].join(" ").trim()) || this;
          _this.name = "PineconeUnmappedHttpError";
          return _this;
        }
        return PineconeUnmappedHttpError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnmappedHttpError = PineconeUnmappedHttpError;
    var mapHttpStatusError = function(failedRequestInfo) {
      switch (failedRequestInfo.status) {
        case 400:
          return new PineconeBadRequestError(failedRequestInfo);
        case 401:
          return new PineconeAuthorizationError(failedRequestInfo);
        case 404:
          return new PineconeNotFoundError(failedRequestInfo);
        case 409:
          return new PineconeConflictError(failedRequestInfo);
        case 500:
          return new PineconeInternalServerError(failedRequestInfo);
        case 501:
          return new PineconeNotImplementedError(failedRequestInfo);
        default:
          throw new PineconeUnmappedHttpError(failedRequestInfo);
      }
    };
    exports.mapHttpStatusError = mapHttpStatusError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/request.js
var require_request = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/request.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeConnectionError = void 0;
    var base_1 = require_base();
    var PineconeConnectionError = (
      /** @class */
      function(_super) {
        __extends(PineconeConnectionError2, _super);
        function PineconeConnectionError2() {
          var _this = _super.call(this, "Request failed to reach Pinecone. Verify you have the correct environment, project id, and index name configured.") || this;
          _this.name = "PineconeConnectionError";
          return _this;
        }
        return PineconeConnectionError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConnectionError = PineconeConnectionError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/validation.js
var require_validation = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/validation.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeArgumentError = void 0;
    var base_1 = require_base();
    var PineconeArgumentError = (
      /** @class */
      function(_super) {
        __extends(PineconeArgumentError2, _super);
        function PineconeArgumentError2(message) {
          var _this = _super.call(this, "".concat(message)) || this;
          _this.name = "PineconeArgumentError";
          return _this;
        }
        return PineconeArgumentError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeArgumentError = PineconeArgumentError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/utils.js
var require_utils = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractMessage = void 0;
    var extractMessage = function(error) {
      return __awaiter(void 0, void 0, void 0, function() {
        var message, messageJSON;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, error.response.text()];
            case 1:
              message = _a2.sent();
              try {
                messageJSON = JSON.parse(message);
                if (messageJSON.message) {
                  message = messageJSON.message;
                }
              } catch (e) {
              }
              return [2, message];
          }
        });
      });
    };
    exports.extractMessage = extractMessage;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/handling.js
var require_handling = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/handling.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleApiError = exports.handleFetchError = void 0;
    var utils_1 = require_utils();
    var http_1 = require_http();
    var request_1 = require_request();
    var handleFetchError = function(e, handleResponseError) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(e instanceof Error && e.name === "FetchError"))
                return [3, 1];
              return [2, new request_1.PineconeConnectionError()];
            case 1:
              return [4, handleResponseError(e)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleFetchError = handleFetchError;
    var handleApiError = function(e, customMessage) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, (0, exports.handleFetchError)(e, function(responseError) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var rawMessage, statusCode, message, _a3;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        return [4, (0, utils_1.extractMessage)(responseError)];
                      case 1:
                        rawMessage = _b.sent();
                        statusCode = responseError.response.status;
                        if (!customMessage)
                          return [3, 3];
                        return [4, customMessage(statusCode, rawMessage)];
                      case 2:
                        _a3 = _b.sent();
                        return [3, 4];
                      case 3:
                        _a3 = rawMessage;
                        _b.label = 4;
                      case 4:
                        message = _a3;
                        return [2, (0, http_1.mapHttpStatusError)({
                          status: responseError.response.status,
                          url: responseError.response.url,
                          message
                        })];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleApiError = handleApiError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/upsert.js
var require_upsert = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/upsert.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeBatchUpsertError = void 0;
    var base_1 = require_base();
    var PineconeBatchUpsertError = (
      /** @class */
      function(_super) {
        __extends(PineconeBatchUpsertError2, _super);
        function PineconeBatchUpsertError2(successCount, failureCount, failures) {
          var _this = this;
          var maxErrors = 3;
          if (failures.length > maxErrors) {
            failures = failures.slice(0, maxErrors);
            failures.push("...and ".concat(failureCount - maxErrors, " other errors"));
          }
          _this = _super.call(this, "".concat(failureCount, " out of ").concat(failureCount + successCount, " upserts failed. \n	").concat(failures.join("\n	"))) || this;
          _this.name = "PineconeBatchUpsertError";
          return _this;
        }
        return PineconeBatchUpsertError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeBatchUpsertError = PineconeBatchUpsertError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/index.js
var require_errors = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeBatchUpsertError = exports.handleApiError = exports.extractMessage = exports.PineconeArgumentError = exports.PineconeConnectionError = exports.PineconeUnknownRequestFailure = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
    var config_1 = require_config();
    Object.defineProperty(exports, "PineconeConfigurationError", { enumerable: true, get: function() {
      return config_1.PineconeConfigurationError;
    } });
    Object.defineProperty(exports, "PineconeUnexpectedResponseError", { enumerable: true, get: function() {
      return config_1.PineconeUnexpectedResponseError;
    } });
    Object.defineProperty(exports, "PineconeEnvironmentVarsNotSupportedError", { enumerable: true, get: function() {
      return config_1.PineconeEnvironmentVarsNotSupportedError;
    } });
    Object.defineProperty(exports, "PineconeUnknownRequestFailure", { enumerable: true, get: function() {
      return config_1.PineconeUnknownRequestFailure;
    } });
    __exportStar(require_http(), exports);
    var request_1 = require_request();
    Object.defineProperty(exports, "PineconeConnectionError", { enumerable: true, get: function() {
      return request_1.PineconeConnectionError;
    } });
    var validation_1 = require_validation();
    Object.defineProperty(exports, "PineconeArgumentError", { enumerable: true, get: function() {
      return validation_1.PineconeArgumentError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "extractMessage", { enumerable: true, get: function() {
      return utils_1.extractMessage;
    } });
    var handling_1 = require_handling();
    Object.defineProperty(exports, "handleApiError", { enumerable: true, get: function() {
      return handling_1.handleApiError;
    } });
    var upsert_1 = require_upsert();
    Object.defineProperty(exports, "PineconeBatchUpsertError", { enumerable: true, get: function() {
      return upsert_1.PineconeBatchUpsertError;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        super.optimizeNames(names, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError2(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError2(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError2(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/json-schema-traverse/index.js"(exports, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/data.json"(exports, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports.default = Ajv;
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/ajv.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module2.exports = exports = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEdge = void 0;
    var isEdge = function() {
      return typeof EdgeRuntime === "string";
    };
    exports.isEdge = isEdge;
  }
});

// node_modules/@pinecone-database/pinecone/dist/validator.js
var require_validator = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/validator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildConfigValidator = exports.buildValidator = exports.errorFormatter = void 0;
    var ajv_1 = __importDefault(require_ajv());
    var errors_1 = require_errors();
    var environment_1 = require_environment();
    var prepend = function(prefix, message) {
      return "".concat(prefix, " ").concat(message);
    };
    var schemaPathPropNameRegex = /properties\/(.+)\//;
    var schemaPathArrayPropNameRegex = /properties\/(.+)\/items/;
    var schemaPathGroupNumberRegex = /anyOf\/(\d+)\/(.+)/;
    var instancePathItemIndexRegex = /(\d+)$/;
    var maxErrors = 3;
    var formatIndividualError = function(e, formattedMessageList) {
      if (e.schemaPath.indexOf("properties") > -1) {
        if (e.schemaPath.indexOf("items") > -1) {
          var propNameMatch = schemaPathArrayPropNameRegex.exec(e.schemaPath);
          var propName = propNameMatch ? propNameMatch[1] : "unknown";
          var itemIndexMatch = instancePathItemIndexRegex.exec(e.instancePath);
          var itemIndex = itemIndexMatch ? itemIndexMatch[1] : "unknown";
          formattedMessageList.push("item at index ".concat(itemIndex, " of the '").concat(propName, "' array ").concat(e.message));
        } else {
          var propNameMatch = schemaPathPropNameRegex.exec(e.schemaPath);
          var propName = propNameMatch ? propNameMatch[1] : "unknown";
          formattedMessageList.push("property '".concat(propName, "' ").concat(e.message));
        }
      } else if (e.schemaPath.indexOf("items") > -1) {
        var itemIndexMatch = instancePathItemIndexRegex.exec(e.instancePath);
        var itemIndex = itemIndexMatch ? itemIndexMatch[1] : "unknown";
        formattedMessageList.push("item at index ".concat(itemIndex, " of the array ").concat(e.message));
      } else if (e.instancePath === "") {
        formattedMessageList.push("argument ".concat(e.message));
      }
    };
    var missingPropertiesErrors = function(subject, errors, messageParts) {
      var missingPropertyNames = errors.filter(function(error) {
        return error.keyword === "required";
      }).map(function(error) {
        return error.params.missingProperty !== void 0 ? error.params.missingProperty : "unknown";
      });
      if (missingPropertyNames.length > 0) {
        var missingMessage = prepend(subject, "".concat(messageParts.length > 0 ? "M" : "m", "ust have required ").concat(missingPropertyNames.length > 1 ? "properties" : "property", ": ").concat(missingPropertyNames.join(", "), "."));
        messageParts.push(missingMessage);
      }
    };
    var neverErrors = function(subject, errors, messageParts) {
      var neverPropertyErrors = errors.filter(function(error) {
        return error.keyword === "not";
      }).map(function(error) {
        return error.instancePath.slice(1);
      });
      if (neverPropertyErrors.length > 0) {
        var neverMessage = prepend(subject, "must not have ".concat(neverPropertyErrors.length > 1 ? "properties" : "property", ": ").concat(neverPropertyErrors.join(", "), "."));
        messageParts.push(neverMessage);
      }
    };
    var typeErrors = function(subject, errors, messageParts) {
      var typeErrorsList = [];
      var errorCount = 0;
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e.keyword === "type") {
          errorCount += 1;
          if (errorCount <= maxErrors) {
            formatIndividualError(e, typeErrorsList);
          }
        }
      }
      if (errorCount > maxErrors) {
        typeErrorsList.push("and ".concat(errorCount - maxErrors, " other errors"));
      }
      if (typeErrorsList.length > 0) {
        var prefix = messageParts.length > 0 ? "There were also type errors:" : "".concat(subject, " had type errors:");
        var typeErrorMessage = prepend(prefix, typeErrorsList.join(", ")) + ".";
        messageParts.push(typeErrorMessage);
      }
    };
    var validationErrors = function(subject, errors, messageParts) {
      var validationErrors2 = [];
      var errorCount = 0;
      for (var _i = 0, errors_2 = errors; _i < errors_2.length; _i++) {
        var e = errors_2[_i];
        if (e.keyword === "minLength" && e.params.limit === 1) {
          e.message = "must not be blank";
        }
        switch (e.keyword) {
          case "minimum":
          case "maximum":
          case "exclusiveMinimum":
          case "exclusiveMaximum":
          case "minLength":
          case "maxLength":
          case "maxProperties":
          case "minProperties":
          case "minItems":
          case "maxItems":
          case "additionalItems":
          case "additionalProperties":
            errorCount += 1;
            if (errorCount > maxErrors) {
              continue;
            } else {
              formatIndividualError(e, validationErrors2);
            }
            break;
          default:
        }
      }
      if (errorCount > maxErrors) {
        validationErrors2.push("and ".concat(errorCount - maxErrors, " other errors"));
      }
      if (validationErrors2.length > 0) {
        var prefix = messageParts.length > 0 ? "There were also validation errors:" : "".concat(subject, " had validation errors:");
        var validationErrorMessage = prepend(prefix, validationErrors2.join(", ")) + ".";
        messageParts.push(validationErrorMessage);
      }
    };
    var errorFormatter = function(subject, errors) {
      var anyOfErrors = errors.filter(function(error2) {
        return error2.schemaPath.indexOf("anyOf") > -1 && error2.keyword !== "anyOf";
      });
      if (anyOfErrors.length > 0) {
        var groups = {};
        for (var _i = 0, anyOfErrors_1 = anyOfErrors; _i < anyOfErrors_1.length; _i++) {
          var error = anyOfErrors_1[_i];
          var schemaPathMatch = schemaPathGroupNumberRegex.exec(error.schemaPath);
          var groupNumber = schemaPathMatch ? schemaPathMatch[1] : "unknown";
          error.schemaPath = schemaPathMatch ? schemaPathMatch[2] : "unknown";
          if (groups[groupNumber]) {
            groups[groupNumber].push(error);
          } else {
            groups[groupNumber] = [error];
          }
        }
        return "".concat(subject, " accepts multiple types. Either ") + Object.entries(groups).map(function(_a2) {
          var key = _a2[0], group = _a2[1];
          return "".concat(parseInt(key) + 1, ")") + (0, exports.errorFormatter)("", group);
        }).join(" ");
      }
      var messageParts = [];
      neverErrors(subject, errors, messageParts);
      missingPropertiesErrors(subject, errors, messageParts);
      typeErrors(subject, errors, messageParts);
      validationErrors(subject, errors, messageParts);
      return messageParts.join(" ");
    };
    exports.errorFormatter = errorFormatter;
    var buildValidator = function(errorMessagePrefix, schema) {
      if ((0, environment_1.isEdge)()) {
        return function(data) {
        };
      }
      if (process && process.env && process.env.PINECONE_DISABLE_RUNTIME_VALIDATIONS) {
        return function(data) {
        };
      }
      var ajv = new ajv_1.default({ allErrors: true });
      var validate = ajv.compile(schema);
      return function(data) {
        var valid = validate(data);
        if (!valid) {
          var errors = validate.errors || [];
          var msg = (0, exports.errorFormatter)(errorMessagePrefix, errors);
          throw new errors_1.PineconeArgumentError(msg);
        }
        return data;
      };
    };
    exports.buildValidator = buildValidator;
    var buildConfigValidator = function(schema, methodName) {
      var prefix = "The argument to ".concat(methodName);
      return (0, exports.buildValidator)(prefix, schema);
    };
    exports.buildConfigValidator = buildConfigValidator;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/utils.js
var require_utils2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleCollectionRequestError = exports.handleIndexRequestError = exports.validCollectionMessage = exports.validIndexMessage = void 0;
    var errors_1 = require_errors();
    var validIndexMessage = function(api, name) {
      return __awaiter(void 0, void 0, void 0, function() {
        var validNames, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, api.listIndexes()];
            case 1:
              validNames = _a2.sent();
              return [2, "Index '".concat(name, "' does not exist. Valid index names: [").concat(validNames.map(function(n) {
                return "'".concat(n, "'");
              }).join(", "), "]")];
            case 2:
              e_1 = _a2.sent();
              return [2, "Index '".concat(name, "' does not exist.")];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.validIndexMessage = validIndexMessage;
    var validCollectionMessage = function(api, name) {
      return __awaiter(void 0, void 0, void 0, function() {
        var validNames, e_2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, api.listCollections()];
            case 1:
              validNames = _a2.sent();
              return [2, "Collection '".concat(name, "' does not exist. Valid collection names: [").concat(validNames.map(function(n) {
                return "'".concat(n, "'");
              }).join(", "), "]")];
            case 2:
              e_2 = _a2.sent();
              return [2, "Collection '".concat(name, "' does not exist.")];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.validCollectionMessage = validCollectionMessage;
    var handleIndexRequestError = function(e, api, indexName) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, (0, errors_1.handleApiError)(e, function(statusCode, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var _a3;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        if (!(statusCode === 404))
                          return [3, 2];
                        return [4, (0, exports.validIndexMessage)(api, indexName)];
                      case 1:
                        _a3 = _b.sent();
                        return [3, 3];
                      case 2:
                        _a3 = rawMessageText;
                        _b.label = 3;
                      case 3:
                        return [2, _a3];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleIndexRequestError = handleIndexRequestError;
    var handleCollectionRequestError = function(e, api, collectionName) {
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, (0, errors_1.handleApiError)(e, function(statusCode, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var _a3;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        if (!(statusCode === 404))
                          return [3, 2];
                        return [4, (0, exports.validCollectionMessage)(api, collectionName)];
                      case 1:
                        _a3 = _b.sent();
                        return [3, 3];
                      case 2:
                        _a3 = rawMessageText;
                        _b.label = 3;
                      case 3:
                        return [2, _a3];
                    }
                  });
                });
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    exports.handleCollectionRequestError = handleCollectionRequestError;
  }
});

// node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "node_modules/@sinclair/typebox/typebox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;
    exports.Modifier = Symbol.for("TypeBox.Modifier");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Has(kind2) {
        return map.has(kind2);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind2, func) {
        map.set(kind2, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind2) {
        return map.get(kind2);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var TypeGuardUnknownTypeError = class extends Error {
      constructor(schema) {
        super("TypeGuard: Unknown type");
        this.schema = schema;
      }
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsObject(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
      }
      function IsArray(value) {
        return typeof value === "object" && value !== null && Array.isArray(value);
      }
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (typeof value !== "string")
          return false;
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      function IsString(value) {
        return typeof value === "string";
      }
      function IsNumber(value) {
        return typeof value === "number" && globalThis.Number.isFinite(value);
      }
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      function IsOptionalBigInt(value) {
        return value === void 0 || value !== void 0 && IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return value === void 0 || value !== void 0 && IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return value === void 0 || value !== void 0 && IsBoolean(value);
      }
      function IsOptionalString(value) {
        return value === void 0 || value !== void 0 && IsString(value);
      }
      function IsOptionalPattern(value) {
        return value === void 0 || value !== void 0 && IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return value === void 0 || value !== void 0 && IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return value === void 0 || TSchema(value);
      }
      function TAny(schema) {
        return TKind(schema) && schema[exports.Kind] === "Any" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema) {
        return TKind(schema) && schema[exports.Kind] === "Array" && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems);
      }
      TypeGuard2.TArray = TArray;
      function TBigInt(schema) {
        return TKind(schema) && schema[exports.Kind] === "BigInt" && schema.type === "null" && schema.typeOf === "BigInt" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema) {
        return TKind(schema) && schema[exports.Kind] === "Boolean" && schema.type === "boolean" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Constructor" && schema.type === "object" && schema.instanceOf === "Constructor" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {
          return false;
        }
        for (const parameter of schema.parameters) {
          if (!TSchema(parameter))
            return false;
        }
        return true;
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema) {
        return TKind(schema) && schema[exports.Kind] === "Date" && schema.type === "object" && schema.instanceOf === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Function" && schema.type === "object" && schema.instanceOf === "Function" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {
          return false;
        }
        for (const parameter of schema.parameters) {
          if (!TSchema(parameter))
            return false;
        }
        return true;
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema) {
        return TKind(schema) && schema[exports.Kind] === "Integer" && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Intersect" && IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id))) {
          return false;
        }
        if ("type" in schema && schema.type !== "object") {
          return false;
        }
        for (const inner of schema.allOf) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TIntersect = TIntersect;
      function TKind(schema) {
        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === "string";
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "string";
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "number";
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "boolean";
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema) {
        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema) {
        return TKind(schema) && schema[exports.Kind] === "Never" && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema) {
        return TKind(schema) && schema[exports.Kind] === "Not" && TSchema(schema.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema) {
        return TKind(schema) && schema[exports.Kind] === "Null" && schema.type === "null" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema) {
        return TKind(schema) && schema[exports.Kind] === "Number" && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Object" && schema.type === "object" && IsOptionalString(schema.$id) && IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) {
          return false;
        }
        for (const [key, value] of Object.entries(schema.properties)) {
          if (!IsControlCharacterFree(key))
            return false;
          if (!TSchema(value))
            return false;
        }
        return true;
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema) {
        return TKind(schema) && schema[exports.Kind] === "Promise" && schema.type === "object" && schema.instanceOf === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Record" && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && IsObject(schema.patternProperties))) {
          return false;
        }
        const keys = Object.keys(schema.patternProperties);
        if (keys.length !== 1) {
          return false;
        }
        if (!IsPattern(keys[0])) {
          return false;
        }
        if (!TSchema(schema.patternProperties[keys[0]])) {
          return false;
        }
        return true;
      }
      TypeGuard2.TRecord = TRecord;
      function TRef(schema) {
        return TKind(schema) && schema[exports.Kind] === "Ref" && IsOptionalString(schema.$id) && IsString(schema.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema) {
        return TKind(schema) && schema[exports.Kind] === "String" && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema) {
        return TKind(schema) && schema[exports.Kind] === "Symbol" && schema.type === "null" && schema.typeOf === "Symbol" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema) {
        return TKind(schema) && schema[exports.Kind] === "TemplateLiteral" && schema.type === "string" && IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema) {
        return TKind(schema) && schema[exports.Kind] === "This" && IsOptionalString(schema.$id) && IsString(schema.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTuple(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Tuple" && schema.type === "array" && IsOptionalString(schema.$id) && IsNumber(schema.minItems) && IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) {
          return false;
        }
        if (schema.items === void 0 && schema.additionalItems === void 0 && schema.minItems === 0) {
          return true;
        }
        if (!IsArray(schema.items)) {
          return false;
        }
        for (const inner of schema.items) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema) {
        return TKind(schema) && schema[exports.Kind] === "Undefined" && schema.type === "null" && schema.typeOf === "Undefined" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Union" && IsArray(schema.anyOf) && IsOptionalString(schema.$id))) {
          return false;
        }
        for (const inner of schema.anyOf) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema) {
        return TKind(schema) && schema[exports.Kind] === "Uint8Array" && schema.type === "object" && IsOptionalString(schema.$id) && schema.instanceOf === "Uint8Array" && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema) {
        return TKind(schema) && schema[exports.Kind] === "Unknown" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema) {
        return TKind(schema) && schema[exports.Kind] === "Unsafe";
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema) {
        return TKind(schema) && schema[exports.Kind] === "Void" && schema.type === "null" && schema.typeOf === "Void" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonlyOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "ReadonlyOptional";
      }
      TypeGuard2.TReadonlyOptional = TReadonlyOptional;
      function TReadonly(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema) {
        return typeof schema === "object" && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema) {
        if (schema[exports.Kind] === "Undefined")
          return true;
        if (schema[exports.Kind] === "Not") {
          return !Check(schema.not);
        }
        if (schema[exports.Kind] === "Intersect") {
          const intersect = schema;
          return intersect.allOf.every((schema2) => Check(schema2));
        }
        if (schema[exports.Kind] === "Union") {
          const union = schema;
          return union.anyOf.some((schema2) => Check(schema2));
        }
        return false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function AnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function Any(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))
          return TypeExtendsResult.True;
        if (TypeGuard.TUnion(right))
          return TypeExtendsResult.Union;
        if (TypeGuard.TUnknown(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TAny(right))
          return TypeExtendsResult.True;
        return TypeExtendsResult.Union;
      }
      function ArrayRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        return TypeExtendsResult.False;
      }
      function Array2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TArray(right))
          return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
      }
      function BigInt(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function BooleanRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "boolean")
          return TypeExtendsResult.True;
        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Boolean2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Constructor(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TConstructor(right))
          return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
          return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
          return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function Date2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Function2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TFunction(right))
          return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
          return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
          return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function IntegerRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "number")
          return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Integer(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Intersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsLiteralString(schema) {
        return typeof schema.const === "string";
      }
      function IsLiteralNumber(schema) {
        return typeof schema.const === "number";
      }
      function IsLiteralBoolean(schema) {
        return typeof schema.const === "boolean";
      }
      function Literal(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (TypeGuard.TString(right))
          return StringRight(left, right);
        if (TypeGuard.TNumber(right))
          return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
          return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
          return BooleanRight(left, right);
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function NeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function Never(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function Not(left, right) {
        if (TypeGuard.TNot(left))
          return Visit(UnwrapNot(left), right);
        if (TypeGuard.TNot(right))
          return Visit(left, UnwrapNot(right));
        throw new Error(`TypeExtends: Invalid fallthrough for Not`);
      }
      function Null(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function NumberRight(left, right) {
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))
          return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Number2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema, count) {
        return globalThis.Object.keys(schema.properties).length === count;
      }
      function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        if (Visit(left, right) === TypeExtendsResult.False)
          return TypeExtendsResult.False;
        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))
          return TypeExtendsResult.False;
        return TypeExtendsResult.True;
      }
      function ObjectRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TString(left) && IsObjectStringLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TDate(left) && IsObjectDateLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {
          return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        return TypeExtendsResult.False;
      }
      function Object2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (!TypeGuard.TObject(right))
          return TypeExtendsResult.False;
        for (const key of globalThis.Object.keys(right.properties)) {
          if (!(key in left.properties))
            return TypeExtendsResult.False;
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      }
      function Promise2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TPromise(right))
          return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
          return exports.Type.Number();
        if (exports.PatternStringExact in schema.patternProperties)
          return exports.Type.String();
        throw Error("TypeExtends: Cannot get record key");
      }
      function RecordValue(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
          return schema.patternProperties[exports.PatternNumberExact];
        if (exports.PatternStringExact in schema.patternProperties)
          return schema.patternProperties[exports.PatternStringExact];
        throw Error("TypeExtends: Cannot get record value");
      }
      function RecordRight(left, right) {
        const Key = RecordKey(right);
        const Value = RecordValue(right);
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)
          return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TObject(left)) {
          for (const key of globalThis.Object.keys(left.properties)) {
            if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        }
        return TypeExtendsResult.False;
      }
      function Record(left, right) {
        const Value = RecordValue(left);
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TRecord(right))
          return TypeExtendsResult.False;
        return Visit(Value, RecordValue(right));
      }
      function StringRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "string")
          return TypeExtendsResult.True;
        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function String2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Symbol2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TemplateLiteral(left, right) {
        if (TypeGuard.TTemplateLiteral(left))
          return Visit(TemplateLiteralResolver.Resolve(left), right);
        if (TypeGuard.TTemplateLiteral(right))
          return Visit(left, TemplateLiteralResolver.Resolve(right));
        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);
      }
      function TupleRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        return TypeExtendsResult.False;
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
      }
      function Tuple(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TTuple(right))
          return TypeExtendsResult.False;
        if (left.items === void 0 && right.items !== void 0 || left.items !== void 0 && right.items === void 0)
          return TypeExtendsResult.False;
        if (left.items === void 0 && right.items === void 0)
          return TypeExtendsResult.True;
        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Uint8Array2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Undefined(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (TypeGuard.TVoid(right))
          return VoidRight(left, right);
        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function UnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Union(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function UnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function Unknown(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TString(right))
          return StringRight(left, right);
        if (TypeGuard.TNumber(right))
          return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
          return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
          return BooleanRight(left, right);
        if (TypeGuard.TArray(right))
          return ArrayRight(left, right);
        if (TypeGuard.TTuple(right))
          return TupleRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        if (TypeGuard.TUndefined(left))
          return TypeExtendsResult.True;
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Void(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))
          return TemplateLiteral(left, right);
        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))
          return Not(left, right);
        if (TypeGuard.TAny(left))
          return Any(left, right);
        if (TypeGuard.TArray(left))
          return Array2(left, right);
        if (TypeGuard.TBigInt(left))
          return BigInt(left, right);
        if (TypeGuard.TBoolean(left))
          return Boolean2(left, right);
        if (TypeGuard.TConstructor(left))
          return Constructor(left, right);
        if (TypeGuard.TDate(left))
          return Date2(left, right);
        if (TypeGuard.TFunction(left))
          return Function2(left, right);
        if (TypeGuard.TInteger(left))
          return Integer(left, right);
        if (TypeGuard.TIntersect(left))
          return Intersect(left, right);
        if (TypeGuard.TLiteral(left))
          return Literal(left, right);
        if (TypeGuard.TNever(left))
          return Never(left, right);
        if (TypeGuard.TNull(left))
          return Null(left, right);
        if (TypeGuard.TNumber(left))
          return Number2(left, right);
        if (TypeGuard.TObject(left))
          return Object2(left, right);
        if (TypeGuard.TRecord(left))
          return Record(left, right);
        if (TypeGuard.TString(left))
          return String2(left, right);
        if (TypeGuard.TSymbol(left))
          return Symbol2(left, right);
        if (TypeGuard.TTuple(left))
          return Tuple(left, right);
        if (TypeGuard.TPromise(left))
          return Promise2(left, right);
        if (TypeGuard.TUint8Array(left))
          return Uint8Array2(left, right);
        if (TypeGuard.TUndefined(left))
          return Undefined(left, right);
        if (TypeGuard.TUnion(left))
          return Union(left, right);
        if (TypeGuard.TUnknown(left))
          return Unknown(left, right);
        if (TypeGuard.TVoid(left))
          return Void(left, right);
        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      function IsArray(value) {
        return globalThis.Array.isArray(value);
      }
      function Array2(value) {
        return value.map((value2) => Visit(value2));
      }
      function Object2(value) {
        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {
          return { ...acc, [key]: Visit(value[key]) };
        }, {});
        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {
          return { ...acc, [key]: Visit(value[key]) };
        }, {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        if (IsArray(value))
          return Array2(value);
        if (IsObject(value))
          return Object2(value);
        return value;
      }
      function Clone(schema, options) {
        return { ...Visit(schema), ...options };
      }
      TypeClone2.Clone = Clone;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema) {
        return schema.map((schema2) => {
          const { [exports.Modifier]: _, ...clone } = TypeClone.Clone(schema2, {});
          return clone;
        });
      }
      function IsIntersectOptional(schema) {
        return schema.every((schema2) => TypeGuard.TOptional(schema2));
      }
      function IsUnionOptional(schema) {
        return schema.some((schema2) => TypeGuard.TOptional(schema2));
      }
      function ResolveIntersect(schema) {
        const optional = IsIntersectOptional(schema.allOf);
        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
      }
      function ResolveUnion(schema) {
        const optional = IsUnionOptional(schema.anyOf);
        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
      }
      function ResolveOptional(schema) {
        if (schema[exports.Kind] === "Intersect")
          return ResolveIntersect(schema);
        if (schema[exports.Kind] === "Union")
          return ResolveUnion(schema);
        return schema;
      }
      function Intersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema2) => {
          const indexed = Visit(schema2, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function Union(schema, key) {
        const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function Object2(schema, key) {
        const property = schema.properties[key];
        return property === void 0 ? exports.Type.Never() : exports.Type.Union([property]);
      }
      function Tuple(schema, key) {
        const items = schema.items;
        if (items === void 0)
          return exports.Type.Never();
        const element = items[key];
        if (element === void 0)
          return exports.Type.Never();
        return element;
      }
      function Visit(schema, key) {
        if (schema[exports.Kind] === "Intersect")
          return Intersect(schema, key);
        if (schema[exports.Kind] === "Union")
          return Union(schema, key);
        if (schema[exports.Kind] === "Object")
          return Object2(schema, key);
        if (schema[exports.Kind] === "Tuple")
          return Tuple(schema, key);
        return exports.Type.Never();
      }
      function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function Intersect(schema, callback) {
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function Union(schema, callback) {
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function Object2(schema, callback) {
        return callback(schema);
      }
      function Visit(schema, callback) {
        if (schema[exports.Kind] === "Intersect")
          return Intersect(schema, callback);
        if (schema[exports.Kind] === "Union")
          return Union(schema, callback);
        if (schema[exports.Kind] === "Object")
          return Object2(schema, callback);
        return schema;
      }
      function Map2(schema, callback, options) {
        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function Intersect(schema, options) {
        return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
      }
      function Union(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function Object2(schema, options) {
        return globalThis.Object.keys(schema.properties);
      }
      function Record(schema, options) {
        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];
      }
      function Visit(schema, options) {
        if (TypeGuard.TIntersect(schema))
          return Intersect(schema, options);
        if (TypeGuard.TUnion(schema))
          return Union(schema, options);
        if (TypeGuard.TObject(schema))
          return Object2(schema, options);
        if (TypeGuard.TRecord(schema))
          return Record(schema, options);
        return [];
      }
      function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema) {
        if (globalThis.Array.isArray(schema))
          return schema;
        if (TypeGuard.TUnionLiteral(schema))
          return schema.anyOf.map((schema2) => schema2.const.toString());
        if (TypeGuard.TLiteral(schema))
          return [schema.const];
        if (TypeGuard.TTemplateLiteral(schema)) {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw Error("KeyArrayResolver: Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        }
        return [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* Union(union) {
        for (const schema of union.anyOf) {
          if (schema[exports.Kind] === "Union") {
            yield* Union(schema);
          } else {
            yield schema;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...Union(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema, acc) {
        if (TypeGuard.TTemplateLiteral(schema)) {
          const pattern = schema.pattern.slice(1, schema.pattern.length - 1);
          return pattern;
        } else if (TypeGuard.TUnion(schema)) {
          const tokens = schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|");
          return `(${tokens})`;
        } else if (TypeGuard.TNumber(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TInteger(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TBigInt(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TString(schema)) {
          return `${acc}${exports.PatternString}`;
        } else if (TypeGuard.TLiteral(schema)) {
          return `${acc}${Escape(schema.const.toString())}`;
        } else if (TypeGuard.TBoolean(schema)) {
          return `${acc}${exports.PatternBoolean}`;
        } else if (TypeGuard.TNever(schema)) {
          throw Error("TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever");
        } else {
          throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);
        }
      }
      function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    var TemplateLiteralParserError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
      }
      function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, "(");
      }
      function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ")");
      }
      function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, "|");
      }
      function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
          return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (count === 0 && index !== pattern.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
      }
      function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            return true;
        }
        return false;
      }
      function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0) {
            const range2 = pattern.slice(start, index);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            start = index + 1;
          }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
          expressions.push(Parse(range));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern) {
        function Group(value, index) {
          if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern2, index) {
          for (let scan = index; scan < pattern2.length; scan++) {
            if (IsOpenParen(pattern2, scan))
              return [index, scan];
          }
          return [index, pattern2.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(Parse(range));
            index = end;
          } else {
            const [start, end] = Range(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
              expressions.push(Parse(range));
            index = end - 1;
          }
        }
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "and", expr: expressions };
      }
      function Parse(pattern) {
        if (IsGroup(pattern))
          return Parse(InGroup(pattern));
        if (IsPrecedenceOr(pattern))
          return Or(pattern);
        if (IsPrecedenceAnd(pattern))
          return And(pattern);
        return { type: "const", const: pattern };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        if (IsBoolean(expression))
          return true;
        if (IsNumber(expression) || IsString(expression))
          return false;
        if (expression.type === "and")
          return expression.expr.every((expr) => Check(expr));
        if (expression.type === "or")
          return expression.expr.every((expr) => Check(expr));
        if (expression.type === "const")
          return true;
        throw Error(`TemplateLiteralFinite: Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1)
          return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        if (expression.type === "and")
          return yield* And(expression);
        if (expression.type === "or")
          return yield* Or(expression);
        if (expression.type === "const")
          return yield* Const(expression);
        throw Error("TemplateLiteralGenerator: Unknown expression");
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        if (trim === "boolean")
          return yield exports.Type.Boolean();
        if (trim === "number")
          return yield exports.Type.Number();
        if (trim === "bigint")
          return yield exports.Type.BigInt();
        if (trim === "string")
          return yield exports.Type.String();
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L = exports.Type.Literal("$");
          const R = ParseLiteral(template.slice(1));
          return yield* [L, ...R];
        }
        for (let i = 2; i < template.length; i++) {
          if (template[i] === "}") {
            const L = ParseUnion(template.slice(2, i));
            const R = ParseLiteral(template.slice(i + 1));
            return yield* [...L, ...R];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i = 0; i < template.length; i++) {
          if (template[i] === "$") {
            const L = exports.Type.Literal(template.slice(0, i));
            const R = ParseTerminal(template.slice(i));
            return yield* [L, ...R];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    var TypeOrdinal = 0;
    var TypeBuilder = class {
      /** `[Utility]` Creates a schema without `static` and `params` types */
      Create(schema) {
        return schema;
      }
      /** `[Standard]` Omits compositing symbols from this schema */
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var StandardTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Modifier]` Creates a Optional property */
      Optional(schema) {
        return { [exports.Modifier]: "Optional", ...TypeClone.Clone(schema, {}) };
      }
      /** `[Modifier]` Creates a ReadonlyOptional property */
      ReadonlyOptional(schema) {
        return { [exports.Modifier]: "ReadonlyOptional", ...TypeClone.Clone(schema, {}) };
      }
      /** `[Modifier]` Creates a Readonly object or property */
      Readonly(schema) {
        return { [exports.Modifier]: "Readonly", ...schema };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Standard]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Standard]` Creates an Array type */
      Array(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Clone(items, {}) });
      }
      /** `[Standard]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Standard]` Creates a Composite object type. */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
      }
      /** `[Standard]` Creates a Enum type */
      Enum(item, options = {}) {
        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const anyOf = values.map((value) => typeof value === "string" ? { [exports.Kind]: "Literal", type: "string", const: value } : { [exports.Kind]: "Literal", type: "number", const: value });
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf });
      }
      /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Clone(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Clone(falseType, options);
        }
      }
      /** `[Standard]` Excludes from the left type any type that is not assignable to the right */
      Exclude(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
          return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
          return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
          const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
        } else {
          return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options);
        }
      }
      /** `[Standard]` Extracts from the left type any type that is assignable to the right */
      Extract(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
          return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
          return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
          const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
        } else {
          return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options);
        }
      }
      /** `[Standard]` Returns indexed property types for the given keys */
      Index(schema, unresolved, options = {}) {
        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {
          return TypeClone.Clone(schema.items, options);
        } else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {
          const items = schema.items === void 0 ? [] : schema.items;
          const cloned = items.map((schema2) => TypeClone.Clone(schema2, {}));
          return this.Union(cloned, options);
        } else {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone = TypeClone.Clone(schema, {});
          return IndexedAccessor.Resolve(clone, keys, options);
        }
      }
      /** `[Standard]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
      }
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Clone(allOf[0], options);
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};
        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {
          return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned });
        } else {
          return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
        }
      }
      /** `[Standard]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        if (TypeGuard.TRecord(schema)) {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          if (pattern === exports.PatternNumberExact)
            return this.Number(options);
          if (pattern === exports.PatternStringExact)
            return this.String(options);
          throw Error("StandardTypeBuilder: Unable to resolve key type from Record key pattern");
        } else if (TypeGuard.TTuple(schema)) {
          const items = schema.items === void 0 ? [] : schema.items;
          const literals = items.map((_, index) => exports.Type.Literal(index));
          return this.Union(literals, options);
        } else if (TypeGuard.TArray(schema)) {
          return this.Number(options);
        } else {
          const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        }
      }
      /** `[Standard]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Standard]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Standard]` Creates a Not type */
      Not(not, options) {
        return this.Create({ ...options, [exports.Kind]: "Not", not });
      }
      /** `[Standard]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
      }
      /** `[Standard]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
      }
      /** `[Standard]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});
        if (requiredKeys.length > 0) {
          return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys });
        } else {
          return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
        }
      }
      Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          if (schema2.required) {
            schema2.required = schema2.required.filter((key) => !keys.includes(key));
            if (schema2.required.length === 0)
              delete schema2.required;
          }
          for (const key of globalThis.Object.keys(schema2.properties)) {
            if (keys.includes(key))
              delete schema2.properties[key];
          }
          return this.Create(schema2);
        }, options);
      }
      /** `[Standard]` Creates a mapped type where all properties are Optional */
      Partial(schema, options = {}) {
        function Apply(schema2) {
          switch (schema2[exports.Modifier]) {
            case "ReadonlyOptional":
              schema2[exports.Modifier] = "ReadonlyOptional";
              break;
            case "Readonly":
              schema2[exports.Modifier] = "ReadonlyOptional";
              break;
            case "Optional":
              schema2[exports.Modifier] = "Optional";
              break;
            default:
              schema2[exports.Modifier] = "Optional";
              break;
          }
        }
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          delete schema2.required;
          globalThis.Object.keys(schema2.properties).forEach((key) => Apply(schema2.properties[key]));
          return schema2;
        }, options);
      }
      Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          if (schema2.required) {
            schema2.required = schema2.required.filter((key) => keys.includes(key));
            if (schema2.required.length === 0)
              delete schema2.required;
          }
          for (const key of globalThis.Object.keys(schema2.properties)) {
            if (!keys.includes(key))
              delete schema2.properties[key];
          }
          return this.Create(schema2);
        }, options);
      }
      /** `[Standard]` Creates a Record type */
      Record(key, schema, options = {}) {
        if (TypeGuard.TTemplateLiteral(key)) {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Clone(schema, {}) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) } });
        } else if (TypeGuard.TUnion(key)) {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});
            return this.Object(properties, { ...options, [exports.Hint]: "Record" });
          } else
            throw Error("TypeBuilder: Record key of type union contains non-literal types");
        } else if (TypeGuard.TLiteral(key)) {
          if (typeof key.const === "string" || typeof key.const === "number") {
            return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);
          } else
            throw Error("TypeBuilder: Record key of type literal is not of type string or number");
        } else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {
          const pattern = exports.PatternNumberExact;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });
        } else if (TypeGuard.TString(key)) {
          const pattern = key.pattern === void 0 ? exports.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });
        } else {
          throw Error(`StandardTypeBuilder: Record key is an invalid type`);
        }
      }
      /** `[Standard]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (options.$id === void 0)
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
      }
      /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */
      Ref(schema, options = {}) {
        if (schema.$id === void 0)
          throw Error("StandardTypeBuilder.Ref: Target type must specify an $id");
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: schema.$id });
      }
      /** `[Standard]` Creates a mapped type where all properties are Required */
      Required(schema, options = {}) {
        function Apply(schema2) {
          switch (schema2[exports.Modifier]) {
            case "ReadonlyOptional":
              schema2[exports.Modifier] = "Readonly";
              break;
            case "Readonly":
              schema2[exports.Modifier] = "Readonly";
              break;
            case "Optional":
              delete schema2[exports.Modifier];
              break;
            default:
              delete schema2[exports.Modifier];
              break;
          }
        }
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          schema2.required = globalThis.Object.keys(schema2.properties);
          globalThis.Object.keys(schema2.properties).forEach((key) => Apply(schema2.properties[key]));
          return schema2;
        }, options);
      }
      /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */
      Rest(schema) {
        if (TypeGuard.TTuple(schema)) {
          if (schema.items === void 0)
            return [];
          return schema.items.map((schema2) => TypeClone.Clone(schema2, {}));
        } else {
          return [TypeClone.Clone(schema, {})];
        }
      }
      /** `[Standard]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
      }
      /** `[Standard]` Creates a template literal type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern = typeof unresolved === "string" ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
      }
      /** `[Standard]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));
        const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema);
      }
      Union(union, options = {}) {
        if (TypeGuard.TTemplateLiteral(union)) {
          return TemplateLiteralResolver.Resolve(union);
        } else {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Clone(anyOf[0], options));
          const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));
          return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
        }
      }
      /** `[Standard]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Standard]` Creates a Unsafe type that infers for the generic argument */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
      }
    };
    exports.StandardTypeBuilder = StandardTypeBuilder;
    var ExtendedTypeBuilder = class extends StandardTypeBuilder {
      /** `[Extended]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "BigInt", type: "null", typeOf: "BigInt" });
      }
      /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
      }
      /** `[Extended]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
        return this.Create({ ...options, [exports.Kind]: "Constructor", type: "object", instanceOf: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[Extended]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Date", type: "object", instanceOf: "Date" });
      }
      /** `[Extended]` Creates a Function type */
      Function(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
        return this.Create({ ...options, [exports.Kind]: "Function", type: "object", instanceOf: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[Extended]` Extracts the InstanceType from the given Constructor */
      InstanceType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
      }
      /** `[Extended]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
      }
      /** `[Extended]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Promise", type: "object", instanceOf: "Promise", item: TypeClone.Clone(item, {}) });
      }
      /** `[Extended]` Creates a regular expression type */
      RegEx(regex, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern: regex.source });
      }
      /** `[Extended]` Extracts the ReturnType from the given Function */
      ReturnType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
      }
      /** `[Extended]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: "Symbol", type: "null", typeOf: "Symbol" });
      }
      /** `[Extended]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Undefined", type: "null", typeOf: "Undefined" });
      }
      /** `[Extended]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "object", instanceOf: "Uint8Array" });
      }
      /** `[Extended]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Void", type: "null", typeOf: "Void" });
      }
    };
    exports.ExtendedTypeBuilder = ExtendedTypeBuilder;
    exports.StandardType = new StandardTypeBuilder();
    exports.Type = new ExtendedTypeBuilder();
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/types.js
var require_types2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionNameSchema = exports.MetadataConfigSchema = exports.DimensionSchema = exports.MetricSchema = exports.PodsSchema = exports.ReplicasSchema = exports.PodTypeSchema = exports.IndexNameSchema = void 0;
    var typebox_1 = require_typebox();
    var nonemptyString = typebox_1.Type.String({ minLength: 1 });
    var positiveInteger = typebox_1.Type.Integer({ minimum: 1 });
    exports.IndexNameSchema = nonemptyString;
    exports.PodTypeSchema = nonemptyString;
    exports.ReplicasSchema = positiveInteger;
    exports.PodsSchema = positiveInteger;
    exports.MetricSchema = nonemptyString;
    exports.DimensionSchema = positiveInteger;
    exports.MetadataConfigSchema = typebox_1.Type.Object({
      indexed: typebox_1.Type.Array(nonemptyString)
    }, { additionalProperties: false });
    exports.CollectionNameSchema = nonemptyString;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js
var require_configureIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureIndex = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var typebox_1 = require_typebox();
    var types_1 = require_types2();
    var ConfigureIndexOptionsSchema = typebox_1.Type.Object({
      replicas: typebox_1.Type.Optional(types_1.ReplicasSchema),
      podType: typebox_1.Type.Optional(types_1.PodTypeSchema)
    }, { additionalProperties: false });
    var configureIndex = function(api) {
      var indexNameValidator = (0, validator_1.buildValidator)("The first argument to configureIndex", types_1.IndexNameSchema);
      var patchRequestValidator = (0, validator_1.buildValidator)("The second argument to configureIndex", ConfigureIndexOptionsSchema);
      return function(name, options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                indexNameValidator(name);
                patchRequestValidator(options);
                if (Object.keys(options).length === 0) {
                  throw new errors_1.PineconeArgumentError("The second argument to configureIndex should not be empty object. Please specify at least one propert (replicas, podType) to update.");
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.configureIndex({ indexName: name, patchRequest: options })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, name)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.configureIndex = configureIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js
var require_debugLog = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debugLog = void 0;
    var debugLog = function(str) {
      if (process && process.env && process.env.PINECONE_DEBUG) {
        console.log(str);
      }
    };
    exports.debugLog = debugLog;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js
var require_queryParamsStringify = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queryParamsStringify = void 0;
    function queryParamsStringify(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.queryParamsStringify = queryParamsStringify;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (Array.isArray(value)) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return queryParamsStringify(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
  }
});

// node_modules/@pinecone-database/pinecone/dist/version.json
var require_version = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/version.json"(exports, module2) {
    module2.exports = {
      name: "@pinecone-database/pinecone",
      version: "1.0.1"
    };
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js
var require_user_agent = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildUserAgent = void 0;
    var environment_1 = require_environment();
    var packageInfo = __importStar(require_version());
    var buildUserAgent = function(isLegacy) {
      var userAgentParts = [
        "".concat(packageInfo.name, " v").concat(packageInfo.version),
        "lang=typescript"
      ];
      if ((0, environment_1.isEdge)()) {
        userAgentParts.push("Edge Runtime");
      }
      if (process && process.version) {
        userAgentParts.push("node ".concat(process.version));
      }
      userAgentParts.push("legacyExport=".concat(isLegacy));
      return userAgentParts.join("; ");
    };
    exports.buildUserAgent = buildUserAgent;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers3(headers) {
          this.map = {};
          if (headers instanceof Headers3) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers3.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers3.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers3.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers3.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers3.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers3.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers3.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers3.prototype[Symbol.iterator] = Headers3.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers3(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers3(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers3();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request3.prototype);
        function Response3(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers3(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response3.prototype);
        Response3.prototype.clone = function() {
          return new Response3(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers3(this.headers),
            url: this.url
          });
        };
        Response3.error = function() {
          var response = new Response3(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response3.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response3(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request3(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response3(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers3;
          self2.Request = Request3;
          self2.Response = Response3;
        }
        exports2.Headers = Headers3;
        exports2.Request = Request3;
        exports2.Response = Response3;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/fetch.js
var require_fetch = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/fetch.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetch = void 0;
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var getFetch = function(config) {
      if (config.fetchApi) {
        return config.fetchApi;
      } else if (global.fetch) {
        return global.fetch;
      } else {
        return cross_fetch_1.default;
      }
    };
    exports.getFetch = getFetch;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetch = exports.buildUserAgent = exports.queryParamsStringify = exports.debugLog = void 0;
    var debugLog_1 = require_debugLog();
    Object.defineProperty(exports, "debugLog", { enumerable: true, get: function() {
      return debugLog_1.debugLog;
    } });
    var queryParamsStringify_1 = require_queryParamsStringify();
    Object.defineProperty(exports, "queryParamsStringify", { enumerable: true, get: function() {
      return queryParamsStringify_1.queryParamsStringify;
    } });
    var user_agent_1 = require_user_agent();
    Object.defineProperty(exports, "buildUserAgent", { enumerable: true, get: function() {
      return user_agent_1.buildUserAgent;
    } });
    var fetch_1 = require_fetch();
    Object.defineProperty(exports, "getFetch", { enumerable: true, get: function() {
      return fetch_1.getFetch;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/createIndex.js
var require_createIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/createIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIndex = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils3();
    var errors_1 = require_errors();
    var utils_2 = require_utils2();
    var typebox_1 = require_typebox();
    var types_1 = require_types2();
    var CreateIndexOptionsSchema = typebox_1.Type.Object({
      name: types_1.IndexNameSchema,
      dimension: types_1.DimensionSchema,
      metric: typebox_1.Type.Optional(types_1.MetricSchema),
      pods: typebox_1.Type.Optional(types_1.PodsSchema),
      replicas: typebox_1.Type.Optional(types_1.ReplicasSchema),
      podType: typebox_1.Type.Optional(types_1.PodTypeSchema),
      metadataConfig: typebox_1.Type.Optional(types_1.MetadataConfigSchema),
      sourceCollection: typebox_1.Type.Optional(types_1.CollectionNameSchema),
      waitUntilReady: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      suppressConflicts: typebox_1.Type.Optional(typebox_1.Type.Boolean())
    }, { additionalProperties: false });
    var createIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(CreateIndexOptionsSchema, "createIndex");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 5, , 7]);
                return [4, api.createIndex({ createRequest: options })];
              case 2:
                _a2.sent();
                if (!options.waitUntilReady)
                  return [3, 4];
                return [4, waitUntilIndexIsReady(api, options.name)];
              case 3:
                return [2, _a2.sent()];
              case 4:
                return [
                  2
                  /*return*/
                ];
              case 5:
                e_1 = _a2.sent();
                return [4, (0, utils_2.handleIndexRequestError)(e_1, api, options.name)];
              case 6:
                err = _a2.sent();
                if (options.suppressConflicts && err.name === "PineconeConflictError") {
                  return [
                    2
                    /*return*/
                  ];
                }
                throw err;
              case 7:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.createIndex = createIndex;
    var waitUntilIndexIsReady = function(api, indexName, seconds) {
      if (seconds === void 0) {
        seconds = 0;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var indexDescription, e_2, err;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 6, , 8]);
              return [4, api.describeIndex({ indexName })];
            case 1:
              indexDescription = _b.sent();
              if (!!((_a2 = indexDescription.status) === null || _a2 === void 0 ? void 0 : _a2.ready))
                return [3, 4];
              return [4, new Promise(function(r) {
                return setTimeout(r, 1e3);
              })];
            case 2:
              _b.sent();
              return [4, waitUntilIndexIsReady(api, indexName, seconds + 1)];
            case 3:
              return [2, _b.sent()];
            case 4:
              (0, utils_1.debugLog)("Index ".concat(indexName, " is ready after ").concat(seconds));
              return [
                2
                /*return*/
              ];
            case 5:
              return [3, 8];
            case 6:
              e_2 = _b.sent();
              return [4, (0, errors_1.handleApiError)(e_2, function(_, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  return __generator(this, function(_a3) {
                    return [2, "Error creating index ".concat(indexName, ": ").concat(rawMessageText)];
                  });
                });
              })];
            case 7:
              err = _b.sent();
              throw err;
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js
var require_deleteIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteIndex = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var utils_1 = require_utils2();
    var deleteIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.IndexNameSchema, "deleteIndex");
      return function(indexName) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(indexName);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.deleteIndex({ indexName })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, indexName)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteIndex = deleteIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js
var require_describeIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeIndex = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var describeIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.IndexNameSchema, "describeIndex");
      var removeDeprecatedFields = function(result) {
        if (result.database) {
          for (var _i = 0, _a2 = Object.keys(result.database); _i < _a2.length; _i++) {
            var key = _a2[_i];
            if (result.database[key] === void 0) {
              delete result.database[key];
            }
          }
        }
      };
      return function(name) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(name);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.describeIndex({ indexName: name })];
              case 2:
                result = _a2.sent();
                removeDeprecatedFields(result);
                return [2, result];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, name)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.describeIndex = describeIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js
var require_listIndexes = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listIndexes = void 0;
    var errors_1 = require_errors();
    var listIndexes = function(api) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var names, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 4]);
                return [4, api.listIndexes()];
              case 1:
                names = _a2.sent();
                return [2, names.map(function(n) {
                  return { name: n };
                })];
              case 2:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 3:
                err = _a2.sent();
                throw err;
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.listIndexes = listIndexes;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/createCollection.js
var require_createCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/createCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCollection = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var typebox_1 = require_typebox();
    var CreateCollectionOptionsSchema = typebox_1.Type.Object({
      name: types_1.CollectionNameSchema,
      source: types_1.IndexNameSchema
    }, { additionalProperties: false });
    var createCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(CreateCollectionOptionsSchema, "createCollection");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.createCollection({ createCollectionRequest: options })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleIndexRequestError)(e_1, api, options.source)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.createCollection = createCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js
var require_deleteCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteCollection = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var deleteCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.CollectionNameSchema, "deleteCollection");
      return function(collectionName) {
        return __awaiter(void 0, void 0, void 0, function() {
          var e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(collectionName);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.deleteCollection({ collectionName })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleCollectionRequestError)(e_1, api, collectionName)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteCollection = deleteCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js
var require_describeCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeCollection = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils2();
    var types_1 = require_types2();
    var describeCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.CollectionNameSchema, "describeCollection");
      return function(name) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(name);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 5]);
                return [4, api.describeCollection({ collectionName: name })];
              case 2:
                result = _a2.sent();
                return [2, {
                  name: result.name,
                  size: result.size,
                  status: result.status,
                  dimension: result.dimension,
                  recordCount: result.vectorCount
                }];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, utils_1.handleCollectionRequestError)(e_1, api, name)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.describeCollection = describeCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/listCollections.js
var require_listCollections = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/listCollections.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listCollections = void 0;
    var errors_1 = require_errors();
    var listCollections = function(api) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var results, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 4]);
                return [4, api.listCollections()];
              case 1:
                results = _a2.sent();
                return [2, results.map(function(c) {
                  return { name: c };
                })];
              case 2:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 3:
                err = _a2.sent();
                throw err;
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.listCollections = listCollections;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/index.js
var require_control = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listCollections = exports.describeCollection = exports.deleteCollection = exports.createCollection = exports.listIndexes = exports.describeIndex = exports.deleteIndex = exports.createIndex = exports.configureIndex = void 0;
    var configureIndex_1 = require_configureIndex();
    Object.defineProperty(exports, "configureIndex", { enumerable: true, get: function() {
      return configureIndex_1.configureIndex;
    } });
    var createIndex_1 = require_createIndex();
    Object.defineProperty(exports, "createIndex", { enumerable: true, get: function() {
      return createIndex_1.createIndex;
    } });
    var deleteIndex_1 = require_deleteIndex();
    Object.defineProperty(exports, "deleteIndex", { enumerable: true, get: function() {
      return deleteIndex_1.deleteIndex;
    } });
    var describeIndex_1 = require_describeIndex();
    Object.defineProperty(exports, "describeIndex", { enumerable: true, get: function() {
      return describeIndex_1.describeIndex;
    } });
    var listIndexes_1 = require_listIndexes();
    Object.defineProperty(exports, "listIndexes", { enumerable: true, get: function() {
      return listIndexes_1.listIndexes;
    } });
    var createCollection_1 = require_createCollection();
    Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
      return createCollection_1.createCollection;
    } });
    var deleteCollection_1 = require_deleteCollection();
    Object.defineProperty(exports, "deleteCollection", { enumerable: true, get: function() {
      return deleteCollection_1.deleteCollection;
    } });
    var describeCollection_1 = require_describeCollection();
    Object.defineProperty(exports, "describeCollection", { enumerable: true, get: function() {
      return describeCollection_1.describeCollection;
    } });
    var listCollections_1 = require_listCollections();
    Object.defineProperty(exports, "listCollections", { enumerable: true, get: function() {
      return listCollections_1.listCollections;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/types.js
var require_types3 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeRecordSchema = exports.RecordSparseValuesSchema = exports.RecordValuesSchema = exports.RecordIdSchema = exports.PineconeConfigurationSchema = void 0;
    var typebox_1 = require_typebox();
    exports.PineconeConfigurationSchema = typebox_1.Type.Object({
      environment: typebox_1.Type.String({ minLength: 1 }),
      apiKey: typebox_1.Type.String({ minLength: 1 }),
      projectId: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 })),
      // fetchApi is a complex type that I don't really want to recreate in the
      // form of a json schema (seems difficult and error prone). So we will
      // rely on TypeScript to guide people in the right direction here.
      // But declaring it here as Type.Any() is needed to avoid getting caught
      // in the additionalProperties check.
      fetchApi: typebox_1.Type.Optional(typebox_1.Type.Any())
    }, { additionalProperties: false });
    exports.RecordIdSchema = typebox_1.Type.String({ minLength: 1 });
    exports.RecordValuesSchema = typebox_1.Type.Array(typebox_1.Type.Number());
    exports.RecordSparseValuesSchema = typebox_1.Type.Object({
      indices: typebox_1.Type.Array(typebox_1.Type.Integer()),
      values: typebox_1.Type.Array(typebox_1.Type.Number())
    }, { additionalProperties: false });
    exports.PineconeRecordSchema = typebox_1.Type.Object({
      id: exports.RecordIdSchema,
      values: exports.RecordValuesSchema,
      sparseValues: typebox_1.Type.Optional(exports.RecordSparseValuesSchema),
      metadata: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/upsert.js
var require_upsert2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/upsert.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var RecordArray = typebox_1.Type.Array(types_1.PineconeRecordSchema);
    var UpsertCommand = (
      /** @class */
      function() {
        function UpsertCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(RecordArray, "upsert");
        }
        UpsertCommand2.prototype.run = function(records) {
          return __awaiter(this, void 0, void 0, function() {
            var api, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(records);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.upsert({
                    upsertRequest: {
                      vectors: records,
                      namespace: this.namespace
                    }
                  })];
                case 3:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return UpsertCommand2;
      }()
    );
    exports.UpsertCommand = UpsertCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/fetch.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var RecordIdsArray = typebox_1.Type.Array(types_1.RecordIdSchema, { minItems: 1 });
    var FetchCommand = (
      /** @class */
      function() {
        function FetchCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(RecordIdsArray, "fetch");
        }
        FetchCommand2.prototype.run = function(ids) {
          return __awaiter(this, void 0, void 0, function() {
            var api, response, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(ids);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.fetch({ ids, namespace: this.namespace })];
                case 3:
                  response = _a2.sent();
                  return [2, {
                    records: response.vectors,
                    namespace: response.namespace
                  }];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return FetchCommand2;
      }()
    );
    exports.FetchCommand = FetchCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/update.js
var require_update = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/update.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types3();
    var UpdateRecordOptionsSchema = typebox_1.Type.Object({
      id: types_1.RecordIdSchema,
      values: typebox_1.Type.Optional(types_1.RecordValuesSchema),
      sparseValues: typebox_1.Type.Optional(types_1.RecordSparseValuesSchema),
      metadata: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
    var UpdateCommand = (
      /** @class */
      function() {
        function UpdateCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(UpdateRecordOptionsSchema, "update");
        }
        UpdateCommand2.prototype.run = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            var requestOptions, api, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(options);
                  requestOptions = {
                    id: options["id"],
                    values: options["values"],
                    sparseValues: options["sparseValues"],
                    setMetadata: options["metadata"]
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.update({
                    updateRequest: __assign(__assign({}, requestOptions), { namespace: this.namespace })
                  })];
                case 3:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return UpdateCommand2;
      }()
    );
    exports.UpdateCommand = UpdateCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/query.js
var require_query = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/query.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryCommand = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var shared = {
      topK: typebox_1.Type.Number(),
      includeValues: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      includeMetadata: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      filter: typebox_1.Type.Optional(typebox_1.Type.Object({}))
    };
    var QueryByRecordId = typebox_1.Type.Object(__assign(__assign({}, shared), { id: types_1.RecordIdSchema, vector: typebox_1.Type.Optional(typebox_1.Type.Never()), sparseVector: typebox_1.Type.Optional(typebox_1.Type.Never()) }), { additionalProperties: false });
    var QueryByVectorValues = typebox_1.Type.Object(__assign(__assign({}, shared), { vector: types_1.RecordValuesSchema, sparseVector: typebox_1.Type.Optional(types_1.RecordSparseValuesSchema), id: typebox_1.Type.Optional(typebox_1.Type.Never()) }), { additionalProperties: false });
    var QuerySchema = typebox_1.Type.Union([QueryByRecordId, QueryByVectorValues]);
    var QueryCommand = (
      /** @class */
      function() {
        function QueryCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(QuerySchema, "query");
        }
        QueryCommand2.prototype.run = function(query) {
          return __awaiter(this, void 0, void 0, function() {
            var api, results, e_1, err;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.validator(query);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, , 6]);
                  return [4, this.apiProvider.provide()];
                case 2:
                  api = _a2.sent();
                  return [4, api.query({
                    queryRequest: __assign(__assign({}, query), { namespace: this.namespace })
                  })];
                case 3:
                  results = _a2.sent();
                  return [2, {
                    matches: results.matches,
                    namespace: this.namespace
                  }];
                case 4:
                  e_1 = _a2.sent();
                  return [4, (0, errors_1.handleApiError)(e_1)];
                case 5:
                  err = _a2.sent();
                  throw err;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return QueryCommand2;
      }()
    );
    exports.QueryCommand = QueryCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteOne.js
var require_deleteOne = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteOne.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteOne = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var deleteOne = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.RecordIdSchema, "deleteOne");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, , 6]);
                return [4, apiProvider.provide()];
              case 2:
                api = _a2.sent();
                return [4, api._delete({ deleteRequest: { ids: [options], namespace } })];
              case 3:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 4:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 5:
                err = _a2.sent();
                throw err;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteOne = deleteOne;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteMany.js
var require_deleteMany = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteMany.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteMany = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types3();
    var DeleteManyByRecordIdSchema = typebox_1.Type.Array(types_1.RecordIdSchema);
    var DeleteManyByFilterSchema = typebox_1.Type.Object({}, { additionalProperties: true, minProperties: 1 });
    var DeleteManySchema = typebox_1.Type.Union([
      DeleteManyByRecordIdSchema,
      DeleteManyByFilterSchema
    ]);
    var deleteMany = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(DeleteManySchema, "deleteMany");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var requestOptions, api, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                validator(options);
                requestOptions = {};
                if (Array.isArray(options)) {
                  requestOptions.ids = options;
                } else {
                  requestOptions.filter = options;
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, , 6]);
                return [4, apiProvider.provide()];
              case 2:
                api = _a2.sent();
                return [4, api._delete({ deleteRequest: __assign(__assign({}, requestOptions), { namespace }) })];
              case 3:
                _a2.sent();
                return [3, 6];
              case 4:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 5:
                err = _a2.sent();
                throw err;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteMany = deleteMany;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteAll.js
var require_deleteAll = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteAll.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteAll = void 0;
    var errors_1 = require_errors();
    var deleteAll = function(apiProvider, namespace) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 3, , 5]);
                return [4, apiProvider.provide()];
              case 1:
                api = _a2.sent();
                return [4, api._delete({ deleteRequest: { deleteAll: true, namespace } })];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 3:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 4:
                err = _a2.sent();
                throw err;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteAll = deleteAll;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/describeIndexStats.js
var require_describeIndexStats = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/describeIndexStats.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeIndexStats = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var DescribeIndexStatsOptionsSchema = typebox_1.Type.Object({
      filter: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
    var describeIndexStats = function(apiProvider) {
      var validator = (0, validator_1.buildConfigValidator)(DescribeIndexStatsOptionsSchema, "describeIndexStats");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, results, mappedResult, key, e_1, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (options) {
                  validator(options);
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, , 6]);
                return [4, apiProvider.provide()];
              case 2:
                api = _a2.sent();
                return [4, api.describeIndexStats({
                  describeIndexStatsRequest: __assign({}, options)
                })];
              case 3:
                results = _a2.sent();
                mappedResult = {
                  namespaces: {},
                  dimension: results.dimension,
                  indexFullness: results.indexFullness,
                  totalRecordCount: results.totalVectorCount
                };
                if (results.namespaces) {
                  for (key in results.namespaces) {
                    mappedResult.namespaces[key] = {
                      recordCount: results.namespaces[key].vectorCount
                    };
                  }
                }
                return [2, mappedResult];
              case 4:
                e_1 = _a2.sent();
                return [4, (0, errors_1.handleApiError)(e_1)];
              case 5:
                err = _a2.sent();
                throw err;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.describeIndexStats = describeIndexStats;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/projectIdSingleton.js
var require_projectIdSingleton = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/projectIdSingleton.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectIdSingleton = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils3();
    exports.ProjectIdSingleton = function() {
      var _this = this;
      var projectIds = {};
      var _fetchProjectId = function(options) {
        return __awaiter(_this, void 0, void 0, function() {
          var apiKey, environment, fetch3, _a2, url, request, response, e_1, _b, json, e_2, _c, _d, _e, _f;
          var _g;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                apiKey = options.apiKey, environment = options.environment;
                fetch3 = (0, utils_1.getFetch)(options);
                _a2 = _buildWhoamiRequest(environment, apiKey), url = _a2.url, request = _a2.request;
                _h.label = 1;
              case 1:
                _h.trys.push([1, 3, , 4]);
                return [4, fetch3(url, request)];
              case 2:
                response = _h.sent();
                return [3, 4];
              case 3:
                e_1 = _h.sent();
                if (e_1 instanceof TypeError) {
                  throw new errors_1.PineconeConfigurationError("A network error occured while attempting to connect to ".concat(url, ". Are you sure you passed the correct environment? Please check your configuration values and try again. Visit https://status.pinecone.io for overall service health information."));
                } else {
                  throw new errors_1.PineconeUnknownRequestFailure(url, e_1);
                }
                return [3, 4];
              case 4:
                if (!(response.status >= 400))
                  return [3, 6];
                _b = errors_1.mapHttpStatusError;
                _g = {
                  status: response.status,
                  url
                };
                return [4, response.text()];
              case 5:
                throw _b.apply(void 0, [(_g.message = _h.sent(), _g)]);
              case 6:
                _h.trys.push([6, 8, , 10]);
                return [4, response.json()];
              case 7:
                json = _h.sent();
                return [3, 10];
              case 8:
                e_2 = _h.sent();
                _c = errors_1.PineconeUnexpectedResponseError.bind;
                _d = [
                  void 0,
                  url,
                  response.status
                ];
                return [4, response.text()];
              case 9:
                throw new (_c.apply(errors_1.PineconeUnexpectedResponseError, _d.concat([_h.sent(), "The HTTP call succeeded but the response could not be parsed as JSON."])))();
              case 10:
                if (!!json.project_name)
                  return [3, 12];
                _e = errors_1.PineconeUnexpectedResponseError.bind;
                _f = [
                  void 0,
                  url,
                  response.status
                ];
                return [4, response.text()];
              case 11:
                throw new (_e.apply(errors_1.PineconeUnexpectedResponseError, _f.concat([_h.sent(), "The HTTP call succeeded but response did not contain expected project_name."])))();
              case 12:
                return [2, json.project_name];
            }
          });
        });
      };
      var _buildWhoamiRequest = function(environment, apiKey) {
        var url = "https://controller.".concat(environment, ".pinecone.io/actions/whoami");
        var request = {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            "Api-Key": apiKey,
            "User-Agent": (0, utils_1.buildUserAgent)(false)
          }
        };
        return { url, request };
      };
      var key = function(config) {
        return "".concat(config.apiKey, ":").concat(config.environment);
      };
      return {
        getProjectId: function(config) {
          return __awaiter(this, void 0, void 0, function() {
            var cacheKey, projectId;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  cacheKey = key(config);
                  if (!(cacheKey in projectIds))
                    return [3, 1];
                  return [2, projectIds[cacheKey]];
                case 1:
                  return [4, _fetchProjectId(config)];
                case 2:
                  projectId = _a2.sent();
                  projectIds[cacheKey] = projectId;
                  return [2, projectId];
              }
            });
          });
        },
        _reset: function() {
          for (var _i = 0, _a2 = Object.keys(projectIds); _i < _a2.length; _i++) {
            var key_1 = _a2[_i];
            delete projectIds[key_1];
          }
        },
        _set: function(config, projectId) {
          var cacheKey = key(config);
          projectIds[cacheKey] = projectId;
        }
      };
    }();
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/vectorOperationsProvider.js
var require_vectorOperationsProvider = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/vectorOperationsProvider.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorOperationsProvider = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var utils_1 = require_utils3();
    var projectIdSingleton_1 = require_projectIdSingleton();
    var basePath = function(config, indexName) {
      return "https://".concat(indexName, "-").concat(config.projectId, ".svc.").concat(config.environment, ".pinecone.io");
    };
    var VectorOperationsProvider = (
      /** @class */
      function() {
        function VectorOperationsProvider2(config, indexName) {
          this.config = config;
          this.indexName = indexName;
        }
        VectorOperationsProvider2.prototype.provide = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this.vectorOperations) {
                    return [2, this.vectorOperations];
                  }
                  if (!this.config.projectId)
                    return [3, 1];
                  this.vectorOperations = this.buildVectorOperationsConfig(this.config, this.indexName);
                  return [3, 3];
                case 1:
                  _a2 = this.config;
                  return [4, projectIdSingleton_1.ProjectIdSingleton.getProjectId(this.config)];
                case 2:
                  _a2.projectId = _b.sent();
                  this.vectorOperations = this.buildVectorOperationsConfig(this.config, this.indexName);
                  _b.label = 3;
                case 3:
                  return [2, this.vectorOperations];
              }
            });
          });
        };
        VectorOperationsProvider2.prototype.buildVectorOperationsConfig = function(config, indexName) {
          var indexConfigurationParameters = {
            basePath: basePath(config, indexName),
            apiKey: config.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
              "User-Agent": (0, utils_1.buildUserAgent)(false)
            },
            fetchApi: (0, utils_1.getFetch)(config)
          };
          var indexConfiguration = new pinecone_generated_ts_fetch_1.Configuration(indexConfigurationParameters);
          var vectorOperations = new pinecone_generated_ts_fetch_1.VectorOperationsApi(indexConfiguration);
          return vectorOperations;
        };
        return VectorOperationsProvider2;
      }()
    );
    exports.VectorOperationsProvider = VectorOperationsProvider;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/index.js
var require_data2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.PineconeConfigurationSchema = void 0;
    var upsert_1 = require_upsert2();
    var fetch_1 = require_fetch2();
    var update_1 = require_update();
    var query_1 = require_query();
    var deleteOne_1 = require_deleteOne();
    var deleteMany_1 = require_deleteMany();
    var deleteAll_1 = require_deleteAll();
    var describeIndexStats_1 = require_describeIndexStats();
    var vectorOperationsProvider_1 = require_vectorOperationsProvider();
    var types_1 = require_types3();
    Object.defineProperty(exports, "PineconeConfigurationSchema", { enumerable: true, get: function() {
      return types_1.PineconeConfigurationSchema;
    } });
    var Index = (
      /** @class */
      function() {
        function Index2(indexName, config, namespace) {
          if (namespace === void 0) {
            namespace = "";
          }
          this.config = config;
          this.target = {
            index: indexName,
            namespace
          };
          var apiProvider = new vectorOperationsProvider_1.VectorOperationsProvider(config, indexName);
          this.deleteAll = (0, deleteAll_1.deleteAll)(apiProvider, namespace);
          this.deleteMany = (0, deleteMany_1.deleteMany)(apiProvider, namespace);
          this.deleteOne = (0, deleteOne_1.deleteOne)(apiProvider, namespace);
          this.describeIndexStats = (0, describeIndexStats_1.describeIndexStats)(apiProvider);
          this._fetchCommand = new fetch_1.FetchCommand(apiProvider, namespace);
          this._queryCommand = new query_1.QueryCommand(apiProvider, namespace);
          this._updateCommand = new update_1.UpdateCommand(apiProvider, namespace);
          this._upsertCommand = new upsert_1.UpsertCommand(apiProvider, namespace);
        }
        Index2.prototype.namespace = function(namespace) {
          return new Index2(this.target.index, this.config, namespace);
        };
        Index2.prototype.upsert = function(data) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._upsertCommand.run(data)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Index2.prototype.fetch = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._fetchCommand.run(options)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Index2.prototype.query = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._queryCommand.run(options)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Index2.prototype.update = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._updateCommand.run(options)];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return Index2;
      }()
    );
    exports.Index = Index;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone.js
var require_pinecone = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pinecone = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var control_1 = require_control();
    var errors_1 = require_errors();
    var data_1 = require_data2();
    var validator_1 = require_validator();
    var utils_1 = require_utils3();
    var Pinecone2 = (
      /** @class */
      function() {
        function Pinecone3(options) {
          if (options === void 0) {
            options = this._readEnvironmentConfig();
          }
          this._validateConfig(options);
          this.config = options;
          var apiKey = options.apiKey, environment = options.environment;
          var controllerPath = "https://controller.".concat(environment, ".pinecone.io");
          var apiConfig = {
            basePath: controllerPath,
            apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
              "User-Agent": (0, utils_1.buildUserAgent)(false)
            },
            fetchApi: (0, utils_1.getFetch)(options)
          };
          var api = new pinecone_generated_ts_fetch_1.IndexOperationsApi(new pinecone_generated_ts_fetch_1.Configuration(apiConfig));
          this.describeIndex = (0, control_1.describeIndex)(api);
          this.listIndexes = (0, control_1.listIndexes)(api);
          this.createIndex = (0, control_1.createIndex)(api);
          this.deleteIndex = (0, control_1.deleteIndex)(api);
          this.configureIndex = (0, control_1.configureIndex)(api);
          this.createCollection = (0, control_1.createCollection)(api);
          this.listCollections = (0, control_1.listCollections)(api);
          this.describeCollection = (0, control_1.describeCollection)(api);
          this.deleteCollection = (0, control_1.deleteCollection)(api);
        }
        Pinecone3.prototype._readEnvironmentConfig = function() {
          if (!process || !process.env) {
            throw new errors_1.PineconeEnvironmentVarsNotSupportedError("Your execution environment does not support reading environment variables from process.env, so a configuration object is required when calling new Pinecone()");
          }
          var environmentConfig = {};
          var requiredEnvVarMap = {
            environment: "PINECONE_ENVIRONMENT",
            apiKey: "PINECONE_API_KEY"
          };
          var missingVars = [];
          for (var _i = 0, _a2 = Object.entries(requiredEnvVarMap); _i < _a2.length; _i++) {
            var _b = _a2[_i], key = _b[0], envVar = _b[1];
            var value = process.env[envVar] || "";
            if (!value) {
              missingVars.push(envVar);
            }
            environmentConfig[key] = value;
          }
          if (missingVars.length > 0) {
            throw new errors_1.PineconeConfigurationError("Since you called 'new Pinecone()' with no configuration object, we attempted to find client configuration in environment variables but the required environment variables were not set. Missing variables: ".concat(missingVars.join(", "), "."));
          }
          var optionalEnvVarMap = { projectId: "PINECONE_PROJECT_ID" };
          for (var _c = 0, _d = Object.entries(optionalEnvVarMap); _c < _d.length; _c++) {
            var _e = _d[_c], key = _e[0], envVar = _e[1];
            var value = process.env[envVar];
            if (value !== void 0) {
              environmentConfig[key] = value;
            }
          }
          return environmentConfig;
        };
        Pinecone3.prototype._validateConfig = function(options) {
          (0, validator_1.buildValidator)("The client configuration", data_1.PineconeConfigurationSchema)(options);
        };
        Pinecone3.prototype.getConfig = function() {
          return this.config;
        };
        Pinecone3.prototype.index = function(indexName) {
          return new data_1.Index(indexName, this.config);
        };
        Pinecone3.prototype.Index = function(indexName) {
          return this.index(indexName);
        };
        Pinecone3.prototype.__curlStarter = function() {
          console.log("Example curl command to list indexes: ");
          console.log('curl "https://controller.'.concat(this.config.environment, '.pinecone.io/databases" -H "Api-Key: ').concat(this.config.apiKey, '" -H "Accept: application/json"'));
        };
        return Pinecone3;
      }()
    );
    exports.Pinecone = Pinecone2;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/runtime.js
var require_runtime2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/runtime.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
    exports.BASE_PATH = "https://unknown-unknown.svc.unknown.pinecone.io".replace(/\/+$/, "");
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(configuration) {
          if (configuration === void 0) {
            configuration = {};
          }
          this.configuration = configuration;
        }
        Object.defineProperty(Configuration2.prototype, "config", {
          set: function(configuration) {
            this.configuration = configuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "basePath", {
          get: function() {
            return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fetchApi", {
          get: function() {
            return this.configuration.fetchApi;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "middleware", {
          get: function() {
            return this.configuration.middleware || [];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
          get: function() {
            return this.configuration.queryParamsStringify || querystring;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "username", {
          get: function() {
            return this.configuration.username;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "password", {
          get: function() {
            return this.configuration.password;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "apiKey", {
          get: function() {
            var apiKey = this.configuration.apiKey;
            if (apiKey) {
              return typeof apiKey === "function" ? apiKey : function() {
                return apiKey;
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "accessToken", {
          get: function() {
            var _this = this;
            var accessToken = this.configuration.accessToken;
            if (accessToken) {
              return typeof accessToken === "function" ? accessToken : function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    return [2, accessToken];
                  });
                });
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "headers", {
          get: function() {
            return this.configuration.headers;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "credentials", {
          get: function() {
            return this.configuration.credentials;
          },
          enumerable: false,
          configurable: true
        });
        return Configuration2;
      }()
    );
    exports.Configuration = Configuration;
    exports.DefaultConfig = new Configuration();
    var BaseAPI = (
      /** @class */
      function() {
        function BaseAPI2(configuration) {
          if (configuration === void 0) {
            configuration = exports.DefaultConfig;
          }
          var _this = this;
          this.configuration = configuration;
          this.fetchApi = function(url, init) {
            return __awaiter(_this, void 0, void 0, function() {
              var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
              return __generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    fetchParams = { url, init };
                    _i = 0, _a2 = this.middleware;
                    _f.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    middleware = _a2[_i];
                    if (!middleware.pre)
                      return [3, 3];
                    return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
                  case 2:
                    fetchParams = _f.sent() || fetchParams;
                    _f.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    response = void 0;
                    _f.label = 5;
                  case 5:
                    _f.trys.push([5, 7, , 12]);
                    return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
                  case 6:
                    response = _f.sent();
                    return [3, 12];
                  case 7:
                    e_1 = _f.sent();
                    _b = 0, _c = this.middleware;
                    _f.label = 8;
                  case 8:
                    if (!(_b < _c.length))
                      return [3, 11];
                    middleware = _c[_b];
                    if (!middleware.onError)
                      return [3, 10];
                    return [4, middleware.onError({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      error: e_1,
                      response: response ? response.clone() : void 0
                    })];
                  case 9:
                    response = _f.sent() || response;
                    _f.label = 10;
                  case 10:
                    _b++;
                    return [3, 8];
                  case 11:
                    if (response === void 0) {
                      if (e_1 instanceof Error) {
                        throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                      } else {
                        throw e_1;
                      }
                    }
                    return [3, 12];
                  case 12:
                    _d = 0, _e = this.middleware;
                    _f.label = 13;
                  case 13:
                    if (!(_d < _e.length))
                      return [3, 16];
                    middleware = _e[_d];
                    if (!middleware.post)
                      return [3, 15];
                    return [4, middleware.post({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      response: response.clone()
                    })];
                  case 14:
                    response = _f.sent() || response;
                    _f.label = 15;
                  case 15:
                    _d++;
                    return [3, 13];
                  case 16:
                    return [2, response];
                }
              });
            });
          };
          this.middleware = configuration.middleware;
        }
        BaseAPI2.prototype.withMiddleware = function() {
          var _a2;
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
          }
          var next = this.clone();
          next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
          return next;
        };
        BaseAPI2.prototype.withPreMiddleware = function() {
          var preMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            preMiddlewares[_i] = arguments[_i];
          }
          var middlewares = preMiddlewares.map(function(pre) {
            return { pre };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.withPostMiddleware = function() {
          var postMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            postMiddlewares[_i] = arguments[_i];
          }
          var middlewares = postMiddlewares.map(function(post) {
            return { post };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.request = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var _a2, url, init, response;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.createFetchParams(context, initOverrides)];
                case 1:
                  _a2 = _b.sent(), url = _a2.url, init = _a2.init;
                  return [4, this.fetchApi(url, init)];
                case 2:
                  response = _b.sent();
                  if (response && (response.status >= 200 && response.status < 300)) {
                    return [2, response];
                  }
                  throw new ResponseError(response, "Response returned an error code");
              }
            });
          });
        };
        BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var url, headers, initOverrideFn, initParams, overriddenInit, _a2, init;
            var _this = this;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  url = this.configuration.basePath + context.path;
                  if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
                    url += "?" + this.configuration.queryParamsStringify(context.query);
                  }
                  headers = Object.assign({}, this.configuration.headers, context.headers);
                  Object.keys(headers).forEach(function(key) {
                    return headers[key] === void 0 ? delete headers[key] : {};
                  });
                  initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a3) {
                        return [2, initOverrides];
                      });
                    });
                  };
                  initParams = {
                    method: context.method,
                    headers,
                    body: context.body,
                    credentials: this.configuration.credentials
                  };
                  _a2 = [__assign({}, initParams)];
                  return [4, initOverrideFn({
                    init: initParams,
                    context
                  })];
                case 1:
                  overriddenInit = __assign.apply(void 0, _a2.concat([_b.sent()]));
                  init = __assign(__assign({}, overriddenInit), { body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body) });
                  return [2, { url, init }];
              }
            });
          });
        };
        BaseAPI2.prototype.clone = function() {
          var constructor = this.constructor;
          var next = new constructor(this.configuration);
          next.middleware = this.middleware.slice();
          return next;
        };
        return BaseAPI2;
      }()
    );
    exports.BaseAPI = BaseAPI;
    function isBlob(value) {
      return typeof Blob !== "undefined" && value instanceof Blob;
    }
    function isFormData(value) {
      return typeof FormData !== "undefined" && value instanceof FormData;
    }
    var ResponseError = (
      /** @class */
      function(_super) {
        __extends(ResponseError2, _super);
        function ResponseError2(response, msg) {
          var _this = _super.call(this, msg) || this;
          _this.response = response;
          _this.name = "ResponseError";
          return _this;
        }
        return ResponseError2;
      }(Error)
    );
    exports.ResponseError = ResponseError;
    var FetchError = (
      /** @class */
      function(_super) {
        __extends(FetchError2, _super);
        function FetchError2(cause, msg) {
          var _this = _super.call(this, msg) || this;
          _this.cause = cause;
          _this.name = "FetchError";
          return _this;
        }
        return FetchError2;
      }(Error)
    );
    exports.FetchError = FetchError;
    var RequiredError = (
      /** @class */
      function(_super) {
        __extends(RequiredError2, _super);
        function RequiredError2(field, msg) {
          var _this = _super.call(this, msg) || this;
          _this.field = field;
          _this.name = "RequiredError";
          return _this;
        }
        return RequiredError2;
      }(Error)
    );
    exports.RequiredError = RequiredError;
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    function exists(json, key) {
      var value = json[key];
      return value !== null && value !== void 0;
    }
    exports.exists = exists;
    function querystring(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.querystring = querystring;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (value instanceof Array) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return querystring(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
    function mapValues(data, fn) {
      return Object.keys(data).reduce(function(acc, key) {
        var _a2;
        return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
      }, {});
    }
    exports.mapValues = mapValues;
    function canConsumeForm(consumes) {
      for (var _i = 0, consumes_1 = consumes; _i < consumes_1.length; _i++) {
        var consume = consumes_1[_i];
        if ("multipart/form-data" === consume.contentType) {
          return true;
        }
      }
      return false;
    }
    exports.canConsumeForm = canConsumeForm;
    var JSONApiResponse = (
      /** @class */
      function() {
        function JSONApiResponse2(raw, transformer) {
          if (transformer === void 0) {
            transformer = function(jsonValue) {
              return jsonValue;
            };
          }
          this.raw = raw;
          this.transformer = transformer;
        }
        JSONApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a2 = this.transformer;
                  return [4, this.raw.json()];
                case 1:
                  return [2, _a2.apply(this, [_b.sent()])];
              }
            });
          });
        };
        return JSONApiResponse2;
      }()
    );
    exports.JSONApiResponse = JSONApiResponse;
    var VoidApiResponse = (
      /** @class */
      function() {
        function VoidApiResponse2(raw) {
          this.raw = raw;
        }
        VoidApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, void 0];
            });
          });
        };
        return VoidApiResponse2;
      }()
    );
    exports.VoidApiResponse = VoidApiResponse;
    var BlobApiResponse = (
      /** @class */
      function() {
        function BlobApiResponse2(raw) {
          this.raw = raw;
        }
        BlobApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.blob()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return BlobApiResponse2;
      }()
    );
    exports.BlobApiResponse = BlobApiResponse;
    var TextApiResponse = (
      /** @class */
      function() {
        function TextApiResponse2(raw) {
          this.raw = raw;
        }
        TextApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.raw.text()];
                case 1:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        ;
        return TextApiResponse2;
      }()
    );
    exports.TextApiResponse = TextApiResponse;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ApproximatedConfig.js
var require_ApproximatedConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ApproximatedConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApproximatedConfigToJSON = exports.ApproximatedConfigFromJSONTyped = exports.ApproximatedConfigFromJSON = exports.instanceOfApproximatedConfig = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfApproximatedConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfApproximatedConfig = instanceOfApproximatedConfig;
    function ApproximatedConfigFromJSON(json) {
      return ApproximatedConfigFromJSONTyped(json, false);
    }
    exports.ApproximatedConfigFromJSON = ApproximatedConfigFromJSON;
    function ApproximatedConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "kBits": !(0, runtime_1.exists)(json, "k_bits") ? void 0 : json["k_bits"],
        "hybrid": !(0, runtime_1.exists)(json, "hybrid") ? void 0 : json["hybrid"]
      };
    }
    exports.ApproximatedConfigFromJSONTyped = ApproximatedConfigFromJSONTyped;
    function ApproximatedConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "k_bits": value.kBits,
        "hybrid": value.hybrid
      };
    }
    exports.ApproximatedConfigToJSON = ApproximatedConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CollectionMeta.js
var require_CollectionMeta2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CollectionMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionMetaToJSON = exports.CollectionMetaFromJSONTyped = exports.CollectionMetaFromJSON = exports.instanceOfCollectionMeta = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfCollectionMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCollectionMeta = instanceOfCollectionMeta;
    function CollectionMetaFromJSON(json) {
      return CollectionMetaFromJSONTyped(json, false);
    }
    exports.CollectionMetaFromJSON = CollectionMetaFromJSON;
    function CollectionMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "size": !(0, runtime_1.exists)(json, "size") ? void 0 : json["size"],
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : json["status"]
      };
    }
    exports.CollectionMetaFromJSONTyped = CollectionMetaFromJSONTyped;
    function CollectionMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "size": value.size,
        "status": value.status
      };
    }
    exports.CollectionMetaToJSON = CollectionMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js
var require_CreateCollectionRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = void 0;
    function instanceOfCreateCollectionRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "source" in value;
      return isInstance;
    }
    exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
    function CreateCollectionRequestFromJSON(json) {
      return CreateCollectionRequestFromJSONTyped(json, false);
    }
    exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
    function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "source": json["source"]
      };
    }
    exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
    function CreateCollectionRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "source": value.source
      };
    }
    exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js
var require_CreateRequestIndexConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequestIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestIndexConfigToJSON = exports.CreateRequestIndexConfigFromJSONTyped = exports.CreateRequestIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig2();
    function CreateRequestIndexConfigFromJSON(json) {
      return CreateRequestIndexConfigFromJSONTyped(json, false);
    }
    exports.CreateRequestIndexConfigFromJSON = CreateRequestIndexConfigFromJSON;
    function CreateRequestIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.CreateRequestIndexConfigFromJSONTyped = CreateRequestIndexConfigFromJSONTyped;
    function CreateRequestIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.CreateRequestIndexConfigToJSON = CreateRequestIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequest.js
var require_CreateRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/CreateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateRequestToJSON = exports.CreateRequestFromJSONTyped = exports.CreateRequestFromJSON = exports.instanceOfCreateRequest = void 0;
    var runtime_1 = require_runtime2();
    var CreateRequestIndexConfig_1 = require_CreateRequestIndexConfig2();
    function instanceOfCreateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "dimension" in value;
      return isInstance;
    }
    exports.instanceOfCreateRequest = instanceOfCreateRequest;
    function CreateRequestFromJSON(json) {
      return CreateRequestFromJSONTyped(json, false);
    }
    exports.CreateRequestFromJSON = CreateRequestFromJSON;
    function CreateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "dimension": json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"],
        "sourceCollection": !(0, runtime_1.exists)(json, "source_collection") ? void 0 : json["source_collection"]
      };
    }
    exports.CreateRequestFromJSONTyped = CreateRequestFromJSONTyped;
    function CreateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, CreateRequestIndexConfig_1.CreateRequestIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig,
        "source_collection": value.sourceCollection
      };
    }
    exports.CreateRequestToJSON = CreateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DeleteRequest.js
var require_DeleteRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DeleteRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfDeleteRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
    function DeleteRequestFromJSON(json) {
      return DeleteRequestFromJSONTyped(json, false);
    }
    exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
    function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ids": !(0, runtime_1.exists)(json, "ids") ? void 0 : json["ids"],
        "deleteAll": !(0, runtime_1.exists)(json, "deleteAll") ? void 0 : json["deleteAll"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
    function DeleteRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ids": value.ids,
        "deleteAll": value.deleteAll,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.DeleteRequestToJSON = DeleteRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js
var require_DescribeIndexStatsRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfDescribeIndexStatsRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
    function DescribeIndexStatsRequestFromJSON(json) {
      return DescribeIndexStatsRequestFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
    function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
    function DescribeIndexStatsRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "filter": value.filter
      };
    }
    exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/NamespaceSummary.js
var require_NamespaceSummary2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/NamespaceSummary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfNamespaceSummary(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
    function NamespaceSummaryFromJSON(json) {
      return NamespaceSummaryFromJSONTyped(json, false);
    }
    exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
    function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectorCount": !(0, runtime_1.exists)(json, "vectorCount") ? void 0 : json["vectorCount"]
      };
    }
    exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
    function NamespaceSummaryToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectorCount": value.vectorCount
      };
    }
    exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js
var require_DescribeIndexStatsResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsResponseToJSON = exports.DescribeIndexStatsResponseFromJSONTyped = exports.DescribeIndexStatsResponseFromJSON = exports.instanceOfDescribeIndexStatsResponse = void 0;
    var runtime_1 = require_runtime2();
    var NamespaceSummary_1 = require_NamespaceSummary2();
    function instanceOfDescribeIndexStatsResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsResponse = instanceOfDescribeIndexStatsResponse;
    function DescribeIndexStatsResponseFromJSON(json) {
      return DescribeIndexStatsResponseFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsResponseFromJSON = DescribeIndexStatsResponseFromJSON;
    function DescribeIndexStatsResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespaces": !(0, runtime_1.exists)(json, "namespaces") ? void 0 : (0, runtime_1.mapValues)(json["namespaces"], NamespaceSummary_1.NamespaceSummaryFromJSON),
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexFullness": !(0, runtime_1.exists)(json, "indexFullness") ? void 0 : json["indexFullness"],
        "totalVectorCount": !(0, runtime_1.exists)(json, "totalVectorCount") ? void 0 : json["totalVectorCount"]
      };
    }
    exports.DescribeIndexStatsResponseFromJSONTyped = DescribeIndexStatsResponseFromJSONTyped;
    function DescribeIndexStatsResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespaces": value.namespaces === void 0 ? void 0 : (0, runtime_1.mapValues)(value.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
        "dimension": value.dimension,
        "indexFullness": value.indexFullness,
        "totalVectorCount": value.totalVectorCount
      };
    }
    exports.DescribeIndexStatsResponseToJSON = DescribeIndexStatsResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SparseValues.js
var require_SparseValues2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SparseValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = void 0;
    function instanceOfSparseValues(value) {
      var isInstance = true;
      isInstance = isInstance && "indices" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfSparseValues = instanceOfSparseValues;
    function SparseValuesFromJSON(json) {
      return SparseValuesFromJSONTyped(json, false);
    }
    exports.SparseValuesFromJSON = SparseValuesFromJSON;
    function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indices": json["indices"],
        "values": json["values"]
      };
    }
    exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
    function SparseValuesToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indices": value.indices,
        "values": value.values
      };
    }
    exports.SparseValuesToJSON = SparseValuesToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/Vector.js
var require_Vector2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/Vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfVector = instanceOfVector;
    function VectorFromJSON(json) {
      return VectorFromJSONTyped(json, false);
    }
    exports.VectorFromJSON = VectorFromJSON;
    function VectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.VectorFromJSONTyped = VectorFromJSONTyped;
    function VectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.VectorToJSON = VectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/FetchResponse.js
var require_FetchResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/FetchResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = void 0;
    var runtime_1 = require_runtime2();
    var Vector_1 = require_Vector2();
    function instanceOfFetchResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfFetchResponse = instanceOfFetchResponse;
    function FetchResponseFromJSON(json) {
      return FetchResponseFromJSONTyped(json, false);
    }
    exports.FetchResponseFromJSON = FetchResponseFromJSON;
    function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": !(0, runtime_1.exists)(json, "vectors") ? void 0 : (0, runtime_1.mapValues)(json["vectors"], Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
    function FetchResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors === void 0 ? void 0 : (0, runtime_1.mapValues)(value.vectors, Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.FetchResponseToJSON = FetchResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/HnswConfig.js
var require_HnswConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/HnswConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HnswConfigToJSON = exports.HnswConfigFromJSONTyped = exports.HnswConfigFromJSON = exports.instanceOfHnswConfig = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfHnswConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfHnswConfig = instanceOfHnswConfig;
    function HnswConfigFromJSON(json) {
      return HnswConfigFromJSONTyped(json, false);
    }
    exports.HnswConfigFromJSON = HnswConfigFromJSON;
    function HnswConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "efConstruction": !(0, runtime_1.exists)(json, "ef_construction") ? void 0 : json["ef_construction"],
        "ef": !(0, runtime_1.exists)(json, "ef") ? void 0 : json["ef"],
        "m": !(0, runtime_1.exists)(json, "M") ? void 0 : json["M"],
        "maxElements": !(0, runtime_1.exists)(json, "max_elements") ? void 0 : json["max_elements"]
      };
    }
    exports.HnswConfigFromJSONTyped = HnswConfigFromJSONTyped;
    function HnswConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ef_construction": value.efConstruction,
        "ef": value.ef,
        "M": value.m,
        "max_elements": value.maxElements
      };
    }
    exports.HnswConfigToJSON = HnswConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js
var require_IndexMetaDatabaseIndexConfig2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabaseIndexConfig.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseIndexConfigToJSON = exports.IndexMetaDatabaseIndexConfigFromJSONTyped = exports.IndexMetaDatabaseIndexConfigFromJSON = void 0;
    var ApproximatedConfig_1 = require_ApproximatedConfig2();
    function IndexMetaDatabaseIndexConfigFromJSON(json) {
      return IndexMetaDatabaseIndexConfigFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseIndexConfigFromJSON = IndexMetaDatabaseIndexConfigFromJSON;
    function IndexMetaDatabaseIndexConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return __assign({}, (0, ApproximatedConfig_1.ApproximatedConfigFromJSONTyped)(json, true));
    }
    exports.IndexMetaDatabaseIndexConfigFromJSONTyped = IndexMetaDatabaseIndexConfigFromJSONTyped;
    function IndexMetaDatabaseIndexConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      if ((0, ApproximatedConfig_1.instanceOfApproximatedConfig)(value)) {
        return (0, ApproximatedConfig_1.ApproximatedConfigToJSON)(value);
      }
      return {};
    }
    exports.IndexMetaDatabaseIndexConfigToJSON = IndexMetaDatabaseIndexConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js
var require_IndexMetaDatabase2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaDatabase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaDatabaseToJSON = exports.IndexMetaDatabaseFromJSONTyped = exports.IndexMetaDatabaseFromJSON = exports.instanceOfIndexMetaDatabase = void 0;
    var runtime_1 = require_runtime2();
    var IndexMetaDatabaseIndexConfig_1 = require_IndexMetaDatabaseIndexConfig2();
    function instanceOfIndexMetaDatabase(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaDatabase = instanceOfIndexMetaDatabase;
    function IndexMetaDatabaseFromJSON(json) {
      return IndexMetaDatabaseFromJSONTyped(json, false);
    }
    exports.IndexMetaDatabaseFromJSON = IndexMetaDatabaseFromJSON;
    function IndexMetaDatabaseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": !(0, runtime_1.exists)(json, "name") ? void 0 : json["name"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexType": !(0, runtime_1.exists)(json, "index_type") ? void 0 : json["index_type"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"],
        "indexConfig": !(0, runtime_1.exists)(json, "index_config") ? void 0 : (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigFromJSON)(json["index_config"]),
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : json["metadata_config"]
      };
    }
    exports.IndexMetaDatabaseFromJSONTyped = IndexMetaDatabaseFromJSONTyped;
    function IndexMetaDatabaseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "index_type": value.indexType,
        "metric": value.metric,
        "pods": value.pods,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "index_config": (0, IndexMetaDatabaseIndexConfig_1.IndexMetaDatabaseIndexConfigToJSON)(value.indexConfig),
        "metadata_config": value.metadataConfig
      };
    }
    exports.IndexMetaDatabaseToJSON = IndexMetaDatabaseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaStatus.js
var require_IndexMetaStatus2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMetaStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaStatusToJSON = exports.IndexMetaStatusFromJSONTyped = exports.IndexMetaStatusFromJSON = exports.instanceOfIndexMetaStatus = exports.IndexMetaStatusStateEnum = void 0;
    var runtime_1 = require_runtime2();
    exports.IndexMetaStatusStateEnum = {
      Initializing: "Initializing",
      ScalingUp: "ScalingUp",
      ScalingDown: "ScalingDown",
      Terminating: "Terminating",
      Ready: "Ready"
    };
    function instanceOfIndexMetaStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMetaStatus = instanceOfIndexMetaStatus;
    function IndexMetaStatusFromJSON(json) {
      return IndexMetaStatusFromJSONTyped(json, false);
    }
    exports.IndexMetaStatusFromJSON = IndexMetaStatusFromJSON;
    function IndexMetaStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ready": !(0, runtime_1.exists)(json, "ready") ? void 0 : json["ready"],
        "state": !(0, runtime_1.exists)(json, "state") ? void 0 : json["state"]
      };
    }
    exports.IndexMetaStatusFromJSONTyped = IndexMetaStatusFromJSONTyped;
    function IndexMetaStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ready": value.ready,
        "state": value.state
      };
    }
    exports.IndexMetaStatusToJSON = IndexMetaStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMeta.js
var require_IndexMeta2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/IndexMeta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexMetaToJSON = exports.IndexMetaFromJSONTyped = exports.IndexMetaFromJSON = exports.instanceOfIndexMeta = void 0;
    var runtime_1 = require_runtime2();
    var IndexMetaDatabase_1 = require_IndexMetaDatabase2();
    var IndexMetaStatus_1 = require_IndexMetaStatus2();
    function instanceOfIndexMeta(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexMeta = instanceOfIndexMeta;
    function IndexMetaFromJSON(json) {
      return IndexMetaFromJSONTyped(json, false);
    }
    exports.IndexMetaFromJSON = IndexMetaFromJSON;
    function IndexMetaFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "database": !(0, runtime_1.exists)(json, "database") ? void 0 : (0, IndexMetaDatabase_1.IndexMetaDatabaseFromJSON)(json["database"]),
        "status": !(0, runtime_1.exists)(json, "status") ? void 0 : (0, IndexMetaStatus_1.IndexMetaStatusFromJSON)(json["status"])
      };
    }
    exports.IndexMetaFromJSONTyped = IndexMetaFromJSONTyped;
    function IndexMetaToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "database": (0, IndexMetaDatabase_1.IndexMetaDatabaseToJSON)(value.database),
        "status": (0, IndexMetaStatus_1.IndexMetaStatusToJSON)(value.status)
      };
    }
    exports.IndexMetaToJSON = IndexMetaToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/PatchRequest.js
var require_PatchRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/PatchRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatchRequestToJSON = exports.PatchRequestFromJSONTyped = exports.PatchRequestFromJSON = exports.instanceOfPatchRequest = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfPatchRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfPatchRequest = instanceOfPatchRequest;
    function PatchRequestFromJSON(json) {
      return PatchRequestFromJSONTyped(json, false);
    }
    exports.PatchRequestFromJSON = PatchRequestFromJSON;
    function PatchRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"]
      };
    }
    exports.PatchRequestFromJSONTyped = PatchRequestFromJSONTyped;
    function PatchRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "replicas": value.replicas,
        "pod_type": value.podType
      };
    }
    exports.PatchRequestToJSON = PatchRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufAny.js
var require_ProtobufAny2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufAny.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfProtobufAny(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfProtobufAny = instanceOfProtobufAny;
    function ProtobufAnyFromJSON(json) {
      return ProtobufAnyFromJSONTyped(json, false);
    }
    exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
    function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "typeUrl": !(0, runtime_1.exists)(json, "typeUrl") ? void 0 : json["typeUrl"],
        "value": !(0, runtime_1.exists)(json, "value") ? void 0 : json["value"]
      };
    }
    exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
    function ProtobufAnyToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "typeUrl": value.typeUrl,
        "value": value.value
      };
    }
    exports.ProtobufAnyToJSON = ProtobufAnyToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufNullValue.js
var require_ProtobufNullValue2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ProtobufNullValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = void 0;
    exports.ProtobufNullValue = {
      NullValue: "NULL_VALUE"
    };
    function ProtobufNullValueFromJSON(json) {
      return ProtobufNullValueFromJSONTyped(json, false);
    }
    exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
    function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
      return json;
    }
    exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
    function ProtobufNullValueToJSON(value) {
      return value;
    }
    exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryVector.js
var require_QueryVector2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfQueryVector(value) {
      var isInstance = true;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfQueryVector = instanceOfQueryVector;
    function QueryVectorFromJSON(json) {
      return QueryVectorFromJSONTyped(json, false);
    }
    exports.QueryVectorFromJSON = QueryVectorFromJSON;
    function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "topK": !(0, runtime_1.exists)(json, "topK") ? void 0 : json["topK"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
    function QueryVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "topK": value.topK,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.QueryVectorToJSON = QueryVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryRequest.js
var require_QueryRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = void 0;
    var runtime_1 = require_runtime2();
    var QueryVector_1 = require_QueryVector2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfQueryRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "topK" in value;
      return isInstance;
    }
    exports.instanceOfQueryRequest = instanceOfQueryRequest;
    function QueryRequestFromJSON(json) {
      return QueryRequestFromJSONTyped(json, false);
    }
    exports.QueryRequestFromJSON = QueryRequestFromJSON;
    function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "topK": json["topK"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"],
        "includeValues": !(0, runtime_1.exists)(json, "includeValues") ? void 0 : json["includeValues"],
        "includeMetadata": !(0, runtime_1.exists)(json, "includeMetadata") ? void 0 : json["includeMetadata"],
        "queries": !(0, runtime_1.exists)(json, "queries") ? void 0 : json["queries"].map(QueryVector_1.QueryVectorFromJSON),
        "vector": !(0, runtime_1.exists)(json, "vector") ? void 0 : json["vector"],
        "sparseVector": !(0, runtime_1.exists)(json, "sparseVector") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseVector"]),
        "id": !(0, runtime_1.exists)(json, "id") ? void 0 : json["id"]
      };
    }
    exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
    function QueryRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespace": value.namespace,
        "topK": value.topK,
        "filter": value.filter,
        "includeValues": value.includeValues,
        "includeMetadata": value.includeMetadata,
        "queries": value.queries === void 0 ? void 0 : value.queries.map(QueryVector_1.QueryVectorToJSON),
        "vector": value.vector,
        "sparseVector": (0, SparseValues_1.SparseValuesToJSON)(value.sparseVector),
        "id": value.id
      };
    }
    exports.QueryRequestToJSON = QueryRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ScoredVector.js
var require_ScoredVector2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/ScoredVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfScoredVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfScoredVector = instanceOfScoredVector;
    function ScoredVectorFromJSON(json) {
      return ScoredVectorFromJSONTyped(json, false);
    }
    exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
    function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "score": !(0, runtime_1.exists)(json, "score") ? void 0 : json["score"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
    function ScoredVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "score": value.score,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.ScoredVectorToJSON = ScoredVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SingleQueryResults.js
var require_SingleQueryResults2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/SingleQueryResults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = void 0;
    var runtime_1 = require_runtime2();
    var ScoredVector_1 = require_ScoredVector2();
    function instanceOfSingleQueryResults(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
    function SingleQueryResultsFromJSON(json) {
      return SingleQueryResultsFromJSONTyped(json, false);
    }
    exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
    function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
    function SingleQueryResultsToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryResponse.js
var require_QueryResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/QueryResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = void 0;
    var runtime_1 = require_runtime2();
    var ScoredVector_1 = require_ScoredVector2();
    var SingleQueryResults_1 = require_SingleQueryResults2();
    function instanceOfQueryResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfQueryResponse = instanceOfQueryResponse;
    function QueryResponseFromJSON(json) {
      return QueryResponseFromJSONTyped(json, false);
    }
    exports.QueryResponseFromJSON = QueryResponseFromJSON;
    function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "results": !(0, runtime_1.exists)(json, "results") ? void 0 : json["results"].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
    function QueryResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "results": value.results === void 0 ? void 0 : value.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.QueryResponseToJSON = QueryResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/RpcStatus.js
var require_RpcStatus2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/RpcStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = void 0;
    var runtime_1 = require_runtime2();
    var ProtobufAny_1 = require_ProtobufAny2();
    function instanceOfRpcStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfRpcStatus = instanceOfRpcStatus;
    function RpcStatusFromJSON(json) {
      return RpcStatusFromJSONTyped(json, false);
    }
    exports.RpcStatusFromJSON = RpcStatusFromJSON;
    function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "code": !(0, runtime_1.exists)(json, "code") ? void 0 : json["code"],
        "message": !(0, runtime_1.exists)(json, "message") ? void 0 : json["message"],
        "details": !(0, runtime_1.exists)(json, "details") ? void 0 : json["details"].map(ProtobufAny_1.ProtobufAnyFromJSON)
      };
    }
    exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
    function RpcStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "code": value.code,
        "message": value.message,
        "details": value.details === void 0 ? void 0 : value.details.map(ProtobufAny_1.ProtobufAnyToJSON)
      };
    }
    exports.RpcStatusToJSON = RpcStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpdateRequest.js
var require_UpdateRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpdateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = void 0;
    var runtime_1 = require_runtime2();
    var SparseValues_1 = require_SparseValues2();
    function instanceOfUpdateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
    function UpdateRequestFromJSON(json) {
      return UpdateRequestFromJSONTyped(json, false);
    }
    exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
    function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "setMetadata": !(0, runtime_1.exists)(json, "setMetadata") ? void 0 : json["setMetadata"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
    function UpdateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "setMetadata": value.setMetadata,
        "namespace": value.namespace
      };
    }
    exports.UpdateRequestToJSON = UpdateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertRequest.js
var require_UpsertRequest2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = void 0;
    var runtime_1 = require_runtime2();
    var Vector_1 = require_Vector2();
    function instanceOfUpsertRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "vectors" in value;
      return isInstance;
    }
    exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
    function UpsertRequestFromJSON(json) {
      return UpsertRequestFromJSONTyped(json, false);
    }
    exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
    function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": json["vectors"].map(Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
    function UpsertRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors.map(Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.UpsertRequestToJSON = UpsertRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertResponse.js
var require_UpsertResponse2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/UpsertResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = void 0;
    var runtime_1 = require_runtime2();
    function instanceOfUpsertResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
    function UpsertResponseFromJSON(json) {
      return UpsertResponseFromJSONTyped(json, false);
    }
    exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
    function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "upsertedCount": !(0, runtime_1.exists)(json, "upsertedCount") ? void 0 : json["upsertedCount"]
      };
    }
    exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
    function UpsertResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "upsertedCount": value.upsertedCount
      };
    }
    exports.UpsertResponseToJSON = UpsertResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/index.js
var require_models2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApproximatedConfig2(), exports);
    __exportStar(require_CollectionMeta2(), exports);
    __exportStar(require_CreateCollectionRequest2(), exports);
    __exportStar(require_CreateRequest2(), exports);
    __exportStar(require_CreateRequestIndexConfig2(), exports);
    __exportStar(require_DeleteRequest2(), exports);
    __exportStar(require_DescribeIndexStatsRequest2(), exports);
    __exportStar(require_DescribeIndexStatsResponse2(), exports);
    __exportStar(require_FetchResponse2(), exports);
    __exportStar(require_HnswConfig2(), exports);
    __exportStar(require_IndexMeta2(), exports);
    __exportStar(require_IndexMetaDatabase2(), exports);
    __exportStar(require_IndexMetaDatabaseIndexConfig2(), exports);
    __exportStar(require_IndexMetaStatus2(), exports);
    __exportStar(require_NamespaceSummary2(), exports);
    __exportStar(require_PatchRequest2(), exports);
    __exportStar(require_ProtobufAny2(), exports);
    __exportStar(require_ProtobufNullValue2(), exports);
    __exportStar(require_QueryRequest2(), exports);
    __exportStar(require_QueryResponse2(), exports);
    __exportStar(require_QueryVector2(), exports);
    __exportStar(require_RpcStatus2(), exports);
    __exportStar(require_ScoredVector2(), exports);
    __exportStar(require_SingleQueryResults2(), exports);
    __exportStar(require_SparseValues2(), exports);
    __exportStar(require_UpdateRequest2(), exports);
    __exportStar(require_UpsertRequest2(), exports);
    __exportStar(require_UpsertResponse2(), exports);
    __exportStar(require_Vector2(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js
var require_IndexOperationsApi2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/IndexOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexOperationsApi = void 0;
    var runtime = __importStar(require_runtime2());
    var models_1 = require_models2();
    var IndexOperationsApi = (
      /** @class */
      function(_super) {
        __extends(IndexOperationsApi2, _super);
        function IndexOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        IndexOperationsApi2.prototype.configureIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling configureIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "PATCH",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.PatchRequestToJSON)(requestParameters.patchRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.configureIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.configureIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createCollection = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.CreateRequestToJSON)(requestParameters.createRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.createIndex = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.createIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.TextApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.deleteIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.deleteIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collectionName}".replace("{".concat("collectionName", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.CollectionMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling describeIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases/{indexName}".replace("{".concat("indexName", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.IndexMetaFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.describeIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollectionsRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listCollections = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listCollectionsRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexesRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/databases",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        IndexOperationsApi2.prototype.listIndexes = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listIndexesRaw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return IndexOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.IndexOperationsApi = IndexOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js
var require_VectorOperationsApi2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/VectorOperationsApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorOperationsApi = void 0;
    var runtime = __importStar(require_runtime2());
    var models_1 = require_models2();
    var VectorOperationsApi = (
      /** @class */
      function(_super) {
        __extends(VectorOperationsApi2, _super);
        function VectorOperationsApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        VectorOperationsApi2.prototype._deleteRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === void 0) {
                    throw new runtime.RequiredError("deleteRequest", "Required parameter requestParameters.deleteRequest was null or undefined when calling _delete.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype._delete = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this._deleteRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1Raw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.deleteAll !== void 0) {
                    queryParameters["deleteAll"] = requestParameters.deleteAll;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.delete1 = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.delete1Raw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStatsRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === void 0) {
                    throw new runtime.RequiredError("describeIndexStatsRequest", "Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStatsRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1Raw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.describeIndexStats1 = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.describeIndexStats1Raw(initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetchRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.ids === null || requestParameters.ids === void 0) {
                    throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling fetch.");
                  }
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/fetch",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.FetchResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.fetch = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.fetchRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.queryRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.queryRequest === null || requestParameters.queryRequest === void 0) {
                    throw new runtime.RequiredError("queryRequest", "Required parameter requestParameters.queryRequest was null or undefined when calling query.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/query",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.QueryRequestToJSON)(requestParameters.queryRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.QueryResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.query = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.queryRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.updateRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.updateRequest === null || requestParameters.updateRequest === void 0) {
                    throw new runtime.RequiredError("updateRequest", "Required parameter requestParameters.updateRequest was null or undefined when calling update.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/update",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.UpdateRequestToJSON)(requestParameters.updateRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.update = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.updateRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsertRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === void 0) {
                    throw new runtime.RequiredError("upsertRequest", "Required parameter requestParameters.upsertRequest was null or undefined when calling upsert.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/upsert",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, models_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
                  }, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, models_1.UpsertResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        VectorOperationsApi2.prototype.upsert = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.upsertRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a2.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        return VectorOperationsApi2;
      }(runtime.BaseAPI)
    );
    exports.VectorOperationsApi = VectorOperationsApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/index.js
var require_apis2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/apis/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IndexOperationsApi2(), exports);
    __exportStar(require_VectorOperationsApi2(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/index.js
var require_pinecone_generated_ts_fetch2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/pinecone-generated-ts-fetch/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_runtime2(), exports);
    __exportStar(require_apis2(), exports);
    __exportStar(require_models2(), exports);
  }
});

// node_modules/cross-fetch/dist/browser-polyfill.js
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers3(headers) {
          this.map = {};
          if (headers instanceof Headers3) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers3.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers3.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers3.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers3.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers3.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers3.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers3.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers3.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers3.prototype[Symbol.iterator] = Headers3.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers3(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers3(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers3();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request3.prototype);
        function Response3(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers3(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response3.prototype);
        Response3.prototype.clone = function() {
          return new Response3(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers3(this.headers),
            url: this.url
          });
        };
        Response3.error = function() {
          var response = new Response3(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response3.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response3(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request3(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response3(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers3;
          self2.Request = Request3;
          self2.Response = Response3;
        }
        exports2.Headers = Headers3;
        exports2.Request = Request3;
        exports2.Response = Response3;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(typeof self !== "undefined" ? self : exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/index.js
var require_v0 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeClient = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch2();
    require_browser_polyfill();
    var utils_1 = require_utils3();
    var PineconeError = (
      /** @class */
      function(_super) {
        __extends(PineconeError2, _super);
        function PineconeError2(message) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          _this.name = "PineconeError";
          Object.setPrototypeOf(_this, _newTarget.prototype);
          _this.stack = "";
          return _this;
        }
        return PineconeError2;
      }(Error)
    );
    function streamToArrayBuffer(stream) {
      return __awaiter(this, void 0, void 0, function() {
        var result, reader, _a2, done, value, newResult;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              result = new Uint8Array(0);
              reader = stream.getReader();
              _b.label = 1;
            case 1:
              if (false)
                return [3, 3];
              return [4, reader.read()];
            case 2:
              _a2 = _b.sent(), done = _a2.done, value = _a2.value;
              if (done) {
                return [3, 3];
              }
              if (value) {
                newResult = new Uint8Array(result.length + value.length);
                newResult.set(result);
                newResult.set(value, result.length);
                result = newResult;
              }
              return [3, 1];
            case 3:
              return [2, result];
          }
        });
      });
    }
    function handler(func, args) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var e_1, error, body, buffer, _b, text, json;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 2, , 7]);
              return [4, func(args)];
            case 1:
              return [2, _c.sent()];
            case 2:
              e_1 = _c.sent();
              error = e_1;
              if (!(error && error.response))
                return [3, 5];
              body = (_a2 = error.response) === null || _a2 === void 0 ? void 0 : _a2.body;
              _b = body;
              if (!_b)
                return [3, 4];
              return [4, streamToArrayBuffer(body)];
            case 3:
              _b = _c.sent();
              _c.label = 4;
            case 4:
              buffer = _b;
              text = buffer && new TextDecoder().decode(buffer);
              try {
                json = text && JSON.parse(text);
                return [2, Promise.reject(new PineconeError("".concat(json === null || json === void 0 ? void 0 : json.message)))];
              } catch (e) {
                return [2, Promise.reject(new PineconeError("PineconeClient: Error calling ".concat(func.name.replace("bound ", ""), ": ").concat(text)))];
              }
              return [3, 6];
            case 5:
              return [2, Promise.reject(new PineconeError("PineconeClient: Error calling ".concat(func.name.replace("bound ", ""), ": ").concat(error)))];
            case 6:
              return [3, 7];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    function exposeMethods(instance, target) {
      var _this = this;
      var _loop_1 = function(prop2) {
        var descriptor = instance[prop2];
        if (descriptor && typeof descriptor === "function" && prop2 !== "constructor") {
          target[prop2] = function(args) {
            return __awaiter(_this, void 0, void 0, function() {
              var boundFunction;
              return __generator(this, function(_a3) {
                Object.defineProperty(descriptor, "name", { value: prop2 });
                boundFunction = descriptor.bind(instance);
                return [2, handler(boundFunction, args)];
              });
            });
          };
        }
      };
      for (var _i = 0, _a2 = Object.keys(Object.getPrototypeOf(instance)); _i < _a2.length; _i++) {
        var prop = _a2[_i];
        _loop_1(prop);
      }
    }
    function attachHandler(instance) {
      var _this = this;
      var _loop_2 = function(prop2) {
        var descriptor = instance[prop2];
        if (descriptor && typeof descriptor === "function" && prop2 !== "constructor") {
          instance[prop2] = function(args) {
            return __awaiter(_this, void 0, void 0, function() {
              var boundFunction;
              return __generator(this, function(_a3) {
                Object.defineProperty(descriptor, "name", { value: prop2 });
                boundFunction = descriptor.bind(instance);
                return [2, handler(boundFunction, args)];
              });
            });
          };
        }
      };
      for (var _i = 0, _a2 = Object.keys(Object.getPrototypeOf(instance)); _i < _a2.length; _i++) {
        var prop = _a2[_i];
        _loop_2(prop);
      }
      return instance;
    }
    var PineconeClient = (
      /** @class */
      function() {
        function PineconeClient2() {
          this.apiKey = null;
          this.projectName = null;
          this.environment = null;
        }
        PineconeClient2.prototype.getProjectName = function(controllerPath, apiKey) {
          return __awaiter(this, void 0, void 0, function() {
            var whoami, request, response, error, statusText, project_name, error_1;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  whoami = "".concat(controllerPath, "/actions/whoami");
                  request = {
                    method: "GET",
                    headers: {
                      "Content-Type": "application/json",
                      "Api-Key": apiKey
                    }
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 7, , 8]);
                  return [4, fetch(whoami, request)];
                case 2:
                  response = _a2.sent();
                  if (!(response.status !== 200))
                    return [3, 4];
                  return [4, response.text()];
                case 3:
                  error = _a2.sent();
                  statusText = response.statusText;
                  throw new Error("".concat(statusText, " - ").concat(error));
                case 4:
                  return [4, response.json()];
                case 5:
                  project_name = _a2.sent().project_name;
                  return [2, project_name];
                case 6:
                  return [3, 8];
                case 7:
                  error_1 = _a2.sent();
                  throw new PineconeError("Failed getting project name. ".concat(error_1));
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PineconeClient2.prototype.init = function(configuration) {
          return __awaiter(this, void 0, void 0, function() {
            var environment, apiKey, controllerPath, _a2, error_2, controllerConfigurationParameters, controllerConfiguration, indexOperations;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  environment = configuration.environment, apiKey = configuration.apiKey;
                  this.apiKey = apiKey;
                  this.environment = environment;
                  controllerPath = "https://controller.".concat(environment, ".pinecone.io");
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 3, , 4]);
                  _a2 = this;
                  return [4, this.getProjectName(controllerPath, apiKey)];
                case 2:
                  _a2.projectName = _b.sent();
                  return [3, 4];
                case 3:
                  error_2 = _b.sent();
                  throw error_2;
                case 4:
                  controllerConfigurationParameters = {
                    basePath: controllerPath,
                    apiKey,
                    queryParamsStringify: utils_1.queryParamsStringify,
                    headers: {
                      "User-Agent": (0, utils_1.buildUserAgent)(true)
                    }
                  };
                  controllerConfiguration = new pinecone_generated_ts_fetch_1.Configuration(controllerConfigurationParameters);
                  indexOperations = new pinecone_generated_ts_fetch_1.IndexOperationsApi(controllerConfiguration);
                  exposeMethods(indexOperations, this);
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PineconeClient2.prototype.Index = function(index) {
          if (!this.apiKey)
            throw new Error("PineconeClient: API key not set. Call init() first.");
          if (!this.projectName)
            throw new Error("PineconeClient: Project name not set. Call init() first.");
          if (!this.environment)
            throw new Error("PineconeClient: Environment not set. Call init() first.");
          var indexConfigurationParameters = {
            basePath: "https://".concat(index, "-").concat(this.projectName, ".svc.").concat(this.environment, ".pinecone.io"),
            apiKey: this.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
              "User-Agent": (0, utils_1.buildUserAgent)(true)
            }
          };
          var indexConfiguration = new pinecone_generated_ts_fetch_1.Configuration(indexConfigurationParameters);
          var vectorOperations = new pinecone_generated_ts_fetch_1.VectorOperationsApi(indexConfiguration);
          return attachHandler(vectorOperations);
        };
        return PineconeClient2;
      }()
    );
    exports.PineconeClient = PineconeClient;
  }
});

// node_modules/@pinecone-database/pinecone/dist/v0/utils.js
var require_utils4 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/v0/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = void 0;
    var waitUntilIndexIsReady = function(client, indexName, retries) {
      if (retries === void 0) {
        retries = 0;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var indexDescription, e_1;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 6, , 7]);
              return [4, client.describeIndex({ indexName })];
            case 1:
              indexDescription = _b.sent();
              if (!!((_a2 = indexDescription.status) === null || _a2 === void 0 ? void 0 : _a2.ready))
                return [3, 4];
              return [4, new Promise(function(r) {
                return setTimeout(r, 1e3);
              })];
            case 2:
              _b.sent();
              return [4, waitUntilIndexIsReady(client, indexName, retries + 1)];
            case 3:
              _b.sent();
              return [3, 5];
            case 4:
              console.log("Index ready after ".concat(retries, " seconds"));
              return [
                2
                /*return*/
              ];
            case 5:
              return [3, 7];
            case 6:
              e_1 = _b.sent();
              console.error("Error waiting until index is ready", e_1);
              return [3, 7];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var createIndexIfNotExists = function(client, indexName, dimension) {
      return __awaiter(void 0, void 0, void 0, function() {
        var indexList, e_2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 5, , 6]);
              return [4, client.listIndexes()];
            case 1:
              indexList = _a2.sent();
              if (!!indexList.includes(indexName))
                return [3, 4];
              console.log("Creating index", indexName);
              return [4, client.createIndex({
                createRequest: {
                  name: indexName,
                  dimension
                }
              })];
            case 2:
              _a2.sent();
              console.log("Waiting until index is ready...");
              return [4, waitUntilIndexIsReady(client, indexName)];
            case 3:
              _a2.sent();
              console.log("Index is ready.");
              _a2.label = 4;
            case 4:
              return [3, 6];
            case 5:
              e_2 = _a2.sent();
              console.error("Error creating index", e_2);
              return [3, 6];
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var sliceIntoChunks = function(arr, chunkSize) {
      return Array.from({ length: Math.ceil(arr.length / chunkSize) }, function(_, i) {
        return arr.slice(i * chunkSize, (i + 1) * chunkSize);
      });
    };
    var chunkedUpsert = function(index, vectors, namespace, chunkSize) {
      if (chunkSize === void 0) {
        chunkSize = 10;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var chunks, e_3;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              chunks = sliceIntoChunks(vectors, chunkSize);
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, Promise.allSettled(chunks.map(function(chunk) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var e_4;
                  return __generator(this, function(_a3) {
                    switch (_a3.label) {
                      case 0:
                        _a3.trys.push([0, 2, , 3]);
                        return [4, index.upsert({
                          upsertRequest: {
                            vectors: chunk,
                            namespace
                          }
                        })];
                      case 1:
                        _a3.sent();
                        return [3, 3];
                      case 2:
                        e_4 = _a3.sent();
                        console.log("Error upserting chunk", e_4);
                        return [3, 3];
                      case 3:
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }))];
            case 2:
              _a2.sent();
              return [2, true];
            case 3:
              e_3 = _a2.sent();
              throw new Error("Error upserting vectors into index: ".concat(e_3));
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var utils = {
      waitUntilIndexIsReady,
      createIndexIfNotExists,
      chunkedUpsert
    };
    exports.utils = utils;
  }
});

// node_modules/@pinecone-database/pinecone/dist/index.js
var require_dist = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.PineconeClient = exports.Errors = exports.Index = exports.Pinecone = void 0;
    var pinecone_1 = require_pinecone();
    Object.defineProperty(exports, "Pinecone", { enumerable: true, get: function() {
      return pinecone_1.Pinecone;
    } });
    var data_1 = require_data2();
    Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
      return data_1.Index;
    } });
    exports.Errors = __importStar(require_errors());
    var v0_1 = require_v0();
    Object.defineProperty(exports, "PineconeClient", { enumerable: true, get: function() {
      return v0_1.PineconeClient;
    } });
    var utils_1 = require_utils4();
    Object.defineProperty(exports, "utils", { enumerable: true, get: function() {
      return utils_1.utils;
    } });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_promises2 = require("fs/promises");
var import_http = require("http");

// utils/globalHandlers.ts
var PluginHandler = class {
  constructor() {
  }
  init(app2) {
    this.app = app2;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  getPlugins() {
    if (!this.plugins) {
      return {
        //@ts-ignore
        dataview: this.app.plugins.plugins["dataview"].api,
        //@ts-ignore
        frontmatter: this.app.plugins.plugins["metadata-menu"].api,
        ska_se: this.app.plugins.plugins["ska-se-obsidian-plugin"].api
      };
    }
    return this.plugins;
  }
};
var pluginHandler = new PluginHandler();
var globalHandlers_default = pluginHandler;

// utils/files.ts
async function removeError(file, app2) {
  await app2.fileManager.renameFile(
    file,
    file.path.split("\u274C").join("").trim()
  );
}
async function removeWarning(file, app2) {
  await app2.fileManager.renameFile(
    file,
    file.path.split("\u26A0\uFE0F").join("").trim()
  );
}
async function addError(file, app2) {
  if (file.path.includes("\u274C"))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(".md")[0].trim() + " \u274C.md"
  );
}
async function addWarning(file, app2) {
  if (file.path.includes("\u26A0\uFE0F"))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(".md")[0].trim() + " \u26A0\uFE0F.md"
  );
}
async function addIconToName(file, app2, icon) {
  if (file.path.includes(icon))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(".md")[0].trim() + ` ${icon}.md`
  );
}
async function removeIconFromName(file, app2, icon) {
  if (!file.path.includes(icon))
    return;
  await app2.fileManager.renameFile(
    file,
    file.path.split(icon).join("").trim()
  );
}
async function getSection(file, headingToSearch) {
  var _a2, _b, _c, _d, _e;
  const app2 = globalHandlers_default.app;
  const { metadataCache, vault } = app2;
  const headings = (_b = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.headings) != null ? _b : [];
  let text = await vault.cachedRead(file);
  const hIdx = headings.findIndex(
    ({ heading }) => heading === headingToSearch
  );
  if (hIdx === -1) {
    text = "";
  } else {
    text = text.split("\n").slice(
      headings[hIdx].position.start.line + 1,
      (_e = (_d = (_c = headings[hIdx + 1]) == null ? void 0 : _c.position) == null ? void 0 : _d.start) == null ? void 0 : _e.line
    ).join("\n").trim();
  }
  console.log(text);
  return text;
}
async function insertMarkdownUnderHeading(file, headingToSearch, markdown, offset = [], offsetLine = []) {
  var _a2, _b;
  if (!markdown)
    markdown = "";
  const app2 = globalHandlers_default.app;
  const { metadataCache, vault } = app2;
  const cache = metadataCache.getFileCache(file);
  const headings = (_a2 = cache == null ? void 0 : cache.headings) != null ? _a2 : [];
  const sections = (_b = cache == null ? void 0 : cache.sections) != null ? _b : [];
  let text = await vault.read(file);
  let dLength = text.length;
  const heading = headings.find(
    ({ heading: heading2 }) => heading2 === headingToSearch
  );
  if (!heading) {
    console.log("No heading found");
    return [offset, offsetLine];
  }
  const hIdx = sections.findIndex(
    ({ position }) => position.end.offset === heading.position.end.offset
  );
  const totalOffset = offset == null ? void 0 : offset.reduce((acc, curr, idx) => {
    if (offsetLine && heading.position.start.line >= offsetLine[idx]) {
      return acc + curr;
    }
    return acc;
  }, 0);
  if (!sections[hIdx + 1] || sections[hIdx + 1].type === "heading") {
    console.log("here");
    text = text.slice(0, heading.position.end.offset + totalOffset) + markdown + text.slice(heading.position.end.offset + totalOffset);
  } else {
    text = text.slice(0, heading.position.end.offset + totalOffset) + markdown + text.slice(
      sections[hIdx + 1].position.end.offset + 1 + totalOffset
    );
  }
  await app2.vault.modify(file, text);
  offset.push(text.length - dLength);
  offsetLine == null ? void 0 : offsetLine.push(heading.position.start.line);
  return [offset, offsetLine];
}

// node_modules/openai/version.mjs
var VERSION = "4.11.0";

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  OpenAIError: () => OpenAIError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${status} ${APIError.makeMessage(error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data === null || data === void 0 ? void 0 : data["code"];
    this.param = data === null || data === void 0 ? void 0 : data["param"];
    this.type = data === null || data === void 0 ? void 0 : data["type"];
  }
  static makeMessage(error, message) {
    return (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message || "status code (no body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message !== null && message !== void 0 ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(response, controller) {
    this.response = response;
    this.controller = controller;
    this.decoder = new SSEDecoder();
  }
  async *iterMessages() {
    if (!this.response.body) {
      this.controller.abort();
      throw new OpenAIError(`Attempted to iterate over a response with no body`);
    }
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(this.response.body);
    for await (const chunk of iter) {
      for (const line of lineDecoder.decode(chunk)) {
        const sse = this.decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = this.decoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async *[Symbol.asyncIterator]() {
    let done = false;
    try {
      for await (const sse of this.iterMessages()) {
        if (done)
          continue;
        if (sse.data.startsWith("[DONE]")) {
          done = true;
          continue;
        }
        if (sse.event === null) {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error(`Could not parse message into JSON:`, sse.data);
            console.error(`From chunk:`, sse.raw);
            throw e;
          }
        }
      }
      done = true;
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError")
        return;
      throw e;
    } finally {
      if (!done)
        this.controller.abort();
    }
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) !== null && _a2 !== void 0 ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) !== null && _a2 !== void 0 ? _a2 : "unknown_file");
    return new File2([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) !== null && _b !== void 0 ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) === null || _c === void 0 ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value === null || value === void 0 ? void 0 : value.constructor) === null || _a2 === void 0 ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) === null || _a2 === void 0 ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
var MAX_RETRIES = 2;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    return new Stream(response, props.controller);
  }
  const contentType = response.headers.get("content-type");
  if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries !== null && maxRetries !== void 0 ? maxRetries : MAX_RETRIES);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch !== null && overridenFetch !== void 0 ? overridenFetch : fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) !== null && _b !== void 0 ? _b : this.httpAgent) !== null && _c !== void 0 ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent === null || httpAgent === void 0 ? void 0 : httpAgent.options) === null || _d === void 0 ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) !== null && _e !== void 0 ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options),
      ...headers
    };
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) !== null && _f !== void 0 ? _f : null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    retriesRemaining -= 1;
    let timeoutMillis;
    const retryAfterHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader) {
      const timeoutSeconds = parseInt(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!timeoutMillis || !Number.isInteger(timeoutMillis) || timeoutMillis <= 0 || timeoutMillis > 60 * 1e3) {
      const maxRetries = (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 2;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);
    const jitter = Math.random() - 0.5;
    return (sleepSeconds + jitter) * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a2 = process.env) === null || _a2 === void 0 ? void 0 : _a2[env]) !== null && _b !== void 0 ? _b : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) === null || _c === void 0 ? void 0 : _c.get) === null || _d === void 0 ? void 0 : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.object = body.object;
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data;
  }
  getPaginatedItems() {
    return this.data;
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2, _b;
    if (!((_a2 = this.data) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return null;
    }
    const next = (_b = this.data[this.data.length - 1]) === null || _b === void 0 ? void 0 : _b.id;
    if (!next)
      return null;
    return { params: { after: next } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this.client = client;
    this.get = client.get.bind(client);
    this.post = client.post.bind(client);
    this.patch = client.patch.bind(client);
    this.put = client.put.bind(client);
    this.delete = client.delete.bind(client);
    this.getAPIList = client.getAPIList.bind(client);
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this.client);
    this.translations = new Translations(this.client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false });
  }
};
(function(Completions3) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this.client);
  }
};
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/openai/resources/completions.mjs
var Completions2 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this.post("/completions", { body, ...options, stream: (_a2 = body.stream) !== null && _a2 !== void 0 ? _a2 : false });
  }
};
(function(Completions3) {
})(Completions2 || (Completions2 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this.post("/embeddings", { body, ...options });
  }
};
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));

// node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   *
   * @deprecated The Edits API is deprecated; please use Chat Completions instead.
   *
   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api
   */
  create(body, options) {
    return this.post("/edits", { body, ...options });
  }
};
(function(Edits2) {
})(Edits || (Edits = {}));

// node_modules/openai/resources/files.mjs
var Files = class extends APIResource {
  /**
   * Upload a file that contains document(s) to be used across various
   * endpoints/features. Currently, the size of all the files uploaded by one
   * organization can be up to 1 GB. Please contact us if you need to increase the
   * storage limit.
   */
  create(body, options) {
    return this.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this.get(`/files/${fileId}`, options);
  }
  /**
   * Returns a list of files that belong to the user's organization.
   */
  list(options) {
    return this.getAPIList("/files", FileObjectsPage, options);
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  retrieveContent(fileId, options) {
    return this.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/json", ...options === null || options === void 0 ? void 0 : options.headers }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends Page {
};
(function(Files2) {
})(Files || (Files = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)
   */
  create(body, options) {
    return this.post("/fine-tunes", { body, ...options });
  }
  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)
   */
  retrieve(fineTuneId, options) {
    return this.get(`/fine-tunes/${fineTuneId}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   */
  list(options) {
    return this.getAPIList("/fine-tunes", FineTunesPage, options);
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuneId, options) {
    return this.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a2;
    return this.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream: (_a2 = query === null || query === void 0 ? void 0 : query.stream) !== null && _a2 !== void 0 ? _a2 : false
    });
  }
};
var FineTunesPage = class extends Page {
};
(function(FineTunes2) {
})(FineTunes || (FineTunes = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
(function(Jobs2) {
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this.client);
  }
};
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this.post("/images/generations", { body, ...options });
  }
};
(function(Images2) {
})(Images || (Images = {}));

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
(function(Models2) {
})(Models || (Models = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  create(body, options) {
    return this.post("/moderations", { body, ...options });
  }
};
(function(Moderations2) {
})(Moderations || (Moderations = {}));

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string} [opts.apiKey=process.env['OPENAI_API_KEY']] - The API Key to send to the API.
   * @param {string} [opts.baseURL] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * @param {string | null} [opts.organization]
   */
  constructor(_b) {
    var _c, _d, _e;
    var { apiKey = readEnv("OPENAI_API_KEY"), organization = (_c = readEnv("OPENAI_ORG_ID")) !== null && _c !== void 0 ? _c : null, ...opts } = _b === void 0 ? {} : _b;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'my apiKey' }).");
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: (_d = opts.baseURL) !== null && _d !== void 0 ? _d : `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_e = options.timeout) !== null && _e !== void 0 ? _e : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var { OpenAIError: OpenAIError2, APIError: APIError2, APIConnectionError: APIConnectionError2, APIConnectionTimeoutError: APIConnectionTimeoutError2, APIUserAbortError: APIUserAbortError2, NotFoundError: NotFoundError2, ConflictError: ConflictError2, RateLimitError: RateLimitError2, BadRequestError: BadRequestError2, AuthenticationError: AuthenticationError2, InternalServerError: InternalServerError2, PermissionDeniedError: PermissionDeniedError2, UnprocessableEntityError: UnprocessableEntityError2 } = error_exports;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions2;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// utils/requirements.ts
var import_pinecone = __toESM(require_dist());
var pinecone = new import_pinecone.Pinecone({
  apiKey: "81f56d81-b6ff-4af4-b3f5-3108d730bb88",
  environment: "gcp-starter"
});
var openai = new openai_default({
  apiKey: "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",
  // defaults to process.env["OPENAI_API_KEY"]
  dangerouslyAllowBrowser: true
});
async function getEmbedMarkdown({
  path,
  subpath
}) {
  var _a2, _b, _c, _d, _e;
  const { metadataCache, vault } = app;
  const file = metadataCache.getFirstLinkpathDest(path, "");
  const headings = (_b = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.headings) != null ? _b : [];
  let text = await vault.cachedRead(file);
  if (subpath) {
    const hIdx = headings.findIndex(
      ({ heading }) => heading === subpath
    );
    if (hIdx === -1) {
      text = "";
    } else {
      text = text.split("\n").slice(
        headings[hIdx].position.start.line + 1,
        (_e = (_d = (_c = headings[hIdx + 1]) == null ? void 0 : _c.position) == null ? void 0 : _d.start) == null ? void 0 : _e.line
      ).join("\n").trim();
    }
  }
  return text.split("\n").map((line) => `${line}`).join("\n");
}
async function interfacesTable(file) {
  const { dataview: dv } = globalHandlers_default.getPlugins();
  const app2 = globalHandlers_default.app;
  const render = [];
  const connectionsJson = JSON.parse(
    await app2.vault.read(
      app2.metadataCache.getFirstLinkpathDest(
        "System Diagram.canvas",
        ""
      )
    )
  );
  const thisNode = connectionsJson.nodes.find(
    (node) => file.path.includes(node.file)
  );
  const connectingTo = connectionsJson.edges.filter(
    (edge) => edge.fromNode === thisNode.id
  );
  const connectingFrom = connectionsJson.edges.filter(
    (edge) => edge.toNode === thisNode.id
  );
  const connections = [...connectingTo, ...connectingFrom];
  for (let connection of connections) {
    const int = app2.metadataCache.getFirstLinkpathDest(
      connection.label,
      ""
    );
    const node = connectionsJson.nodes.find(
      (node2) => connection.fromNode === node2.id && connection.toNode === thisNode.id || connection.toNode === node2.id && connection.fromNode === thisNode.id
    );
    const nodeFile = app2.metadataCache.getFirstLinkpathDest(node.file, "");
    render.push([
      int ? `[[${int.basename}]]` : "None\u26A0\uFE0F",
      `[[${nodeFile == null ? void 0 : nodeFile.basename}]]`
    ]);
  }
  const tableMarkdown = render.length ? "\n" + dv.markdownTable(["Interface Name", "Connecting To"], render) : "";
  return tableMarkdown;
}
async function testsTable(file) {
  var _a2, _b;
  const { dataview: dv, ska_se } = globalHandlers_default.getPlugins();
  const app2 = globalHandlers_default.app;
  const cache = app2.metadataCache.getFileCache(file);
  const tests = dv.pages(`"${ska_se.settings.test_documentation_root_folder}"`).where((test) => {
    return test.System && test.System.path.includes(file.path);
  }).values;
  if (tests.length === 0)
    return "";
  const testsSection = (_a2 = cache == null ? void 0 : cache.headings) == null ? void 0 : _a2.find(
    (h) => h.heading === "System Tests"
  );
  const testsHeadingIndex = (_b = cache == null ? void 0 : cache.sections) == null ? void 0 : _b.findIndex(
    (section) => section.position.start.line === (testsSection == null ? void 0 : testsSection.position.start.line)
  );
  const listData = "\n" + dv.markdownList(
    tests.map(
      (test) => `[[${test.file.path}|${test.file.name}]] ${test.Status === "success" ? "	\u2705" : "	\u274C"}`
    )
  );
  return listData != null ? listData : "";
}
async function requirementsTable2(file) {
  const { dataview: dv, ska_se } = globalHandlers_default.getPlugins();
  const app2 = globalHandlers_default.app;
  const cache = app2.metadataCache.getFileCache(file);
  const thisRequirements = dv.pages(`"${ska_se.settings.system_design_root_folder}/Requirements"`).where((req) => {
    var _a2;
    return req.System && req.System == ((_a2 = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a2.ID);
  }).values;
  if (thisRequirements.length === 0)
    return "";
  const tableValues = [];
  for (const req of thisRequirements) {
    const toReturn = ["", ""];
    toReturn[0] = await getEmbedMarkdown({
      path: req.file.path,
      subpath: "Description"
    });
    toReturn[1] = "[[" + req.file.path.split("/").pop() + "]]";
    tableValues.push(toReturn);
  }
  const tableHeaders = ["Description", "Source"];
  const tableMarkdown = "\n" + dv.markdownTable(tableHeaders, tableValues);
  return tableMarkdown != null ? tableMarkdown : "";
}
async function compareRequirements(res) {
  var _a2, _b;
  if (!res)
    return;
  const searchResult = await pinecone.index("requirements").query({
    vector: res.values,
    topK: 10,
    includeMetadata: true
  });
  const potentialConflicts = (_a2 = searchResult.matches) == null ? void 0 : _a2.filter(
    (match) => {
      var _a3, _b2;
      return match.score && match.score > 0.9 && match.score < 0.99 && ((_a3 = match.metadata) == null ? void 0 : _a3.description) !== ((_b2 = res.metadata) == null ? void 0 : _b2.description);
    }
  ).map(
    (match) => {
      var _a3, _b2;
      return "- " + ((_a3 = match.metadata) == null ? void 0 : _a3.description) + `
File path: ${(_b2 = match.metadata) == null ? void 0 : _b2.path}`;
    }
  ).join("\n\n");
  if (!potentialConflicts || potentialConflicts === "") {
    console.log("No conflicts found");
    return;
  }
  console.log(potentialConflicts);
  const prompt = `Given requirement:
		${(_b = res.metadata) == null ? void 0 : _b.description}
		
		Requirements to compare to:
		${potentialConflicts}

		---
		Are there any conflicts between the given requirement and the requirements to compare? YES/NO - short reasoning - [[file path]]`;
  const result = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      {
        role: "system",
        content: `You are an engineering assistant tasked with comparing a set of requirements and detecting if there are any potential conflicts between them.
					You should only respond in a following format: YES/NO/UNCLEAR - short reasoning - [[file path]]. Remember about the double brackets around the file path.
					Remember to provide reasoning in a short but clear way. If the answer is YES, you should also provide a brief description of a possible ways to resolve the issue.
					If the answer is UNCLEAR provide a short instruction on how the requirement can be improved. If there are multiple conflicts, provide a response only for the one that is conflicting`
      },
      {
        role: "user",
        content: prompt
      }
    ]
  });
  return result.choices[0].message.content;
}
async function addEmbed(value, file) {
  var _a2, _b, _c, _d;
  const text = `System: 
		${value.system}

		Description:
		${value.description}

		Source:
		${value.source}`;
  const res = (_a2 = (await pinecone.index("requirements").fetch([value.id])).records) == null ? void 0 : _a2[value.id];
  if (((_b = res == null ? void 0 : res.metadata) == null ? void 0 : _b.description) === value.description && res.metadata.source === value.source) {
    if (((_c = res == null ? void 0 : res.metadata) == null ? void 0 : _c.path) !== file.path) {
      await pinecone.index("requirements").update({ id: res.id, metadata: { path: file.path } });
      return {
        ...res,
        metadata: {
          ...res.metadata,
          path: file.path
        }
      };
    } else {
      return res;
    }
  }
  const embedding = await openai.embeddings.create({
    input: text,
    model: "text-embedding-ada-002"
  });
  await pinecone.index("requirements").upsert([
    {
      id: value.id,
      values: embedding.data[0].embedding,
      metadata: {
        description: value.description,
        source: value.source,
        system: value.system,
        path: file.path
      }
    }
  ]);
  const resAdded = (_d = (await pinecone.index("requirements").fetch([value.id])).records) == null ? void 0 : _d[value.id];
  return resAdded;
}

// utils/templates.ts
var import_promises = require("fs/promises");
async function addRequirement(args) {
  const app2 = globalHandlers_default.app;
  const { ska_se } = globalHandlers_default.getPlugins();
  const requirementTemplate = await (0, import_promises.readFile)(
    app2.vault.adapter.getBasePath() + "/.obsidian/plugins/ska_se/templates/requirement.template.md"
  );
  let data = requirementTemplate.toString().replace(/%system%/g, args.system).replace(/%description%/g, args.description).replace(/%source%/g, args.source);
  if (!args.id) {
    const num_equirements = app2.vault.getFiles().filter(
      (file) => file.basename.startsWith(`REQ.${args.system}.`)
    ).length;
    args.id = `REQ.${args.system}.${num_equirements + 1}`;
  }
  if (args.id) {
    data = data.replace(/%id%/g, args.id.toUpperCase().replace(/ /g, "_"));
  }
  const rootPath = ska_se.settings.system_design_root_folder;
  return await app2.vault.create(
    rootPath + "/Requirements/" + args.id + ".md",
    data
  );
}
async function addComponent({
  system,
  path,
  fileName,
  id
}) {
  const app2 = globalHandlers_default.app;
  const componentTemplate = await (0, import_promises.readFile)(
    app2.vault.adapter.getBasePath() + "/.obsidian/plugins/ska_se/templates/component.template.md"
  );
  let data = componentTemplate.toString().replace(/%system%/g, system);
  if (id) {
    data = data.replace(/%id%/g, id.toUpperCase().replace(/ /g, "_"));
  }
  await app2.vault.createFolder(path + "/" + fileName);
  return await app2.vault.create(
    path + "/" + fileName + "/" + fileName + ".md",
    data
  );
}
async function addToSystemDiagram({
  file,
  isComponent
}) {
  var _a2, _b, _c, _d, _e;
  const app2 = globalHandlers_default.app;
  const systemDiagram = app2.metadataCache.getFirstLinkpathDest(
    "System Diagram.canvas",
    ""
  );
  console.log(systemDiagram);
  if (!systemDiagram)
    throw new Error("No system diagram found");
  const d = await app2.vault.cachedRead(systemDiagram);
  const dataJson = JSON.parse(d);
  const canvasStyle = (_b = (_a2 = app2.workspace.getLeaf().getContainer()) == null ? void 0 : _a2.doc.getElementsByClassName("canvas")[0]) == null ? void 0 : _b.getAttribute("style");
  const canvasTranslate = (_e = (_d = (_c = canvasStyle == null ? void 0 : canvasStyle.split("translate(")[2]) == null ? void 0 : _c.split("px)")[0]) == null ? void 0 : _d.split("px, ")) != null ? _e : [0, 0];
  dataJson.nodes.push({
    type: isComponent ? "text" : "group",
    id: Math.random().toString(36).substring(14),
    file: file.path,
    x: Number(-canvasTranslate[0]) - 150,
    y: Number(-canvasTranslate[1]) - 100,
    width: 300,
    height: 200,
    label: file.basename,
    ...isComponent ? { text: file.basename } : {}
  });
  await app2.vault.modify(systemDiagram, JSON.stringify(dataJson));
}

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default",
  system_design_root_folder: "11-Systems_design",
  test_documentation_root_folder: "05-Test_documentation",
  interfaces_root_folder: "12-Interfaces"
};
var MyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    (0, import_http.createServer)(async (req, res) => {
      const reqUrl = req.url;
      console.log(reqUrl);
      if (!reqUrl) {
        res.end("No url provided");
        return;
      }
      res.writeHead(200, {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Origin, X-Requested-With, Content-Type, Accept"
      });
      const file = this.app.vault.getAbstractFileByPath(
        "models/Waddles_wm.stl"
      );
      const uint8View = new Uint8Array(
        await this.app.vault.readBinary(file)
      );
      res.end(uint8View);
    }).listen(5566);
    globalHandlers_default.init(this.app);
    this.app.workspace.onLayoutReady(() => {
      console.log(this.app.plugins.plugins);
      globalHandlers_default.setPlugins({
        //@ts-ignore
        dataview: this.app.plugins.plugins["dataview"].api,
        //@ts-ignore
        frontmatter: this.app.plugins.plugins["metadata-menu"].api,
        //@ts-ignore
        ska_se: this.app.plugins.plugins["ska-se-obsidian-plugin"]
      });
    });
    const ribbonIconEl = this.addRibbonIcon(
      "dice",
      "SKA SE",
      (evt) => {
        new import_obsidian.Notice("This is a notice!");
      }
    );
    ribbonIconEl.addClass("my-plugin-ribbon-class");
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Status Bar Text");
    this.addCommand({
      id: "add-requirements",
      name: "Add requirement",
      callback: async () => {
        var _a2, _b;
        const currentFile = this.app.workspace.getActiveFile();
        if (!currentFile) {
          new import_obsidian.Notice("Active file is not a component");
          return;
        }
        const system = (_b = (_a2 = app.metadataCache.getFileCache(currentFile)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b.ID;
        if (!system) {
          new import_obsidian.Notice("Active file is not a component");
          return;
        }
        const newRequirement = await addRequirement({
          description: "",
          source: "",
          system
        });
        app.workspace.createLeafBySplit(app.workspace.getLeaf(false)).openFile(newRequirement);
      }
    });
    this.addCommand({
      id: "add-component",
      name: "Add component",
      callback: async () => {
        new CreateComponentModal(this.app, this.settings).open();
      }
    });
    this.registerMarkdownCodeBlockProcessor(
      "stlrender",
      async (source, el, ctx) => {
        var _a2, _b;
        const frame = document.createElement("iframe");
        frame.id = "stlframe";
        el.appendChild(frame);
        const content = await (0, import_promises2.readFile)(
          app.vault.adapter.getBasePath() + "/.obsidian/plugins/ska_se/templates/index.html"
        );
        const doc = (_a2 = frame.contentWindow) == null ? void 0 : _a2.document;
        doc == null ? void 0 : doc.open();
        doc == null ? void 0 : doc.write(content.toString());
        doc == null ? void 0 : doc.close();
        frame.style.width = "100%";
        frame.style.minHeight = "400px";
        const f = document.getElementById("stlframe");
        (_b = f.contentWindow) == null ? void 0 : _b.addEventListener("load", () => {
          var _a3;
          (_a3 = f.contentWindow) == null ? void 0 : _a3.startRender("/" + source);
        });
      }
    );
    this.addCommand({
      id: "sample-editor-command",
      name: "Sample editor command",
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        editor.replaceSelection("Sample Editor Command");
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.app.workspace.on("file-open", () => {
      const thisFile = this.app.workspace.getActiveFile();
      if (!thisFile)
        return;
      if (thisFile.extension === "canvas")
        this.app.workspace.onLayoutReady(
          () => handleCanvas(thisFile, this)
        );
      else if (thisFile.extension === "md" && thisFile.path.includes(
        this.settings.system_design_root_folder
      ) && !thisFile.path.includes("Requirements")) {
        console.log("system design");
        this.app.workspace.onLayoutReady(() => {
          handleSystem(thisFile);
        });
      } else if (thisFile.extension === "md" && thisFile.path.includes(this.settings.interfaces_root_folder)) {
        console.log("interfaces");
        this.app.workspace.onLayoutReady(() => {
          handleInterface(thisFile);
        });
      } else if (thisFile.extension === "md" && thisFile.path.includes("Requirements") && thisFile.basename !== "Requirements") {
        console.log("handling requirement");
        handleRequirement(thisFile, this.app);
      }
    });
    this.app.workspace.on("file-open", async (file) => {
      if (!file)
        return;
      if (file.extension === "md") {
        const dv = globalHandlers_default.getPlugins().dataview;
        const pages = [...dv.pages('"Requirements"')];
        console.log(pages);
        if (!pages)
          return;
        const pageClass = Object.entries(pages).find(([, page]) => {
          return page.file.path === file.path;
        });
        if (pageClass && pageClass[1].Class.includes("Requirement")) {
          await handleRequirement(file, app);
        }
      }
    });
    const resolvedFiles = [];
    this.app.metadataCache.on("resolved", async () => {
      for (let i = 0; i < resolvedFiles.length; i++) {
        await resolvedFiles[i]();
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
async function handleCanvas(canvasFile, plugin) {
  const app2 = globalHandlers_default.app;
  const canvasFileRaw = await app2.vault.read(canvasFile);
  const canvasJson = JSON.parse(canvasFileRaw);
  if (canvasFile.basename !== "System Diagram")
    return;
  const nodes = document.getElementsByClassName("canvas-node");
  Array.from(nodes).forEach((node) => {
    resolveComponent(node);
  });
  const edges = canvasJson.edges;
  edges.forEach(
    (edge, idx) => {
      if (!edge.label) {
        canvasJson.edges[idx].label = "\u26A0\uFE0F";
      }
    }
  );
  await app2.vault.modify(canvasFile, JSON.stringify(canvasJson));
  const usedEdges = [];
  const newConnections = {};
  const edgesEls = Array.from(
    document.getElementsByClassName("canvas-path-label")
  );
  edges.forEach((edge, idx) => resolveEdge(edge, idx));
  await app2.vault.modify(canvasFile, JSON.stringify(canvasJson));
  const int = await globalHandlers_default.getPlugins().dataview.pages(`"${plugin.settings.interfaces_root_folder}"`);
  int.forEach(async (i) => {
    await globalHandlers_default.getPlugins().frontmatter.postValues(i.file.path, [
      { name: "Connections", payload: { value: "" } }
    ]);
  });
  Object.entries(newConnections).forEach(async ([file, connections]) => {
    const fileCache = app2.metadataCache.getCache(file);
    if (fileCache && fileCache.frontmatter && fileCache.frontmatter.Connections) {
      await globalHandlers_default.getPlugins().frontmatter.postValues(file, [
        {
          name: "Connections",
          payload: {
            value: connections.map((c) => `
 - ${c.trim()}`).join("")
          }
        }
      ]);
    }
  });
  async function resolveComponent(node) {
    var _a2;
    let isGroup = false;
    if (node.classList.contains("canvas-node-group"))
      isGroup = true;
    node.classList.add("canvas-node-subsystem");
    const groupContent = (_a2 = node.childNodes[0]) == null ? void 0 : _a2.childNodes[0];
    const groupLabel = node.childNodes[1];
    const nodeName = isGroup ? groupLabel == null ? void 0 : groupLabel.textContent : groupContent == null ? void 0 : groupContent.textContent;
    if (!nodeName)
      return;
    const nodeFile = app2.metadataCache.getFirstLinkpathDest(nodeName, "");
    if (!nodeFile)
      return;
    if (node.classList.contains("dom-event-registered"))
      return;
    plugin.registerDomEvent(node, "dblclick", () => {
      if (nodeFile && nodeFile.extension === "md") {
        app2.workspace.openLinkText(nodeFile.path, "", true);
      }
    });
    node.classList.add("dom-event-registered");
    let update = false;
    for (let i = 0; i < canvasJson.nodes.length; i++) {
      if (canvasJson.nodes[i].label === nodeName && canvasJson.nodes[i].file !== (nodeFile == null ? void 0 : nodeFile.path)) {
        update = true;
        canvasJson.nodes[i].file = nodeFile == null ? void 0 : nodeFile.path;
        break;
      }
    }
    update && await app2.vault.modify(canvasFile, JSON.stringify(canvasJson));
    if (isGroup) {
      plugin.registerDomEvent(
        groupLabel,
        "focusout",
        () => resolveComponent(node)
      );
    } else {
      plugin.registerDomEvent(
        groupContent,
        "mouseout",
        () => resolveComponent(node)
      );
    }
  }
  async function resolveEdge(edgeJson, index) {
    var _a2, _b, _c, _d, _e;
    const edge = Array.from(edgesEls).find((edge2) => {
      var _a3;
      return edgeJson.label === ((_a3 = edge2.childNodes[0]) == null ? void 0 : _a3.textContent) && !usedEdges.includes(edge2);
    });
    if (!edge)
      return;
    const edgeName = (_a2 = edge.childNodes[0]) == null ? void 0 : _a2.textContent;
    if (!edgeName || edgeName.length <= 3) {
      canvasJson.edges[index].label = "\u26A0\uFE0F";
      return;
    }
    let bestMatch = "";
    Object.entries(app2.vault.fileMap).forEach(([path, file]) => {
      if (path.includes(".md")) {
        if (file.basename.toLowerCase().includes(edgeName == null ? void 0 : edgeName.toLowerCase()) && file.basename.length > bestMatch.length) {
          bestMatch = file.basename;
        }
      }
    });
    const edgeFile = edgeName ? app2.metadataCache.getFirstLinkpathDest(bestMatch, "") : null;
    if (!edgeFile || edgeFile.extension !== "md")
      return;
    if (!edge.classList.contains("dom-event-registered")) {
      plugin.registerDomEvent(edge, "dblclick", () => {
        app2.workspace.openLinkText(edgeFile.path, "", true);
      });
      edge.classList.add("dom-event-registered");
    }
    const fromNode = canvasJson.nodes.find((node) => {
      return node.id === edgeJson.fromNode;
    }).file;
    const toNode = canvasJson.nodes.find((node) => {
      return node.id === edgeJson.toNode;
    }).file;
    const fromFile = app2.metadataCache.getFirstLinkpathDest(fromNode, "");
    const toFile2 = app2.metadataCache.getFirstLinkpathDest(toNode, "");
    const fromConenction = (_c = (_b = app2.metadataCache.getFileCache(fromFile)) == null ? void 0 : _b.frontmatter) == null ? void 0 : _c.ID;
    const toConnection = (_e = (_d = app2.metadataCache.getFileCache(toFile2)) == null ? void 0 : _d.frontmatter) == null ? void 0 : _e.ID;
    if (edgeFile) {
      const edgeFileCache = app2.metadataCache.getCache(edgeFile.path);
      if (edgeFileCache && edgeFileCache.frontmatter && edgeFileCache.frontmatter.Connections) {
        if (!newConnections[edgeFile.path]) {
          newConnections[edgeFile.path] = [];
        }
        newConnections[edgeFile.path].push(
          `${fromConenction} <=> ${toConnection}`
        );
      }
    }
    canvasJson.edges[index].label = edgeFile.basename;
    usedEdges.push(edge);
  }
}
async function handleSystem(file) {
  var _a2, _b, _c, _d;
  if (!file)
    return;
  const { frontmatter } = globalHandlers_default.getPlugins();
  const system = (_b = (_a2 = app.metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b.System;
  const alias = (_d = (_c = app.metadataCache.getFileCache(file)) == null ? void 0 : _c.frontmatter) == null ? void 0 : _d.aliases;
  console.log("alias", alias);
  await frontmatter.postValues(file, [
    {
      name: "ID",
      payload: {
        value: system + "." + (alias ? alias[0].toUpperCase().trim() : file.basename.replace(/[^\w.,\s]/g, "").toUpperCase().trim().replace(/ /g, "_"))
      }
    }
  ]);
  let index = 0;
  async function resolveHeadingComponent(r_file) {
    if (r_file !== file)
      return;
    console.log("resolving heading component", index);
    switch (index) {
      case 0:
        const rtmk = await requirementsTable2(file);
        await insertMarkdownUnderHeading(file, "Requirements", rtmk);
        break;
      case 1:
        const ttmk = await testsTable(file);
        await insertMarkdownUnderHeading(file, "Tests", ttmk);
        break;
      case 2:
        const itmk = await interfacesTable(file);
        await insertMarkdownUnderHeading(file, "Interfaces", itmk);
        break;
      default:
        break;
    }
    index++;
    if (index > 2)
      app.metadataCache.off("resolve", resolveHeadingComponent);
  }
  app.metadataCache.on("resolve", resolveHeadingComponent);
}
async function handleInterface(file) {
  var _a2;
  const { metadataCache, vault } = app;
  const fm = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter;
  if (!fm.Type)
    return;
  if (fm.Type.includes("Electrical")) {
    await addIconToName(file, app, "\u26A1");
  } else {
    await removeIconFromName(file, app, "\u26A1");
  }
  if (fm.Type.includes("Mechanical")) {
    await addIconToName(file, app, "\u{1F6E0}\uFE0F");
  } else {
    await removeIconFromName(file, app, "\u{1F6E0}\uFE0F");
  }
  if (fm.Type.includes("Software")) {
    await addIconToName(file, app, "\u{1F4BB}");
  } else {
    await removeIconFromName(file, app, "\u{1F4BB}");
  }
}
async function handleRequirement(file, app2) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const { metadataCache, vault } = app2;
  const headings = (_b = (_a2 = metadataCache.getFileCache(file)) == null ? void 0 : _a2.headings) != null ? _b : [];
  let text = await vault.cachedRead(file);
  const dIdx = headings.findIndex(
    ({ heading }) => heading === "Description"
  );
  const hIdx = headings.findIndex(
    ({ heading }) => heading === "Source"
  );
  if (hIdx === -1) {
    text = "";
    await addWarning(file, app2);
  } else {
    text = text.split("\n").slice(
      headings[hIdx].position.start.line + 1,
      (_e = (_d = (_c = headings[hIdx + 1]) == null ? void 0 : _c.position) == null ? void 0 : _d.start) == null ? void 0 : _e.line
    ).join("\n").trim();
    if (text === "") {
      await addWarning(file, app2);
    } else {
      await removeWarning(file, app2);
    }
  }
  const text2 = await vault.cachedRead(file);
  const values = {
    id: file.basename.replace(/[^\w.,\s]/g, "").trim(),
    description: text2.split("\n").slice(
      headings[dIdx].position.start.line + 1,
      (_h = (_g = (_f = headings[dIdx + 1]) == null ? void 0 : _f.position) == null ? void 0 : _g.start) == null ? void 0 : _h.line
    ).join("\n").trim(),
    source: text2.split("\n").slice(
      headings[hIdx].position.start.line + 1,
      (_k = (_j = (_i = headings[hIdx + 1]) == null ? void 0 : _i.position) == null ? void 0 : _j.start) == null ? void 0 : _k.line
    ).join("\n").trim(),
    system: (_n = (_m = (_l = metadataCache.getFileCache(file)) == null ? void 0 : _l.frontmatter) == null ? void 0 : _m.System) != null ? _n : "Unspecified/General"
  };
  addEmbed(values, file).then(async (res) => {
    const data = await file.vault.read(file);
    const result = await compareRequirements(res);
    const { frontmatter } = globalHandlers_default.getPlugins();
    console.log(result);
    if (result == null ? void 0 : result.includes("YES")) {
      const newData = data.replace(
        await getSection(file, "Conflict"),
        ""
      );
      await this.app.vault.modify(file, newData);
      await addError(file, this.app);
      await app2.vault.modify(file, newData + `${result}`);
      frontmatter.postValues(file, [
        {
          name: "Status",
          payload: {
            value: "conflict"
          }
        },
        {
          name: "Conflicting With",
          payload: {
            value: result.substring(
              result.indexOf("[[") + 2,
              result.indexOf("]]")
            )
          }
        }
      ]);
    } else {
      await removeError(file, this.app);
      await this.app.vault.modify(
        file,
        data.replace(await getSection(file, "Conflict"), "")
      );
      frontmatter.postValues(file, [
        {
          name: "Status",
          payload: {
            value: "in-review"
          }
        },
        {
          name: "Conflicting With",
          payload: {
            value: ""
          }
        }
      ]);
    }
  });
  await new Promise((resolve) => setTimeout(resolve, 1e3));
}
var CreateComponentModal = class extends import_obsidian.Modal {
  constructor(app2, settings) {
    super(app2);
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    const app2 = this.app;
    const currentFile = this.app.workspace.getActiveFile();
    contentEl.innerHTML = `
		<h2>Create Component</h2>
		<p>Enter component name</p>
		<input type="text" id="component-name" placeholder="Component name" />
		<p>Select if this is a component</p>
		<input type="checkbox" id="is-component" />
		<br>
		<button id="create-component">Create</button>
		`;
    const button = contentEl.querySelector("#create-component");
    const input = contentEl.querySelector(
      "#component-name"
    );
    const isComponent = contentEl.querySelector(
      "#is-component"
    );
    const isCanvas = (currentFile == null ? void 0 : currentFile.extension) === "canvas";
    async function handleCreate() {
      if (!input.value)
        return;
      const name = input.value;
      if (!currentFile) {
        new import_obsidian.Notice("Active file is not a component");
        return;
      }
      let rootPath = currentFile.path.split(currentFile.name)[0];
      if (isCanvas) {
        rootPath = this.settings.system_design_root_folder;
      }
      const newComponent = await addComponent({
        system: "TWR2",
        path: rootPath,
        fileName: name
      });
      await addToSystemDiagram({
        file: newComponent,
        isComponent: isComponent.checked
      });
      app2.workspace.createLeafBySplit(app2.workspace.getLeaf()).openFile(newComponent);
      this.close();
    }
    button == null ? void 0 : button.addEventListener("click", handleCreate.bind(this));
    contentEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        handleCreate.bind(this)();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText(
      (text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
        this.plugin.settings.mySetting = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Systems design root folder").setDesc("The folder where the systems design files are stored").addText(
      (text) => text.setPlaceholder("Enter the folder path").setValue("11-System_design").onChange(async (value) => {
        this.plugin.settings.system_design_root_folder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Tests root folder").setDesc("The folder where the tests are stored").addText(
      (text) => text.setPlaceholder("Enter the folder path").setValue("05-Test_documentation").onChange(async (value) => {
        this.plugin.settings.test_documentation_root_folder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Interfaces root folder").setDesc("The folder where the interfaces are stored").addText(
      (text) => text.setPlaceholder("Enter the folder path").setValue("12-Interfaces").onChange(async (value) => {
        this.plugin.settings.interfaces_root_folder = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL3J1bnRpbWUudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9BcHByb3hpbWF0ZWRDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9Db2xsZWN0aW9uTWV0YS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0NyZWF0ZUNvbGxlY3Rpb25SZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvQ3JlYXRlUmVxdWVzdEluZGV4Q29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvQ3JlYXRlUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0RlbGV0ZVJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9EZXNjcmliZUluZGV4U3RhdHNSZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvTmFtZXNwYWNlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0Rlc2NyaWJlSW5kZXhTdGF0c1Jlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvU3BhcnNlVmFsdWVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvVmVjdG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvRmV0Y2hSZXNwb25zZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0huc3dDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGFEYXRhYmFzZUluZGV4Q29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvSW5kZXhNZXRhRGF0YWJhc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGFTdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGEudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9QYXRjaFJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9Qcm90b2J1ZkFueS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Byb3RvYnVmTnVsbFZhbHVlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvUXVlcnlWZWN0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9RdWVyeVJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9TY29yZWRWZWN0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9TaW5nbGVRdWVyeVJlc3VsdHMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9RdWVyeVJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvUnBjU3RhdHVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvVXBkYXRlUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Vwc2VydFJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9VcHNlcnRSZXNwb25zZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9hcGlzL0luZGV4T3BlcmF0aW9uc0FwaS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvYXBpcy9WZWN0b3JPcGVyYXRpb25zQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9hcGlzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvYmFzZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvY29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy9odHRwLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy9yZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy92YWxpZGF0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2Vycm9ycy91dGlscy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvaGFuZGxpbmcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZXJyb3JzL3Vwc2VydC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9lcnJvcnMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2NvZGVnZW4vY29kZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9zY29wZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvbmFtZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9ycy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcnVsZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb2RlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEudHMiLCAibm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3JlZl9lcnJvci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9kYXRhLmpzb24iLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy91cm4tdXVpZC50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3Vybi50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL21haWx0by50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3dzcy50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL3NyYy9zY2hlbWVzL3dzLnRzIiwgIm5vZGVfbW9kdWxlcy91cmktanMvc3JjL3NjaGVtZXMvaHR0cHMudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvc2NoZW1lcy9odHRwLnRzIiwgIm5vZGVfbW9kdWxlcy91cmktanMvc3JjL3VyaS50cyIsICJub2RlX21vZHVsZXMvdXJpLWpzL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5lczYuanMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvcmVnZXhwcy1pcmkudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvcmVnZXhwcy11cmkudHMiLCAibm9kZV9tb2R1bGVzL3VyaS1qcy9zcmMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3J1bnRpbWUvdXJpLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29yZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2lkLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2NvcmUvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9ydW50aW1lL3VjczJsZW5ndGgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdFByb3BlcnRpZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi9ydW50aW1lL2VxdWFsLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2VudW0udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9jb250YWlucy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsUHJvcGVydGllcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL25vdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hbGxPZi50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9tZXRhZGF0YS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kcmFmdDcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvbiIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL25vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy91dGlscy9lbnZpcm9ubWVudC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92YWxpZGF0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC91dGlscy50cyIsICJub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvdHlwZWJveC5qcyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2NvbnRyb2wvY29uZmlndXJlSW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvZGVidWdMb2cudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvcXVlcnlQYXJhbXNTdHJpbmdpZnkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9kaXN0L3ZlcnNpb24uanNvbiIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy91dGlscy91c2VyLWFnZW50LnRzIiwgIm5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdXRpbHMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9jcmVhdGVJbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL2RlbGV0ZUluZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2NvbnRyb2wvZGVzY3JpYmVJbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL2xpc3RJbmRleGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2NvbnRyb2wvY3JlYXRlQ29sbGVjdGlvbi50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9jb250cm9sL2RlbGV0ZUNvbGxlY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9kZXNjcmliZUNvbGxlY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9saXN0Q29sbGVjdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvY29udHJvbC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9kYXRhL3R5cGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2RhdGEvdXBzZXJ0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL2RhdGEvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS91cGRhdGUudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9xdWVyeS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9kYXRhL2RlbGV0ZU9uZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9kYXRhL2RlbGV0ZU1hbnkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9kZWxldGVBbGwudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9kZXNjcmliZUluZGV4U3RhdHMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9wcm9qZWN0SWRTaW5nbGV0b24udHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS92ZWN0b3JPcGVyYXRpb25zUHJvdmlkZXIudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvZGF0YS9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy9waW5lY29uZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvcnVudGltZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0FwcHJveGltYXRlZENvbmZpZy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0NvbGxlY3Rpb25NZXRhLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvQ3JlYXRlQ29sbGVjdGlvblJlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9DcmVhdGVSZXF1ZXN0SW5kZXhDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9DcmVhdGVSZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvRGVsZXRlUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0Rlc2NyaWJlSW5kZXhTdGF0c1JlcXVlc3QudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9OYW1lc3BhY2VTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvRGVzY3JpYmVJbmRleFN0YXRzUmVzcG9uc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9TcGFyc2VWYWx1ZXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9WZWN0b3IudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9GZXRjaFJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvSG5zd0NvbmZpZy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0luZGV4TWV0YURhdGFiYXNlSW5kZXhDb25maWcudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9JbmRleE1ldGFEYXRhYmFzZS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0luZGV4TWV0YVN0YXR1cy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL0luZGV4TWV0YS50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1BhdGNoUmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Byb3RvYnVmQW55LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvUHJvdG9idWZOdWxsVmFsdWUudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9RdWVyeVZlY3Rvci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1F1ZXJ5UmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Njb3JlZFZlY3Rvci50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1NpbmdsZVF1ZXJ5UmVzdWx0cy50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1F1ZXJ5UmVzcG9uc2UudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9ScGNTdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL21vZGVscy9VcGRhdGVSZXF1ZXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvVXBzZXJ0UmVxdWVzdC50cyIsICJub2RlX21vZHVsZXMvQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lL3NyYy92MC9waW5lY29uZS1nZW5lcmF0ZWQtdHMtZmV0Y2gvbW9kZWxzL1Vwc2VydFJlc3BvbnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9tb2RlbHMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL2FwaXMvSW5kZXhPcGVyYXRpb25zQXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9AcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmUvc3JjL3YwL3BpbmVjb25lLWdlbmVyYXRlZC10cy1mZXRjaC9hcGlzL1ZlY3Rvck9wZXJhdGlvbnNBcGkudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL2FwaXMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvcGluZWNvbmUtZ2VuZXJhdGVkLXRzLWZldGNoL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvdjAvdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZS9zcmMvaW5kZXgudHMiLCAibWFpbi50cyIsICJ1dGlscy9nbG9iYWxIYW5kbGVycy50cyIsICJ1dGlscy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy92ZXJzaW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2Vycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3N0cmVhbWluZy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9fc2hpbXMvcmVnaXN0cnkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL011bHRpcGFydEJvZHkudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy91cGxvYWRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcGFnaW5hdGlvbi50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vdHJhbnNjcmlwdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zbGF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvYXVkaW8vYXVkaW8udHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvY29tcGxldGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VtYmVkZGluZ3MudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2VkaXRzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9maWxlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5lcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvZmluZS10dW5pbmcvZmluZS10dW5pbmcudHMiLCAibm9kZV9tb2R1bGVzL29wZW5haS9zcmMvcmVzb3VyY2VzL2ltYWdlcy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9yZXNvdXJjZXMvbW9kZWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9vcGVuYWkvc3JjL3Jlc291cmNlcy9tb2RlcmF0aW9ucy50cyIsICJub2RlX21vZHVsZXMvb3BlbmFpL3NyYy9pbmRleC50cyIsICJ1dGlscy9yZXF1aXJlbWVudHMudHMiLCAidXRpbHMvdGVtcGxhdGVzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJleHBvcnQgYWJzdHJhY3QgY2xhc3MgX0NvZGVPck5hbWUge1xuICBhYnN0cmFjdCByZWFkb25seSBzdHI6IHN0cmluZ1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG4gIGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZ1xuICBhYnN0cmFjdCBlbXB0eVN0cigpOiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBJREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2lcblxuZXhwb3J0IGNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gIHJlYWRvbmx5IHN0cjogc3RyaW5nXG4gIGNvbnN0cnVjdG9yKHM6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICBpZiAoIUlERU5USUZJRVIudGVzdChzKSkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKVxuICAgIHRoaXMuc3RyID0gc1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJcbiAgfVxuXG4gIGVtcHR5U3RyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHtbdGhpcy5zdHJdOiAxfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgcmVhZG9ubHkgX2l0ZW1zOiByZWFkb25seSBDb2RlSXRlbVtdXG4gIHByaXZhdGUgX3N0cj86IHN0cmluZ1xuICBwcml2YXRlIF9uYW1lcz86IFVzZWROYW1lc1xuXG4gIGNvbnN0cnVjdG9yKGNvZGU6IHN0cmluZyB8IHJlYWRvbmx5IENvZGVJdGVtW10pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGVcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RyXG4gIH1cblxuICBlbXB0eVN0cigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdXG4gICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInXG4gIH1cblxuICBnZXQgc3RyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLl9zdHIgPz89IHRoaXMuX2l0ZW1zLnJlZHVjZSgoczogc3RyaW5nLCBjOiBDb2RlSXRlbSkgPT4gYCR7c30ke2N9YCwgXCJcIikpXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gKHRoaXMuX25hbWVzID8/PSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIGMpID0+IHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSkgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDFcbiAgICAgIHJldHVybiBuYW1lc1xuICAgIH0sIHt9KSlcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDb2RlSXRlbSA9IE5hbWUgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG5leHBvcnQgdHlwZSBVc2VkTmFtZXMgPSBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCB0eXBlIENvZGUgPSBfQ29kZSB8IE5hbWVcblxuZXhwb3J0IHR5cGUgU2FmZUV4cHIgPSBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxcblxuZXhwb3J0IGNvbnN0IG5pbCA9IG5ldyBfQ29kZShcIlwiKVxuXG50eXBlIENvZGVBcmcgPSBTYWZlRXhwciB8IHN0cmluZyB8IHVuZGVmaW5lZFxuXG5leHBvcnQgZnVuY3Rpb24gXyhzdHJzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogQ29kZUFyZ1tdKTogX0NvZGUge1xuICBjb25zdCBjb2RlOiBDb2RlSXRlbVtdID0gW3N0cnNbMF1dXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKVxuICAgIGNvZGUucHVzaChzdHJzWysraV0pXG4gIH1cbiAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKVxufVxuXG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyKHN0cnM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiAoQ29kZUFyZyB8IHN0cmluZ1tdKVtdKTogX0NvZGUge1xuICBjb25zdCBleHByOiBDb2RlSXRlbVtdID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgZXhwci5wdXNoKHBsdXMpXG4gICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKVxuICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpXG4gIH1cbiAgb3B0aW1pemUoZXhwcilcbiAgcmV0dXJuIG5ldyBfQ29kZShleHByKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlOiBDb2RlSXRlbVtdLCBhcmc6IENvZGVBcmcgfCBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKVxuICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKSBjb2RlLnB1c2goYXJnKVxuICBlbHNlIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKVxufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZShleHByOiBDb2RlSXRlbVtdKTogdm9pZCB7XG4gIGxldCBpID0gMVxuICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pXG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcylcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGV4cHJbaSsrXSA9IFwiK1wiXG4gICAgfVxuICAgIGkrK1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGE6IENvZGVJdGVtLCBiOiBDb2RlSXRlbSk6IENvZGVJdGVtIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGIgPT09ICdcIlwiJykgcmV0dXJuIGFcbiAgaWYgKGEgPT09ICdcIlwiJykgcmV0dXJuIGJcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIikgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImBcbiAgICBpZiAoYlswXSA9PT0gJ1wiJykgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWBcbiAgcmV0dXJuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJDb25jYXQoYzE6IENvZGUsIGMyOiBDb2RlKTogQ29kZSB7XG4gIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHJgJHtjMX0ke2MyfWBcbn1cblxuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHg/OiBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsKTogU2FmZUV4cHIgfCBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgPyB4XG4gICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh4OiB1bmtub3duKTogQ29kZSB7XG4gIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeDogdW5rbm93bik6IHN0cmluZyB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleTogQ29kZSB8IHN0cmluZyB8IG51bWJlcik6IENvZGUge1xuICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIElERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfYFske2tleX1dYFxufVxuXG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXNtRXhwb3J0TmFtZShrZXk6IENvZGUgfCBzdHJpbmcgfCBudW1iZXIpOiBDb2RlIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBJREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4cENvZGUocng6IFJlZ0V4cCk6IENvZGUge1xuICByZXR1cm4gbmV3IF9Db2RlKHJ4LnRvU3RyaW5nKCkpXG59XG4iLCAiaW1wb3J0IHtfLCBuaWwsIENvZGUsIE5hbWV9IGZyb20gXCIuL2NvZGVcIlxuXG5pbnRlcmZhY2UgTmFtZUdyb3VwIHtcbiAgcHJlZml4OiBzdHJpbmdcbiAgaW5kZXg6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVWYWx1ZSB7XG4gIHJlZjogVmFsdWVSZWZlcmVuY2UgLy8gdGhpcyBpcyB0aGUgcmVmZXJlbmNlIHRvIGFueSB2YWx1ZSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBmcm9tIGdlbmVyYXRlZCBjb2RlIHZpYSBgZ2xvYmFsc2AgdmFyIGluIHRoZSBjbG9zdXJlXG4gIGtleT86IHVua25vd24gLy8gYW55IGtleSB0byBpZGVudGlmeSBhIGdsb2JhbCB0byBhdm9pZCBkdXBsaWNhdGVzLCBpZiBub3QgcGFzc2VkIHJlZiBpcyB1c2VkXG4gIGNvZGU/OiBDb2RlIC8vIHRoaXMgaXMgdGhlIGNvZGUgY3JlYXRpbmcgdGhlIHZhbHVlIG5lZWRlZCBmb3Igc3RhbmRhbG9uZSBjb2RlIHdpdF9vdXQgY2xvc3VyZSAtIGNhbiBiZSBhIHByaW1pdGl2ZSB2YWx1ZSwgZnVuY3Rpb24gb3IgaW1wb3J0IChgcmVxdWlyZWApXG59XG5cbmV4cG9ydCB0eXBlIFZhbHVlUmVmZXJlbmNlID0gdW5rbm93biAvLyBwb3NzaWJseSBtYWtlIENvZGVHZW4gcGFyYW1ldGVyaXplZCB0eXBlIG9uIHRoaXMgdHlwZVxuXG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSB2YWx1ZT86IE5hbWVWYWx1ZVxuICBjb25zdHJ1Y3RvcihuYW1lOiBWYWx1ZVNjb3BlTmFtZSkge1xuICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApXG4gICAgdGhpcy52YWx1ZSA9IG5hbWUudmFsdWVcbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NvcGVPcHRpb25zIHtcbiAgcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwYXJlbnQ/OiBTY29wZVxufVxuXG5pbnRlcmZhY2UgVmFsdWVTY29wZU9wdGlvbnMgZXh0ZW5kcyBTY29wZU9wdGlvbnMge1xuICBzY29wZTogU2NvcGVTdG9yZVxuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBTY29wZVN0b3JlID0gUmVjb3JkPHN0cmluZywgVmFsdWVSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZD5cblxudHlwZSBTY29wZVZhbHVlcyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogTWFwPHVua25vd24sIFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgdHlwZSBTY29wZVZhbHVlU2V0cyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogU2V0PFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgZW51bSBVc2VkVmFsdWVTdGF0ZSB7XG4gIFN0YXJ0ZWQsXG4gIENvbXBsZXRlZCxcbn1cblxuZXhwb3J0IHR5cGUgVXNlZFNjb3BlVmFsdWVzID0ge1xuICBbUHJlZml4IGluIHN0cmluZ10/OiBNYXA8VmFsdWVTY29wZU5hbWUsIFVzZWRWYWx1ZVN0YXRlIHwgdW5kZWZpbmVkPlxufVxuXG5leHBvcnQgY29uc3QgdmFyS2luZHMgPSB7XG4gIGNvbnN0OiBuZXcgTmFtZShcImNvbnN0XCIpLFxuICBsZXQ6IG5ldyBOYW1lKFwibGV0XCIpLFxuICB2YXI6IG5ldyBOYW1lKFwidmFyXCIpLFxufVxuXG5leHBvcnQgY2xhc3MgU2NvcGUge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX25hbWVzOiB7W1ByZWZpeCBpbiBzdHJpbmddPzogTmFtZUdyb3VwfSA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3BhcmVudD86IFNjb3BlXG5cbiAgY29uc3RydWN0b3Ioe3ByZWZpeGVzLCBwYXJlbnR9OiBTY29wZU9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXNcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIHRvTmFtZShuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogTmFtZSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV3TmFtZShwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpXG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YFxuICB9XG5cbiAgcHJpdmF0ZSBfbmFtZUdyb3VwKHByZWZpeDogc3RyaW5nKTogTmFtZUdyb3VwIHtcbiAgICBpZiAodGhpcy5fcGFyZW50Py5fcHJlZml4ZXM/LmhhcyhwcmVmaXgpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7cHJlZml4LCBpbmRleDogMH0pXG4gIH1cbn1cblxuaW50ZXJmYWNlIFNjb3BlUGF0aCB7XG4gIHByb3BlcnR5OiBzdHJpbmdcbiAgaXRlbUluZGV4OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgTmFtZSB7XG4gIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nXG4gIHZhbHVlPzogTmFtZVZhbHVlXG4gIHNjb3BlUGF0aD86IENvZGVcblxuICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgbmFtZVN0cjogc3RyaW5nKSB7XG4gICAgc3VwZXIobmFtZVN0cilcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICB9XG5cbiAgc2V0VmFsdWUodmFsdWU6IE5hbWVWYWx1ZSwge3Byb3BlcnR5LCBpdGVtSW5kZXh9OiBTY29wZVBhdGgpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLnNjb3BlUGF0aCA9IF9gLiR7bmV3IE5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYFxuICB9XG59XG5cbmludGVyZmFjZSBWU09wdGlvbnMgZXh0ZW5kcyBWYWx1ZVNjb3BlT3B0aW9ucyB7XG4gIF9uOiBDb2RlXG59XG5cbmNvbnN0IGxpbmUgPSBfYFxcbmBcblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlcyA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfc2NvcGU6IFNjb3BlU3RvcmVcbiAgcmVhZG9ubHkgb3B0czogVlNPcHRpb25zXG5cbiAgY29uc3RydWN0b3Iob3B0czogVmFsdWVTY29wZU9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZVxuICAgIHRoaXMub3B0cyA9IHsuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBuaWx9XG4gIH1cblxuICBnZXQoKTogU2NvcGVTdG9yZSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njb3BlXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogVmFsdWVTY29wZU5hbWUge1xuICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpXG4gIH1cblxuICB2YWx1ZShuYW1lT3JQcmVmaXg6IFZhbHVlU2NvcGVOYW1lIHwgc3RyaW5nLCB2YWx1ZTogTmFtZVZhbHVlKTogVmFsdWVTY29wZU5hbWUge1xuICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpXG4gICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCkgYXMgVmFsdWVTY29wZU5hbWVcbiAgICBjb25zdCB7cHJlZml4fSA9IG5hbWVcbiAgICBjb25zdCB2YWx1ZUtleSA9IHZhbHVlLmtleSA/PyB2YWx1ZS5yZWZcbiAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XVxuICAgIGlmICh2cykge1xuICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpXG4gICAgICBpZiAoX25hbWUpIHJldHVybiBfbmFtZVxuICAgIH0gZWxzZSB7XG4gICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpXG4gICAgfVxuICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSlcblxuICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pXG4gICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGhcbiAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWZcbiAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7cHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4fSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0VmFsdWUocHJlZml4OiBzdHJpbmcsIGtleU9yUmVmOiB1bmtub3duKTogVmFsdWVTY29wZU5hbWUgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF1cbiAgICBpZiAoIXZzKSByZXR1cm5cbiAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKVxuICB9XG5cbiAgc2NvcGVSZWZzKHNjb3BlTmFtZTogTmFtZSwgdmFsdWVzOiBTY29wZVZhbHVlcyB8IFNjb3BlVmFsdWVTZXRzID0gdGhpcy5fdmFsdWVzKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lOiBWYWx1ZVNjb3BlTmFtZSkgPT4ge1xuICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKVxuICAgICAgcmV0dXJuIF9gJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gXG4gICAgfSlcbiAgfVxuXG4gIHNjb3BlQ29kZShcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMgPSB0aGlzLl92YWx1ZXMsXG4gICAgdXNlZFZhbHVlcz86IFVzZWRTY29wZVZhbHVlcyxcbiAgICBnZXRDb2RlPzogKG46IFZhbHVlU2NvcGVOYW1lKSA9PiBDb2RlIHwgdW5kZWZpbmVkXG4gICk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXMoXG4gICAgICB2YWx1ZXMsXG4gICAgICAobmFtZTogVmFsdWVTY29wZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApXG4gICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGVcbiAgICAgIH0sXG4gICAgICB1c2VkVmFsdWVzLFxuICAgICAgZ2V0Q29kZVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3JlZHVjZVZhbHVlcyhcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMsXG4gICAgdmFsdWVDb2RlOiAobjogVmFsdWVTY29wZU5hbWUpID0+IENvZGUgfCB1bmRlZmluZWQsXG4gICAgdXNlZFZhbHVlczogVXNlZFNjb3BlVmFsdWVzID0ge30sXG4gICAgZ2V0Q29kZT86IChuOiBWYWx1ZVNjb3BlTmFtZSkgPT4gQ29kZSB8IHVuZGVmaW5lZFxuICApOiBDb2RlIHtcbiAgICBsZXQgY29kZTogQ29kZSA9IG5pbFxuICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XVxuICAgICAgaWYgKCF2cykgY29udGludWVcbiAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSlcbiAgICAgIHZzLmZvckVhY2goKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSkgcmV0dXJuXG4gICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpXG4gICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmNvbnN0XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSBpZiAoKGMgPSBnZXRDb2RlPy4obmFtZSkpKSB7XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSlcbiAgICAgICAgfVxuICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1Njb3BlVmFsdWVTZXRzLCBOYW1lVmFsdWUsIFZhbHVlU2NvcGUsIFZhbHVlU2NvcGVOYW1lfSBmcm9tIFwiLi9zY29wZVwiXG5pbXBvcnQge18sIG5pbCwgX0NvZGUsIENvZGUsIE5hbWUsIFVzZWROYW1lcywgQ29kZUl0ZW0sIGFkZENvZGVBcmcsIF9Db2RlT3JOYW1lfSBmcm9tIFwiLi9jb2RlXCJcbmltcG9ydCB7U2NvcGUsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbmV4cG9ydCB7Xywgc3RyLCBzdHJDb25jYXQsIG5pbCwgZ2V0UHJvcGVydHksIHN0cmluZ2lmeSwgcmVnZXhwQ29kZSwgTmFtZSwgQ29kZX0gZnJvbSBcIi4vY29kZVwiXG5leHBvcnQge1Njb3BlLCBTY29wZVN0b3JlLCBWYWx1ZVNjb3BlLCBWYWx1ZVNjb3BlTmFtZSwgU2NvcGVWYWx1ZVNldHMsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbi8vIHR5cGUgZm9yIGV4cHJlc3Npb25zIHRoYXQgY2FuIGJlIHNhZmVseSBpbnNlcnRlZCBpbiBjb2RlIHdpdGhvdXQgcXVvdGVzXG5leHBvcnQgdHlwZSBTYWZlRXhwciA9IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG4vLyB0eXBlIHRoYXQgaXMgZWl0aGVyIENvZGUgb2YgZnVuY3Rpb24gdGhhdCBhZGRzIGNvZGUgdG8gQ29kZUdlbiBpbnN0YW5jZSB1c2luZyBpdHMgbWV0aG9kc1xuZXhwb3J0IHR5cGUgQmxvY2sgPSBDb2RlIHwgKCgpID0+IHZvaWQpXG5cbmV4cG9ydCBjb25zdCBvcGVyYXRvcnMgPSB7XG4gIEdUOiBuZXcgX0NvZGUoXCI+XCIpLFxuICBHVEU6IG5ldyBfQ29kZShcIj49XCIpLFxuICBMVDogbmV3IF9Db2RlKFwiPFwiKSxcbiAgTFRFOiBuZXcgX0NvZGUoXCI8PVwiKSxcbiAgRVE6IG5ldyBfQ29kZShcIj09PVwiKSxcbiAgTkVROiBuZXcgX0NvZGUoXCIhPT1cIiksXG4gIE5PVDogbmV3IF9Db2RlKFwiIVwiKSxcbiAgT1I6IG5ldyBfQ29kZShcInx8XCIpLFxuICBBTkQ6IG5ldyBfQ29kZShcIiYmXCIpLFxuICBBREQ6IG5ldyBfQ29kZShcIitcIiksXG59XG5cbmFic3RyYWN0IGNsYXNzIE5vZGUge1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKF9uYW1lczogVXNlZE5hbWVzLCBfY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIDFcbiAgLy8gfVxufVxuXG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLCBwcml2YXRlIHJlYWRvbmx5IG5hbWU6IE5hbWUsIHByaXZhdGUgcmhzPzogU2FmZUV4cHIpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe2VzNSwgX259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyB2YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmRcbiAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWBcbiAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfblxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pIHJldHVyblxuICAgIGlmICh0aGlzLnJocykgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fVxuICB9XG59XG5cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBsaHM6IENvZGUsIHB1YmxpYyByaHM6IFNhZmVFeHByLCBwcml2YXRlIHJlYWRvbmx5IHNpZGVFZmZlY3RzPzogYm9vbGVhbikge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBOYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKSByZXR1cm5cbiAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIE5hbWUgPyB7fSA6IHsuLi50aGlzLmxocy5uYW1lc31cbiAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocylcbiAgfVxufVxuXG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gIGNvbnN0cnVjdG9yKGxoczogQ29kZSwgcHJpdmF0ZSByZWFkb25seSBvcDogQ29kZSwgcmhzOiBTYWZlRXhwciwgc2lkZUVmZmVjdHM/OiBib29sZWFuKSB7XG4gICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX25cbiAgfVxufVxuXG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICByZWFkb25seSBuYW1lczogVXNlZE5hbWVzID0ge31cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbGFiZWw6IE5hbWUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uXG4gIH1cbn1cblxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgcmVhZG9ubHkgbmFtZXM6IFVzZWROYW1lcyA9IHt9XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGxhYmVsPzogQ29kZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiXG4gICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfblxuICB9XG59XG5cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGVycm9yOiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfblxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXNcbiAgfVxufVxuXG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29kZTogU2FmZUV4cHIpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMge1xuICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBfQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9XG4gIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBub2RlczogQ2hpbGROb2RlW10gPSBbXSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKVxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtub2Rlc30gPSB0aGlzXG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSkgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pXG4gICAgICBlbHNlIGlmIChuKSBub2Rlc1tpXSA9IG5cbiAgICAgIGVsc2Ugbm9kZXMuc3BsaWNlKGksIDEpXG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtub2Rlc30gPSB0aGlzXG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXVxuICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgY29udGludWVcbiAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpXG4gICAgICBub2Rlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGMsIG4pID0+IGMgKyBuLmNvdW50LCAxKVxuICAvLyB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uXG4gIH1cbn1cblxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge31cblxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJlbHNlXCJcbn1cblxuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiaWZcIlxuICBlbHNlPzogSWYgfCBFbHNlXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbiwgbm9kZXM/OiBDaGlsZE5vZGVbXSkge1xuICAgIHN1cGVyKG5vZGVzKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmVsc2UpIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKVxuICAgIHJldHVybiBjb2RlXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IElmIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKVxuICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvblxuICAgIGlmIChjb25kID09PSB0cnVlKSByZXR1cm4gdGhpcy5ub2RlcyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgIGxldCBlID0gdGhpcy5lbHNlXG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IChucyBhcyBFbHNlIHwgdW5kZWZpbmVkKVxuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKSByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXNcbiAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCkgcmV0dXJuIHRoaXNcbiAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKVxuICAgIH1cbiAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICB0aGlzLmVsc2UgPSB0aGlzLmVsc2U/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpIHJldHVyblxuICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzXG4gICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbilcbiAgICBpZiAodGhpcy5lbHNlKSBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKVxuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHN1cGVyLmNvdW50ICsgKHRoaXMuZWxzZT8uY291bnQgfHwgMClcbiAgLy8gfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiZm9yXCJcbn1cblxuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlcmF0aW9uOiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgcmV0dXJuXG4gICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpXG4gIH1cbn1cblxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhcktpbmQ6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnJvbTogU2FmZUV4cHIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0bzogU2FmZUV4cHJcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kXG4gICAgY29uc3Qge25hbWUsIGZyb20sIHRvfSA9IHRoaXNcbiAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pXG4gICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50bylcbiAgfVxufVxuXG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb29wOiBcIm9mXCIgfCBcImluXCIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogTmFtZSxcbiAgICBwcml2YXRlIGl0ZXJhYmxlOiBDb2RlXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgcmV0dXJuXG4gICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpXG4gIH1cbn1cblxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmdW5jXCJcbiAgY29uc3RydWN0b3IocHVibGljIG5hbWU6IE5hbWUsIHB1YmxpYyBhcmdzOiBDb2RlLCBwdWJsaWMgYXN5bmM/OiBib29sZWFuKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiXG4gICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcInJldHVyblwiXG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgY2F0Y2g/OiBDYXRjaFxuICBmaW5hbGx5PzogRmluYWxseVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmNhdGNoKSBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuZmluYWxseSkgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpXG4gICAgcmV0dXJuIGNvZGVcbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB7XG4gICAgc3VwZXIub3B0aW1pemVOb2RlcygpXG4gICAgdGhpcy5jYXRjaD8ub3B0aW1pemVOb2RlcygpIGFzIENhdGNoIHwgdW5kZWZpbmVkXG4gICAgdGhpcy5maW5hbGx5Py5vcHRpbWl6ZU5vZGVzKCkgYXMgRmluYWxseSB8IHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB7XG4gICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIHRoaXMuY2F0Y2g/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICB0aGlzLmZpbmFsbHk/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lc1xuICAgIGlmICh0aGlzLmNhdGNoKSBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcylcbiAgICBpZiAodGhpcy5maW5hbGx5KSBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKVxuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHN1cGVyLmNvdW50ICsgKHRoaXMuY2F0Y2g/LmNvdW50IHx8IDApICsgKHRoaXMuZmluYWxseT8uY291bnQgfHwgMClcbiAgLy8gfVxufVxuXG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJjYXRjaFwiXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGVycm9yOiBOYW1lKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImZpbmFsbHlcIlxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG50eXBlIFN0YXJ0QmxvY2tOb2RlID0gSWYgfCBGb3IgfCBGdW5jIHwgUmV0dXJuIHwgVHJ5XG5cbnR5cGUgTGVhZk5vZGUgPSBEZWYgfCBBc3NpZ24gfCBMYWJlbCB8IEJyZWFrIHwgVGhyb3cgfCBBbnlDb2RlXG5cbnR5cGUgQ2hpbGROb2RlID0gU3RhcnRCbG9ja05vZGUgfCBMZWFmTm9kZVxuXG50eXBlIEVuZEJsb2NrTm9kZVR5cGUgPVxuICB8IHR5cGVvZiBJZlxuICB8IHR5cGVvZiBFbHNlXG4gIHwgdHlwZW9mIEZvclxuICB8IHR5cGVvZiBGdW5jXG4gIHwgdHlwZW9mIFJldHVyblxuICB8IHR5cGVvZiBDYXRjaFxuICB8IHR5cGVvZiBGaW5hbGx5XG5cbnR5cGUgQ29uc3RhbnRzID0gUmVjb3JkPHN0cmluZywgU2FmZUV4cHIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUdlbk9wdGlvbnMge1xuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgQ0dPcHRpb25zIGV4dGVuZHMgQ29kZUdlbk9wdGlvbnMge1xuICBfbjogXCJcXG5cIiB8IFwiXCJcbn1cblxuZXhwb3J0IGNsYXNzIENvZGVHZW4ge1xuICByZWFkb25seSBfc2NvcGU6IFNjb3BlXG4gIHJlYWRvbmx5IF9leHRTY29wZTogVmFsdWVTY29wZVxuICByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlU2V0cyA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX25vZGVzOiBQYXJlbnROb2RlW11cbiAgcHJpdmF0ZSByZWFkb25seSBfYmxvY2tTdGFydHM6IG51bWJlcltdID0gW11cbiAgcHJpdmF0ZSByZWFkb25seSBfY29uc3RhbnRzOiBDb25zdGFudHMgPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG9wdHM6IENHT3B0aW9uc1xuXG4gIGNvbnN0cnVjdG9yKGV4dFNjb3BlOiBWYWx1ZVNjb3BlLCBvcHRzOiBDb2RlR2VuT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRzID0gey4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCJ9XG4gICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZVxuICAgIHRoaXMuX3Njb3BlID0gbmV3IFNjb3BlKHtwYXJlbnQ6IGV4dFNjb3BlfSlcbiAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXVxuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKVxuICB9XG5cbiAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgbmFtZShwcmVmaXg6IHN0cmluZyk6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeClcbiAgfVxuXG4gIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICBzY29wZU5hbWUocHJlZml4OiBzdHJpbmcpOiBWYWx1ZVNjb3BlTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KVxuICB9XG5cbiAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lOiBWYWx1ZVNjb3BlTmFtZSB8IHN0cmluZywgdmFsdWU6IE5hbWVWYWx1ZSk6IE5hbWUge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKVxuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSlcbiAgICB2cy5hZGQobmFtZSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0U2NvcGVWYWx1ZShwcmVmaXg6IHN0cmluZywga2V5T3JSZWY6IHVua25vd24pOiBWYWx1ZVNjb3BlTmFtZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpXG4gIH1cblxuICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICBzY29wZVJlZnMoc2NvcGVOYW1lOiBOYW1lKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcylcbiAgfVxuXG4gIHNjb3BlQ29kZSgpOiBDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcylcbiAgfVxuXG4gIHByaXZhdGUgX2RlZihcbiAgICB2YXJLaW5kOiBOYW1lLFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICByaHM/OiBTYWZlRXhwcixcbiAgICBjb25zdGFudD86IGJvb2xlYW5cbiAgKTogTmFtZSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KSB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzXG4gICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgY29uc3QobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLCByaHM6IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gIGxldChuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsIHJocz86IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgdmFyKG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZywgcmhzPzogU2FmZUV4cHIsIF9jb25zdGFudD86IGJvb2xlYW4pOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmKHZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGFzc2lnbm1lbnQgY29kZVxuICBhc3NpZ24obGhzOiBDb2RlLCByaHM6IFNhZmVFeHByLCBzaWRlRWZmZWN0cz86IGJvb2xlYW4pOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKVxuICB9XG5cbiAgLy8gYCs9YCBjb2RlXG4gIGFkZChsaHM6IENvZGUsIHJoczogU2FmZUV4cHIpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgb3BlcmF0b3JzLkFERCwgcmhzKSlcbiAgfVxuXG4gIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgY29kZShjOiBCbG9jayB8IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIikgYygpXG4gICAgZWxzZSBpZiAoYyAhPT0gbmlsKSB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICBvYmplY3QoLi4ua2V5VmFsdWVzOiBbTmFtZSB8IHN0cmluZywgU2FmZUV4cHIgfCBzdHJpbmddW10pOiBfQ29kZSB7XG4gICAgY29uc3QgY29kZTogQ29kZUl0ZW1bXSA9IFtcIntcIl1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpIGNvZGUucHVzaChcIixcIilcbiAgICAgIGNvZGUucHVzaChrZXkpXG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgIGNvZGUucHVzaChcIjpcIilcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSlcbiAgfVxuXG4gIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgaWYoY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbiwgdGhlbkJvZHk/OiBCbG9jaywgZWxzZUJvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSlcblxuICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKVxuICAgIH0gZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKVxuICAgIH0gZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gIGVsc2VJZihjb25kaXRpb246IENvZGUgfCBib29sZWFuKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKVxuICB9XG5cbiAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICBlbHNlKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKVxuICB9XG5cbiAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gIGVuZElmKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpXG4gIH1cblxuICBwcml2YXRlIF9mb3Iobm9kZTogRm9yLCBmb3JCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICBpZiAoZm9yQm9keSkgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICBmb3IoaXRlcmF0aW9uOiBDb2RlLCBmb3JCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpXG4gIH1cblxuICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gIGZvclJhbmdlKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBmcm9tOiBTYWZlRXhwcixcbiAgICB0bzogU2FmZUV4cHIsXG4gICAgZm9yQm9keTogKGluZGV4OiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB0aGlzLm9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdmFyS2luZHMubGV0XG4gICk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSlcbiAgfVxuXG4gIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICBmb3JPZihcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgaXRlcmFibGU6IENvZGUsXG4gICAgZm9yQm9keTogKGl0ZW06IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHZhcktpbmRzLmNvbnN0XG4gICk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIE5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSlcbiAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgX2Ake2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgdGhpcy52YXIobmFtZSwgX2Ake2Fycn1bJHtpfV1gKVxuICAgICAgICBmb3JCb2R5KG5hbWUpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKVxuICB9XG5cbiAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gIGZvckluKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBvYmo6IENvZGUsXG4gICAgZm9yQm9keTogKGl0ZW06IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHRoaXMub3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB2YXJLaW5kcy5jb25zdFxuICApOiBDb2RlR2VuIHtcbiAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgX2BPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSlcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpXG4gIH1cblxuICAvLyBlbmQgYGZvcmAgbG9vcFxuICBlbmRGb3IoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpXG4gIH1cblxuICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICBsYWJlbChsYWJlbDogTmFtZSk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKVxuICB9XG5cbiAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgYnJlYWsobGFiZWw/OiBDb2RlKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpXG4gIH1cblxuICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgcmV0dXJuKHZhbHVlOiBCbG9jayB8IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKVxuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIHRoaXMuY29kZSh2YWx1ZSlcbiAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pXG4gIH1cblxuICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgdHJ5KHRyeUJvZHk6IEJsb2NrLCBjYXRjaENvZGU/OiAoZTogTmFtZSkgPT4gdm9pZCwgZmluYWxseUNvZGU/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSkgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKVxuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIHRoaXMuY29kZSh0cnlCb2R5KVxuICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKVxuICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKVxuICAgICAgY2F0Y2hDb2RlKGVycm9yKVxuICAgIH1cbiAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKVxuICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KVxuICB9XG5cbiAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgdGhyb3coZXJyb3I6IENvZGUpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSlcbiAgfVxuXG4gIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gIGJsb2NrKGJvZHk/OiBCbG9jaywgbm9kZUNvdW50PzogbnVtYmVyKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpXG4gICAgaWYgKGJvZHkpIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICBlbmRCbG9jayhub2RlQ291bnQ/OiBudW1iZXIpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKVxuICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpXG4gICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlblxuICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYClcbiAgICB9XG4gICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gIGZ1bmMobmFtZTogTmFtZSwgYXJnczogQ29kZSA9IG5pbCwgYXN5bmM/OiBib29sZWFuLCBmdW5jQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSlcbiAgICBpZiAoZnVuY0JvZHkpIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gIGVuZEZ1bmMoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKVxuICB9XG5cbiAgb3B0aW1pemUobiA9IDEpOiB2b2lkIHtcbiAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbGVhZk5vZGUobm9kZTogTGVhZk5vZGUpOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgX2Jsb2NrTm9kZShub2RlOiBTdGFydEJsb2NrTm9kZSk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSlcbiAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpXG4gIH1cblxuICBwcml2YXRlIF9lbmRCbG9ja05vZGUoTjE6IEVuZEJsb2NrTm9kZVR5cGUsIE4yPzogRW5kQmxvY2tOb2RlVHlwZSk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZVxuICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgIHRoaXMuX25vZGVzLnBvcCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKVxuICB9XG5cbiAgcHJpdmF0ZSBfZWxzZU5vZGUobm9kZTogSWYgfCBFbHNlKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlXG4gICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpXG4gICAgfVxuICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdldCBfcm9vdCgpOiBSb290IHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0gYXMgUm9vdFxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX2N1cnJOb2RlKCk6IFBhcmVudE5vZGUge1xuICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXNcbiAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV1cbiAgfVxuXG4gIHByaXZhdGUgc2V0IF9jdXJyTm9kZShub2RlOiBQYXJlbnROb2RlKSB7XG4gICAgY29uc3QgbnMgPSB0aGlzLl9ub2Rlc1xuICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZVxuICB9XG5cbiAgLy8gZ2V0IG5vZGVDb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiB0aGlzLl9yb290LmNvdW50XG4gIC8vIH1cbn1cblxuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogVXNlZE5hbWVzKTogVXNlZE5hbWVzIHtcbiAgZm9yIChjb25zdCBuIGluIGZyb20pIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMClcbiAgcmV0dXJuIG5hbWVzXG59XG5cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBmcm9tOiBTYWZlRXhwcik6IFVzZWROYW1lcyB7XG4gIHJldHVybiBmcm9tIGluc3RhbmNlb2YgX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lc1xufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHI8VCBleHRlbmRzIFNhZmVFeHByIHwgQ29kZT4oZXhwcjogVCwgbmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiBUXG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwcjogU2FmZUV4cHIsIG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogU2FmZUV4cHIge1xuICBpZiAoZXhwciBpbnN0YW5jZW9mIE5hbWUpIHJldHVybiByZXBsYWNlTmFtZShleHByKVxuICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKSByZXR1cm4gZXhwclxuICByZXR1cm4gbmV3IF9Db2RlKFxuICAgIGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXM6IENvZGVJdGVtW10sIGM6IFNhZmVFeHByIHwgc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpIGMgPSByZXBsYWNlTmFtZShjKVxuICAgICAgaWYgKGMgaW5zdGFuY2VvZiBfQ29kZSkgaXRlbXMucHVzaCguLi5jLl9pdGVtcylcbiAgICAgIGVsc2UgaXRlbXMucHVzaChjKVxuICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfSwgW10pXG4gIClcblxuICBmdW5jdGlvbiByZXBsYWNlTmFtZShuOiBOYW1lKTogU2FmZUV4cHIge1xuICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdXG4gICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpIHJldHVybiBuXG4gICAgZGVsZXRlIG5hbWVzW24uc3RyXVxuICAgIHJldHVybiBjXG4gIH1cblxuICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlOiBTYWZlRXhwcik6IGUgaXMgX0NvZGUge1xuICAgIHJldHVybiAoXG4gICAgICBlIGluc3RhbmNlb2YgX0NvZGUgJiZcbiAgICAgIGUuX2l0ZW1zLnNvbWUoXG4gICAgICAgIChjKSA9PiBjIGluc3RhbmNlb2YgTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkXG4gICAgICApXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogVXNlZE5hbWVzKTogdm9pZCB7XG4gIGZvciAoY29uc3QgbiBpbiBmcm9tKSBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Q8VCBleHRlbmRzIENvZGUgfCBTYWZlRXhwcj4oeDogVCk6IFRcbmV4cG9ydCBmdW5jdGlvbiBub3QoeDogQ29kZSB8IFNhZmVFeHByKTogQ29kZSB8IFNhZmVFeHByIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogX2AhJHtwYXIoeCl9YFxufVxuXG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChvcGVyYXRvcnMuQU5EKVxuXG4vLyBib29sZWFuIEFORCAoJiYpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGFuZCguLi5hcmdzOiBDb2RlW10pOiBDb2RlIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpXG59XG5cbmNvbnN0IG9yQ29kZSA9IG1hcHBlbmQob3BlcmF0b3JzLk9SKVxuXG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gb3IoLi4uYXJnczogQ29kZVtdKTogQ29kZSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZShvckNvZGUpXG59XG5cbnR5cGUgTUFwcGVuZCA9ICh4OiBDb2RlLCB5OiBDb2RlKSA9PiBDb2RlXG5cbmZ1bmN0aW9uIG1hcHBlbmQob3A6IENvZGUpOiBNQXBwZW5kIHtcbiAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gbmlsID8geSA6IHkgPT09IG5pbCA/IHggOiBfYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKVxufVxuXG5mdW5jdGlvbiBwYXIoeDogQ29kZSk6IENvZGUge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE5hbWUgPyB4IDogX2AoJHt4fSlgXG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYSwgRXZhbHVhdGVkUHJvcGVydGllcywgRXZhbHVhdGVkSXRlbXN9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IHtfQ29kZX0gZnJvbSBcIi4vY29kZWdlbi9jb2RlXCJcbmltcG9ydCB0eXBlIHtSdWxlLCBWYWxpZGF0aW9uUnVsZXN9IGZyb20gXCIuL3J1bGVzXCJcblxuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5leHBvcnQgZnVuY3Rpb24gdG9IYXNoPFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KGFycjogVFtdKToge1tLIGluIFRdPzogdHJ1ZX0ge1xuICBjb25zdCBoYXNoOiB7W0sgaW4gVF0/OiB0cnVlfSA9IHt9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIGhhc2hbaXRlbV0gPSB0cnVlXG4gIHJldHVybiBoYXNoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdDogU2NoZW1hQ3h0LCBzY2hlbWE6IEFueVNjaGVtYSk6IGJvb2xlYW4gfCB2b2lkIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiBzY2hlbWFcbiAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZVxuICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKVxuICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdDogU2NoZW1hQ3h0LCBzY2hlbWE6IEFueVNjaGVtYSA9IGl0LnNjaGVtYSk6IHZvaWQge1xuICBjb25zdCB7b3B0cywgc2VsZn0gPSBpdFxuICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKSByZXR1cm5cbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSByZXR1cm5cbiAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmICghcnVsZXNba2V5XSkgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoXG4gIHNjaGVtYTogQW55U2NoZW1hLFxuICBydWxlczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW4gfCBSdWxlfVxuKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChydWxlc1trZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYTogQW55U2NoZW1hLCBSVUxFUzogVmFsaWRhdGlvblJ1bGVzKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKFxuICB7dG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRofTogU2NoZW1hT2JqQ3h0LFxuICBzY2hlbWE6IHVua25vd24sXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgJGRhdGE/OiBzdHJpbmcgfCBmYWxzZVxuKTogQ29kZSB8IG51bWJlciB8IGJvb2xlYW4ge1xuICBpZiAoISRkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gc2NoZW1hXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIF9gJHtzY2hlbWF9YFxuICB9XG4gIHJldHVybiBfYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cjogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKSByZXR1cm4gYCR7c3RyfWBcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hJdGVtPFQ+KHhzOiBUIHwgVFtdLCBmOiAoeDogVCkgPT4gdm9pZCk6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICBmb3IgKGNvbnN0IHggb2YgeHMpIGYoeClcbiAgfSBlbHNlIHtcbiAgICBmKHhzKVxuICB9XG59XG5cbnR5cGUgU29tZUV2YWx1YXRlZCA9IEV2YWx1YXRlZFByb3BlcnRpZXMgfCBFdmFsdWF0ZWRJdGVtc1xuXG50eXBlIE1lcmdlRXZhbHVhdGVkRnVuYzxUIGV4dGVuZHMgU29tZUV2YWx1YXRlZD4gPSAoXG4gIGdlbjogQ29kZUdlbixcbiAgZnJvbTogTmFtZSB8IFQsXG4gIHRvOiBOYW1lIHwgRXhjbHVkZTxULCB0cnVlPiB8IHVuZGVmaW5lZCxcbiAgdG9OYW1lPzogdHlwZW9mIE5hbWVcbikgPT4gTmFtZSB8IFRcblxuaW50ZXJmYWNlIE1ha2VNZXJnZUZ1bmNBcmdzPFQgZXh0ZW5kcyBTb21lRXZhbHVhdGVkPiB7XG4gIG1lcmdlTmFtZXM6IChnZW46IENvZGVHZW4sIGZyb206IE5hbWUsIHRvOiBOYW1lKSA9PiB2b2lkXG4gIG1lcmdlVG9OYW1lOiAoZ2VuOiBDb2RlR2VuLCBmcm9tOiBULCB0bzogTmFtZSkgPT4gdm9pZFxuICBtZXJnZVZhbHVlczogKGZyb206IFQsIHRvOiBFeGNsdWRlPFQsIHRydWU+KSA9PiBUXG4gIHJlc3VsdFRvTmFtZTogKGdlbjogQ29kZUdlbiwgcmVzPzogVCkgPT4gTmFtZVxufVxuXG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQ8VCBleHRlbmRzIFNvbWVFdmFsdWF0ZWQ+KHtcbiAgbWVyZ2VOYW1lcyxcbiAgbWVyZ2VUb05hbWUsXG4gIG1lcmdlVmFsdWVzLFxuICByZXN1bHRUb05hbWUsXG59OiBNYWtlTWVyZ2VGdW5jQXJnczxUPik6IE1lcmdlRXZhbHVhdGVkRnVuYzxUPiB7XG4gIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgY29uc3QgcmVzID1cbiAgICAgIHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBmcm9tXG4gICAgICAgIDogdG8gaW5zdGFuY2VvZiBOYW1lXG4gICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBOYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgTmFtZVxuICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0bylcbiAgICByZXR1cm4gdG9OYW1lID09PSBOYW1lICYmICEocmVzIGluc3RhbmNlb2YgTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzXG4gIH1cbn1cblxuaW50ZXJmYWNlIE1lcmdlRXZhbHVhdGVkIHtcbiAgcHJvcHM6IE1lcmdlRXZhbHVhdGVkRnVuYzxFdmFsdWF0ZWRQcm9wZXJ0aWVzPlxuICBpdGVtczogTWVyZ2VFdmFsdWF0ZWRGdW5jPEV2YWx1YXRlZEl0ZW1zPlxufVxuXG5leHBvcnQgY29uc3QgbWVyZ2VFdmFsdWF0ZWQ6IE1lcmdlRXZhbHVhdGVkID0ge1xuICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmlmKFxuICAgICAgICAgIF9gJHtmcm9tfSA9PT0gdHJ1ZWAsXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbih0bywgX2Ake3RvfSB8fCB7fWApLmNvZGUoX2BPYmplY3QuYXNzaWduKCR7dG99LCAke2Zyb219KWApXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih0bywgX2Ake3RvfSB8fCB7fWApXG4gICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsuLi5mcm9tLCAuLi50b30pLFxuICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gIH0pLFxuICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odG8sIF9gJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKVxuICAgICAgKSxcbiAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZWAsICgpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogX2Ake3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKVxuICAgICAgKSxcbiAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gIH0pLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuOiBDb2RlR2VuLCBwcz86IEV2YWx1YXRlZFByb3BlcnRpZXMpOiBOYW1lIHtcbiAgaWYgKHBzID09PSB0cnVlKSByZXR1cm4gZ2VuLnZhcihcInByb3BzXCIsIHRydWUpXG4gIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIF9ge31gKVxuICBpZiAocHMgIT09IHVuZGVmaW5lZCkgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKVxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW46IENvZGVHZW4sIHByb3BzOiBOYW1lLCBwczoge1tLIGluIHN0cmluZ10/OiB0cnVlfSk6IHZvaWQge1xuICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbihfYCR7cHJvcHN9JHtnZXRQcm9wZXJ0eShwKX1gLCB0cnVlKSlcbn1cblxuY29uc3Qgc25pcHBldHM6IHtbUyBpbiBzdHJpbmddPzogX0NvZGV9ID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZ1bmMoZ2VuOiBDb2RlR2VuLCBmOiB7Y29kZTogc3RyaW5nfSk6IE5hbWUge1xuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICByZWY6IGYsXG4gICAgY29kZTogc25pcHBldHNbZi5jb2RlXSB8fCAoc25pcHBldHNbZi5jb2RlXSA9IG5ldyBfQ29kZShmLmNvZGUpKSxcbiAgfSlcbn1cblxuZXhwb3J0IGVudW0gVHlwZSB7XG4gIE51bSxcbiAgU3RyLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKFxuICBkYXRhUHJvcDogTmFtZSB8IHN0cmluZyB8IG51bWJlcixcbiAgZGF0YVByb3BUeXBlPzogVHlwZSxcbiAganNQcm9wZXJ0eVN5bnRheD86IGJvb2xlYW5cbik6IENvZGUgfCBzdHJpbmcge1xuICAvLyBsZXQgcGF0aFxuICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBOYW1lKSB7XG4gICAgY29uc3QgaXNOdW1iZXIgPSBkYXRhUHJvcFR5cGUgPT09IFR5cGUuTnVtXG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgPyBfYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgOiBfYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgOiBpc051bWJlclxuICAgICAgPyBfYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICA6IF9gXCIvXCIgKyAke2RhdGFQcm9wfS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWAgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgfVxuICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/IGdldFByb3BlcnR5KGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShcbiAgaXQ6IFNjaGVtYUN4dCxcbiAgbXNnOiBzdHJpbmcsXG4gIG1vZGU6IGJvb2xlYW4gfCBcImxvZ1wiID0gaXQub3B0cy5zdHJpY3RTY2hlbWFcbik6IHZvaWQge1xuICBpZiAoIW1vZGUpIHJldHVyblxuICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWBcbiAgaWYgKG1vZGUgPT09IHRydWUpIHRocm93IG5ldyBFcnJvcihtc2cpXG4gIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKVxufVxuIiwgImltcG9ydCB7TmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5cbmNvbnN0IG5hbWVzID0ge1xuICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICBkYXRhOiBuZXcgTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgLy8gYXJncyBwYXNzZWQgZnJvbSByZWZlcmVuY2luZyBzY2hlbWFcbiAgdmFsQ3h0OiBuZXcgTmFtZShcInZhbEN4dFwiKSwgLy8gdmFsaWRhdGlvbi9kYXRhIGNvbnRleHQgLSBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIGRlc3RydWN0dXJlZCB0byB0aGUgbmFtZXMgYmVsb3dcbiAgaW5zdGFuY2VQYXRoOiBuZXcgTmFtZShcImluc3RhbmNlUGF0aFwiKSxcbiAgcGFyZW50RGF0YTogbmV3IE5hbWUoXCJwYXJlbnREYXRhXCIpLFxuICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBOYW1lKFwicGFyZW50RGF0YVByb3BlcnR5XCIpLFxuICByb290RGF0YTogbmV3IE5hbWUoXCJyb290RGF0YVwiKSwgLy8gcm9vdCBkYXRhIC0gc2FtZSBhcyB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGZpcnN0L3RvcCB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGR5bmFtaWNBbmNob3JzOiBuZXcgTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLCAvLyB1c2VkIHRvIHN1cHBvcnQgcmVjdXJzaXZlUmVmIGFuZCBkeW5hbWljUmVmXG4gIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgdkVycm9yczogbmV3IE5hbWUoXCJ2RXJyb3JzXCIpLCAvLyBudWxsIG9yIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gIGVycm9yczogbmV3IE5hbWUoXCJlcnJvcnNcIiksIC8vIGNvdW50ZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgdGhpczogbmV3IE5hbWUoXCJ0aGlzXCIpLFxuICAvLyBcImdsb2JhbHNcIlxuICBzZWxmOiBuZXcgTmFtZShcInNlbGZcIiksXG4gIHNjb3BlOiBuZXcgTmFtZShcInNjb3BlXCIpLFxuICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICBqc29uOiBuZXcgTmFtZShcImpzb25cIiksXG4gIGpzb25Qb3M6IG5ldyBOYW1lKFwianNvblBvc1wiKSxcbiAganNvbkxlbjogbmV3IE5hbWUoXCJqc29uTGVuXCIpLFxuICBqc29uUGFydDogbmV3IE5hbWUoXCJqc29uUGFydFwiKSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmFtZXNcbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEVycm9yQ3h0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4vaW5kZXhcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBzdHIsIHN0ckNvbmNhdCwgQ29kZSwgTmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5pbXBvcnQge1NhZmVFeHByfSBmcm9tIFwiLi9jb2RlZ2VuL2NvZGVcIlxuaW1wb3J0IHtnZXRFcnJvclBhdGgsIFR5cGV9IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0IE4gZnJvbSBcIi4vbmFtZXNcIlxuXG5leHBvcnQgY29uc3Qga2V5d29yZEVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmR9KSA9PiBzdHJgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59XG5cbmV4cG9ydCBjb25zdCBrZXl3b3JkJERhdGFFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkLCBzY2hlbWFUeXBlfSkgPT5cbiAgICBzY2hlbWFUeXBlXG4gICAgICA/IHN0cmBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIG11c3QgYmUgJHtzY2hlbWFUeXBlfSAoJGRhdGEpYFxuICAgICAgOiBzdHJgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUGF0aHMge1xuICBpbnN0YW5jZVBhdGg/OiBDb2RlXG4gIHNjaGVtYVBhdGg/OiBzdHJpbmdcbiAgcGFyZW50U2NoZW1hPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0RXJyb3IoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IGtleXdvcmRFcnJvcixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHMsXG4gIG92ZXJyaWRlQWxsRXJyb3JzPzogYm9vbGVhblxuKTogdm9pZCB7XG4gIGNvbnN0IHtpdH0gPSBjeHRcbiAgY29uc3Qge2dlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzfSA9IGl0XG4gIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKVxuICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgPz8gKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKVxuICB9IGVsc2Uge1xuICAgIHJldHVybkVycm9ycyhpdCwgX2BbJHtlcnJPYmp9XWApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IGtleXdvcmRFcnJvcixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHNcbik6IHZvaWQge1xuICBjb25zdCB7aXR9ID0gY3h0XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9yc30gPSBpdFxuICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocylcbiAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopXG4gIGlmICghKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgIHJldHVybkVycm9ycyhpdCwgTi52RXJyb3JzKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbjogQ29kZUdlbiwgZXJyc0NvdW50OiBOYW1lKTogdm9pZCB7XG4gIGdlbi5hc3NpZ24oTi5lcnJvcnMsIGVycnNDb3VudClcbiAgZ2VuLmlmKF9gJHtOLnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT5cbiAgICBnZW4uaWYoXG4gICAgICBlcnJzQ291bnQsXG4gICAgICAoKSA9PiBnZW4uYXNzaWduKF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksXG4gICAgICAoKSA9PiBnZW4uYXNzaWduKE4udkVycm9ycywgbnVsbClcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7XG4gIGdlbixcbiAga2V5d29yZCxcbiAgc2NoZW1hVmFsdWUsXG4gIGRhdGEsXG4gIGVycnNDb3VudCxcbiAgaXQsXG59OiBLZXl3b3JkRXJyb3JDeHQpOiB2b2lkIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpXG4gIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBOLmVycm9ycywgKGkpID0+IHtcbiAgICBnZW4uY29uc3QoZXJyLCBfYCR7Ti52RXJyb3JzfVske2l9XWApXG4gICAgZ2VuLmlmKF9gJHtlcnJ9Lmluc3RhbmNlUGF0aCA9PT0gdW5kZWZpbmVkYCwgKCkgPT5cbiAgICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uaW5zdGFuY2VQYXRoYCwgc3RyQ29uY2F0KE4uaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKVxuICAgIClcbiAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LnNjaGVtYVBhdGhgLCBzdHJgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YClcbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LnNjaGVtYWAsIHNjaGVtYVZhbHVlKVxuICAgICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5kYXRhYCwgZGF0YSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZEVycm9yKGdlbjogQ29kZUdlbiwgZXJyT2JqOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IGVyciA9IGdlbi5jb25zdChcImVyclwiLCBlcnJPYmopXG4gIGdlbi5pZihcbiAgICBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbGAsXG4gICAgKCkgPT4gZ2VuLmFzc2lnbihOLnZFcnJvcnMsIF9gWyR7ZXJyfV1gKSxcbiAgICBfYCR7Ti52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgXG4gIClcbiAgZ2VuLmNvZGUoX2Ake04uZXJyb3JzfSsrYClcbn1cblxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0OiBTY2hlbWFDeHQsIGVycnM6IENvZGUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnZ9ID0gaXRcbiAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICBnZW4udGhyb3coX2BuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0oJHtlcnJzfSlgKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgZXJycylcbiAgICBnZW4ucmV0dXJuKGZhbHNlKVxuICB9XG59XG5cbmNvbnN0IEUgPSB7XG4gIGtleXdvcmQ6IG5ldyBOYW1lKFwia2V5d29yZFwiKSxcbiAgc2NoZW1hUGF0aDogbmV3IE5hbWUoXCJzY2hlbWFQYXRoXCIpLCAvLyBhbHNvIHVzZWQgaW4gSlREIGVycm9yc1xuICBwYXJhbXM6IG5ldyBOYW1lKFwicGFyYW1zXCIpLFxuICBwcm9wZXJ0eU5hbWU6IG5ldyBOYW1lKFwicHJvcGVydHlOYW1lXCIpLFxuICBtZXNzYWdlOiBuZXcgTmFtZShcIm1lc3NhZ2VcIiksXG4gIHNjaGVtYTogbmV3IE5hbWUoXCJzY2hlbWFcIiksXG4gIHBhcmVudFNjaGVtYTogbmV3IE5hbWUoXCJwYXJlbnRTY2hlbWFcIiksXG59XG5cbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBlcnJvclBhdGhzPzogRXJyb3JQYXRoc1xuKTogQ29kZSB7XG4gIGNvbnN0IHtjcmVhdGVFcnJvcnN9ID0gY3h0Lml0XG4gIGlmIChjcmVhdGVFcnJvcnMgPT09IGZhbHNlKSByZXR1cm4gX2B7fWBcbiAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIGVycm9yUGF0aHM6IEVycm9yUGF0aHMgPSB7fVxuKTogQ29kZSB7XG4gIGNvbnN0IHtnZW4sIGl0fSA9IGN4dFxuICBjb25zdCBrZXlWYWx1ZXM6IFtOYW1lLCBTYWZlRXhwciB8IHN0cmluZ11bXSA9IFtcbiAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gIF1cbiAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcylcbiAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKVxufVxuXG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7ZXJyb3JQYXRofTogU2NoZW1hQ3h0LCB7aW5zdGFuY2VQYXRofTogRXJyb3JQYXRocyk6IFtOYW1lLCBDb2RlXSB7XG4gIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgPyBzdHJgJHtlcnJvclBhdGh9JHtnZXRFcnJvclBhdGgoaW5zdGFuY2VQYXRoLCBUeXBlLlN0cil9YFxuICAgIDogZXJyb3JQYXRoXG4gIHJldHVybiBbTi5pbnN0YW5jZVBhdGgsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXVxufVxuXG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoXG4gIHtrZXl3b3JkLCBpdDoge2VyclNjaGVtYVBhdGh9fTogS2V5d29yZEVycm9yQ3h0LFxuICB7c2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hfTogRXJyb3JQYXRoc1xuKTogW05hbWUsIHN0cmluZyB8IENvZGVdIHtcbiAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogc3RyYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWBcbiAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICBzY2hQYXRoID0gc3RyYCR7c2NoUGF0aH0ke2dldEVycm9yUGF0aChzY2hlbWFQYXRoLCBUeXBlLlN0cil9YFxuICB9XG4gIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXVxufVxuXG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICB7cGFyYW1zLCBtZXNzYWdlfTogS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAga2V5VmFsdWVzOiBbTmFtZSwgU2FmZUV4cHIgfCBzdHJpbmddW11cbik6IHZvaWQge1xuICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0fSA9IGN4dFxuICBjb25zdCB7b3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGh9ID0gaXRcbiAga2V5VmFsdWVzLnB1c2goXG4gICAgW0Uua2V5d29yZCwga2V5d29yZF0sXG4gICAgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8IF9ge31gXVxuICApXG4gIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAga2V5VmFsdWVzLnB1c2goW0UubWVzc2FnZSwgdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShjeHQpIDogbWVzc2FnZV0pXG4gIH1cbiAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgIGtleVZhbHVlcy5wdXNoKFxuICAgICAgW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sXG4gICAgICBbRS5wYXJlbnRTY2hlbWEsIF9gJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLFxuICAgICAgW04uZGF0YSwgZGF0YV1cbiAgICApXG4gIH1cbiAgaWYgKHByb3BlcnR5TmFtZSkga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKVxufVxuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkRXJyb3JEZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JDeHR9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtyZXBvcnRFcnJvcn0gZnJvbSBcIi4uL2Vycm9yc1wiXG5pbXBvcnQge18sIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5cbmNvbnN0IGJvb2xFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZX0gPSBpdFxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQsIGZhbHNlKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgZ2VuLnJldHVybihOLmRhdGEpXG4gIH0gZWxzZSB7XG4gICAgZ2VuLmFzc2lnbihfYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKVxuICAgIGdlbi5yZXR1cm4odHJ1ZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hfSA9IGl0XG4gIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpIC8vIFRPRE8gdmFyXG4gICAgZmFsc2VTY2hlbWFFcnJvcihpdClcbiAgfSBlbHNlIHtcbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICB9XG59XG5cbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQ6IFNjaGVtYUN4dCwgb3ZlcnJpZGVBbGxFcnJvcnM/OiBib29sZWFuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGF9ID0gaXRcbiAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgY29uc3QgY3h0OiBLZXl3b3JkRXJyb3JDeHQgPSB7XG4gICAgZ2VuLFxuICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgZGF0YSxcbiAgICBzY2hlbWE6IGZhbHNlLFxuICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIGl0LFxuICB9XG4gIHJlcG9ydEVycm9yKGN4dCwgYm9vbEVycm9yLCB1bmRlZmluZWQsIG92ZXJyaWRlQWxsRXJyb3JzKVxufVxuIiwgImltcG9ydCB0eXBlIHtBZGRlZEtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgSlNPTlR5cGUgPSB0eXBlb2YgX2pzb25UeXBlc1tudW1iZXJdXG5cbmNvbnN0IGpzb25UeXBlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KF9qc29uVHlwZXMpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pTT05UeXBlKHg6IHVua25vd24pOiB4IGlzIEpTT05UeXBlIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KVxufVxuXG50eXBlIFZhbGlkYXRpb25UeXBlcyA9IHtcbiAgW0sgaW4gSlNPTlR5cGVdOiBib29sZWFuIHwgUnVsZUdyb3VwIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJ1bGVzIHtcbiAgcnVsZXM6IFJ1bGVHcm91cFtdXG4gIHBvc3Q6IFJ1bGVHcm91cFxuICBhbGw6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFuIHwgUnVsZX0gLy8gcnVsZXMgdGhhdCBoYXZlIHRvIGJlIHZhbGlkYXRlZFxuICBrZXl3b3Jkczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW59IC8vIGFsbCBrbm93biBrZXl3b3JkcyAoc3VwZXJzZXQgb2YgXCJhbGxcIilcbiAgdHlwZXM6IFZhbGlkYXRpb25UeXBlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVHcm91cCB7XG4gIHR5cGU/OiBKU09OVHlwZVxuICBydWxlczogUnVsZVtdXG59XG5cbi8vIFRoaXMgaW50ZXJmYWNlIHdyYXBzIEtleXdvcmREZWZpbml0aW9uIGJlY2F1c2UgZGVmaW5pdGlvbiBjYW4gaGF2ZSBtdWx0aXBsZSBrZXl3b3Jkc1xuZXhwb3J0IGludGVyZmFjZSBSdWxlIHtcbiAga2V5d29yZDogc3RyaW5nXG4gIGRlZmluaXRpb246IEFkZGVkS2V5d29yZERlZmluaXRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bGVzKCk6IFZhbGlkYXRpb25SdWxlcyB7XG4gIGNvbnN0IGdyb3VwczogUmVjb3JkPFwibnVtYmVyXCIgfCBcInN0cmluZ1wiIHwgXCJhcnJheVwiIHwgXCJvYmplY3RcIiwgUnVsZUdyb3VwPiA9IHtcbiAgICBudW1iZXI6IHt0eXBlOiBcIm51bWJlclwiLCBydWxlczogW119LFxuICAgIHN0cmluZzoge3R5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXX0sXG4gICAgYXJyYXk6IHt0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXX0sXG4gICAgb2JqZWN0OiB7dHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdfSxcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVzOiB7Li4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlfSxcbiAgICBydWxlczogW3tydWxlczogW119LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgIHBvc3Q6IHtydWxlczogW119LFxuICAgIGFsbDoge30sXG4gICAga2V5d29yZHM6IHt9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYU9iamVjdH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGUsIFJ1bGVHcm91cCwgUnVsZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZShcbiAge3NjaGVtYSwgc2VsZn06IFNjaGVtYU9iakN4dCxcbiAgdHlwZTogSlNPTlR5cGVcbik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV1cbiAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgZ3JvdXA6IFJ1bGVHcm91cCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgcnVsZTogUnVsZSk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gKFxuICAgIHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cz8uc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKVxuICApXG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JDeHQsXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtpc0pTT05UeXBlLCBKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNGb3JUeXBlfSBmcm9tIFwiLi9hcHBsaWNhYmlsaXR5XCJcbmltcG9ydCB7cmVwb3J0RXJyb3J9IGZyb20gXCIuLi9lcnJvcnNcIlxuaW1wb3J0IHtfLCBuaWwsIGFuZCwgbm90LCBvcGVyYXRvcnMsIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7dG9IYXNoLCBzY2hlbWFSZWZPclZhbH0gZnJvbSBcIi4uL3V0aWxcIlxuXG5leHBvcnQgZW51bSBEYXRhVHlwZSB7XG4gIENvcnJlY3QsXG4gIFdyb25nLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpXG4gIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIilcbiAgaWYgKGhhc051bGwpIHtcbiAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIilcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpXG4gICAgfVxuICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpIHR5cGVzLnB1c2goXCJudWxsXCIpXG4gIH1cbiAgcmV0dXJuIHR5cGVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRKU09OVHlwZXModHM6IHVua25vd24gfCB1bmtub3duW10pOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXM6IHVua25vd25bXSA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXVxuICBpZiAodHlwZXMuZXZlcnkoaXNKU09OVHlwZSkpIHJldHVybiB0eXBlc1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgSlNPTlR5cGUgb3IgSlNPTlR5cGVbXTogXCIgKyB0eXBlcy5qb2luKFwiLFwiKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiBib29sZWFuIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgb3B0c30gPSBpdFxuICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpXG4gIGNvbnN0IGNoZWNrVHlwZXMgPVxuICAgIHR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgc2NoZW1hSGFzUnVsZXNGb3JUeXBlKGl0LCB0eXBlc1swXSkpXG4gIGlmIChjaGVja1R5cGVzKSB7XG4gICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpXG4gICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aCkgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKVxuICAgICAgZWxzZSByZXBvcnRUeXBlRXJyb3IoaXQpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY2hlY2tUeXBlc1xufVxuXG5jb25zdCBDT0VSQ0lCTEU6IFNldDxKU09OVHlwZT4gPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSlcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXM6IEpTT05UeXBlW10sIGNvZXJjZVR5cGVzPzogYm9vbGVhbiB8IFwiYXJyYXlcIik6IEpTT05UeXBlW10ge1xuICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gY29lcmNlRGF0YShpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSwgY29lcmNlVG86IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgb3B0c30gPSBpdFxuICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCBfYHR5cGVvZiAke2RhdGF9YClcbiAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsIF9gdW5kZWZpbmVkYClcbiAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgIGdlbi5pZihfYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+XG4gICAgICBnZW5cbiAgICAgICAgLmFzc2lnbihkYXRhLCBfYCR7ZGF0YX1bMF1gKVxuICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCBfYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKVxuICAgIClcbiAgfVxuICBnZW4uaWYoX2Ake2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKVxuICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KVxuICAgIH1cbiAgfVxuICBnZW4uZWxzZSgpXG4gIHJlcG9ydFR5cGVFcnJvcihpdClcbiAgZ2VuLmVuZElmKClcblxuICBnZW4uaWYoX2Ake2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKVxuICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhVHlwZX0gPT0gXCJudW1iZXJcIiB8fCAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cImApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFwiXCJgKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihcbiAgICAgICAgICAgIF9gJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gKyR7ZGF0YX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoXG4gICAgICAgICAgICBfYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gKyR7ZGF0YX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBcInRydWVcIiB8fCAke2RhdGF9ID09PSAxYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgZ2VuLmVsc2VJZihfYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApXG4gICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbClcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKFxuICAgICAgICAgICAgX2Ake2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFske2RhdGF9XWApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoe2dlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5fTogU2NoZW1hT2JqQ3h0LCBleHByOiBOYW1lKTogdm9pZCB7XG4gIC8vIFRPRE8gdXNlIGdlbi5wcm9wZXJ0eVxuICBnZW4uaWYoX2Ake3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PlxuICAgIGdlbi5hc3NpZ24oX2Ake3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RhdGFUeXBlKFxuICBkYXRhVHlwZTogSlNPTlR5cGUsXG4gIGRhdGE6IE5hbWUsXG4gIHN0cmljdE51bXM/OiBib29sZWFuIHwgXCJsb2dcIixcbiAgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3Rcbik6IENvZGUge1xuICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBvcGVyYXRvcnMuRVEgOiBvcGVyYXRvcnMuTkVRXG4gIGxldCBjb25kOiBDb2RlXG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgcmV0dXJuIF9gJHtkYXRhfSAke0VRfSBudWxsYFxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgY29uZCA9IF9gQXJyYXkuaXNBcnJheSgke2RhdGF9KWBcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgY29uZCA9IF9gJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYFxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgY29uZCA9IG51bUNvbmQoX2AhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjb25kID0gbnVtQ29uZCgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX2B0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWBcbiAgfVxuICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiBub3QoY29uZClcblxuICBmdW5jdGlvbiBudW1Db25kKF9jb25kOiBDb2RlID0gbmlsKTogQ29kZSB7XG4gICAgcmV0dXJuIGFuZChfYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/IF9gaXNGaW5pdGUoJHtkYXRhfSlgIDogbmlsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhcbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdLFxuICBkYXRhOiBOYW1lLFxuICBzdHJpY3ROdW1zPzogYm9vbGVhbiB8IFwibG9nXCIsXG4gIGNvcnJlY3Q/OiBEYXRhVHlwZVxuKTogQ29kZSB7XG4gIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KVxuICB9XG4gIGxldCBjb25kOiBDb2RlXG4gIGNvbnN0IHR5cGVzID0gdG9IYXNoKGRhdGFUeXBlcylcbiAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgIGNvbnN0IG5vdE9iaiA9IF9gdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImBcbiAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6IF9gISR7ZGF0YX0gfHwgJHtub3RPYmp9YFxuICAgIGRlbGV0ZSB0eXBlcy5udWxsXG4gICAgZGVsZXRlIHR5cGVzLmFycmF5XG4gICAgZGVsZXRlIHR5cGVzLm9iamVjdFxuICB9IGVsc2Uge1xuICAgIGNvbmQgPSBuaWxcbiAgfVxuICBpZiAodHlwZXMubnVtYmVyKSBkZWxldGUgdHlwZXMuaW50ZWdlclxuICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpIGNvbmQgPSBhbmQoY29uZCwgY2hlY2tEYXRhVHlwZSh0IGFzIEpTT05UeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSlcbiAgcmV0dXJuIGNvbmRcbn1cblxuZXhwb3J0IHR5cGUgVHlwZUVycm9yID0gRXJyb3JPYmplY3Q8XCJ0eXBlXCIsIHt0eXBlOiBzdHJpbmd9PlxuXG5jb25zdCB0eXBlRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hfSkgPT4gYG11c3QgYmUgJHtzY2hlbWF9YCxcbiAgcGFyYW1zOiAoe3NjaGVtYSwgc2NoZW1hVmFsdWV9KSA9PlxuICAgIHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/IF9ge3R5cGU6ICR7c2NoZW1hfX1gIDogX2B7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpXG4gIHJlcG9ydEVycm9yKGN4dCwgdHlwZUVycm9yKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0OiBTY2hlbWFPYmpDeHQpOiBLZXl3b3JkRXJyb3JDeHQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWF9ID0gaXRcbiAgY29uc3Qgc2NoZW1hQ29kZSA9IHNjaGVtYVJlZk9yVmFsKGl0LCBzY2hlbWEsIFwidHlwZVwiKVxuICByZXR1cm4ge1xuICAgIGdlbixcbiAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICBkYXRhLFxuICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgc2NoZW1hQ29kZSxcbiAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIGl0LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIHN0cmluZ2lmeX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IHtjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi91dGlsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0OiBTY2hlbWFPYmpDeHQsIHR5Pzogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHtwcm9wZXJ0aWVzLCBpdGVtc30gPSBpdC5zY2hlbWFcbiAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpOiBudW1iZXIpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0OiBTY2hlbWFPYmpDeHQsIHByb3A6IHN0cmluZyB8IG51bWJlciwgZGVmYXVsdFZhbHVlOiB1bmtub3duKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHN9ID0gaXRcbiAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgY29uc3QgY2hpbGREYXRhID0gX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eShwcm9wKX1gXG4gIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjb25kaXRpb24gPSBfYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYFxuICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgY29uZGl0aW9uID0gX2Ake2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImBcbiAgfVxuICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgLy8gKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIiA/IGAgfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImAgOiBcIlwiKVxuICBnZW4uaWYoY29uZGl0aW9uLCBfYCR7Y2hpbGREYXRhfSA9ICR7c3RyaW5naWZ5KGRlZmF1bHRWYWx1ZSl9YClcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hLCBTY2hlbWFNYXB9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi4vY29tcGlsZVwiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBhbmQsIG9yLCBub3QsIG5pbCwgc3RyQ29uY2F0LCBnZXRQcm9wZXJ0eSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBUeXBlfSBmcm9tIFwiLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBOIGZyb20gXCIuLi9jb21waWxlL25hbWVzXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uL2NvbXBpbGUvdXRpbFwiXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQ6IEtleXdvcmRDeHQsIHByb3A6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBfYCR7cHJvcH1gfSwgdHJ1ZSlcbiAgICBjeHQuZXJyb3IoKVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcChcbiAge2dlbiwgZGF0YSwgaXQ6IHtvcHRzfX06IEtleXdvcmRDeHQsXG4gIHByb3BlcnRpZXM6IHN0cmluZ1tdLFxuICBtaXNzaW5nOiBOYW1lXG4pOiBDb2RlIHtcbiAgcmV0dXJuIG9yKFxuICAgIC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PlxuICAgICAgYW5kKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCBfYCR7bWlzc2luZ30gPSAke3Byb3B9YClcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dDogS2V5d29yZEN4dCwgbWlzc2luZzogTmFtZSk6IHZvaWQge1xuICBjeHQuc2V0UGFyYW1zKHttaXNzaW5nUHJvcGVydHk6IG1pc3Npbmd9LCB0cnVlKVxuICBjeHQuZXJyb3IoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUHJvcEZ1bmMoZ2VuOiBDb2RlR2VuKTogTmFtZSB7XG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgY29kZTogX2BPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuOiBDb2RlR2VuLCBkYXRhOiBOYW1lLCBwcm9wZXJ0eTogTmFtZSB8IHN0cmluZyk6IENvZGUge1xuICByZXR1cm4gX2Ake2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoXG4gIGdlbjogQ29kZUdlbixcbiAgZGF0YTogTmFtZSxcbiAgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcsXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgY29uZCA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYFxuICByZXR1cm4gb3duUHJvcGVydGllcyA/IF9gJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoXG4gIGdlbjogQ29kZUdlbixcbiAgZGF0YTogTmFtZSxcbiAgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcsXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgY29uZCA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYFxuICByZXR1cm4gb3duUHJvcGVydGllcyA/IG9yKGNvbmQsIG5vdChpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcD86IFNjaGVtYU1hcCk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0OiBTY2hlbWFDeHQsIHNjaGVtYU1hcDogU2NoZW1hTWFwKTogc3RyaW5nW10ge1xuICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcihcbiAgICAocCkgPT4gIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFNYXBbcF0gYXMgQW55U2NoZW1hKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKFxuICB7c2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHtnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRofSwgaXR9OiBLZXl3b3JkQ3h0LFxuICBmdW5jOiBDb2RlLFxuICBjb250ZXh0OiBDb2RlLFxuICBwYXNzU2NoZW1hPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gX2Ake3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGFcbiAgY29uc3QgdmFsQ3h0OiBbTmFtZSwgQ29kZSB8IG51bWJlcl1bXSA9IFtcbiAgICBbTi5pbnN0YW5jZVBhdGgsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgW04ucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgW04ucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgIFtOLnJvb3REYXRhLCBOLnJvb3REYXRhXSxcbiAgXVxuICBpZiAoaXQub3B0cy5keW5hbWljUmVmKSB2YWxDeHQucHVzaChbTi5keW5hbWljQW5jaG9ycywgTi5keW5hbWljQW5jaG9yc10pXG4gIGNvbnN0IGFyZ3MgPSBfYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWBcbiAgcmV0dXJuIGNvbnRleHQgIT09IG5pbCA/IF9gJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6IF9gJHtmdW5jfSgke2FyZ3N9KWBcbn1cblxuY29uc3QgbmV3UmVnRXhwID0gX2BuZXcgUmVnRXhwYFxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGF0dGVybih7Z2VuLCBpdDoge29wdHN9fTogS2V5d29yZEN4dCwgcGF0dGVybjogc3RyaW5nKTogTmFtZSB7XG4gIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCJcbiAgY29uc3Qge3JlZ0V4cH0gPSBvcHRzLmNvZGVcbiAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSlcblxuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICBrZXk6IHJ4LnRvU3RyaW5nKCksXG4gICAgcmVmOiByeCxcbiAgICBjb2RlOiBfYCR7cmVnRXhwLmNvZGUgPT09IFwibmV3IFJlZ0V4cFwiID8gbmV3UmVnRXhwIDogdXNlRnVuYyhnZW4sIHJlZ0V4cCl9KCR7cGF0dGVybn0sICR7dX0pYCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0OiBLZXl3b3JkQ3h0KTogTmFtZSB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpXG4gICAgcmV0dXJuIHZhbGlkQXJyXG4gIH1cbiAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSlcbiAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSlcbiAgcmV0dXJuIHZhbGlkXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5OdW0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgICBnZW4uaWYobm90KHZhbGlkKSwgbm90VmFsaWQpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoOiBBbnlTY2hlbWEpID0+IGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuXG4gIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG5cbiAgZ2VuLmJsb2NrKCgpID0+XG4gICAgc2NoZW1hLmZvckVhY2goKF9zY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHNjaFZhbGlkXG4gICAgICApXG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCBfYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YClcbiAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpXG4gICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgIGlmICghbWVyZ2VkKSBnZW4uaWYobm90KHZhbGlkKSlcbiAgICB9KVxuICApXG5cbiAgY3h0LnJlc3VsdChcbiAgICB2YWxpZCxcbiAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAoKSA9PiBjeHQuZXJyb3IodHJ1ZSlcbiAgKVxufVxuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLlwiXG5pbXBvcnQgdHlwZSB7XG4gIEFueVNjaGVtYSxcbiAgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7XywgbmlsLCBub3QsIHN0cmluZ2lmeSwgQ29kZSwgTmFtZSwgQ29kZUdlbn0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uL25hbWVzXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7Y2FsbFZhbGlkYXRlQ29kZX0gZnJvbSBcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCJcbmltcG9ydCB7ZXh0ZW5kRXJyb3JzfSBmcm9tIFwiLi4vZXJyb3JzXCJcblxudHlwZSBLZXl3b3JkQ29tcGlsYXRpb25SZXN1bHQgPSBBbnlTY2hlbWEgfCBTY2hlbWFWYWxpZGF0ZUZ1bmN0aW9uIHwgQW55VmFsaWRhdGVGdW5jdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQ6IEtleXdvcmRDeHQsIGRlZjogTWFjcm9LZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gIGNvbnN0IG1hY3JvU2NoZW1hID0gZGVmLm1hY3JvLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KVxuICBjb25zdCBzY2hlbWFSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgbWFjcm9TY2hlbWEpXG4gIGlmIChpdC5vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSkgaXQuc2VsZi52YWxpZGF0ZVNjaGVtYShtYWNyb1NjaGVtYSwgdHJ1ZSlcblxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgY3h0LnN1YnNjaGVtYShcbiAgICB7XG4gICAgICBzY2hlbWE6IG1hY3JvU2NoZW1hLFxuICAgICAgc2NoZW1hUGF0aDogbmlsLFxuICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgfSxcbiAgICB2YWxpZFxuICApXG4gIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0OiBLZXl3b3JkQ3h0LCBkZWY6IEZ1bmNLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0fSA9IGN4dFxuICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKVxuICBjb25zdCB2YWxpZGF0ZSA9XG4gICAgISRkYXRhICYmIGRlZi5jb21waWxlID8gZGVmLmNvbXBpbGUuY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIDogZGVmLnZhbGlkYXRlXG4gIGNvbnN0IHZhbGlkYXRlUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHZhbGlkYXRlKVxuICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVLZXl3b3JkKVxuICBjeHQub2soZGVmLnZhbGlkID8/IHZhbGlkKVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpOiB2b2lkIHtcbiAgICBpZiAoZGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgIGFzc2lnblZhbGlkKClcbiAgICAgIGlmIChkZWYubW9kaWZ5aW5nKSBtb2RpZnlEYXRhKGN4dClcbiAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZGVmLmFzeW5jID8gdmFsaWRhdGVBc3luYygpIDogdmFsaWRhdGVTeW5jKClcbiAgICAgIGlmIChkZWYubW9kaWZ5aW5nKSBtb2RpZnlEYXRhKGN4dClcbiAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCk6IE5hbWUge1xuICAgIGNvbnN0IHJ1bGVFcnJzID0gZ2VuLmxldChcInJ1bGVFcnJzXCIsIG51bGwpXG4gICAgZ2VuLnRyeShcbiAgICAgICgpID0+IGFzc2lnblZhbGlkKF9gYXdhaXQgYCksXG4gICAgICAoZSkgPT5cbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKFxuICAgICAgICAgIF9gJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9YCxcbiAgICAgICAgICAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCBfYCR7ZX0uZXJyb3JzYCksXG4gICAgICAgICAgKCkgPT4gZ2VuLnRocm93KGUpXG4gICAgICAgIClcbiAgICApXG4gICAgcmV0dXJuIHJ1bGVFcnJzXG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMoKTogQ29kZSB7XG4gICAgY29uc3QgdmFsaWRhdGVFcnJzID0gX2Ake3ZhbGlkYXRlUmVmfS5lcnJvcnNgXG4gICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpXG4gICAgYXNzaWduVmFsaWQobmlsKVxuICAgIHJldHVybiB2YWxpZGF0ZUVycnNcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdDogQ29kZSA9IGRlZi5hc3luYyA/IF9gYXdhaXQgYCA6IG5pbCk6IHZvaWQge1xuICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gTi50aGlzIDogTi5zZWxmXG4gICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKVxuICAgIGdlbi5hc3NpZ24oXG4gICAgICB2YWxpZCxcbiAgICAgIF9gJHtfYXdhaXR9JHtjYWxsVmFsaWRhdGVDb2RlKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsXG4gICAgICBkZWYubW9kaWZ5aW5nXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBnZW4uaWYobm90KGRlZi52YWxpZCA/PyB2YWxpZCksIGVycm9ycylcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dDogS2V5d29yZEN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgX2Ake2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSlcbn1cblxuZnVuY3Rpb24gYWRkRXJycyhjeHQ6IEtleXdvcmRDeHQsIGVycnM6IENvZGUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbn0gPSBjeHRcbiAgZ2VuLmlmKFxuICAgIF9gQXJyYXkuaXNBcnJheSgke2VycnN9KWAsXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuXG4gICAgICAgIC5hc3NpZ24oTi52RXJyb3JzLCBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke04udkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgLmFzc2lnbihOLmVycm9ycywgX2Ake04udkVycm9yc30ubGVuZ3RoYClcbiAgICAgIGV4dGVuZEVycm9ycyhjeHQpXG4gICAgfSxcbiAgICAoKSA9PiBjeHQuZXJyb3IoKVxuICApXG59XG5cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHtzY2hlbWFFbnZ9OiBTY2hlbWFPYmpDeHQsIGRlZjogRnVuY0tleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIilcbn1cblxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW46IENvZGVHZW4sIGtleXdvcmQ6IHN0cmluZywgcmVzdWx0PzogS2V5d29yZENvbXBpbGF0aW9uUmVzdWx0KTogTmFtZSB7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYClcbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFxuICAgIFwia2V5d29yZFwiLFxuICAgIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8ge3JlZjogcmVzdWx0fSA6IHtyZWY6IHJlc3VsdCwgY29kZTogc3RyaW5naWZ5KHJlc3VsdCl9XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShcbiAgc2NoZW1hOiB1bmtub3duLFxuICBzY2hlbWFUeXBlOiBKU09OVHlwZVtdLFxuICBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlXG4pOiBib29sZWFuIHtcbiAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgcmV0dXJuIChcbiAgICAhc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PlxuICAgICAgc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKVxuICAgIClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoXG4gIHtzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGh9OiBTY2hlbWFPYmpDeHQsXG4gIGRlZjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAga2V5d29yZDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIH1cblxuICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llc1xuICBpZiAoZGVwcz8uc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YClcbiAgfVxuXG4gIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpXG4gICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIikgc2VsZi5sb2dnZXIuZXJyb3IobXNnKVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtfLCBzdHIsIGdldFByb3BlcnR5LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQge2VzY2FwZUZyYWdtZW50LCBnZXRFcnJvclBhdGgsIFR5cGV9IGZyb20gXCIuLi91dGlsXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY2hlbWFDb250ZXh0IHtcbiAgLy8gVE9ETyB1c2UgT3B0aW9uYWw/IGFsaWduIHdpdGggU2NoZW1DeHQgcHJvcGVydHkgdHlwZXNcbiAgc2NoZW1hOiBBbnlTY2hlbWFcbiAgc2NoZW1hUGF0aDogQ29kZVxuICBlcnJTY2hlbWFQYXRoOiBzdHJpbmdcbiAgdG9wU2NoZW1hUmVmPzogQ29kZVxuICBlcnJvclBhdGg/OiBDb2RlXG4gIGRhdGFMZXZlbD86IG51bWJlclxuICBkYXRhVHlwZXM/OiBKU09OVHlwZVtdXG4gIGRhdGE/OiBOYW1lXG4gIHBhcmVudERhdGE/OiBOYW1lXG4gIHBhcmVudERhdGFQcm9wZXJ0eT86IENvZGUgfCBudW1iZXJcbiAgZGF0YU5hbWVzPzogTmFtZVtdXG4gIGRhdGFQYXRoQXJyPzogKENvZGUgfCBudW1iZXIpW11cbiAgcHJvcGVydHlOYW1lPzogTmFtZVxuICBqdGREaXNjcmltaW5hdG9yPzogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhPzogYm9vbGVhblxuICBjb21wb3NpdGVSdWxlPzogdHJ1ZVxuICBjcmVhdGVFcnJvcnM/OiBib29sZWFuXG4gIGFsbEVycm9ycz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU3Vic2NoZW1hQXJncyA9IFBhcnRpYWw8e1xuICBrZXl3b3JkOiBzdHJpbmdcbiAgc2NoZW1hUHJvcDogc3RyaW5nIHwgbnVtYmVyXG4gIHNjaGVtYTogQW55U2NoZW1hXG4gIHNjaGVtYVBhdGg6IENvZGVcbiAgZXJyU2NoZW1hUGF0aDogc3RyaW5nXG4gIHRvcFNjaGVtYVJlZjogQ29kZVxuICBkYXRhOiBOYW1lIHwgQ29kZVxuICBkYXRhUHJvcDogQ29kZSB8IHN0cmluZyB8IG51bWJlclxuICBkYXRhVHlwZXM6IEpTT05UeXBlW11cbiAgZGVmaW5lZFByb3BlcnRpZXM6IFNldDxzdHJpbmc+XG4gIHByb3BlcnR5TmFtZTogTmFtZVxuICBkYXRhUHJvcFR5cGU6IFR5cGVcbiAganRkRGlzY3JpbWluYXRvcjogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhOiBib29sZWFuXG4gIGNvbXBvc2l0ZVJ1bGU6IHRydWVcbiAgY3JlYXRlRXJyb3JzOiBib29sZWFuXG4gIGFsbEVycm9yczogYm9vbGVhblxufT5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1YnNjaGVtYShcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAge2tleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmfTogU3Vic2NoZW1hQXJnc1xuKTogU3Vic2NoZW1hQ29udGV4dCB7XG4gIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJylcbiAgfVxuXG4gIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHtcbiAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICBzY2hlbWFQYXRoOiBfYCR7aXQuc2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfWAsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIH1cbiAgICAgIDoge1xuICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IF9gJHtpdC5zY2hlbWFQYXRofSR7Z2V0UHJvcGVydHkoa2V5d29yZCl9JHtnZXRQcm9wZXJ0eShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHtlc2NhcGVGcmFnbWVudChzY2hlbWFQcm9wKX1gLFxuICAgICAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWEsXG4gICAgICBzY2hlbWFQYXRoLFxuICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoXG4gIHN1YnNjaGVtYTogU3Vic2NoZW1hQ29udGV4dCxcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAge2RhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWV9OiBTdWJzY2hlbWFBcmdzXG4pOiB2b2lkIHtcbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJylcbiAgfVxuXG4gIGNvbnN0IHtnZW59ID0gaXRcblxuICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzfSA9IGl0XG4gICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCBfYCR7aXQuZGF0YX0ke2dldFByb3BlcnR5KGRhdGFQcm9wKX1gLCB0cnVlKVxuICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpXG4gICAgc3Vic2NoZW1hLmVycm9yUGF0aCA9IHN0cmAke2Vycm9yUGF0aH0ke2dldEVycm9yUGF0aChkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWBcbiAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gX2Ake2RhdGFQcm9wfWBcbiAgICBzdWJzY2hlbWEuZGF0YVBhdGhBcnIgPSBbLi4uZGF0YVBhdGhBcnIsIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHldXG4gIH1cblxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKSAvLyByZXBsYWNlYWJsZSBpZiB1c2VkIG9uY2U/XG4gICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSlcbiAgICBpZiAocHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVcbiAgICAvLyBUT0RPIHNvbWV0aGluZyBpcyBwb3NzaWJseSB3cm9uZyBoZXJlIHdpdGggbm90IGNoYW5naW5nIHBhcmVudERhdGFQcm9wZXJ0eSBhbmQgbm90IGFwcGVuZGluZyBkYXRhUGF0aEFyclxuICB9XG5cbiAgaWYgKGRhdGFUeXBlcykgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlc1xuXG4gIGZ1bmN0aW9uIGRhdGFDb250ZXh0UHJvcHMoX25leHREYXRhOiBOYW1lKTogdm9pZCB7XG4gICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGFcbiAgICBzdWJzY2hlbWEuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMVxuICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXVxuICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGFcbiAgICBzdWJzY2hlbWEuZGF0YU5hbWVzID0gWy4uLml0LmRhdGFOYW1lcywgX25leHREYXRhXVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKFxuICBzdWJzY2hlbWE6IFN1YnNjaGVtYUNvbnRleHQsXG4gIHtqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnN9OiBTdWJzY2hlbWFBcmdzXG4pOiB2b2lkIHtcbiAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlXG4gIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9yc1xuICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnNcbiAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yIC8vIG5vdCBpbmhlcml0ZWRcbiAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGEgLy8gbm90IGluaGVyaXRlZFxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWEsIEFueVNjaGVtYU9iamVjdCwgVXJpUmVzb2x2ZXJ9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcIi4uL2FqdlwiXG5pbXBvcnQgdHlwZSB7VVJJQ29tcG9uZW50c30gZnJvbSBcInVyaS1qc1wiXG5pbXBvcnQge2VhY2hJdGVtfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCAqIGFzIGVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIlxuaW1wb3J0ICogYXMgdHJhdmVyc2UgZnJvbSBcImpzb24tc2NoZW1hLXRyYXZlcnNlXCJcblxuLy8gdGhlIGhhc2ggb2YgbG9jYWwgcmVmZXJlbmNlcyBpbnNpZGUgdGhlIHNjaGVtYSAoY3JlYXRlZCBieSBnZXRTY2hlbWFSZWZzKSwgdXNlZCBmb3IgaW5saW5lIHJlc29sdXRpb25cbmV4cG9ydCB0eXBlIExvY2FsUmVmcyA9IHtbUmVmIGluIHN0cmluZ10/OiBBbnlTY2hlbWFPYmplY3R9XG5cbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIGtleXdvcmQgZGVmaW5pdGlvbnNcbmNvbnN0IFNJTVBMRV9JTkxJTkVEID0gbmV3IFNldChbXG4gIFwidHlwZVwiLFxuICBcImZvcm1hdFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJtYXhMZW5ndGhcIixcbiAgXCJtaW5MZW5ndGhcIixcbiAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gIFwibWluUHJvcGVydGllc1wiLFxuICBcIm1heEl0ZW1zXCIsXG4gIFwibWluSXRlbXNcIixcbiAgXCJtYXhpbXVtXCIsXG4gIFwibWluaW11bVwiLFxuICBcInVuaXF1ZUl0ZW1zXCIsXG4gIFwibXVsdGlwbGVPZlwiLFxuICBcInJlcXVpcmVkXCIsXG4gIFwiZW51bVwiLFxuICBcImNvbnN0XCIsXG5dKVxuXG5leHBvcnQgZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYTogQW55U2NoZW1hLCBsaW1pdDogYm9vbGVhbiB8IG51bWJlciA9IHRydWUpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB0cnVlXG4gIGlmIChsaW1pdCA9PT0gdHJ1ZSkgcmV0dXJuICFoYXNSZWYoc2NoZW1hKVxuICBpZiAoIWxpbWl0KSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0XG59XG5cbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICBcIiRyZWZcIixcbiAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICBcIiRkeW5hbWljUmVmXCIsXG4gIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pXG5cbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IGJvb2xlYW4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKSByZXR1cm4gdHJ1ZVxuICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKSByZXR1cm4gdHJ1ZVxuICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IG51bWJlciB7XG4gIGxldCBjb3VudCA9IDBcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpIHJldHVybiBJbmZpbml0eVxuICAgIGNvdW50KytcbiAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpIGNvbnRpbnVlXG4gICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBlYWNoSXRlbShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSlcbiAgICB9XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5XG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsUGF0aChyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplPzogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChub3JtYWxpemUgIT09IGZhbHNlKSBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICBjb25zdCBwID0gcmVzb2x2ZXIucGFyc2UoaWQpXG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBwOiBVUklDb21wb25lbnRzKTogc3RyaW5nIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHJlc29sdmVyLnNlcmlhbGl6ZShwKVxuICByZXR1cm4gc2VyaWFsaXplZC5zcGxpdChcIiNcIilbMF0gKyBcIiNcIlxufVxuXG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVJZChpZDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVVcmwocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBiYXNlSWQ6IHN0cmluZywgaWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpXG59XG5cbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHRoaXM6IEFqdiwgc2NoZW1hOiBBbnlTY2hlbWEsIGJhc2VJZDogc3RyaW5nKTogTG9jYWxSZWZzIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB7fVxuICBjb25zdCB7c2NoZW1hSWQsIHVyaVJlc29sdmVyfSA9IHRoaXMub3B0c1xuICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKVxuICBjb25zdCBiYXNlSWRzOiB7W0pzb25QdHIgaW4gc3RyaW5nXT86IHN0cmluZ30gPSB7XCJcIjogc2NoSWR9XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKVxuICBjb25zdCBsb2NhbFJlZnM6IExvY2FsUmVmcyA9IHt9XG4gIGNvbnN0IHNjaGVtYVJlZnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG5cbiAgdHJhdmVyc2Uoc2NoZW1hLCB7YWxsS2V5czogdHJ1ZX0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICBpZiAocGFyZW50SnNvblB0ciA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhQcmVmaXggKyBqc29uUHRyXG4gICAgbGV0IGJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl1cbiAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIikgYmFzZUlkID0gYWRkUmVmLmNhbGwodGhpcywgc2NoW3NjaGVtYUlkXSlcbiAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcilcbiAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpXG4gICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZFxuXG4gICAgZnVuY3Rpb24gYWRkUmVmKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZVxuICAgICAgcmVmID0gbm9ybWFsaXplSWQoYmFzZUlkID8gX3Jlc29sdmUoYmFzZUlkLCByZWYpIDogcmVmKVxuICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpIHRocm93IGFtYmlndW9zKHJlZilcbiAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZilcbiAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdXG4gICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXVxuICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZilcbiAgICAgIH0gZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZilcbiAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEFuY2hvcih0aGlzOiBBanYsIGFuY2hvcjogdW5rbm93bik6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApXG4gICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGxvY2FsUmVmc1xuXG4gIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMTogQW55U2NoZW1hLCBzY2gyOiBBbnlTY2hlbWEgfCB1bmRlZmluZWQsIHJlZjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpIHRocm93IGFtYmlndW9zKHJlZilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFtYmlndW9zKHJlZjogc3RyaW5nKTogRXJyb3Ige1xuICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYClcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEtleXdvcmRFcnJvckN4dCxcbiAgS2V5d29yZEN4dFBhcmFtcyxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB0eXBlIHtJbnN0YW5jZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jb3JlXCJcbmltcG9ydCB7Ym9vbE9yRW1wdHlTY2hlbWEsIHRvcEJvb2xPckVtcHR5U2NoZW1hfSBmcm9tIFwiLi9ib29sU2NoZW1hXCJcbmltcG9ydCB7Y29lcmNlQW5kQ2hlY2tEYXRhVHlwZSwgZ2V0U2NoZW1hVHlwZXN9IGZyb20gXCIuL2RhdGFUeXBlXCJcbmltcG9ydCB7c2hvdWxkVXNlR3JvdXAsIHNob3VsZFVzZVJ1bGV9IGZyb20gXCIuL2FwcGxpY2FiaWxpdHlcIlxuaW1wb3J0IHtjaGVja0RhdGFUeXBlLCBjaGVja0RhdGFUeXBlcywgcmVwb3J0VHlwZUVycm9yLCBEYXRhVHlwZX0gZnJvbSBcIi4vZGF0YVR5cGVcIlxuaW1wb3J0IHthc3NpZ25EZWZhdWx0c30gZnJvbSBcIi4vZGVmYXVsdHNcIlxuaW1wb3J0IHtmdW5jS2V5d29yZENvZGUsIG1hY3JvS2V5d29yZENvZGUsIHZhbGlkYXRlS2V5d29yZFVzYWdlLCB2YWxpZFNjaGVtYVR5cGV9IGZyb20gXCIuL2tleXdvcmRcIlxuaW1wb3J0IHtnZXRTdWJzY2hlbWEsIGV4dGVuZFN1YnNjaGVtYURhdGEsIFN1YnNjaGVtYUFyZ3MsIGV4dGVuZFN1YnNjaGVtYU1vZGV9IGZyb20gXCIuL3N1YnNjaGVtYVwiXG5pbXBvcnQge18sIG5pbCwgc3RyLCBvciwgbm90LCBnZXRQcm9wZXJ0eSwgQmxvY2ssIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5pbXBvcnQge3Jlc29sdmVVcmx9IGZyb20gXCIuLi9yZXNvbHZlXCJcbmltcG9ydCB7XG4gIHNjaGVtYVJlZk9yVmFsLFxuICBzY2hlbWFIYXNSdWxlc0J1dFJlZixcbiAgY2hlY2tVbmtub3duUnVsZXMsXG4gIGNoZWNrU3RyaWN0TW9kZSxcbiAgdW5lc2NhcGVKc29uUG9pbnRlcixcbiAgbWVyZ2VFdmFsdWF0ZWQsXG59IGZyb20gXCIuLi91dGlsXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZSwgUnVsZSwgUnVsZUdyb3VwfSBmcm9tIFwiLi4vcnVsZXNcIlxuaW1wb3J0IHtcbiAgRXJyb3JQYXRocyxcbiAgcmVwb3J0RXJyb3IsXG4gIHJlcG9ydEV4dHJhRXJyb3IsXG4gIHJlc2V0RXJyb3JzQ291bnQsXG4gIGtleXdvcmQkRGF0YUVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3JzXCJcblxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgY2hlY2tLZXl3b3JkcyhpdClcbiAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbihcbiAge2dlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0c306IFNjaGVtYUN4dCxcbiAgYm9keTogQmxvY2tcbik6IHZvaWQge1xuICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgX2Ake04uZGF0YX0sICR7Ti52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgZ2VuLmNvZGUoX2BcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YClcbiAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cylcbiAgICAgIGdlbi5jb2RlKGJvZHkpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIF9gJHtOLmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+XG4gICAgICBnZW4uY29kZShmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykpLmNvZGUoYm9keSlcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0czogSW5zdGFuY2VPcHRpb25zKTogQ29kZSB7XG4gIHJldHVybiBfYHske04uaW5zdGFuY2VQYXRofT1cIlwiLCAke04ucGFyZW50RGF0YX0sICR7Ti5wYXJlbnREYXRhUHJvcGVydHl9LCAke04ucm9vdERhdGF9PSR7XG4gICAgTi5kYXRhXG4gIH0ke29wdHMuZHluYW1pY1JlZiA/IF9gLCAke04uZHluYW1pY0FuY2hvcnN9PXt9YCA6IG5pbH19PXt9YFxufVxuXG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW46IENvZGVHZW4sIG9wdHM6IEluc3RhbmNlT3B0aW9ucyk6IHZvaWQge1xuICBnZW4uaWYoXG4gICAgTi52YWxDeHQsXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuLnZhcihOLmluc3RhbmNlUGF0aCwgX2Ake04udmFsQ3h0fS4ke04uaW5zdGFuY2VQYXRofWApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YSwgX2Ake04udmFsQ3h0fS4ke04ucGFyZW50RGF0YX1gKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGFQcm9wZXJ0eSwgX2Ake04udmFsQ3h0fS4ke04ucGFyZW50RGF0YVByb3BlcnR5fWApXG4gICAgICBnZW4udmFyKE4ucm9vdERhdGEsIF9gJHtOLnZhbEN4dH0uJHtOLnJvb3REYXRhfWApXG4gICAgICBpZiAob3B0cy5keW5hbWljUmVmKSBnZW4udmFyKE4uZHluYW1pY0FuY2hvcnMsIF9gJHtOLnZhbEN4dH0uJHtOLmR5bmFtaWNBbmNob3JzfWApXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBnZW4udmFyKE4uaW5zdGFuY2VQYXRoLCBfYFwiXCJgKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGEsIF9gdW5kZWZpbmVkYClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhUHJvcGVydHksIF9gdW5kZWZpbmVkYClcbiAgICAgIGdlbi52YXIoTi5yb290RGF0YSwgTi5kYXRhKVxuICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZikgZ2VuLnZhcihOLmR5bmFtaWNBbmNob3JzLCBfYHt9YClcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIG9wdHMsIGdlbn0gPSBpdFxuICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KSBjb21tZW50S2V5d29yZChpdClcbiAgICBjaGVja05vRGVmYXVsdChpdClcbiAgICBnZW4ubGV0KE4udkVycm9ycywgbnVsbClcbiAgICBnZW4ubGV0KE4uZXJyb3JzLCAwKVxuICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKSByZXNldEV2YWx1YXRlZChpdClcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQpXG4gICAgcmV0dXJuUmVzdWx0cyhpdClcbiAgfSlcbiAgcmV0dXJuXG59XG5cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICBjb25zdCB7Z2VuLCB2YWxpZGF0ZU5hbWV9ID0gaXRcbiAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsIF9gJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApXG4gIGdlbi5pZihfYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKF9gJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgX2B1bmRlZmluZWRgKSlcbiAgZ2VuLmlmKF9gJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oX2Ake2l0LmV2YWx1YXRlZH0uaXRlbXNgLCBfYHVuZGVmaW5lZGApKVxufVxuXG5mdW5jdGlvbiBmdW5jU291cmNlVXJsKHNjaGVtYTogQW55U2NoZW1hLCBvcHRzOiBJbnN0YW5jZU9wdGlvbnMpOiBDb2RlIHtcbiAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdXG4gIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyBfYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogbmlsXG59XG5cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdDogU2NoZW1hQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgY2hlY2tLZXl3b3JkcyhpdClcbiAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpXG59XG5cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHtzY2hlbWEsIHNlbGZ9OiBTY2hlbWFDeHQpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiAhc2NoZW1hXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdDogU2NoZW1hQ3h0KTogaXQgaXMgU2NoZW1hT2JqQ3h0IHtcbiAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCJcbn1cblxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdDogU2NoZW1hT2JqQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBnZW4sIG9wdHN9ID0gaXRcbiAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KSBjb21tZW50S2V5d29yZChpdClcbiAgdXBkYXRlQ29udGV4dChpdClcbiAgY2hlY2tBc3luY1NjaGVtYShpdClcbiAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgTi5lcnJvcnMpXG4gIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KVxuICAvLyBUT0RPIHZhclxuICBnZW4udmFyKHZhbGlkLCBfYCR7ZXJyc0NvdW50fSA9PT0gJHtOLmVycm9yc31gKVxufVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY2hlY2tVbmtub3duUnVsZXMoaXQpXG4gIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KVxufVxuXG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCwgZXJyc0NvdW50PzogTmFtZSk6IHZvaWQge1xuICBpZiAoaXQub3B0cy5qdGQpIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpXG4gIGNvbnN0IHR5cGVzID0gZ2V0U2NoZW1hVHlwZXMoaXQuc2NoZW1hKVxuICBjb25zdCBjaGVja2VkVHlwZXMgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcylcbiAgc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCAhY2hlY2tlZFR5cGVzLCBlcnJzQ291bnQpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cywgc2VsZn0gPSBpdFxuICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9EZWZhdWx0KGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgb3B0c30gPSBpdFxuICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIilcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF1cbiAgaWYgKHNjaElkKSBpdC5iYXNlSWQgPSByZXNvbHZlVXJsKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQXN5bmNTY2hlbWEoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBpZiAoaXQuc2NoZW1hLiRhc3luYyAmJiAhaXQuc2NoZW1hRW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hXCIpXG59XG5cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHtnZW4sIHNjaGVtYUVudiwgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzfTogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudFxuICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgIGdlbi5jb2RlKF9gJHtOLnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IHN0cmAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YFxuICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHtyZWY6IHNjaGVtYUVudi5yb290fSlcbiAgICBnZW4uY29kZShfYCR7Ti5zZWxmfS5vcHRzLiRjb21tZW50KCR7bXNnfSwgJHtzY2hlbWFQYXRofSwgJHtyb290TmFtZX0uc2NoZW1hKWApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdDogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHN9ID0gaXRcbiAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgIGdlbi5pZihcbiAgICAgIF9gJHtOLmVycm9yc30gPT09IDBgLFxuICAgICAgKCkgPT4gZ2VuLnJldHVybihOLmRhdGEpLFxuICAgICAgKCkgPT4gZ2VuLnRocm93KF9gbmV3ICR7VmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9KCR7Ti52RXJyb3JzfSlgKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBnZW4uYXNzaWduKF9gJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIE4udkVycm9ycylcbiAgICBpZiAob3B0cy51bmV2YWx1YXRlZCkgYXNzaWduRXZhbHVhdGVkKGl0KVxuICAgIGdlbi5yZXR1cm4oX2Ake04uZXJyb3JzfSA9PT0gMGApXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHtnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zfTogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGlmIChwcm9wcyBpbnN0YW5jZW9mIE5hbWUpIGdlbi5hc3NpZ24oX2Ake2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcylcbiAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgTmFtZSkgZ2VuLmFzc2lnbihfYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKVxufVxuXG5mdW5jdGlvbiBzY2hlbWFLZXl3b3JkcyhcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAgdHlwZXM6IEpTT05UeXBlW10sXG4gIHR5cGVFcnJvcnM6IGJvb2xlYW4sXG4gIGVycnNDb3VudD86IE5hbWVcbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGFsbEVycm9ycywgb3B0cywgc2VsZn0gPSBpdFxuICBjb25zdCB7UlVMRVN9ID0gc2VsZlxuICBpZiAoc2NoZW1hLiRyZWYgJiYgKG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmIHx8ICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSkpIHtcbiAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCAoUlVMRVMuYWxsLiRyZWYgYXMgUnVsZSkuZGVmaW5pdGlvbikpIC8vIFRPRE8gdHlwZWNhc3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW9wdHMuanRkKSBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcylcbiAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSBncm91cEtleXdvcmRzKGdyb3VwKVxuICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdClcbiAgfSlcblxuICBmdW5jdGlvbiBncm91cEtleXdvcmRzKGdyb3VwOiBSdWxlR3JvdXApOiB2b2lkIHtcbiAgICBpZiAoIXNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApKSByZXR1cm5cbiAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgZ2VuLmlmKGNoZWNrRGF0YVR5cGUoZ3JvdXAudHlwZSwgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSlcbiAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApXG4gICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgZ2VuLmVsc2UoKVxuICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpXG4gICAgICB9XG4gICAgICBnZW4uZW5kSWYoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKVxuICAgIH1cbiAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5pZihfYCR7Ti5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApXG4gIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQsIGdyb3VwOiBSdWxlR3JvdXApOiB2b2lkIHtcbiAgY29uc3Qge1xuICAgIGdlbixcbiAgICBzY2hlbWEsXG4gICAgb3B0czoge3VzZURlZmF1bHRzfSxcbiAgfSA9IGl0XG4gIGlmICh1c2VEZWZhdWx0cykgYXNzaWduRGVmYXVsdHMoaXQsIGdyb3VwLnR5cGUpXG4gIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICBpZiAoc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgIGtleXdvcmRDb2RlKGl0LCBydWxlLmtleXdvcmQsIHJ1bGUuZGVmaW5pdGlvbiwgZ3JvdXAudHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RyaWN0VHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgaWYgKGl0LnNjaGVtYUVudi5tZXRhIHx8ICFpdC5vcHRzLnN0cmljdFR5cGVzKSByZXR1cm5cbiAgY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKVxuICBpZiAoIWl0Lm9wdHMuYWxsb3dVbmlvblR5cGVzKSBjaGVja011bHRpcGxlVHlwZXMoaXQsIHR5cGVzKVxuICBjaGVja0tleXdvcmRUeXBlcyhpdCwgaXQuZGF0YVR5cGVzKVxufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAoIXR5cGVzLmxlbmd0aCkgcmV0dXJuXG4gIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgIGl0LmRhdGFUeXBlcyA9IHR5cGVzXG4gICAgcmV0dXJuXG4gIH1cbiAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApXG4gICAgfVxuICB9KVxuICBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgdHlwZXMpXG59XG5cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0czogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHRzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGxcbiAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdXG4gICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgc2hvdWxkVXNlUnVsZShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICBjb25zdCB7dHlwZX0gPSBydWxlLmRlZmluaXRpb25cbiAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGBtaXNzaW5nIHR5cGUgXCIke3R5cGUuam9pbihcIixcIil9XCIgZm9yIGtleXdvcmQgXCIke2tleXdvcmR9XCJgKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUczogSlNPTlR5cGVbXSwga3dkVDogSlNPTlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNjaFRzLmluY2x1ZGVzKGt3ZFQpIHx8IChrd2RUID09PSBcIm51bWJlclwiICYmIHNjaFRzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSlcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzOiBKU09OVHlwZVtdLCB0OiBKU09OVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHMuaW5jbHVkZXModCkgfHwgKHQgPT09IFwiaW50ZWdlclwiICYmIHRzLmluY2x1ZGVzKFwibnVtYmVyXCIpKVxufVxuXG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB3aXRoVHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3QgdHM6IEpTT05UeXBlW10gPSBbXVxuICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgaWYgKGluY2x1ZGVzVHlwZSh3aXRoVHlwZXMsIHQpKSB0cy5wdXNoKHQpXG4gICAgZWxzZSBpZiAod2l0aFR5cGVzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSAmJiB0ID09PSBcIm51bWJlclwiKSB0cy5wdXNoKFwiaW50ZWdlclwiKVxuICB9XG4gIGl0LmRhdGFUeXBlcyA9IHRzXG59XG5cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQ6IFNjaGVtYU9iakN4dCwgbXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoXG4gIG1zZyArPSBgIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RUeXBlcylgXG4gIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKVxufVxuXG5leHBvcnQgY2xhc3MgS2V5d29yZEN4dCBpbXBsZW1lbnRzIEtleXdvcmRFcnJvckN4dCB7XG4gIHJlYWRvbmx5IGdlbjogQ29kZUdlblxuICByZWFkb25seSBhbGxFcnJvcnM/OiBib29sZWFuXG4gIHJlYWRvbmx5IGtleXdvcmQ6IHN0cmluZ1xuICByZWFkb25seSBkYXRhOiBOYW1lIC8vIE5hbWUgcmVmZXJlbmNpbmcgdGhlIGN1cnJlbnQgbGV2ZWwgb2YgdGhlIGRhdGEgaW5zdGFuY2VcbiAgcmVhZG9ubHkgJGRhdGE/OiBzdHJpbmcgfCBmYWxzZVxuICBzY2hlbWE6IGFueSAvLyBrZXl3b3JkIHZhbHVlIGluIHRoZSBzY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hVmFsdWU6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIC8vIENvZGUgcmVmZXJlbmNlIHRvIGtleXdvcmQgc2NoZW1hIHZhbHVlIG9yIHByaW1pdGl2ZSB2YWx1ZVxuICByZWFkb25seSBzY2hlbWFDb2RlOiBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiAvLyBDb2RlIHJlZmVyZW5jZSB0byByZXNvbHZlZCBzY2hlbWEgdmFsdWUgKGRpZmZlcmVudCBpZiBzY2hlbWEgaXMgJGRhdGEpXG4gIHJlYWRvbmx5IHNjaGVtYVR5cGU6IEpTT05UeXBlW10gLy8gYWxsb3dlZCB0eXBlKHMpIG9mIGtleXdvcmQgdmFsdWUgaW4gdGhlIHNjaGVtYVxuICByZWFkb25seSBwYXJlbnRTY2hlbWE6IEFueVNjaGVtYU9iamVjdFxuICByZWFkb25seSBlcnJzQ291bnQ/OiBOYW1lIC8vIE5hbWUgcmVmZXJlbmNlIHRvIHRoZSBudW1iZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnMgY29sbGVjdGVkIGJlZm9yZSB0aGlzIGtleXdvcmQsXG4gIC8vIHJlcXVpcmVzIG9wdGlvbiB0cmFja0Vycm9ycyBpbiBrZXl3b3JkIGRlZmluaXRpb25cbiAgcGFyYW1zOiBLZXl3b3JkQ3h0UGFyYW1zIC8vIG9iamVjdCB0byBwYXNzIHBhcmFtZXRlcnMgdG8gZXJyb3IgbWVzc2FnZXMgZnJvbSBrZXl3b3JkIGNvZGVcbiAgcmVhZG9ubHkgaXQ6IFNjaGVtYU9iakN4dCAvLyBzY2hlbWEgY29tcGlsYXRpb24gY29udGV4dCAoc2NoZW1hIGlzIGd1YXJhbnRlZWQgdG8gYmUgYW4gb2JqZWN0LCBub3QgYm9vbGVhbilcbiAgcmVhZG9ubHkgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uXG5cbiAgY29uc3RydWN0b3IoaXQ6IFNjaGVtYU9iakN4dCwgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLCBrZXl3b3JkOiBzdHJpbmcpIHtcbiAgICB2YWxpZGF0ZUtleXdvcmRVc2FnZShpdCwgZGVmLCBrZXl3b3JkKVxuICAgIHRoaXMuZ2VuID0gaXQuZ2VuXG4gICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnNcbiAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgdGhpcy5kYXRhID0gaXQuZGF0YVxuICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhXG4gICAgdGhpcy5zY2hlbWFWYWx1ZSA9IHNjaGVtYVJlZk9yVmFsKGl0LCB0aGlzLnNjaGVtYSwga2V5d29yZCwgdGhpcy4kZGF0YSlcbiAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZVxuICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hXG4gICAgdGhpcy5wYXJhbXMgPSB7fVxuICAgIHRoaXMuaXQgPSBpdFxuICAgIHRoaXMuZGVmID0gZGVmXG5cbiAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2hlbWFDb2RlID0gdGhpcy5zY2hlbWFWYWx1ZVxuICAgICAgaWYgKCF2YWxpZFNjaGVtYVR5cGUodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIE4uZXJyb3JzKVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdChjb25kaXRpb246IENvZGUsIHN1Y2Nlc3NBY3Rpb24/OiAoKSA9PiB2b2lkLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbFJlc3VsdChub3QoY29uZGl0aW9uKSwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbilcbiAgfVxuXG4gIGZhaWxSZXN1bHQoY29uZGl0aW9uOiBDb2RlLCBzdWNjZXNzQWN0aW9uPzogKCkgPT4gdm9pZCwgZmFpbEFjdGlvbj86ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pXG4gICAgaWYgKGZhaWxBY3Rpb24pIGZhaWxBY3Rpb24oKVxuICAgIGVsc2UgdGhpcy5lcnJvcigpXG4gICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgIHRoaXMuZ2VuLmVsc2UoKVxuICAgICAgc3VjY2Vzc0FjdGlvbigpXG4gICAgICBpZiAodGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmVuZElmKClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5lbmRJZigpXG4gICAgICBlbHNlIHRoaXMuZ2VuLmVsc2UoKVxuICAgIH1cbiAgfVxuXG4gIHBhc3MoY29uZGl0aW9uOiBDb2RlLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbFJlc3VsdChub3QoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKVxuICB9XG5cbiAgZmFpbChjb25kaXRpb24/OiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yKClcbiAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmlmKGZhbHNlKSAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKVxuICAgIHRoaXMuZXJyb3IoKVxuICAgIGlmICh0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uZW5kSWYoKVxuICAgIGVsc2UgdGhpcy5nZW4uZWxzZSgpXG4gIH1cblxuICBmYWlsJGRhdGEoY29uZGl0aW9uOiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLiRkYXRhKSByZXR1cm4gdGhpcy5mYWlsKGNvbmRpdGlvbilcbiAgICBjb25zdCB7c2NoZW1hQ29kZX0gPSB0aGlzXG4gICAgdGhpcy5mYWlsKF9gJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgke29yKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApXG4gIH1cblxuICBlcnJvcihhcHBlbmQ/OiBib29sZWFuLCBlcnJvclBhcmFtcz86IEtleXdvcmRDeHRQYXJhbXMsIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzKTogdm9pZCB7XG4gICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcylcbiAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocylcbiAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocylcbiAgfVxuXG4gIHByaXZhdGUgX2Vycm9yKGFwcGVuZD86IGJvb2xlYW4sIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzKTogdm9pZCB7XG4gICAgOyhhcHBlbmQgPyByZXBvcnRFeHRyYUVycm9yIDogcmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLmVycm9yLCBlcnJvclBhdGhzKVxuICB9XG5cbiAgJGRhdGFFcnJvcigpOiB2b2lkIHtcbiAgICByZXBvcnRFcnJvcih0aGlzLCB0aGlzLmRlZi4kZGF0YUVycm9yIHx8IGtleXdvcmQkRGF0YUVycm9yKVxuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKVxuICAgIHJlc2V0RXJyb3JzQ291bnQodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KVxuICB9XG5cbiAgb2soY29uZDogQ29kZSB8IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5pZihjb25kKVxuICB9XG5cbiAgc2V0UGFyYW1zKG9iajogS2V5d29yZEN4dFBhcmFtcywgYXNzaWduPzogdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChhc3NpZ24pIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iailcbiAgICBlbHNlIHRoaXMucGFyYW1zID0gb2JqXG4gIH1cblxuICBibG9jayRkYXRhKHZhbGlkOiBOYW1lLCBjb2RlQmxvY2s6ICgpID0+IHZvaWQsICRkYXRhVmFsaWQ6IENvZGUgPSBuaWwpOiB2b2lkIHtcbiAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpXG4gICAgICBjb2RlQmxvY2soKVxuICAgIH0pXG4gIH1cblxuICBjaGVjayRkYXRhKHZhbGlkOiBOYW1lID0gbmlsLCAkZGF0YVZhbGlkOiBDb2RlID0gbmlsKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLiRkYXRhKSByZXR1cm5cbiAgICBjb25zdCB7Z2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWZ9ID0gdGhpc1xuICAgIGdlbi5pZihvcihfYCR7c2NoZW1hQ29kZX0gPT09IHVuZGVmaW5lZGAsICRkYXRhVmFsaWQpKVxuICAgIGlmICh2YWxpZCAhPT0gbmlsKSBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCB8fCBkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgIGdlbi5lbHNlSWYodGhpcy5pbnZhbGlkJGRhdGEoKSlcbiAgICAgIHRoaXMuJGRhdGFFcnJvcigpXG4gICAgICBpZiAodmFsaWQgIT09IG5pbCkgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgfVxuICAgIGdlbi5lbHNlKClcbiAgfVxuXG4gIGludmFsaWQkZGF0YSgpOiBDb2RlIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0fSA9IHRoaXNcbiAgICByZXR1cm4gb3Iod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpXG5cbiAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpOiBDb2RlIHtcbiAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIE5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXVxuICAgICAgICByZXR1cm4gX2Ake2NoZWNrRGF0YVR5cGVzKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKX1gXG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCk6IENvZGUge1xuICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZVNjaGVtYVJlZiA9IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGUkZGF0YVwiLCB7cmVmOiBkZWYudmFsaWRhdGVTY2hlbWF9KSAvLyBUT0RPIHZhbHVlLmNvZGUgZm9yIHN0YW5kYWxvbmVcbiAgICAgICAgcmV0dXJuIF9gISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYFxuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbFxuICAgIH1cbiAgfVxuXG4gIHN1YnNjaGVtYShhcHBsOiBTdWJzY2hlbWFBcmdzLCB2YWxpZDogTmFtZSk6IFNjaGVtYUN4dCB7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hKHRoaXMuaXQsIGFwcGwpXG4gICAgZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpXG4gICAgZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIGFwcGwpXG4gICAgY29uc3QgbmV4dENvbnRleHQgPSB7Li4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkfVxuICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKVxuICAgIHJldHVybiBuZXh0Q29udGV4dFxuICB9XG5cbiAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0OiBTY2hlbWFDeHQsIHRvTmFtZT86IHR5cGVvZiBOYW1lKTogdm9pZCB7XG4gICAgY29uc3Qge2l0LCBnZW59ID0gdGhpc1xuICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZCkgcmV0dXJuXG4gICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKVxuICAgIH1cbiAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpXG4gICAgfVxuICB9XG5cbiAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiBib29sZWFuIHwgdm9pZCB7XG4gICAgY29uc3Qge2l0LCBnZW59ID0gdGhpc1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIE5hbWUpKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5d29yZENvZGUoXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBydWxlVHlwZT86IEpTT05UeXBlXG4pOiB2b2lkIHtcbiAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZClcbiAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpXG4gIH0gZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfSBlbHNlIGlmIChcIm1hY3JvXCIgaW4gZGVmKSB7XG4gICAgbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfSBlbHNlIGlmIChkZWYuY29tcGlsZSB8fCBkZWYudmFsaWRhdGUpIHtcbiAgICBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpXG4gIH1cbn1cblxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokL1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKFxuICAkZGF0YTogc3RyaW5nLFxuICB7ZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyfTogU2NoZW1hQ3h0XG4pOiBDb2RlIHwgbnVtYmVyIHtcbiAgbGV0IGpzb25Qb2ludGVyXG4gIGxldCBkYXRhOiBDb2RlXG4gIGlmICgkZGF0YSA9PT0gXCJcIikgcmV0dXJuIE4ucm9vdERhdGFcbiAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApXG4gICAganNvblBvaW50ZXIgPSAkZGF0YVxuICAgIGRhdGEgPSBOLnJvb3REYXRhXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKVxuICAgIGlmICghbWF0Y2hlcykgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKVxuICAgIGNvbnN0IHVwOiBudW1iZXIgPSArbWF0Y2hlc1sxXVxuICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXVxuICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSlcbiAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF1cbiAgICB9XG4gICAgaWYgKHVwID4gZGF0YUxldmVsKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSlcbiAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXVxuICAgIGlmICghanNvblBvaW50ZXIpIHJldHVybiBkYXRhXG4gIH1cblxuICBsZXQgZXhwciA9IGRhdGFcbiAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIilcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgIGRhdGEgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpfWBcbiAgICAgIGV4cHIgPSBfYCR7ZXhwcn0gJiYgJHtkYXRhfWBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cHJcblxuICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZTogc3RyaW5nLCB1cDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWBcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtFcnJvck9iamVjdH0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBlcnJvcnM6IFBhcnRpYWw8RXJyb3JPYmplY3Q+W11cbiAgcmVhZG9ubHkgYWp2OiB0cnVlXG4gIHJlYWRvbmx5IHZhbGlkYXRpb246IHRydWVcblxuICBjb25zdHJ1Y3RvcihlcnJvcnM6IFBhcnRpYWw8RXJyb3JPYmplY3Q+W10pIHtcbiAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcbiAgICB0aGlzLmFqdiA9IHRoaXMudmFsaWRhdGlvbiA9IHRydWVcbiAgfVxufVxuIiwgImltcG9ydCB7cmVzb2x2ZVVybCwgbm9ybWFsaXplSWQsIGdldEZ1bGxQYXRofSBmcm9tIFwiLi9yZXNvbHZlXCJcbmltcG9ydCB0eXBlIHtVcmlSZXNvbHZlcn0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBtaXNzaW5nUmVmOiBzdHJpbmdcbiAgcmVhZG9ubHkgbWlzc2luZ1NjaGVtYTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBiYXNlSWQ6IHN0cmluZywgcmVmOiBzdHJpbmcsIG1zZz86IHN0cmluZykge1xuICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YClcbiAgICB0aGlzLm1pc3NpbmdSZWYgPSByZXNvbHZlVXJsKHJlc29sdmVyLCBiYXNlSWQsIHJlZilcbiAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSBub3JtYWxpemVJZChnZXRGdWxsUGF0aChyZXNvbHZlciwgdGhpcy5taXNzaW5nUmVmKSlcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgRXZhbHVhdGVkUHJvcGVydGllcyxcbiAgRXZhbHVhdGVkSXRlbXMsXG59IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcIi4uL2NvcmVcIlxuaW1wb3J0IHR5cGUge0luc3RhbmNlT3B0aW9uc30gZnJvbSBcIi4uL2NvcmVcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBuaWwsIHN0cmluZ2lmeSwgTmFtZSwgQ29kZSwgVmFsdWVTY29wZU5hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IFZhbGlkYXRpb25FcnJvciBmcm9tIFwiLi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCJcbmltcG9ydCBOIGZyb20gXCIuL25hbWVzXCJcbmltcG9ydCB7TG9jYWxSZWZzLCBnZXRGdWxsUGF0aCwgX2dldEZ1bGxQYXRoLCBpbmxpbmVSZWYsIG5vcm1hbGl6ZUlkLCByZXNvbHZlVXJsfSBmcm9tIFwiLi9yZXNvbHZlXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNCdXRSZWYsIHVuZXNjYXBlRnJhZ21lbnR9IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0IHt2YWxpZGF0ZUZ1bmN0aW9uQ29kZX0gZnJvbSBcIi4vdmFsaWRhdGVcIlxuaW1wb3J0ICogYXMgVVJJIGZyb20gXCJ1cmktanNcIlxuaW1wb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vcnVsZXNcIlxuXG5leHBvcnQgdHlwZSBTY2hlbWFSZWZzID0ge1xuICBbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBBbnlTY2hlbWFcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFDeHQge1xuICByZWFkb25seSBnZW46IENvZGVHZW5cbiAgcmVhZG9ubHkgYWxsRXJyb3JzPzogYm9vbGVhbiAvLyB2YWxpZGF0aW9uIG1vZGUgLSB3aGV0aGVyIHRvIGNvbGxlY3QgYWxsIGVycm9ycyBvciBicmVhayBvbiBlcnJvclxuICByZWFkb25seSBkYXRhOiBOYW1lIC8vIE5hbWUgd2l0aCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGFydCBvZiBkYXRhIGluc3RhbmNlXG4gIHJlYWRvbmx5IHBhcmVudERhdGE6IE5hbWUgLy8gc2hvdWxkIGJlIHVzZWQgaW4ga2V5d29yZHMgbW9kaWZ5aW5nIGRhdGFcbiAgcmVhZG9ubHkgcGFyZW50RGF0YVByb3BlcnR5OiBDb2RlIHwgbnVtYmVyIC8vIHNob3VsZCBiZSB1c2VkIGluIGtleXdvcmRzIG1vZGlmeWluZyBkYXRhXG4gIHJlYWRvbmx5IGRhdGFOYW1lczogTmFtZVtdXG4gIHJlYWRvbmx5IGRhdGFQYXRoQXJyOiAoQ29kZSB8IG51bWJlcilbXVxuICByZWFkb25seSBkYXRhTGV2ZWw6IG51bWJlciAvLyB0aGUgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSB2YWxpZGF0ZWQgZGF0YSxcbiAgLy8gaXQgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIGJvdGggdGhlIHByb3BlcnR5IG5hbWVzIGFuZCB0aGUgZGF0YSBvbiBhbGwgbGV2ZWxzIGZyb20gdGhlIHRvcC5cbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdIC8vIGRhdGEgdHlwZXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBwYXJ0IG9mIGRhdGEgaW5zdGFuY2VcbiAgZGVmaW5lZFByb3BlcnRpZXM6IFNldDxzdHJpbmc+IC8vIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGtlZXAgdHJhY2sgb2YgZm9yIHJlcXVpcmVkIGNoZWNrc1xuICByZWFkb25seSB0b3BTY2hlbWFSZWY6IENvZGVcbiAgcmVhZG9ubHkgdmFsaWRhdGVOYW1lOiBOYW1lXG4gIGV2YWx1YXRlZD86IE5hbWVcbiAgcmVhZG9ubHkgVmFsaWRhdGlvbkVycm9yPzogTmFtZVxuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYSAvLyBjdXJyZW50IHNjaGVtYSBvYmplY3QgLSBlcXVhbCB0byBwYXJlbnRTY2hlbWEgcGFzc2VkIHZpYSBLZXl3b3JkQ3h0XG4gIHJlYWRvbmx5IHNjaGVtYUVudjogU2NoZW1hRW52XG4gIHJlYWRvbmx5IHJvb3RJZDogc3RyaW5nXG4gIGJhc2VJZDogc3RyaW5nIC8vIHRoZSBjdXJyZW50IHNjaGVtYSBiYXNlIFVSSSB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciByZXNvbHZpbmcgVVJJcyBpbiByZWZlcmVuY2VzIChcXCRyZWYpXG4gIHJlYWRvbmx5IHNjaGVtYVBhdGg6IENvZGUgLy8gdGhlIHJ1bi10aW1lIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGN1cnJlbnQgc2NoZW1hXG4gIHJlYWRvbmx5IGVyclNjaGVtYVBhdGg6IHN0cmluZyAvLyB0aGlzIGlzIGFjdHVhbCBzdHJpbmcsIHNob3VsZCBub3QgYmUgY2hhbmdlZCB0byBDb2RlXG4gIHJlYWRvbmx5IGVycm9yUGF0aDogQ29kZVxuICByZWFkb25seSBwcm9wZXJ0eU5hbWU/OiBOYW1lXG4gIHJlYWRvbmx5IGNvbXBvc2l0ZVJ1bGU/OiBib29sZWFuIC8vIHRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgc2NoZW1hIGlzIGluc2lkZSB0aGUgY29tcG91bmQga2V5d29yZCxcbiAgLy8gd2hlcmUgZmFpbGluZyBzb21lIHJ1bGUgZG9lc24ndCBtZWFuIHZhbGlkYXRpb24gZmFpbHVyZSAoYGFueU9mYCwgYG9uZU9mYCwgYG5vdGAsIGBpZmApLlxuICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB5b3UgY2FuIHJldHVybiB2YWxpZGF0aW9uIHJlc3VsdCBpbW1lZGlhdGVseSBhZnRlciBhbnkgZXJyb3IgaW4gY2FzZSB0aGUgb3B0aW9uIGBhbGxFcnJvcnNgIGlzIG5vdCBgdHJ1ZS5cbiAgLy8gWW91IG9ubHkgbmVlZCB0byB1c2UgaXQgaWYgeW91IGhhdmUgbWFueSBzdGVwcyBpbiB5b3VyIGtleXdvcmRzIGFuZCBwb3RlbnRpYWxseSBjYW4gZGVmaW5lIG11bHRpcGxlIGVycm9ycy5cbiAgcHJvcHM/OiBFdmFsdWF0ZWRQcm9wZXJ0aWVzIHwgTmFtZSAvLyBwcm9wZXJ0aWVzIGV2YWx1YXRlZCBieSB0aGlzIHNjaGVtYSAtIHVzZWQgYnkgcGFyZW50IHNjaGVtYSBvciBhc3NpZ25lZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGl0ZW1zPzogRXZhbHVhdGVkSXRlbXMgfCBOYW1lIC8vIGxhc3QgaXRlbSBldmFsdWF0ZWQgYnkgdGhpcyBzY2hlbWEgLSB1c2VkIGJ5IHBhcmVudCBzY2hlbWEgb3IgYXNzaWduZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICBqdGREaXNjcmltaW5hdG9yPzogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhPzogYm9vbGVhblxuICByZWFkb25seSBjcmVhdGVFcnJvcnM/OiBib29sZWFuXG4gIHJlYWRvbmx5IG9wdHM6IEluc3RhbmNlT3B0aW9ucyAvLyBBanYgaW5zdGFuY2Ugb3B0aW9uLlxuICByZWFkb25seSBzZWxmOiBBanYgLy8gY3VycmVudCBBanYgaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFPYmpDeHQgZXh0ZW5kcyBTY2hlbWFDeHQge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYU9iamVjdFxufVxuaW50ZXJmYWNlIFNjaGVtYUVudkFyZ3Mge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYVxuICByZWFkb25seSBzY2hlbWFJZD86IFwiJGlkXCIgfCBcImlkXCJcbiAgcmVhZG9ubHkgcm9vdD86IFNjaGVtYUVudlxuICByZWFkb25seSBiYXNlSWQ/OiBzdHJpbmdcbiAgcmVhZG9ubHkgc2NoZW1hUGF0aD86IHN0cmluZ1xuICByZWFkb25seSBsb2NhbFJlZnM/OiBMb2NhbFJlZnNcbiAgcmVhZG9ubHkgbWV0YT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFNjaGVtYUVudiBpbXBsZW1lbnRzIFNjaGVtYUVudkFyZ3Mge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYVxuICByZWFkb25seSBzY2hlbWFJZD86IFwiJGlkXCIgfCBcImlkXCJcbiAgcmVhZG9ubHkgcm9vdDogU2NoZW1hRW52XG4gIGJhc2VJZDogc3RyaW5nIC8vIFRPRE8gcG9zc2libHksIGl0IHNob3VsZCBiZSByZWFkb25seVxuICBzY2hlbWFQYXRoPzogc3RyaW5nXG4gIGxvY2FsUmVmcz86IExvY2FsUmVmc1xuICByZWFkb25seSBtZXRhPzogYm9vbGVhblxuICByZWFkb25seSAkYXN5bmM/OiBib29sZWFuIC8vIHRydWUgaWYgdGhlIGN1cnJlbnQgc2NoZW1hIGlzIGFzeW5jaHJvbm91cy5cbiAgcmVhZG9ubHkgcmVmczogU2NoZW1hUmVmcyA9IHt9XG4gIHJlYWRvbmx5IGR5bmFtaWNBbmNob3JzOiB7W1JlZiBpbiBzdHJpbmddPzogdHJ1ZX0gPSB7fVxuICB2YWxpZGF0ZT86IEFueVZhbGlkYXRlRnVuY3Rpb25cbiAgdmFsaWRhdGVOYW1lPzogVmFsdWVTY29wZU5hbWVcbiAgc2VyaWFsaXplPzogKGRhdGE6IHVua25vd24pID0+IHN0cmluZ1xuICBzZXJpYWxpemVOYW1lPzogVmFsdWVTY29wZU5hbWVcbiAgcGFyc2U/OiAoZGF0YTogc3RyaW5nKSA9PiB1bmtub3duXG4gIHBhcnNlTmFtZT86IFZhbHVlU2NvcGVOYW1lXG5cbiAgY29uc3RydWN0b3IoZW52OiBTY2hlbWFFbnZBcmdzKSB7XG4gICAgbGV0IHNjaGVtYTogQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpIHNjaGVtYSA9IGVudi5zY2hlbWFcbiAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWFcbiAgICB0aGlzLnNjaGVtYUlkID0gZW52LnNjaGVtYUlkXG4gICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpc1xuICAgIHRoaXMuYmFzZUlkID0gZW52LmJhc2VJZCA/PyBub3JtYWxpemVJZChzY2hlbWE/LltlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pXG4gICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGhcbiAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnNcbiAgICB0aGlzLm1ldGEgPSBlbnYubWV0YVxuICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hPy4kYXN5bmNcbiAgICB0aGlzLnJlZnMgPSB7fVxuICB9XG59XG5cbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG5cbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlU2NoZW1hKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBTY2hlbWFFbnYge1xuICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKVxuICBpZiAoX3NjaCkgcmV0dXJuIF9zY2hcbiAgY29uc3Qgcm9vdElkID0gZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBzY2gucm9vdC5iYXNlSWQpIC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gIGNvbnN0IHtlczUsIGxpbmVzfSA9IHRoaXMub3B0cy5jb2RlXG4gIGNvbnN0IHtvd25Qcm9wZXJ0aWVzfSA9IHRoaXMub3B0c1xuICBjb25zdCBnZW4gPSBuZXcgQ29kZUdlbih0aGlzLnNjb3BlLCB7ZXM1LCBsaW5lcywgb3duUHJvcGVydGllc30pXG4gIGxldCBfVmFsaWRhdGlvbkVycm9yXG4gIGlmIChzY2guJGFzeW5jKSB7XG4gICAgX1ZhbGlkYXRpb25FcnJvciA9IGdlbi5zY29wZVZhbHVlKFwiRXJyb3JcIiwge1xuICAgICAgcmVmOiBWYWxpZGF0aW9uRXJyb3IsXG4gICAgICBjb2RlOiBfYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKVxuICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lXG5cbiAgY29uc3Qgc2NoZW1hQ3h0OiBTY2hlbWFDeHQgPSB7XG4gICAgZ2VuLFxuICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICBkYXRhOiBOLmRhdGEsXG4gICAgcGFyZW50RGF0YTogTi5wYXJlbnREYXRhLFxuICAgIHBhcmVudERhdGFQcm9wZXJ0eTogTi5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgZGF0YU5hbWVzOiBbTi5kYXRhXSxcbiAgICBkYXRhUGF0aEFycjogW25pbF0sIC8vIFRPRE8gY2FuIGl0cyBsZW5ndGggYmUgdXNlZCBhcyBkYXRhTGV2ZWwgaWYgbmlsIGlzIHJlbW92ZWQ/XG4gICAgZGF0YUxldmVsOiAwLFxuICAgIGRhdGFUeXBlczogW10sXG4gICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQ8c3RyaW5nPigpLFxuICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXG4gICAgICBcInNjaGVtYVwiLFxuICAgICAgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgID8ge3JlZjogc2NoLnNjaGVtYSwgY29kZTogc3RyaW5naWZ5KHNjaC5zY2hlbWEpfVxuICAgICAgICA6IHtyZWY6IHNjaC5zY2hlbWF9XG4gICAgKSxcbiAgICB2YWxpZGF0ZU5hbWUsXG4gICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgIHNjaGVtYTogc2NoLnNjaGVtYSxcbiAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICByb290SWQsXG4gICAgYmFzZUlkOiBzY2guYmFzZUlkIHx8IHJvb3RJZCxcbiAgICBzY2hlbWFQYXRoOiBuaWwsXG4gICAgZXJyU2NoZW1hUGF0aDogc2NoLnNjaGVtYVBhdGggfHwgKHRoaXMub3B0cy5qdGQgPyBcIlwiIDogXCIjXCIpLFxuICAgIGVycm9yUGF0aDogX2BcIlwiYCxcbiAgICBvcHRzOiB0aGlzLm9wdHMsXG4gICAgc2VsZjogdGhpcyxcbiAgfVxuXG4gIGxldCBzb3VyY2VDb2RlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgdHJ5IHtcbiAgICB0aGlzLl9jb21waWxhdGlvbnMuYWRkKHNjaClcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShzY2hlbWFDeHQpXG4gICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKVxuICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpXG4gICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMoTi5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWBcbiAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKSBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtOLnNlbGZ9YCwgYCR7Ti5zY29wZX1gLCBzb3VyY2VDb2RlKVxuICAgIGNvbnN0IHZhbGlkYXRlOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpXG4gICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHtyZWY6IHZhbGlkYXRlfSlcblxuICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGxcbiAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hXG4gICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoXG4gICAgaWYgKHNjaC4kYXN5bmMpICh2YWxpZGF0ZSBhcyBBc3luY1ZhbGlkYXRlRnVuY3Rpb24pLiRhc3luYyA9IHRydWVcbiAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7dmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlc31cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgY29uc3Qge3Byb3BzLCBpdGVtc30gPSBzY2hlbWFDeHRcbiAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBOYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBOYW1lLFxuICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgTmFtZSxcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSBzdHJpbmdpZnkodmFsaWRhdGUuZXZhbHVhdGVkKVxuICAgIH1cbiAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZVxuICAgIHJldHVybiBzY2hcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVcbiAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZVxuICAgIGlmIChzb3VyY2VDb2RlKSB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgdGhyb3cgZVxuICB9IGZpbmFsbHkge1xuICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUmVmKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudixcbiAgYmFzZUlkOiBzdHJpbmcsXG4gIHJlZjogc3RyaW5nXG4pOiBBbnlTY2hlbWEgfCBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICByZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpXG4gIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdXG4gIGlmIChzY2hPckZ1bmMpIHJldHVybiBzY2hPckZ1bmNcblxuICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpXG4gIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSByb290LmxvY2FsUmVmcz8uW3JlZl0gLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGlmIChzY2hlbWEpIF9zY2ggPSBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICB9XG5cbiAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSlcbn1cblxuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBBbnlTY2hlbWEgfCBTY2hlbWFFbnYge1xuICBpZiAoaW5saW5lUmVmKHNjaC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKSkgcmV0dXJuIHNjaC5zY2hlbWFcbiAgcmV0dXJuIHNjaC52YWxpZGF0ZSA/IHNjaCA6IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG59XG5cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEodGhpczogQWp2LCBzY2hFbnY6IFNjaGVtYUVudik6IFNjaGVtYUVudiB8IHZvaWQge1xuICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICBpZiAoc2FtZVNjaGVtYUVudihzY2gsIHNjaEVudikpIHJldHVybiBzY2hcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxOiBTY2hlbWFFbnYsIHMyOiBTY2hlbWFFbnYpOiBib29sZWFuIHtcbiAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWRcbn1cblxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUoXG4gIHRoaXM6IEFqdixcbiAgcm9vdDogU2NoZW1hRW52LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxuICByZWY6IHN0cmluZyAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgbGV0IHNjaFxuICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIikgcmVmID0gc2NoXG4gIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZilcbn1cblxuLy8gUmVzb2x2ZSBzY2hlbWEsIGl0cyByb290IGFuZCBiYXNlSWRcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudiwgLy8gcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmcyBUT0RPIGJlbG93IFNjaGVtYUVudiBpcyBhc3NpZ25lZCB0byBpdFxuICByZWY6IHN0cmluZyAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpXG4gIGNvbnN0IHJlZlBhdGggPSBfZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKVxuICBsZXQgYmFzZUlkID0gZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKVxuICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpXG4gIH1cblxuICBjb25zdCBpZCA9IG5vcm1hbGl6ZUlkKHJlZlBhdGgpXG4gIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdXG4gIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBzY2hPclJlZilcbiAgICBpZiAodHlwZW9mIHNjaD8uc2NoZW1hICE9PSBcIm9iamVjdFwiKSByZXR1cm5cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2gpXG4gIH1cblxuICBpZiAodHlwZW9mIHNjaE9yUmVmPy5zY2hlbWEgIT09IFwib2JqZWN0XCIpIHJldHVyblxuICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpXG4gIGlmIChpZCA9PT0gbm9ybWFsaXplSWQocmVmKSkge1xuICAgIGNvbnN0IHtzY2hlbWF9ID0gc2NoT3JSZWZcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgaWYgKHNjaElkKSBiYXNlSWQgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZClcbiAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkfSlcbiAgfVxuICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZilcbn1cblxuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgXCJwcm9wZXJ0aWVzXCIsXG4gIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgXCJlbnVtXCIsXG4gIFwiZGVwZW5kZW5jaWVzXCIsXG4gIFwiZGVmaW5pdGlvbnNcIixcbl0pXG5cbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKFxuICB0aGlzOiBBanYsXG4gIHBhcnNlZFJlZjogVVJJLlVSSUNvbXBvbmVudHMsXG4gIHtiYXNlSWQsIHNjaGVtYSwgcm9vdH06IFNjaGVtYUVudlxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBhcnNlZFJlZi5mcmFnbWVudD8uWzBdICE9PSBcIi9cIikgcmV0dXJuXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSByZXR1cm5cbiAgICBjb25zdCBwYXJ0U2NoZW1hID0gc2NoZW1hW3VuZXNjYXBlRnJhZ21lbnQocGFydCldXG4gICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgc2NoZW1hID0gcGFydFNjaGVtYVxuICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF1cbiAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgYmFzZUlkID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpXG4gICAgfVxuICB9XG4gIGxldCBlbnY6IFNjaGVtYUVudiB8IHVuZGVmaW5lZFxuICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgIGNvbnN0ICRyZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hlbWEuJHJlZilcbiAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZilcbiAgfVxuICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKSByZXR1cm4gZW52XG4gIHJldHVybiB1bmRlZmluZWRcbn1cbiIsICJ7XG4gIFwiJGlkXCI6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJNZXRhLXNjaGVtYSBmb3IgJGRhdGEgcmVmZXJlbmNlIChKU09OIEFueVNjaGVtYSBleHRlbnNpb24gcHJvcG9zYWwpXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInJlcXVpcmVkXCI6IFtcIiRkYXRhXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGRhdGFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImFueU9mXCI6IFt7XCJmb3JtYXRcIjogXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIn0sIHtcImZvcm1hdFwiOiBcImpzb24tcG9pbnRlclwifV1cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBTQ0hFTUVTIH0gZnJvbSBcIi4vdXJpXCI7XG5cbmltcG9ydCBodHRwIGZyb20gXCIuL3NjaGVtZXMvaHR0cFwiO1xuU0NIRU1FU1todHRwLnNjaGVtZV0gPSBodHRwO1xuXG5pbXBvcnQgaHR0cHMgZnJvbSBcIi4vc2NoZW1lcy9odHRwc1wiO1xuU0NIRU1FU1todHRwcy5zY2hlbWVdID0gaHR0cHM7XG5cbmltcG9ydCB3cyBmcm9tIFwiLi9zY2hlbWVzL3dzXCI7XG5TQ0hFTUVTW3dzLnNjaGVtZV0gPSB3cztcblxuaW1wb3J0IHdzcyBmcm9tIFwiLi9zY2hlbWVzL3dzc1wiO1xuU0NIRU1FU1t3c3Muc2NoZW1lXSA9IHdzcztcblxuaW1wb3J0IG1haWx0byBmcm9tIFwiLi9zY2hlbWVzL21haWx0b1wiO1xuU0NIRU1FU1ttYWlsdG8uc2NoZW1lXSA9IG1haWx0bztcblxuaW1wb3J0IHVybiBmcm9tIFwiLi9zY2hlbWVzL3VyblwiO1xuU0NIRU1FU1t1cm4uc2NoZW1lXSA9IHVybjtcblxuaW1wb3J0IHV1aWQgZnJvbSBcIi4vc2NoZW1lcy91cm4tdXVpZFwiO1xuU0NIRU1FU1t1dWlkLnNjaGVtZV0gPSB1dWlkO1xuXG5leHBvcnQgKiBmcm9tIFwiLi91cmlcIjtcbiIsICJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgVVJOQ29tcG9uZW50cyB9IGZyb20gXCIuL3VyblwiO1xuaW1wb3J0IHsgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVVUlEQ29tcG9uZW50cyBleHRlbmRzIFVSTkNvbXBvbmVudHMge1xuXHR1dWlkPzogc3RyaW5nO1xufVxuXG5jb25zdCBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuY29uc3QgVVVJRF9QQVJTRSA9IC9eWzAtOUEtRmEtZlxcLV17MzZ9LztcblxuLy9SRkMgNDEyMlxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVVSURDb21wb25lbnRzLCBVUklPcHRpb25zLCBVUk5Db21wb25lbnRzPiA9IHtcblx0c2NoZW1lIDogXCJ1cm46dXVpZFwiLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKHVybkNvbXBvbmVudHM6VVJOQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVVUlEQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzIGFzIFVVSURDb21wb25lbnRzO1xuXHRcdHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG5cdFx0dXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcblx0XHRcdHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXVpZENvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHV1aWRDb21wb25lbnRzOlVVSURDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cyBhcyBVUk5Db21wb25lbnRzO1xuXHRcdC8vbm9ybWFsaXplIFVVSURcblx0XHR1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIHVybkNvbXBvbmVudHM7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsICJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgcGN0RW5jQ2hhciwgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUk5Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdG5pZD86c3RyaW5nO1xuXHRuc3M/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUk5PcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyB7XG5cdG5pZD86c3RyaW5nO1xufVxuXG5jb25zdCBOSUQkID0gXCIoPzpbMC05QS1aYS16XVswLTlBLVphLXpcXFxcLV17MSwzMX0pXCI7XG5jb25zdCBQQ1RfRU5DT0RFRCQgPSBcIig/OlxcXFwlWzAtOUEtRmEtZl17Mn0pXCI7XG5jb25zdCBUUkFOUyQkID0gXCJbMC05QS1aYS16XFxcXChcXFxcKVxcXFwrXFxcXCxcXFxcLVxcXFwuXFxcXDpcXFxcPVxcXFxAXFxcXDtcXFxcJFxcXFxfXFxcXCFcXFxcKlxcXFwnXFxcXC9cXFxcP1xcXFwjXVwiO1xuY29uc3QgTlNTJCA9IFwiKD86KD86XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFRSQU5TJCQgKyBcIikrKVwiO1xuY29uc3QgVVJOX1NDSEVNRSA9IG5ldyBSZWdFeHAoXCJedXJuXFxcXDooXCIgKyBOSUQkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVRIID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBOSUQkICsgXCIpXFxcXDooXCIgKyBOU1MkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG5jb25zdCBVUk5fRVhDTFVERUQgPSAvW1xceDAwLVxceDIwXFxcXFxcXCJcXCZcXDxcXD5cXFtcXF1cXF5cXGBcXHtcXHxcXH1cXH5cXHg3Ri1cXHhGRl0vZztcblxuLy9SRkMgMjE0MVxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVSTkNvbXBvbmVudHMsVVJOT3B0aW9ucz4gPSB7XG5cdHNjaGVtZSA6IFwidXJuXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG5cdFx0bGV0IHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIFVSTkNvbXBvbmVudHM7XG5cblx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0Y29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcblx0XHRcdGNvbnN0IG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvbnN0IG5zcyA9IG1hdGNoZXNbMl07XG5cdFx0XHRjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWA7XG5cdFx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuXG5cdFx0XHR1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcblx0XHRcdHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuXHRcdFx0dXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0XHR1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSBhcyBVUk5Db21wb25lbnRzO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJuQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAodXJuQ29tcG9uZW50czpVUk5Db21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG5cdFx0Y29uc3QgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG5cdFx0Y29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gO1xuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG5cblx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0dXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHMgYXMgVVJJQ29tcG9uZW50cztcblx0XHRjb25zdCBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcblx0XHR1cmlDb21wb25lbnRzLnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWA7XG5cblx0XHRyZXR1cm4gdXJpQ29tcG9uZW50cztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwgImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBwY3RFbmNDaGFyLCBwY3REZWNDaGFycywgdW5lc2NhcGVDb21wb25lbnQgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgcHVueWNvZGUgZnJvbSBcInB1bnljb2RlXCI7XG5pbXBvcnQgeyBtZXJnZSwgc3ViZXhwLCB0b1VwcGVyQ2FzZSwgdG9BcnJheSB9IGZyb20gXCIuLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFpbHRvSGVhZGVycyB7XG5cdFtoZm5hbWU6c3RyaW5nXTpzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYWlsdG9Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdHRvOkFycmF5PHN0cmluZz4sXG5cdGhlYWRlcnM/Ok1haWx0b0hlYWRlcnMsXG5cdHN1YmplY3Q/OnN0cmluZyxcblx0Ym9keT86c3RyaW5nXG59XG5cbmNvbnN0IE86TWFpbHRvSGVhZGVycyA9IHt9O1xuY29uc3QgaXNJUkkgPSB0cnVlO1xuXG4vL1JGQyAzOTg2XG5jb25zdCBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG5jb25zdCBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuY29uc3QgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAgLy9leHBhbmRlZFxuXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG5jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbmNvbnN0IFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbmNvbnN0IFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbmNvbnN0IERPVF9BVE9NX1RFWFQkID0gc3ViZXhwKEFURVhUJCQgKyBcIitcIiArIHN1YmV4cChcIlxcXFwuXCIgKyBBVEVYVCQkICsgXCIrXCIpICsgXCIqXCIpO1xuY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIFZDSEFSJCQpO1xuY29uc3QgUUNPTlRFTlQkID0gc3ViZXhwKFFURVhUJCQgKyBcInxcIiArIFFVT1RFRF9QQUlSJCk7XG5jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIFFDT05URU5UJCArIFwiKlwiICsgJ1xcXFxcIicpO1xuXG4vL1JGQyA2MDY4XG5jb25zdCBEVEVYVF9OT19PQlMkJCA9IFwiW1xcXFx4MjEtXFxcXHg1QVxcXFx4NUUtXFxcXHg3RV1cIjsgIC8vJWQzMy05MCAvICVkOTQtMTI2XG5jb25zdCBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbmNvbnN0IFFDSEFSJCA9IHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCArIFwifFwiICsgU09NRV9ERUxJTVMkJCk7XG5jb25zdCBET01BSU4kID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBcIlxcXFxbXCIgKyBEVEVYVF9OT19PQlMkJCArIFwiKlwiICsgXCJcXFxcXVwiKTtcbmNvbnN0IExPQ0FMX1BBUlQkID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBRVU9URURfU1RSSU5HJCk7XG5jb25zdCBBRERSX1NQRUMkID0gc3ViZXhwKExPQ0FMX1BBUlQkICsgXCJcXFxcQFwiICsgRE9NQUlOJCk7XG5jb25zdCBUTyQgPSBzdWJleHAoQUREUl9TUEVDJCArIHN1YmV4cChcIlxcXFwsXCIgKyBBRERSX1NQRUMkKSArIFwiKlwiKTtcbmNvbnN0IEhGTkFNRSQgPSBzdWJleHAoUUNIQVIkICsgXCIqXCIpO1xuY29uc3QgSEZWQUxVRSQgPSBIRk5BTUUkO1xuY29uc3QgSEZJRUxEJCA9IHN1YmV4cChIRk5BTUUkICsgXCJcXFxcPVwiICsgSEZWQUxVRSQpO1xuY29uc3QgSEZJRUxEUzIkID0gc3ViZXhwKEhGSUVMRCQgKyBzdWJleHAoXCJcXFxcJlwiICsgSEZJRUxEJCkgKyBcIipcIik7XG5jb25zdCBIRklFTERTJCA9IHN1YmV4cChcIlxcXFw/XCIgKyBIRklFTERTMiQpO1xuY29uc3QgTUFJTFRPX1VSSSA9IG5ldyBSZWdFeHAoXCJebWFpbHRvXFxcXDpcIiArIFRPJCArIFwiP1wiICsgSEZJRUxEUyQgKyBcIj8kXCIpO1xuXG5jb25zdCBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbmNvbnN0IFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbmNvbnN0IE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbmNvbnN0IE5PVF9ET01BSU4gPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCBcIltcXFxcW11cIiwgRFRFWFRfTk9fT0JTJCQsIFwiW1xcXFxdXVwiKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuY29uc3QgVE8gPSBuZXcgUmVnRXhwKFwiXlwiICsgVE8kICsgXCIkXCIpO1xuY29uc3QgSEZJRUxEUyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIRklFTERTMiQgKyBcIiRcIik7XG5cbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcblx0cmV0dXJuICghZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcbn1cblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPE1haWx0b0NvbXBvbmVudHM+ID0gIHtcblx0c2NoZW1lIDogXCJtYWlsdG9cIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6TWFpbHRvQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgTWFpbHRvQ29tcG9uZW50cztcblx0XHRjb25zdCB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSAobWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdKTtcblx0XHRtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuXHRcdFx0bGV0IHVua25vd25IZWFkZXJzID0gZmFsc2Vcblx0XHRcdGNvbnN0IGhlYWRlcnM6TWFpbHRvSGVhZGVycyA9IHt9O1xuXHRcdFx0Y29uc3QgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuXG5cdFx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0Y29uc3QgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG5cblx0XHRcdFx0c3dpdGNoIChoZmllbGRbMF0pIHtcblx0XHRcdFx0XHRjYXNlIFwidG9cIjpcblx0XHRcdFx0XHRcdGNvbnN0IHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG9BZGRycy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdHRvLnB1c2godG9BZGRyc1t4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic3ViamVjdFwiOlxuXHRcdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJib2R5XCI6XG5cdFx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHVua25vd25IZWFkZXJzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdH1cblxuXHRcdG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG5cblx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRjb25zdCBhZGRyID0gdG9beF0uc3BsaXQoXCJAXCIpO1xuXG5cdFx0XHRhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG5cblx0XHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRvW3hdID0gYWRkci5qb2luKFwiQFwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAobWFpbHRvQ29tcG9uZW50czpNYWlsdG9Db21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzIGFzIFVSSUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuXHRcdGlmICh0bykge1xuXHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRjb25zdCB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuXHRcdFx0XHRjb25zdCBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG5cdFx0XHRcdGNvbnN0IGxvY2FsUGFydCA9ICh0b0FkZHIuc2xpY2UoMCwgYXRJZHgpKS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG5cdFx0XHRcdGxldCBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcblxuXHRcdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRvbWFpbiA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcblxuXHRcdGNvbnN0IGZpZWxkcyA9IFtdO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBoZWFkZXJzKSB7XG5cdFx0XHRpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuXHRcdFx0XHRmaWVsZHMucHVzaChcblx0XHRcdFx0XHRuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICtcblx0XHRcdFx0XHRcIj1cIiArXG5cdFx0XHRcdFx0aGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcilcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZpZWxkcy5sZW5ndGgpIHtcblx0XHRcdGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB3cyBmcm9tIFwiLi93c1wiO1xuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwid3NzXCIsXG5cdGRvbWFpbkhvc3QgOiB3cy5kb21haW5Ib3N0LFxuXHRwYXJzZSA6IHdzLnBhcnNlLFxuXHRzZXJpYWxpemUgOiB3cy5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXU0NvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzIHtcblx0cmVzb3VyY2VOYW1lPzogc3RyaW5nO1xuXHRzZWN1cmU/OiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHM6V1NDb21wb25lbnRzKTpib29sZWFuIHtcblx0cmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicgPyB3c0NvbXBvbmVudHMuc2VjdXJlIDogU3RyaW5nKHdzQ29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwid3NzXCI7XG59XG5cbi8vUkZDIDY0NTVcbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlciA9IHtcblx0c2NoZW1lIDogXCJ3c1wiLFxuXG5cdGRvbWFpbkhvc3QgOiB0cnVlLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpXU0NvbXBvbmVudHMge1xuXHRcdGNvbnN0IHdzQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgV1NDb21wb25lbnRzO1xuXG5cdFx0Ly9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG5cdFx0d3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG5cblx0XHQvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcblx0XHR3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuXHRcdHdzQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXHRcdHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcblxuXHRcdHJldHVybiB3c0NvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKHdzQ29tcG9uZW50czpXU0NvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuXHRcdGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcblx0XHRcdHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG5cdFx0aWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdHdzQ29tcG9uZW50cy5zY2hlbWUgPSAod3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJyk7XG5cdFx0XHR3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcblx0XHRpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuXHRcdFx0Y29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKTtcblx0XHRcdHdzQ29tcG9uZW50cy5wYXRoID0gKHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZCk7XG5cdFx0XHR3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcblx0XHRcdHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG5cdFx0d3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuXG5cdFx0cmV0dXJuIHdzQ29tcG9uZW50cztcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCBodHRwIGZyb20gXCIuL2h0dHBcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBzXCIsXG5cdGRvbWFpbkhvc3QgOiBodHRwLmRvbWFpbkhvc3QsXG5cdHBhcnNlIDogaHR0cC5wYXJzZSxcblx0c2VyaWFsaXplIDogaHR0cC5zZXJpYWxpemVcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCAiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBcIixcblxuXHRkb21haW5Ib3N0IDogdHJ1ZSxcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9yZXBvcnQgbWlzc2luZyBob3N0XG5cdFx0aWYgKCFjb21wb25lbnRzLmhvc3QpIHtcblx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHRjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcblxuXHRcdC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcblx0XHRpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRcblx0XHQvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuXHRcdGlmICghY29tcG9uZW50cy5wYXRoKSB7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcblx0XHR9XG5cblx0XHQvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcblx0XHQvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuXHRcdC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwgIi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMSBHYXJ5IENvdXJ0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZVxuICogcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAqICAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICogICAgICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAqICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEdBUlkgQ09VUlQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR0FSWSBDT1VSVCBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uIGFyZSB0aG9zZSBvZiB0aGVcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXG4gKiBvciBpbXBsaWVkLCBvZiBHYXJ5IENvdXJ0LlxuICovXG5cbmltcG9ydCBVUklfUFJPVE9DT0wgZnJvbSBcIi4vcmVnZXhwcy11cmlcIjtcbmltcG9ydCBJUklfUFJPVE9DT0wgZnJvbSBcIi4vcmVnZXhwcy1pcmlcIjtcbmltcG9ydCBwdW55Y29kZSBmcm9tIFwicHVueWNvZGVcIjtcbmltcG9ydCB7IHRvVXBwZXJDYXNlLCB0eXBlT2YsIGFzc2lnbiB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUklDb21wb25lbnRzIHtcblx0c2NoZW1lPzpzdHJpbmc7XG5cdHVzZXJpbmZvPzpzdHJpbmc7XG5cdGhvc3Q/OnN0cmluZztcblx0cG9ydD86bnVtYmVyfHN0cmluZztcblx0cGF0aD86c3RyaW5nO1xuXHRxdWVyeT86c3RyaW5nO1xuXHRmcmFnbWVudD86c3RyaW5nO1xuXHRyZWZlcmVuY2U/OnN0cmluZztcblx0ZXJyb3I/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUklPcHRpb25zIHtcblx0c2NoZW1lPzpzdHJpbmc7XG5cdHJlZmVyZW5jZT86c3RyaW5nO1xuXHR0b2xlcmFudD86Ym9vbGVhbjtcblx0YWJzb2x1dGVQYXRoPzpib29sZWFuO1xuXHRpcmk/OmJvb2xlYW47XG5cdHVuaWNvZGVTdXBwb3J0Pzpib29sZWFuO1xuXHRkb21haW5Ib3N0Pzpib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSVNjaGVtZUhhbmRsZXI8Q29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMgPSBVUklDb21wb25lbnRzLCBPcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyA9IFVSSU9wdGlvbnMsIFBhcmVudENvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzID0gVVJJQ29tcG9uZW50cz4ge1xuXHRzY2hlbWU6c3RyaW5nO1xuXHRwYXJzZShjb21wb25lbnRzOlBhcmVudENvbXBvbmVudHMsIG9wdGlvbnM6T3B0aW9ucyk6Q29tcG9uZW50cztcblx0c2VyaWFsaXplKGNvbXBvbmVudHM6Q29tcG9uZW50cywgb3B0aW9uczpPcHRpb25zKTpQYXJlbnRDb21wb25lbnRzO1xuXHR1bmljb2RlU3VwcG9ydD86Ym9vbGVhbjtcblx0ZG9tYWluSG9zdD86Ym9vbGVhbjtcblx0YWJzb2x1dGVQYXRoPzpib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSVJlZ0V4cHMge1xuXHROT1RfU0NIRU1FIDogUmVnRXhwLFxuXHROT1RfVVNFUklORk8gOiBSZWdFeHAsXG5cdE5PVF9IT1NUIDogUmVnRXhwLFxuXHROT1RfUEFUSCA6IFJlZ0V4cCxcblx0Tk9UX1BBVEhfTk9TQ0hFTUUgOiBSZWdFeHAsXG5cdE5PVF9RVUVSWSA6IFJlZ0V4cCxcblx0Tk9UX0ZSQUdNRU5UIDogUmVnRXhwLFxuXHRFU0NBUEUgOiBSZWdFeHAsXG5cdFVOUkVTRVJWRUQgOiBSZWdFeHAsXG5cdE9USEVSX0NIQVJTIDogUmVnRXhwLFxuXHRQQ1RfRU5DT0RFRCA6IFJlZ0V4cCxcblx0SVBWNEFERFJFU1MgOiBSZWdFeHAsXG5cdElQVjZBRERSRVNTIDogUmVnRXhwLFxufVxuXG5leHBvcnQgY29uc3QgU0NIRU1FUzp7W3NjaGVtZTpzdHJpbmddOlVSSVNjaGVtZUhhbmRsZXJ9ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBwY3RFbmNDaGFyKGNocjpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcblx0bGV0IGU6c3RyaW5nO1xuXG5cdGlmIChjIDwgMTYpIGUgPSBcIiUwXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKChjID4+IDYpIHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKChjICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ZWxzZSBlID0gXCIlXCIgKyAoKGMgPj4gMTIpIHwgMjI0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArICgoYyAmIDYzKSB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cblx0cmV0dXJuIGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwY3REZWNDaGFycyhzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRsZXQgbmV3U3RyID0gXCJcIjtcblx0bGV0IGkgPSAwO1xuXHRjb25zdCBpbCA9IHN0ci5sZW5ndGg7XG5cblx0d2hpbGUgKGkgPCBpbCkge1xuXHRcdGNvbnN0IGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuXG5cdFx0aWYgKGMgPCAxMjgpIHtcblx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuXHRcdFx0aSArPSAzO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG5cdFx0XHRpZiAoKGlsIC0gaSkgPj0gNikge1xuXHRcdFx0XHRjb25zdCBjMiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG5cdFx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcblx0XHRcdH1cblx0XHRcdGkgKz0gNjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoYyA+PSAyMjQpIHtcblx0XHRcdGlmICgoaWwgLSBpKSA+PSA5KSB7XG5cdFx0XHRcdGNvbnN0IGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcblx0XHRcdFx0Y29uc3QgYzMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA3LCAyKSwgMTYpO1xuXHRcdFx0XHRuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcblx0XHRcdH1cblx0XHRcdGkgKz0gOTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcblx0XHRcdGkgKz0gMztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3U3RyO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBwcm90b2NvbDpVUklSZWdFeHBzKSB7XG5cdGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0XHRjb25zdCBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuXHRcdHJldHVybiAoIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cik7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5zY2hlbWUpIGNvbXBvbmVudHMuc2NoZW1lID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG5cdGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnBhdGggPSBTdHJpbmcoY29tcG9uZW50cy5wYXRoKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKChjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUpLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cdGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucXVlcnkgPSBTdHJpbmcoY29tcG9uZW50cy5xdWVyeSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXG5cdHJldHVybiBjb21wb25lbnRzO1xufTtcblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3Q6c3RyaW5nLCBwcm90b2NvbDpVUklSZWdFeHBzKTpzdHJpbmcge1xuXHRjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cdGNvbnN0IFssIGFkZHJlc3NdID0gbWF0Y2hlcztcblx0XG5cdGlmIChhZGRyZXNzKSB7XG5cdFx0cmV0dXJuIGFkZHJlc3Muc3BsaXQoXCIuXCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpLmpvaW4oXCIuXCIpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBob3N0O1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY2KGhvc3Q6c3RyaW5nLCBwcm90b2NvbDpVUklSZWdFeHBzKTpzdHJpbmcge1xuXHRjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cdGNvbnN0IFssIGFkZHJlc3MsIHpvbmVdID0gbWF0Y2hlcztcblxuXHRpZiAoYWRkcmVzcykge1xuXHRcdGNvbnN0IFtsYXN0LCBmaXJzdF0gPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpO1xuXHRcdGNvbnN0IGZpcnN0RmllbGRzID0gZmlyc3QgPyBmaXJzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykgOiBbXTtcblx0XHRjb25zdCBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG5cdFx0Y29uc3QgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcblx0XHRjb25zdCBmaWVsZENvdW50ID0gaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA/IDcgOiA4O1xuXHRcdGNvbnN0IGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcblx0XHRjb25zdCBmaWVsZHMgPSBBcnJheTxzdHJpbmc+KGZpZWxkQ291bnQpO1xuXG5cdFx0Zm9yIChsZXQgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcblx0XHRcdGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG5cdFx0fVxuXG5cdFx0aWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcblx0XHRcdGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2U8QXJyYXk8e2luZGV4Om51bWJlcixsZW5ndGg6bnVtYmVyfT4+KChhY2MsIGZpZWxkLCBpbmRleCkgPT4ge1xuXHRcdFx0aWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcblx0XHRcdFx0Y29uc3QgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAobGFzdExvbmdlc3QgJiYgbGFzdExvbmdlc3QuaW5kZXggKyBsYXN0TG9uZ2VzdC5sZW5ndGggPT09IGluZGV4KSB7XG5cdFx0XHRcdFx0bGFzdExvbmdlc3QubGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWNjLnB1c2goeyBpbmRleCwgbGVuZ3RoIDogMSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCBbXSk7XG5cblx0XHRjb25zdCBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClbMF07XG5cblx0XHRsZXQgbmV3SG9zdDpzdHJpbmc7XG5cdFx0aWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGNvbnN0IG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KSA7XG5cdFx0XHRjb25zdCBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcblx0XHRcdG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0hvc3QgPSBmaWVsZHMuam9pbihcIjpcIik7XG5cdFx0fVxuXG5cdFx0aWYgKHpvbmUpIHtcblx0XHRcdG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdIb3N0O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBob3N0O1xuXHR9XG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xuY29uc3QgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gKDxSZWdFeHBNYXRjaEFycmF5PihcIlwiKS5tYXRjaCgvKCl7MH0vKSlbMV0gPT09IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZzpzdHJpbmcsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9KTpVUklDb21wb25lbnRzIHtcblx0Y29uc3QgY29tcG9uZW50czpVUklDb21wb25lbnRzID0ge307XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cblx0aWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG5cblx0Y29uc3QgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0UpO1xuXG5cdGlmIChtYXRjaGVzKSB7XG5cdFx0aWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuXHRcdFx0Ly9zdG9yZSBlYWNoIGNvbXBvbmVudFxuXHRcdFx0Y29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuXHRcdFx0Y29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG5cdFx0XHRjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG5cdFx0XHRjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcblxuXHRcdFx0Ly9maXggcG9ydCBudW1iZXJcblx0XHRcdGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcblx0XHRcdC8vc3RvcmUgZWFjaCBjb21wb25lbnRcblx0XHRcdGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRjb21wb25lbnRzLnVzZXJpbmZvID0gKHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9ICh1cmlTdHJpbmcuaW5kZXhPZihcIj9cIikgIT09IC0xID8gbWF0Y2hlc1s3XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLmZyYWdtZW50ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkKTtcblxuXHRcdFx0Ly9maXggcG9ydCBudW1iZXJcblx0XHRcdGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMucG9ydCA9ICh1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNvbXBvbmVudHMuaG9zdCkge1xuXHRcdFx0Ly9ub3JtYWxpemUgSVAgaG9zdHNcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Ly9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcblx0XHRpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG5cdFx0fSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwicmVsYXRpdmVcIjtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcblx0XHR9XG5cblx0XHQvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG5cdFx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBjb21wb25lbnRzLnJlZmVyZW5jZSkge1xuXHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgaXMgbm90IGEgXCIgKyBvcHRpb25zLnJlZmVyZW5jZSArIFwiIHJlZmVyZW5jZS5cIjtcblx0XHR9XG5cblx0XHQvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcblx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG5cblx0XHQvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuXHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG5cdFx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcblx0XHRcdGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vY29udmVydCBJUkkgLT4gVVJJXG5cdFx0XHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9ub3JtYWxpemUgZW5jb2RpbmdzXG5cdFx0XHRfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuXHRcdH1cblxuXHRcdC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuXHRcdGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcblx0XHRcdHNjaGVtZUhhbmRsZXIucGFyc2UoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuXHR9XG5cblx0cmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpzdHJpbmd8dW5kZWZpbmVkIHtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblx0Y29uc3QgdXJpVG9rZW5zOkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHRpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCJAXCIpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly9ub3JtYWxpemUgSVAgaG9zdHMsIGFkZCBicmFja2V0cyBhbmQgZXNjYXBlIHpvbmUgc2VwYXJhdG9yIGZvciBJUHY2XG5cdFx0dXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIChfLCAkMSwgJDIpID0+IFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiKSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKTtcblx0fVxuXG5cdHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBSRFMxID0gL15cXC5cXC4/XFwvLztcbmNvbnN0IFJEUzIgPSAvXlxcL1xcLihcXC98JCkvO1xuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG5jb25zdCBSRFM0ID0gL15cXC5cXC4/JC87XG5jb25zdCBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQ6c3RyaW5nKTpzdHJpbmcge1xuXHRjb25zdCBvdXRwdXQ6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcblx0XHRpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgXCIvXCIpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG5cdFx0XHRvdXRwdXQucG9wKCk7XG5cdFx0fSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuXHRcdFx0aW5wdXQgPSBcIlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuXHRcdFx0aWYgKGltKSB7XG5cdFx0XHRcdGNvbnN0IHMgPSBpbVswXTtcblx0XHRcdFx0aW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aCk7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyA9IHt9KTpzdHJpbmcge1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTCk7XG5cdGNvbnN0IHVyaVRva2VuczpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0Ly9maW5kIHNjaGVtZSBoYW5kbGVyXG5cdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcblxuXHQvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cblx0aWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuXG5cdGlmIChjb21wb25lbnRzLmhvc3QpIHtcblx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGFuIElQdjYgYWRkcmVzc1xuXHRcdGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHtcblx0XHRcdC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblx0XHR9XG5cblx0XHQvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcblx0XHRlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuXHRcdFx0Ly9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBvbmVudHMuaG9zdCA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vbm9ybWFsaXplIGVuY29kaW5nXG5cdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG5cblx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUpO1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcblx0fVxuXG5cdGNvbnN0IGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cdGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuXHRcdFx0dXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcblx0XHR9XG5cblx0XHR1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuXG5cdFx0aWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuXHRcdFx0dXJpVG9rZW5zLnB1c2goXCIvXCIpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdGxldCBzID0gY29tcG9uZW50cy5wYXRoO1xuXG5cdFx0aWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuXHRcdFx0cyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuXHRcdH1cblxuXHRcdGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cyA9IHMucmVwbGFjZSgvXlxcL1xcLy8sIFwiLyUyRlwiKTsgIC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcblx0XHR9XG5cblx0XHR1cmlUb2tlbnMucHVzaChzKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIj9cIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCIjXCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuXHR9XG5cblx0cmV0dXJuIHVyaVRva2Vucy5qb2luKFwiXCIpOyAgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2U6VVJJQ29tcG9uZW50cywgcmVsYXRpdmU6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zID0ge30sIHNraXBOb3JtYWxpemF0aW9uPzpib29sZWFuKTpVUklDb21wb25lbnRzIHtcblx0Y29uc3QgdGFyZ2V0OlVSSUNvbXBvbmVudHMgPSB7fTtcblxuXHRpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG5cdFx0YmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7ICAvL25vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcblx0XHRyZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAgLy9ub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuXHR9XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcblx0XHR0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuXHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcblx0XHR0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcblx0XHR0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG5cdFx0dGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuXHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcblx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0fSBlbHNlIHtcblx0XHRpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG5cdFx0XHR0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcblx0XHRcdHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcblx0XHRcdHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcblx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcblx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXJlbGF0aXZlLnBhdGgpIHtcblx0XHRcdFx0dGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG5cdFx0XHRcdGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuXHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxhdGl2ZS5wYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHRcdH1cblx0XHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuXHRcdFx0dGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mbztcblx0XHRcdHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0O1xuXHRcdFx0dGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnQ7XG5cdFx0fVxuXHRcdHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcblx0fVxuXG5cdHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJOnN0cmluZywgcmVsYXRpdmVVUkk6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZSA6ICdudWxsJyB9LCBvcHRpb25zKTtcblx0cmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKSwgc2NoZW1lbGVzc09wdGlvbnMpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTpVUklDb21wb25lbnRzLCBvcHRpb25zPzpVUklPcHRpb25zKTpVUklDb21wb25lbnRzO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6YW55LCBvcHRpb25zPzpVUklPcHRpb25zKTphbnkge1xuXHRpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB1cmk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWwodXJpQTpzdHJpbmcsIHVyaUI6c3RyaW5nLCBvcHRpb25zPzogVVJJT3B0aW9ucyk6Ym9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOlVSSUNvbXBvbmVudHMsIHVyaUI6VVJJQ29tcG9uZW50cywgb3B0aW9ucz86VVJJT3B0aW9ucyk6Ym9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOmFueSwgdXJpQjphbnksIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmJvb2xlYW4ge1xuXHRpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmlBID0gc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaUEsIG9wdGlvbnMpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG5cdH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpQiA9IHNlcmlhbGl6ZSg8VVJJQ29tcG9uZW50cz51cmlCLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB1cmlBID09PSB1cmlCO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHI6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFKSwgcGN0RW5jQ2hhcik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyOnN0cmluZywgb3B0aW9ucz86VVJJT3B0aW9ucyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCghb3B0aW9ucyB8fCAhb3B0aW9ucy5pcmkgPyBVUklfUFJPVE9DT0wuUENUX0VOQ09ERUQgOiBJUklfUFJPVE9DT0wuUENUX0VOQ09ERUQpLCBwY3REZWNDaGFycyk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbmNvbnN0IGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0Y29uc3QgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0bGV0IHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0Y29uc3QgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdGNvbnN0IGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cdGxldCBjb3VudGVyID0gMDtcblx0Y29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdGNvbnN0IGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG5jb25zdCB1Y3MyZW5jb2RlID0gYXJyYXkgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uYXJyYXkpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuY29uc3QgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0bGV0IGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0bGV0IGkgPSAwO1xuXHRsZXQgbiA9IGluaXRpYWxOO1xuXHRsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yIChsZXQgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0bGV0IG9sZGkgPSBpO1xuXHRcdGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdGNvbnN0IHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRjb25zdCBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdGxldCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGRlbHRhID0gMDtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0bGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0bGV0IG0gPSBtYXhJbnQ7XG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRsZXQgcSA9IGRlbHRhO1xuXHRcdFx0XHRmb3IgKGxldCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbmNvbnN0IHRvVW5pY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG5jb25zdCB0b0FTQ0lJID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuY29uc3QgcHVueWNvZGUgPSB7XG5cdC8qKlxuXHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG5cdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHB1bnljb2RlO1xuIiwgImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IGJ1aWxkRXhwcyB9IGZyb20gXCIuL3JlZ2V4cHMtdXJpXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyh0cnVlKTtcbiIsICJpbXBvcnQgeyBVUklSZWdFeHBzIH0gZnJvbSBcIi4vdXJpXCI7XG5pbXBvcnQgeyBtZXJnZSwgc3ViZXhwIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJOmJvb2xlYW4pOlVSSVJlZ0V4cHMge1xuXHRjb25zdFxuXHRcdEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG5cdFx0Q1IkID0gXCJbXFxcXHgwRF1cIixcblx0XHRESUdJVCQkID0gXCJbMC05XVwiLFxuXHRcdERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcblx0XHRIRVhESUckJCA9IG1lcmdlKERJR0lUJCQsIFwiW0EtRmEtZl1cIiksICAvL2Nhc2UtaW5zZW5zaXRpdmVcblx0XHRMRiQkID0gXCJbXFxcXHgwQV1cIixcblx0XHRTUCQkID0gXCJbXFxcXHgyMF1cIixcblx0XHRQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksICAvL2V4cGFuZGVkXG5cdFx0R0VOX0RFTElNUyQkID0gXCJbXFxcXDpcXFxcL1xcXFw/XFxcXCNcXFxcW1xcXFxdXFxcXEBdXCIsXG5cdFx0U1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcblx0XHRSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuXHRcdFVDU0NIQVIkJCA9IGlzSVJJID8gXCJbXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXVwiIDogXCJbXVwiLCAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG5cdFx0SVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIiwgIC8vc3Vic2V0XG5cdFx0VU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG5cdFx0U0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcblx0XHRVU0VSSU5GTyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSkgKyBcIipcIiksXG5cdFx0REVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG5cdFx0REVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSwgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdFx0SVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG5cdFx0SDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG5cdFx0TFMzMiQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIgKyBIMTYkKSArIFwifFwiICsgSVBWNEFERFJFU1MkKSxcblx0XHRJUFY2QUREUkVTUzEkID0gc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTMiQgPSBzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NX1cIiArIExTMzIkKSwgLy8gICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzMkID0gc3ViZXhwKHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezR9XCIgKyBMUzMyJCksIC8vWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1M0JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwxfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInszfVwiICsgTFMzMiQpLCAvL1sgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1M1JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwyfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInsyfVwiICsgTFMzMiQpLCAvL1sgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1M2JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwzfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyAgICAgICAgSDE2JCArIFwiXFxcXDpcIiAgICAgICAgICArIExTMzIkKSwgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuXHRcdElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIExTMzIkKSwgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcblx0XHRJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBIMTYkICksIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcblx0XHRJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG5cdFx0SVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG5cdFx0Wk9ORUlEJCA9IHN1YmV4cChzdWJleHAoVU5SRVNFUlZFRCQkICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQpICsgXCIrXCIpLCAgLy9SRkMgNjg3NFxuXHRcdElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSwgIC8vUkZDIDY4NzRcblx0XHRJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSwgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdFx0SVBWRlVUVVJFJCA9IHN1YmV4cChcIlt2Vl1cIiArIEhFWERJRyQkICsgXCIrXFxcXC5cIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikgKyBcIitcIiksXG5cdFx0SVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksICAvL1JGQyA2ODc0XG5cdFx0UkVHX05BTUUkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSkgKyBcIipcIiksXG5cdFx0SE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcblx0XHRQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuXHRcdEFVVEhPUklUWSQgPSBzdWJleHAoc3ViZXhwKFVTRVJJTkZPJCArIFwiQFwiKSArIFwiP1wiICsgSE9TVCQgKyBzdWJleHAoXCJcXFxcOlwiICsgUE9SVCQpICsgXCI/XCIpLFxuXHRcdFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG5cdFx0U0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuXHRcdFNFR01FTlRfTlokID0gc3ViZXhwKFBDSEFSJCArIFwiK1wiKSxcblx0XHRTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcblx0XHRQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG5cdFx0UEFUSF9BQlNPTFVURSQgPSBzdWJleHAoXCJcXFxcL1wiICsgc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCkgKyBcIj9cIiksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfRU1QVFkkID0gXCIoPyFcIiArIFBDSEFSJCArIFwiKVwiLFxuXHRcdFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuXHRcdEZSQUdNRU5UJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8W1xcXFwvXFxcXD9dXCIpICsgXCIqXCIpLFxuXHRcdEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuXHRcdFJFTEFUSVZFX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG5cdFx0UkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuXHRcdFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG5cdFx0QUJTT0xVVEVfVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIpLFxuXG5cdFx0R0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdFJFTEFUSVZFX1JFRiQgPSBcIl4oKXswfVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0U0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRBVVRIT1JJVFlfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/JFwiXG5cdDtcblxuXHRyZXR1cm4ge1xuXHRcdE5PVF9TQ0hFTUUgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcblx0XHROT1RfVVNFUklORk8gOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfSE9TVCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUEFUSCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUEFUSF9OT1NDSEVNRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX1FVRVJZIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcblx0XHROT1RfRlJBR01FTlQgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuXHRcdEVTQ0FQRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0VU5SRVNFUlZFRCA6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG5cdFx0T1RIRVJfQ0hBUlMgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuXHRcdFBDVF9FTkNPREVEIDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcblx0XHRJUFY0QUREUkVTUyA6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcblx0XHRJUFY2QUREUkVTUyA6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBidWlsZEV4cHMoZmFsc2UpO1xuIiwgImV4cG9ydCBmdW5jdGlvbiBtZXJnZSguLi5zZXRzOkFycmF5PHN0cmluZz4pOnN0cmluZyB7XG5cdGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcblx0XHRzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG5cdFx0Y29uc3QgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG5cdFx0Zm9yIChsZXQgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG5cdFx0fVxuXHRcdHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG5cdFx0cmV0dXJuIHNldHMuam9pbignJyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHNldHNbMF07XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmV4cChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRyZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZU9mKG86YW55KTpzdHJpbmcge1xuXHRyZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IChvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShvYmo6YW55KTpBcnJheTxhbnk+IHtcblx0cmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IChvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6ICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopKSkgOiBbXTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogb2JqZWN0LCBzb3VyY2U6IGFueSk6IGFueSB7XG5cdGNvbnN0IG9iaiA9IHRhcmdldCBhcyBhbnk7XG5cdGlmIChzb3VyY2UpIHtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdG9ialtrZXldID0gc291cmNlW2tleV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmo7XG59IiwgImltcG9ydCAqIGFzIHVyaSBmcm9tIFwidXJpLWpzXCJcblxudHlwZSBVUkkgPSB0eXBlb2YgdXJpICYge2NvZGU6IHN0cmluZ31cbjsodXJpIGFzIFVSSSkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCdcblxuZXhwb3J0IGRlZmF1bHQgdXJpIGFzIFVSSVxuIiwgImV4cG9ydCB7XG4gIEZvcm1hdCxcbiAgRm9ybWF0RGVmaW5pdGlvbixcbiAgQXN5bmNGb3JtYXREZWZpbml0aW9uLFxuICBLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBNYWNyb0tleXdvcmREZWZpbml0aW9uLFxuICBGdW5jS2V5d29yZERlZmluaXRpb24sXG4gIFZvY2FidWxhcnksXG4gIFNjaGVtYSxcbiAgU2NoZW1hT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFzeW5jU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEVycm9yTm9QYXJhbXMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4vY29tcGlsZVwiXG5leHBvcnQgaW50ZXJmYWNlIFBsdWdpbjxPcHRzPiB7XG4gIChhanY6IEFqdiwgb3B0aW9ucz86IE9wdHMpOiBBanZcbiAgW3Byb3A6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQge0tleXdvcmRDeHR9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGVcIlxuZXhwb3J0IHtEZWZpbmVkRXJyb3J9IGZyb20gXCIuL3ZvY2FidWxhcmllcy9lcnJvcnNcIlxuZXhwb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5leHBvcnQge0pTT05TY2hlbWFUeXBlfSBmcm9tIFwiLi90eXBlcy9qc29uLXNjaGVtYVwiXG5leHBvcnQge0pURFNjaGVtYVR5cGUsIFNvbWVKVERTY2hlbWFUeXBlLCBKVEREYXRhVHlwZX0gZnJvbSBcIi4vdHlwZXMvanRkLXNjaGVtYVwiXG5leHBvcnQge18sIHN0ciwgc3RyaW5naWZ5LCBuaWwsIE5hbWUsIENvZGUsIENvZGVHZW4sIENvZGVHZW5PcHRpb25zfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuXG5pbXBvcnQgdHlwZSB7XG4gIFNjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIFNjaGVtYU9iamVjdCxcbiAgQXN5bmNTY2hlbWEsXG4gIFZvY2FidWxhcnksXG4gIEtleXdvcmREZWZpbml0aW9uLFxuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBGb3JtYXQsXG4gIEFkZGVkRm9ybWF0LFxuICBSZWdFeHBFbmdpbmUsXG4gIFVyaVJlc29sdmVyLFxufSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7SlNPTlNjaGVtYVR5cGV9IGZyb20gXCIuL3R5cGVzL2pzb24tc2NoZW1hXCJcbmltcG9ydCB0eXBlIHtKVERTY2hlbWFUeXBlLCBTb21lSlREU2NoZW1hVHlwZSwgSlRERGF0YVR5cGV9IGZyb20gXCIuL3R5cGVzL2p0ZC1zY2hlbWFcIlxuaW1wb3J0IFZhbGlkYXRpb25FcnJvciBmcm9tIFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIlxuaW1wb3J0IE1pc3NpbmdSZWZFcnJvciBmcm9tIFwiLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge2dldFJ1bGVzLCBWYWxpZGF0aW9uUnVsZXMsIFJ1bGUsIFJ1bGVHcm91cCwgSlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuaW1wb3J0IHtTY2hlbWFFbnYsIGNvbXBpbGVTY2hlbWEsIHJlc29sdmVTY2hlbWF9IGZyb20gXCIuL2NvbXBpbGVcIlxuaW1wb3J0IHtDb2RlLCBWYWx1ZVNjb3BlfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHtub3JtYWxpemVJZCwgZ2V0U2NoZW1hUmVmc30gZnJvbSBcIi4vY29tcGlsZS9yZXNvbHZlXCJcbmltcG9ydCB7Z2V0SlNPTlR5cGVzfSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCJcbmltcG9ydCB7ZWFjaEl0ZW19IGZyb20gXCIuL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgKiBhcyAkZGF0YVJlZlNjaGVtYSBmcm9tIFwiLi9yZWZzL2RhdGEuanNvblwiXG5cbmltcG9ydCBEZWZhdWx0VXJpUmVzb2x2ZXIgZnJvbSBcIi4vcnVudGltZS91cmlcIlxuXG5jb25zdCBkZWZhdWx0UmVnRXhwOiBSZWdFeHBFbmdpbmUgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKVxuZGVmYXVsdFJlZ0V4cC5jb2RlID0gXCJuZXcgUmVnRXhwXCJcblxuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUzogKGtleW9mIE9wdGlvbnMpW10gPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXVxuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gIFwidmFsaWRhdGVcIixcbiAgXCJzZXJpYWxpemVcIixcbiAgXCJwYXJzZVwiLFxuICBcIndyYXBwZXJcIixcbiAgXCJyb290XCIsXG4gIFwic2NoZW1hXCIsXG4gIFwia2V5d29yZFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJmb3JtYXRzXCIsXG4gIFwidmFsaWRhdGUkZGF0YVwiLFxuICBcImZ1bmNcIixcbiAgXCJvYmpcIixcbiAgXCJFcnJvclwiLFxuXSlcblxuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IEN1cnJlbnRPcHRpb25zICYgRGVwcmVjYXRlZE9wdGlvbnNcblxuZXhwb3J0IGludGVyZmFjZSBDdXJyZW50T3B0aW9ucyB7XG4gIC8vIHN0cmljdCBtb2RlIG9wdGlvbnMgKE5FVylcbiAgc3RyaWN0PzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0U2NoZW1hPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0TnVtYmVycz86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdFR5cGVzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0VHVwbGVzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0UmVxdWlyZWQ/OiBib29sZWFuIHwgXCJsb2dcIlxuICBhbGxvd01hdGNoaW5nUHJvcGVydGllcz86IGJvb2xlYW4gLy8gZGlzYWJsZXMgYSBzdHJpY3QgbW9kZSByZXN0cmljdGlvblxuICBhbGxvd1VuaW9uVHlwZXM/OiBib29sZWFuXG4gIHZhbGlkYXRlRm9ybWF0cz86IGJvb2xlYW5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgcmVwb3J0aW5nIG9wdGlvbnM6XG4gICRkYXRhPzogYm9vbGVhblxuICBhbGxFcnJvcnM/OiBib29sZWFuXG4gIHZlcmJvc2U/OiBib29sZWFuXG4gIGRpc2NyaW1pbmF0b3I/OiBib29sZWFuXG4gIHVuaWNvZGVSZWdFeHA/OiBib29sZWFuXG4gIHRpbWVzdGFtcD86IFwic3RyaW5nXCIgfCBcImRhdGVcIiAvLyBKVEQgb25seVxuICBwYXJzZURhdGU/OiBib29sZWFuIC8vIEpURCBvbmx5XG4gIGFsbG93RGF0ZT86IGJvb2xlYW4gLy8gSlREIG9ubHlcbiAgJGNvbW1lbnQ/OlxuICAgIHwgdHJ1ZVxuICAgIHwgKChjb21tZW50OiBzdHJpbmcsIHNjaGVtYVBhdGg/OiBzdHJpbmcsIHJvb3RTY2hlbWE/OiBBbnlTY2hlbWFPYmplY3QpID0+IHVua25vd24pXG4gIGZvcm1hdHM/OiB7W05hbWUgaW4gc3RyaW5nXT86IEZvcm1hdH1cbiAga2V5d29yZHM/OiBWb2NhYnVsYXJ5XG4gIHNjaGVtYXM/OiBBbnlTY2hlbWFbXSB8IHtbS2V5IGluIHN0cmluZ10/OiBBbnlTY2hlbWF9XG4gIGxvZ2dlcj86IExvZ2dlciB8IGZhbHNlXG4gIGxvYWRTY2hlbWE/OiAodXJpOiBzdHJpbmcpID0+IFByb21pc2U8QW55U2NoZW1hT2JqZWN0PlxuICAvLyBvcHRpb25zIHRvIG1vZGlmeSB2YWxpZGF0ZWQgZGF0YTpcbiAgcmVtb3ZlQWRkaXRpb25hbD86IGJvb2xlYW4gfCBcImFsbFwiIHwgXCJmYWlsaW5nXCJcbiAgdXNlRGVmYXVsdHM/OiBib29sZWFuIHwgXCJlbXB0eVwiXG4gIGNvZXJjZVR5cGVzPzogYm9vbGVhbiB8IFwiYXJyYXlcIlxuICAvLyBhZHZhbmNlZCBvcHRpb25zOlxuICBuZXh0PzogYm9vbGVhbiAvLyBORVdcbiAgdW5ldmFsdWF0ZWQ/OiBib29sZWFuIC8vIE5FV1xuICBkeW5hbWljUmVmPzogYm9vbGVhbiAvLyBORVdcbiAgc2NoZW1hSWQ/OiBcImlkXCIgfCBcIiRpZFwiXG4gIGp0ZD86IGJvb2xlYW4gLy8gTkVXXG4gIG1ldGE/OiBTY2hlbWFPYmplY3QgfCBib29sZWFuXG4gIGRlZmF1bHRNZXRhPzogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0XG4gIHZhbGlkYXRlU2NoZW1hPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgYWRkVXNlZFNjaGVtYT86IGJvb2xlYW5cbiAgaW5saW5lUmVmcz86IGJvb2xlYW4gfCBudW1iZXJcbiAgcGFzc0NvbnRleHQ/OiBib29sZWFuXG4gIGxvb3BSZXF1aXJlZD86IG51bWJlclxuICBsb29wRW51bT86IG51bWJlciAvLyBORVdcbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbiAgbXVsdGlwbGVPZlByZWNpc2lvbj86IG51bWJlclxuICBpbnQzMnJhbmdlPzogYm9vbGVhbiAvLyBKVEQgb25seVxuICBtZXNzYWdlcz86IGJvb2xlYW5cbiAgY29kZT86IENvZGVPcHRpb25zIC8vIE5FV1xuICB1cmlSZXNvbHZlcj86IFVyaVJlc29sdmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZU9wdGlvbnMge1xuICBlczU/OiBib29sZWFuXG4gIGVzbT86IGJvb2xlYW5cbiAgbGluZXM/OiBib29sZWFuXG4gIG9wdGltaXplPzogYm9vbGVhbiB8IG51bWJlclxuICBmb3JtYXRzPzogQ29kZSAvLyBjb2RlIHRvIHJlcXVpcmUgKG9yIGNvbnN0cnVjdCkgbWFwIG9mIGF2YWlsYWJsZSBmb3JtYXRzIC0gZm9yIHN0YW5kYWxvbmUgY29kZVxuICBzb3VyY2U/OiBib29sZWFuXG4gIHByb2Nlc3M/OiAoY29kZTogc3RyaW5nLCBzY2hlbWE/OiBTY2hlbWFFbnYpID0+IHN0cmluZ1xuICByZWdFeHA/OiBSZWdFeHBFbmdpbmVcbn1cblxuaW50ZXJmYWNlIEluc3RhbmNlQ29kZU9wdGlvbnMgZXh0ZW5kcyBDb2RlT3B0aW9ucyB7XG4gIHJlZ0V4cDogUmVnRXhwRW5naW5lXG4gIG9wdGltaXplOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIERlcHJlY2F0ZWRPcHRpb25zIHtcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGlnbm9yZUtleXdvcmRzV2l0aFJlZj86IGJvb2xlYW5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGpzUHJvcGVydHlTeW50YXg/OiBib29sZWFuIC8vIGFkZGVkIGluc3RlYWQgb2YganNvblBvaW50ZXJzXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICB1bmljb2RlPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgUmVtb3ZlZE9wdGlvbnMge1xuICBmb3JtYXQ/OiBib29sZWFuXG4gIGVycm9yRGF0YVBhdGg/OiBcIm9iamVjdFwiIHwgXCJwcm9wZXJ0eVwiXG4gIG51bGxhYmxlPzogYm9vbGVhbiAvLyBcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdFxuICBqc29uUG9pbnRlcnM/OiBib29sZWFuXG4gIGV4dGVuZFJlZnM/OiB0cnVlIHwgXCJpZ25vcmVcIiB8IFwiZmFpbFwiXG4gIG1pc3NpbmdSZWZzPzogdHJ1ZSB8IFwiaWdub3JlXCIgfCBcImZhaWxcIlxuICBwcm9jZXNzQ29kZT86IChjb2RlOiBzdHJpbmcsIHNjaGVtYT86IFNjaGVtYUVudikgPT4gc3RyaW5nXG4gIHNvdXJjZUNvZGU/OiBib29sZWFuXG4gIHN0cmljdERlZmF1bHRzPzogYm9vbGVhblxuICBzdHJpY3RLZXl3b3Jkcz86IGJvb2xlYW5cbiAgdW5pcXVlSXRlbXM/OiBib29sZWFuXG4gIHVua25vd25Gb3JtYXRzPzogdHJ1ZSB8IHN0cmluZ1tdIHwgXCJpZ25vcmVcIlxuICBjYWNoZT86IGFueVxuICBzZXJpYWxpemU/OiAoc2NoZW1hOiBBbnlTY2hlbWEpID0+IHVua25vd25cbiAgYWp2RXJyb3JzPzogYm9vbGVhblxufVxuXG50eXBlIE9wdGlvbnNJbmZvPFQgZXh0ZW5kcyBSZW1vdmVkT3B0aW9ucyB8IERlcHJlY2F0ZWRPcHRpb25zPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmNvbnN0IHJlbW92ZWRPcHRpb25zOiBPcHRpb25zSW5mbzxSZW1vdmVkT3B0aW9ucz4gPSB7XG4gIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufVxuXG5jb25zdCBkZXByZWNhdGVkT3B0aW9uczogT3B0aW9uc0luZm88RGVwcmVjYXRlZE9wdGlvbnM+ID0ge1xuICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn1cblxudHlwZSBSZXF1aXJlZEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgW0sgaW5cbiAgICB8IFwic3RyaWN0U2NoZW1hXCJcbiAgICB8IFwic3RyaWN0TnVtYmVyc1wiXG4gICAgfCBcInN0cmljdFR5cGVzXCJcbiAgICB8IFwic3RyaWN0VHVwbGVzXCJcbiAgICB8IFwic3RyaWN0UmVxdWlyZWRcIlxuICAgIHwgXCJpbmxpbmVSZWZzXCJcbiAgICB8IFwibG9vcFJlcXVpcmVkXCJcbiAgICB8IFwibG9vcEVudW1cIlxuICAgIHwgXCJtZXRhXCJcbiAgICB8IFwibWVzc2FnZXNcIlxuICAgIHwgXCJzY2hlbWFJZFwiXG4gICAgfCBcImFkZFVzZWRTY2hlbWFcIlxuICAgIHwgXCJ2YWxpZGF0ZVNjaGVtYVwiXG4gICAgfCBcInZhbGlkYXRlRm9ybWF0c1wiXG4gICAgfCBcImludDMycmFuZ2VcIlxuICAgIHwgXCJ1bmljb2RlUmVnRXhwXCJcbiAgICB8IFwidXJpUmVzb2x2ZXJcIl06IE5vbk51bGxhYmxlPE9wdGlvbnNbS10+XG59ICYge2NvZGU6IEluc3RhbmNlQ29kZU9wdGlvbnN9XG5cbmV4cG9ydCB0eXBlIEluc3RhbmNlT3B0aW9ucyA9IE9wdGlvbnMgJiBSZXF1aXJlZEluc3RhbmNlT3B0aW9uc1xuXG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMFxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG86IE9wdGlvbnMpOiBSZXF1aXJlZEluc3RhbmNlT3B0aW9ucyB7XG4gIGNvbnN0IHMgPSBvLnN0cmljdFxuICBjb25zdCBfb3B0eiA9IG8uY29kZT8ub3B0aW1pemVcbiAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDBcbiAgY29uc3QgcmVnRXhwID0gby5jb2RlPy5yZWdFeHAgPz8gZGVmYXVsdFJlZ0V4cFxuICBjb25zdCB1cmlSZXNvbHZlciA9IG8udXJpUmVzb2x2ZXIgPz8gRGVmYXVsdFVyaVJlc29sdmVyXG4gIHJldHVybiB7XG4gICAgc3RyaWN0U2NoZW1hOiBvLnN0cmljdFNjaGVtYSA/PyBzID8/IHRydWUsXG4gICAgc3RyaWN0TnVtYmVyczogby5zdHJpY3ROdW1iZXJzID8/IHMgPz8gdHJ1ZSxcbiAgICBzdHJpY3RUeXBlczogby5zdHJpY3RUeXBlcyA/PyBzID8/IFwibG9nXCIsXG4gICAgc3RyaWN0VHVwbGVzOiBvLnN0cmljdFR1cGxlcyA/PyBzID8/IFwibG9nXCIsXG4gICAgc3RyaWN0UmVxdWlyZWQ6IG8uc3RyaWN0UmVxdWlyZWQgPz8gcyA/PyBmYWxzZSxcbiAgICBjb2RlOiBvLmNvZGUgPyB7Li4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwfSA6IHtvcHRpbWl6ZSwgcmVnRXhwfSxcbiAgICBsb29wUmVxdWlyZWQ6IG8ubG9vcFJlcXVpcmVkID8/IE1BWF9FWFBSRVNTSU9OLFxuICAgIGxvb3BFbnVtOiBvLmxvb3BFbnVtID8/IE1BWF9FWFBSRVNTSU9OLFxuICAgIG1ldGE6IG8ubWV0YSA/PyB0cnVlLFxuICAgIG1lc3NhZ2VzOiBvLm1lc3NhZ2VzID8/IHRydWUsXG4gICAgaW5saW5lUmVmczogby5pbmxpbmVSZWZzID8/IHRydWUsXG4gICAgc2NoZW1hSWQ6IG8uc2NoZW1hSWQgPz8gXCIkaWRcIixcbiAgICBhZGRVc2VkU2NoZW1hOiBvLmFkZFVzZWRTY2hlbWEgPz8gdHJ1ZSxcbiAgICB2YWxpZGF0ZVNjaGVtYTogby52YWxpZGF0ZVNjaGVtYSA/PyB0cnVlLFxuICAgIHZhbGlkYXRlRm9ybWF0czogby52YWxpZGF0ZUZvcm1hdHMgPz8gdHJ1ZSxcbiAgICB1bmljb2RlUmVnRXhwOiBvLnVuaWNvZGVSZWdFeHAgPz8gdHJ1ZSxcbiAgICBpbnQzMnJhbmdlOiBvLmludDMycmFuZ2UgPz8gdHJ1ZSxcbiAgICB1cmlSZXNvbHZlcjogdXJpUmVzb2x2ZXIsXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICBsb2coLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxuICB3YXJuKC4uLmFyZ3M6IHVua25vd25bXSk6IHVua25vd25cbiAgZXJyb3IoLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBanYge1xuICBvcHRzOiBJbnN0YW5jZU9wdGlvbnNcbiAgZXJyb3JzPzogRXJyb3JPYmplY3RbXSB8IG51bGwgLy8gZXJyb3JzIGZyb20gdGhlIGxhc3QgdmFsaWRhdGlvblxuICBsb2dnZXI6IExvZ2dlclxuICAvLyBzaGFyZWQgZXh0ZXJuYWwgc2NvcGUgdmFsdWVzIGZvciBjb21waWxlZCBmdW5jdGlvbnNcbiAgcmVhZG9ubHkgc2NvcGU6IFZhbHVlU2NvcGVcbiAgcmVhZG9ubHkgc2NoZW1hczoge1tLZXkgaW4gc3RyaW5nXT86IFNjaGVtYUVudn0gPSB7fVxuICByZWFkb25seSByZWZzOiB7W1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgc3RyaW5nfSA9IHt9XG4gIHJlYWRvbmx5IGZvcm1hdHM6IHtbTmFtZSBpbiBzdHJpbmddPzogQWRkZWRGb3JtYXR9ID0ge31cbiAgcmVhZG9ubHkgUlVMRVM6IFZhbGlkYXRpb25SdWxlc1xuICByZWFkb25seSBfY29tcGlsYXRpb25zOiBTZXQ8U2NoZW1hRW52PiA9IG5ldyBTZXQoKVxuICBwcml2YXRlIHJlYWRvbmx5IF9sb2FkaW5nOiB7W1JlZiBpbiBzdHJpbmddPzogUHJvbWlzZTxBbnlTY2hlbWFPYmplY3Q+fSA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NhY2hlOiBNYXA8QW55U2NoZW1hLCBTY2hlbWFFbnY+ID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgcmVhZG9ubHkgX21ldGFPcHRzOiBJbnN0YW5jZU9wdGlvbnNcblxuICBzdGF0aWMgVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yXG4gIHN0YXRpYyBNaXNzaW5nUmVmRXJyb3IgPSBNaXNzaW5nUmVmRXJyb3JcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICBvcHRzID0gdGhpcy5vcHRzID0gey4uLm9wdHMsIC4uLnJlcXVpcmVkT3B0aW9ucyhvcHRzKX1cbiAgICBjb25zdCB7ZXM1LCBsaW5lc30gPSB0aGlzLm9wdHMuY29kZVxuXG4gICAgdGhpcy5zY29wZSA9IG5ldyBWYWx1ZVNjb3BlKHtzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXN9KVxuICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKVxuICAgIGNvbnN0IGZvcm1hdE9wdCA9IG9wdHMudmFsaWRhdGVGb3JtYXRzXG4gICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZVxuXG4gICAgdGhpcy5SVUxFUyA9IGdldFJ1bGVzKClcbiAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpXG4gICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIilcbiAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcylcblxuICAgIGlmIChvcHRzLmZvcm1hdHMpIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcylcbiAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKVxuICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKClcbiAgICBpZiAob3B0cy5rZXl3b3JkcykgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3JkcylcbiAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKSB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKVxuICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcylcbiAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdFxuICB9XG5cbiAgX2FkZFZvY2FidWxhcmllcygpOiB2b2lkIHtcbiAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIilcbiAgfVxuXG4gIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpOiB2b2lkIHtcbiAgICBjb25zdCB7JGRhdGEsIG1ldGEsIHNjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGxldCBfZGF0YVJlZlNjaGVtYTogU2NoZW1hT2JqZWN0ID0gJGRhdGFSZWZTY2hlbWFcbiAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7Li4uJGRhdGFSZWZTY2hlbWF9XG4gICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZFxuICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZFxuICAgIH1cbiAgICBpZiAobWV0YSAmJiAkZGF0YSkgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKVxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB7bWV0YSwgc2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZClcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGRhdGEgdXNpbmcgc2NoZW1hXG4gIC8vIEFueVNjaGVtYSB3aWxsIGJlIGNvbXBpbGVkIGFuZCBjYWNoZWQgdXNpbmcgc2NoZW1hIGl0c2VsZiBhcyBhIGtleSBmb3IgTWFwXG4gIHZhbGlkYXRlKHNjaGVtYTogU2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogYm9vbGVhblxuICB2YWxpZGF0ZShzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGJvb2xlYW4gfCBQcm9taXNlPHVua25vd24+XG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogU2NoZW1hIHwgSlNPTlNjaGVtYVR5cGU8VD4gfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBkYXRhIGlzIFRcbiAgLy8gU2VwYXJhdGVkIGZvciB0eXBlIGluZmVyZW5jZSB0byB3b3JrXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogSlREU2NoZW1hVHlwZTxUPiwgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVFxuICAvLyBUaGlzIG92ZXJsb2FkIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHR5cGVzY3JpcHQgaW5mZXJlbmNlLCB0aGUgZmlyc3RcbiAgLy8gYXJndW1lbnQgcHJldmVudHMgbWFudWFsIHR5cGUgYW5ub3RhdGlvbiBmcm9tIG1hdGNoaW5nIHRoaXMgb3ZlcmxvYWRcbiAgdmFsaWRhdGU8TiBleHRlbmRzIG5ldmVyLCBUIGV4dGVuZHMgU29tZUpURFNjaGVtYVR5cGU+KFxuICAgIHNjaGVtYTogVCxcbiAgICBkYXRhOiB1bmtub3duXG4gICk6IGRhdGEgaXMgSlRERGF0YVR5cGU8VD5cbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBBc3luY1NjaGVtYSwgZGF0YTogdW5rbm93biB8IFQpOiBQcm9taXNlPFQ+XG4gIHZhbGlkYXRlPFQ+KHNjaGVtYUtleVJlZjogQW55U2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogZGF0YSBpcyBUIHwgUHJvbWlzZTxUPlxuICB2YWxpZGF0ZTxUPihcbiAgICBzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIGRhdGE6IHVua25vd24gfCBUIC8vIHRvIGJlIHZhbGlkYXRlZFxuICApOiBib29sZWFuIHwgUHJvbWlzZTxUPiB7XG4gICAgbGV0IHY6IEFueVZhbGlkYXRlRnVuY3Rpb24gfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2ID0gdGhpcy5nZXRTY2hlbWE8VD4oc2NoZW1hS2V5UmVmKVxuICAgICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApXG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSB0aGlzLmNvbXBpbGU8VD4oc2NoZW1hS2V5UmVmKVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKVxuICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpIHRoaXMuZXJyb3JzID0gdi5lcnJvcnNcbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIC8vIENyZWF0ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hXG4gIC8vIF9tZXRhOiB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHkgdG8gY29tcGlsZSBtZXRhIHNjaGVtYXMgb2YgdXNlci1kZWZpbmVkIGtleXdvcmRzLlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IFNjaGVtYSB8IEpTT05TY2hlbWFUeXBlPFQ+LCBfbWV0YT86IGJvb2xlYW4pOiBWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFZhbGlkYXRlRnVuY3Rpb248VD5cbiAgLy8gVGhpcyBvdmVybG9hZCBpcyBvbmx5IGludGVuZGVkIGZvciB0eXBlc2NyaXB0IGluZmVyZW5jZSwgdGhlIGZpcnN0XG4gIC8vIGFyZ3VtZW50IHByZXZlbnRzIG1hbnVhbCB0eXBlIGFubm90YXRpb24gZnJvbSBtYXRjaGluZyB0aGlzIG92ZXJsb2FkXG4gIGNvbXBpbGU8TiBleHRlbmRzIG5ldmVyLCBUIGV4dGVuZHMgU29tZUpURFNjaGVtYVR5cGU+KFxuICAgIHNjaGVtYTogVCxcbiAgICBfbWV0YT86IGJvb2xlYW5cbiAgKTogVmFsaWRhdGVGdW5jdGlvbjxKVEREYXRhVHlwZTxUPj5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBc3luY1NjaGVtYSwgX21ldGE/OiBib29sZWFuKTogQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQW55U2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQW55U2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHtcbiAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSlcbiAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpIGFzIEFueVZhbGlkYXRlRnVuY3Rpb248VD5cbiAgfVxuXG4gIC8vIENyZWF0ZXMgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYSB3aXRoIGFzeW5jaHJvbm91cyBsb2FkaW5nIG9mIG1pc3Npbmcgc2NoZW1hcy5cbiAgLy8gYGxvYWRTY2hlbWFgIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgc2NoZW1hIHVyaSBhbmQgcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2NoZW1hLlxuICAvLyBUT0RPIGFsbG93IHBhc3Npbmcgc2NoZW1hIFVSSVxuICAvLyBtZXRhIC0gb3B0aW9uYWwgdHJ1ZSB0byBjb21waWxlIG1ldGEtc2NoZW1hXG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oXG4gICAgc2NoZW1hOiBTY2hlbWFPYmplY3QgfCBKU09OU2NoZW1hVHlwZTxUPixcbiAgICBfbWV0YT86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICAvLyBTZXBhcmF0ZWQgZm9yIHR5cGUgaW5mZXJlbmNlIHRvIHdvcmtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFByb21pc2U8VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihzY2hlbWE6IEFzeW5jU2NoZW1hLCBtZXRhPzogYm9vbGVhbik6IFByb21pc2U8QXN5bmNWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIG1ldGE/OiBib29sZWFuXG4gICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBtZXRhPzogYm9vbGVhblxuICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb248VD4+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5sb2FkU2NoZW1hICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpXG4gICAgfVxuICAgIGNvbnN0IHtsb2FkU2NoZW1hfSA9IHRoaXMub3B0c1xuICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpXG5cbiAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoXG4gICAgICB0aGlzOiBBanYsXG4gICAgICBfc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAgICBfbWV0YT86IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb24+IHtcbiAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKVxuICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKVxuICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKHRoaXM6IEFqdiwgJHJlZj86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHskcmVmfSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb24+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE1pc3NpbmdSZWZFcnJvcikpIHRocm93IGVcbiAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKVxuICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSlcbiAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQodGhpczogQWp2LCB7bWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmfTogTWlzc2luZ1JlZkVycm9yKTogdm9pZCB7XG4gICAgICBpZiAodGhpcy5yZWZzW3JlZl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZilcbiAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKVxuICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSkgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkU2NoZW1hKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBQcm9taXNlPEFueVNjaGVtYU9iamVjdD4ge1xuICAgICAgY29uc3QgcCA9IHRoaXMuX2xvYWRpbmdbcmVmXVxuICAgICAgaWYgKHApIHJldHVybiBwXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuX2xvYWRpbmdbcmVmXSA9IGxvYWRTY2hlbWEocmVmKSlcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgYWRkU2NoZW1hKFxuICAgIHNjaGVtYTogQW55U2NoZW1hIHwgQW55U2NoZW1hW10sIC8vIElmIGFycmF5IGlzIHBhc3NlZCwgYGtleWAgd2lsbCBiZSBpZ25vcmVkXG4gICAga2V5Pzogc3RyaW5nLCAvLyBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgIF9tZXRhPzogYm9vbGVhbiwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICk6IEFqdiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2NoZW1hKSB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGxldCBpZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXVxuICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgJHtzY2hlbWFJZH0gbXVzdCBiZSBzdHJpbmdgKVxuICAgICAgfVxuICAgIH1cbiAgICBrZXkgPSBub3JtYWxpemVJZChrZXkgfHwgaWQpXG4gICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KVxuICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgYWRkTWV0YVNjaGVtYShcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBrZXk/OiBzdHJpbmcsIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICApOiBBanYge1xuICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hOiBBbnlTY2hlbWEsIHRocm93T3JMb2dFcnJvcj86IGJvb2xlYW4pOiBib29sZWFuIHwgUHJvbWlzZTx1bmtub3duPiB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB0cnVlXG4gICAgbGV0ICRzY2hlbWE6IHN0cmluZyB8IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYVxuICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpXG4gICAgfVxuICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKClcbiAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpXG4gICAgICB0aGlzLmVycm9ycyA9IG51bGxcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpXG4gICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpXG4gICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKSB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkXG4gIH1cblxuICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgZ2V0U2NoZW1hPFQgPSB1bmtub3duPihrZXlSZWY6IHN0cmluZyk6IEFueVZhbGlkYXRlRnVuY3Rpb248VD4gfCB1bmRlZmluZWQge1xuICAgIGxldCBzY2hcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKSBrZXlSZWYgPSBzY2hcbiAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICAgIGNvbnN0IHJvb3QgPSBuZXcgU2NoZW1hRW52KHtzY2hlbWE6IHt9LCBzY2hlbWFJZH0pXG4gICAgICBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKVxuICAgICAgaWYgKCFzY2gpIHJldHVyblxuICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2hcbiAgICB9XG4gICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKSBhcyBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHwgdW5kZWZpbmVkXG4gIH1cblxuICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmPzogQW55U2NoZW1hIHwgc3RyaW5nIHwgUmVnRXhwKTogQWp2IHtcbiAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKVxuICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcylcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpXG4gICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKVxuICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl1cbiAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWZcbiAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KVxuICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdXG4gICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIilcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9uczogVm9jYWJ1bGFyeSk6IEFqdiB7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpIHRoaXMuYWRkS2V5d29yZChkZWYpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGFkZEtleXdvcmQoXG4gICAga3dkT3JEZWY6IHN0cmluZyB8IEtleXdvcmREZWZpbml0aW9uLFxuICAgIGRlZj86IEtleXdvcmREZWZpbml0aW9uIC8vIGRlcHJlY2F0ZWRcbiAgKTogQWp2IHtcbiAgICBsZXQga2V5d29yZDogc3RyaW5nIHwgc3RyaW5nW11cbiAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGtleXdvcmQgPSBrd2RPckRlZlxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIilcbiAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVmID0ga3dkT3JEZWZcbiAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIilcbiAgICB9XG5cbiAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpXG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIGVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpXG4gICAgY29uc3QgZGVmaW5pdGlvbjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAgICAgIC4uLmRlZixcbiAgICAgIHR5cGU6IGdldEpTT05UeXBlcyhkZWYudHlwZSksXG4gICAgICBzY2hlbWFUeXBlOiBnZXRKU09OVHlwZXMoZGVmLnNjaGVtYVR5cGUpLFxuICAgIH1cbiAgICBlYWNoSXRlbShcbiAgICAgIGtleXdvcmQsXG4gICAgICBkZWZpbml0aW9uLnR5cGUubGVuZ3RoID09PSAwXG4gICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKVxuICAgIClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0S2V5d29yZChrZXl3b3JkOiBzdHJpbmcpOiBBZGRlZEtleXdvcmREZWZpbml0aW9uIHwgYm9vbGVhbiB7XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdXG4gICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGVcbiAgfVxuXG4gIC8vIFJlbW92ZSBrZXl3b3JkXG4gIHJlbW92ZUtleXdvcmQoa2V5d29yZDogc3RyaW5nKTogQWp2IHtcbiAgICAvLyBUT0RPIHJldHVybiB0eXBlIHNob3VsZCBiZSBBanZcbiAgICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXVxuICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF1cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSB7XG4gICAgICBjb25zdCBpID0gZ3JvdXAucnVsZXMuZmluZEluZGV4KChydWxlKSA9PiBydWxlLmtleXdvcmQgPT09IGtleXdvcmQpXG4gICAgICBpZiAoaSA+PSAwKSBncm91cC5ydWxlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEFkZCBmb3JtYXRcbiAgYWRkRm9ybWF0KG5hbWU6IHN0cmluZywgZm9ybWF0OiBGb3JtYXQpOiBBanYge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwic3RyaW5nXCIpIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KVxuICAgIHRoaXMuZm9ybWF0c1tuYW1lXSA9IGZvcm1hdFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlcnJvcnNUZXh0KFxuICAgIGVycm9yczogRXJyb3JPYmplY3RbXSB8IG51bGwgfCB1bmRlZmluZWQgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7c2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCJ9OiBFcnJvcnNUZXh0T3B0aW9ucyA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAoIWVycm9ycyB8fCBlcnJvcnMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBlcnJvcnNcIlxuICAgIHJldHVybiBlcnJvcnNcbiAgICAgIC5tYXAoKGUpID0+IGAke2RhdGFWYXJ9JHtlLmluc3RhbmNlUGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIC5yZWR1Y2UoKHRleHQsIG1zZykgPT4gdGV4dCArIHNlcGFyYXRvciArIG1zZylcbiAgfVxuXG4gICRkYXRhTWV0YVNjaGVtYShtZXRhU2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsIGtleXdvcmRzSnNvblBvaW50ZXJzOiBzdHJpbmdbXSk6IEFueVNjaGVtYU9iamVjdCB7XG4gICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbFxuICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKVxuICAgIGZvciAoY29uc3QganNvblBvaW50ZXIgb2Yga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpLnNsaWNlKDEpIC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hXG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cykga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddIGFzIEFueVNjaGVtYU9iamVjdFxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIikgY29udGludWVcbiAgICAgICAgY29uc3QgeyRkYXRhfSA9IHJ1bGUuZGVmaW5pdGlvblxuICAgICAgICBjb25zdCBzY2hlbWEgPSBrZXl3b3Jkc1trZXldIGFzIEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKSBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YVNjaGVtYVxuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzOiB7W1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgc3RyaW5nfSwgcmVnZXg/OiBSZWdFeHApOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl1cbiAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKVxuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hZGRTY2hlbWEoXG4gICAgc2NoZW1hOiBBbnlTY2hlbWEsXG4gICAgbWV0YT86IGJvb2xlYW4sXG4gICAgYmFzZUlkPzogc3RyaW5nLFxuICAgIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLFxuICAgIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hXG4gICk6IFNjaGVtYUVudiB7XG4gICAgbGV0IGlkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdHMuanRkKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIilcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIpIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpXG4gICAgfVxuICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKVxuICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZCkgcmV0dXJuIHNjaFxuXG4gICAgYmFzZUlkID0gbm9ybWFsaXplSWQoaWQgfHwgYmFzZUlkKVxuICAgIGNvbnN0IGxvY2FsUmVmcyA9IGdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEsIGJhc2VJZClcbiAgICBzY2ggPSBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmc30pXG4gICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaClcbiAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICBpZiAoYmFzZUlkKSB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpXG4gICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaFxuICAgIH1cbiAgICBpZiAodmFsaWRhdGVTY2hlbWEpIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKVxuICAgIHJldHVybiBzY2hcbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrVW5pcXVlKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NvbXBpbGVTY2hlbWFFbnYoc2NoOiBTY2hlbWFFbnYpOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uIHtcbiAgICBpZiAoc2NoLm1ldGEpIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaClcbiAgICBlbHNlIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXNjaC52YWxpZGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICB9XG5cbiAgcHJpdmF0ZSBfY29tcGlsZU1ldGFTY2hlbWEoc2NoOiBTY2hlbWFFbnYpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0c1xuICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JzVGV4dE9wdGlvbnMge1xuICBzZXBhcmF0b3I/OiBzdHJpbmdcbiAgZGF0YVZhcj86IHN0cmluZ1xufVxuXG5mdW5jdGlvbiBjaGVja09wdGlvbnMoXG4gIHRoaXM6IEFqdixcbiAgY2hlY2tPcHRzOiBPcHRpb25zSW5mbzxSZW1vdmVkT3B0aW9ucyB8IERlcHJlY2F0ZWRPcHRpb25zPixcbiAgb3B0aW9uczogT3B0aW9ucyAmIFJlbW92ZWRPcHRpb25zLFxuICBtc2c6IHN0cmluZyxcbiAgbG9nOiBcIndhcm5cIiB8IFwiZXJyb3JcIiA9IFwiZXJyb3JcIlxuKTogdm9pZCB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgIGNvbnN0IG9wdCA9IGtleSBhcyBrZXlvZiB0eXBlb2YgY2hlY2tPcHRzXG4gICAgaWYgKG9wdCBpbiBvcHRpb25zKSB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY2hFbnYodGhpczogQWp2LCBrZXlSZWY6IHN0cmluZyk6IFNjaGVtYUVudiB8IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGtleVJlZiA9IG5vcm1hbGl6ZUlkKGtleVJlZikgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gIHJldHVybiB0aGlzLnNjaGVtYXNba2V5UmVmXSB8fCB0aGlzLnJlZnNba2V5UmVmXVxufVxuXG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcyh0aGlzOiBBanYpOiB2b2lkIHtcbiAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hc1xuICBpZiAoIW9wdHNTY2hlbWFzKSByZXR1cm5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKSB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcylcbiAgZWxzZSBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcykgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSBhcyBBbnlTY2hlbWEsIGtleSlcbn1cblxuZnVuY3Rpb24gYWRkSW5pdGlhbEZvcm1hdHModGhpczogQWp2KTogdm9pZCB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMub3B0cy5mb3JtYXRzW25hbWVdXG4gICAgaWYgKGZvcm1hdCkgdGhpcy5hZGRGb3JtYXQobmFtZSwgZm9ybWF0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhcbiAgdGhpczogQWp2LFxuICBkZWZzOiBWb2NhYnVsYXJ5IHwge1tLIGluIHN0cmluZ10/OiBLZXl3b3JkRGVmaW5pdGlvbn1cbik6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgIHRoaXMuYWRkVm9jYWJ1bGFyeShkZWZzKVxuICAgIHJldHVyblxuICB9XG4gIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIilcbiAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdIGFzIEtleXdvcmREZWZpbml0aW9uXG4gICAgaWYgKCFkZWYua2V5d29yZCkgZGVmLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgdGhpcy5hZGRLZXl3b3JkKGRlZilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucyh0aGlzOiBBanYpOiBJbnN0YW5jZU9wdGlvbnMge1xuICBjb25zdCBtZXRhT3B0cyA9IHsuLi50aGlzLm9wdHN9XG4gIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpIGRlbGV0ZSBtZXRhT3B0c1tvcHRdXG4gIHJldHVybiBtZXRhT3B0c1xufVxuXG5jb25zdCBub0xvZ3MgPSB7bG9nKCkge30sIHdhcm4oKSB7fSwgZXJyb3IoKSB7fX1cblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcj86IFBhcnRpYWw8TG9nZ2VyPiB8IGZhbHNlKTogTG9nZ2VyIHtcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHJldHVybiBub0xvZ3NcbiAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY29uc29sZVxuICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpIHJldHVybiBsb2dnZXIgYXMgTG9nZ2VyXG4gIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIilcbn1cblxuY29uc3QgS0VZV09SRF9OQU1FID0gL15bYS16XyRdW2EtejAtOV8kOi1dKiQvaVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmQodGhpczogQWp2LCBrZXl3b3JkOiBzdHJpbmcgfCBzdHJpbmdbXSwgZGVmPzogS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge1JVTEVTfSA9IHRoaXNcbiAgZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKSB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApXG4gICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKSB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKVxuICB9KVxuICBpZiAoIWRlZikgcmV0dXJuXG4gIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVsZShcbiAgdGhpczogQWp2LFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gIGRlZmluaXRpb24/OiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBkYXRhVHlwZT86IEpTT05UeXBlXG4pOiB2b2lkIHtcbiAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24/LnBvc3RcbiAgaWYgKGRhdGFUeXBlICYmIHBvc3QpIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKVxuICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7dHlwZTogdH0pID0+IHQgPT09IGRhdGFUeXBlKVxuICBpZiAoIXJ1bGVHcm91cCkge1xuICAgIHJ1bGVHcm91cCA9IHt0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdfVxuICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKVxuICB9XG4gIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZVxuICBpZiAoIWRlZmluaXRpb24pIHJldHVyblxuXG4gIGNvbnN0IHJ1bGU6IFJ1bGUgPSB7XG4gICAga2V5d29yZCxcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgdHlwZTogZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24udHlwZSksXG4gICAgICBzY2hlbWFUeXBlOiBnZXRKU09OVHlwZXMoZGVmaW5pdGlvbi5zY2hlbWFUeXBlKSxcbiAgICB9LFxuICB9XG4gIGlmIChkZWZpbml0aW9uLmJlZm9yZSkgYWRkQmVmb3JlUnVsZS5jYWxsKHRoaXMsIHJ1bGVHcm91cCwgcnVsZSwgZGVmaW5pdGlvbi5iZWZvcmUpXG4gIGVsc2UgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSlcbiAgUlVMRVMuYWxsW2tleXdvcmRdID0gcnVsZVxuICBkZWZpbml0aW9uLmltcGxlbWVudHM/LmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpXG59XG5cbmZ1bmN0aW9uIGFkZEJlZm9yZVJ1bGUodGhpczogQWp2LCBydWxlR3JvdXA6IFJ1bGVHcm91cCwgcnVsZTogUnVsZSwgYmVmb3JlOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpXG4gIGlmIChpID49IDApIHtcbiAgICBydWxlR3JvdXAucnVsZXMuc3BsaWNlKGksIDAsIHJ1bGUpXG4gIH0gZWxzZSB7XG4gICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSlcbiAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApXG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5d29yZE1ldGFzY2hlbWEodGhpczogQWp2LCBkZWY6IEtleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGxldCB7bWV0YVNjaGVtYX0gPSBkZWZcbiAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKSBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpXG4gIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKVxufVxuXG5jb25zdCAkZGF0YVJlZiA9IHtcbiAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn1cblxuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYTogQW55U2NoZW1hKTogQW55U2NoZW1hT2JqZWN0IHtcbiAgcmV0dXJuIHthbnlPZjogW3NjaGVtYSwgJGRhdGFSZWZdfVxufVxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImlkXCIsXG4gIGNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQgTWlzc2luZ1JlZkVycm9yIGZyb20gXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge2NhbGxWYWxpZGF0ZUNvZGV9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7XywgbmlsLCBzdHJpbmdpZnksIENvZGUsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHtTY2hlbWFFbnYsIHJlc29sdmVSZWZ9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcbmltcG9ydCB7bWVyZ2VFdmFsdWF0ZWR9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCIkcmVmXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KTogdm9pZCB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hOiAkcmVmLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7YmFzZUlkLCBzY2hlbWFFbnY6IGVudiwgdmFsaWRhdGVOYW1lLCBvcHRzLCBzZWxmfSA9IGl0XG4gICAgY29uc3Qge3Jvb3R9ID0gZW52XG4gICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpIHJldHVybiBjYWxsUm9vdFJlZigpXG4gICAgY29uc3Qgc2NoT3JFbnYgPSByZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKVxuICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgTWlzc2luZ1JlZkVycm9yKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgJHJlZilcbiAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBTY2hlbWFFbnYpIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpXG4gICAgcmV0dXJuIGlubGluZVJlZlNjaGVtYShzY2hPckVudilcblxuICAgIGZ1bmN0aW9uIGNhbGxSb290UmVmKCk6IHZvaWQge1xuICAgICAgaWYgKGVudiA9PT0gcm9vdCkgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYylcbiAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHtyZWY6IHJvb3R9KVxuICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCBfYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaDogU2NoZW1hRW52KTogdm9pZCB7XG4gICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpXG4gICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2g6IEFueVNjaGVtYSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFxuICAgICAgICBcInNjaGVtYVwiLFxuICAgICAgICBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8ge3JlZjogc2NoLCBjb2RlOiBzdHJpbmdpZnkoc2NoKX0gOiB7cmVmOiBzY2h9XG4gICAgICApXG4gICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IG5pbCxcbiAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0OiBLZXl3b3JkQ3h0LCBzY2g6IFNjaGVtYUVudik6IENvZGUge1xuICBjb25zdCB7Z2VufSA9IGN4dFxuICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHtyZWY6IHNjaC52YWxpZGF0ZX0pXG4gICAgOiBfYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHtyZWY6IHNjaH0pfS52YWxpZGF0ZWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxSZWYoY3h0OiBLZXl3b3JkQ3h0LCB2OiBDb2RlLCBzY2g/OiBTY2hlbWFFbnYsICRhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgaXR9ID0gY3h0XG4gIGNvbnN0IHthbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzfSA9IGl0XG4gIGNvbnN0IHBhc3NDeHQgPSBvcHRzLnBhc3NDb250ZXh0ID8gTi50aGlzIDogbmlsXG4gIGlmICgkYXN5bmMpIGNhbGxBc3luY1JlZigpXG4gIGVsc2UgY2FsbFN5bmNSZWYoKVxuXG4gIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpOiB2b2lkIHtcbiAgICBpZiAoIWVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICBnZW4udHJ5KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnZW4uY29kZShfYGF3YWl0ICR7Y2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpfWApXG4gICAgICAgIGFkZEV2YWx1YXRlZEZyb20odikgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgZ2VuLmlmKF9gISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0pYCwgKCkgPT4gZ2VuLnRocm93KGUpKVxuICAgICAgICBhZGRFcnJvcnNGcm9tKGUpXG4gICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgIH1cbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKTogdm9pZCB7XG4gICAgY3h0LnJlc3VsdChcbiAgICAgIGNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KSxcbiAgICAgICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksXG4gICAgICAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2U6IENvZGUpOiB2b2lkIHtcbiAgICBjb25zdCBlcnJzID0gX2Ake3NvdXJjZX0uZXJyb3JzYFxuICAgIGdlbi5hc3NpZ24oTi52RXJyb3JzLCBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke04udkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCkgLy8gVE9ETyB0YWdnZWRcbiAgICBnZW4uYXNzaWduKE4uZXJyb3JzLCBfYCR7Ti52RXJyb3JzfS5sZW5ndGhgKVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2U6IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IHNjaD8udmFsaWRhdGU/LmV2YWx1YXRlZFxuICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIF9gJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApXG4gICAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIE5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgX2Ake3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYClcbiAgICAgICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIGl0ZW1zLCBpdC5pdGVtcywgTmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgaWRLZXl3b3JkIGZyb20gXCIuL2lkXCJcbmltcG9ydCByZWZLZXl3b3JkIGZyb20gXCIuL3JlZlwiXG5cbmNvbnN0IGNvcmU6IFZvY2FidWxhcnkgPSBbXG4gIFwiJHNjaGVtYVwiLFxuICBcIiRpZFwiLFxuICBcIiRkZWZzXCIsXG4gIFwiJHZvY2FidWxhcnlcIixcbiAge2tleXdvcmQ6IFwiJGNvbW1lbnRcIn0sXG4gIFwiZGVmaW5pdGlvbnNcIixcbiAgaWRLZXl3b3JkLFxuICByZWZLZXl3b3JkLFxuXVxuXG5leHBvcnQgZGVmYXVsdCBjb3JlXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9ycywgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IG9wcyA9IG9wZXJhdG9yc1xuXG50eXBlIEt3ZCA9IFwibWF4aW11bVwiIHwgXCJtaW5pbXVtXCIgfCBcImV4Y2x1c2l2ZU1heGltdW1cIiB8IFwiZXhjbHVzaXZlTWluaW11bVwiXG5cbnR5cGUgQ29tcGFyaXNvbiA9IFwiPD1cIiB8IFwiPj1cIiB8IFwiPFwiIHwgXCI+XCJcblxuY29uc3QgS1dEczoge1tLIGluIEt3ZF06IHtva1N0cjogQ29tcGFyaXNvbjsgb2s6IENvZGU7IGZhaWw6IENvZGV9fSA9IHtcbiAgbWF4aW11bToge29rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1R9LFxuICBtaW5pbXVtOiB7b2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVH0sXG4gIGV4Y2x1c2l2ZU1heGltdW06IHtva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEV9LFxuICBleGNsdXNpdmVNaW5pbXVtOiB7b2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFfSxcbn1cblxuZXhwb3J0IHR5cGUgTGltaXROdW1iZXJFcnJvciA9IEVycm9yT2JqZWN0PFxuICBLd2QsXG4gIHtsaW1pdDogbnVtYmVyOyBjb21wYXJpc29uOiBDb21wYXJpc29ufSxcbiAgbnVtYmVyIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBiZSAke0tXRHNba2V5d29yZCBhcyBLd2RdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgcGFyYW1zOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PlxuICAgIF9ge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gIHR5cGU6IFwibnVtYmVyXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZX0gPSBjeHRcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtkYXRhfSAke0tXRHNba2V5d29yZCBhcyBLd2RdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB0eXBlIE11bHRpcGxlT2ZFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm11bHRpcGxlT2ZcIixcbiAge211bHRpcGxlT2Y6IG51bWJlcn0sXG4gIG51bWJlciB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gIHR5cGU6IFwibnVtYmVyXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvblxuICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIilcbiAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgPyBfYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgOiBfYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWBcbiAgICBjeHQuZmFpbCRkYXRhKF9gKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICBsZXQgbGVuZ3RoID0gMFxuICBsZXQgcG9zID0gMFxuICBsZXQgdmFsdWU6IG51bWJlclxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKytcbiAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKVxuICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApIHBvcysrIC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aFxufVxuXG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0J1xuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHVjczJsZW5ndGggZnJvbSBcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICB0eXBlOiBcInN0cmluZ1wiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGNvbnN0IGxlbiA9XG4gICAgICBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gX2Ake2RhdGF9Lmxlbmd0aGAgOiBfYCR7dXNlRnVuYyhjeHQuZ2VuLCB1Y3MybGVuZ3RoKX0oJHtkYXRhfSlgXG4gICAgY3h0LmZhaWwkZGF0YShfYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHt1c2VQYXR0ZXJufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB0eXBlIFBhdHRlcm5FcnJvciA9IEVycm9yT2JqZWN0PFwicGF0dGVyblwiLCB7cGF0dGVybjogc3RyaW5nfSwgc3RyaW5nIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgbWF0Y2ggcGF0dGVybiBcIiR7c2NoZW1hQ29kZX1cImAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7ZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCJcbiAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/IF9gKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6IHVzZVBhdHRlcm4oY3h0LCBzY2hlbWEpXG4gICAgY3h0LmZhaWwkZGF0YShfYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiXG4gICAgcmV0dXJuIHN0cmBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IHByb3BlcnRpZXNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGV9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGN4dC5mYWlsJGRhdGEoX2BPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7XG4gIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AsXG4gIGNoZWNrTWlzc2luZ1Byb3AsXG4gIHJlcG9ydE1pc3NpbmdQcm9wLFxuICBwcm9wZXJ0eUluRGF0YSxcbiAgbm9Qcm9wZXJ0eUluRGF0YSxcbn0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5pbCwgbm90LCBOYW1lLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgUmVxdWlyZWRFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcInJlcXVpcmVkXCIsXG4gIHttaXNzaW5nUHJvcGVydHk6IHN0cmluZ30sXG4gIHN0cmluZ1tdIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge21pc3NpbmdQcm9wZXJ0eX19KSA9PiBzdHJgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge21pc3NpbmdQcm9wZXJ0eX19KSA9PiBfYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0c30gPSBpdFxuICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWRcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSBhbGxFcnJvcnNNb2RlKClcbiAgICBlbHNlIGV4aXRPbkVycm9yTW9kZSgpXG5cbiAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXNcbiAgICAgIGNvbnN0IHtkZWZpbmVkUHJvcGVydGllc30gPSBjeHQuaXRcbiAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRLZXkgb2Ygc2NoZW1hKSB7XG4gICAgICAgIGlmIChwcm9wcz8uW3JlcXVpcmVkS2V5XSA9PT0gdW5kZWZpbmVkICYmICFkZWZpbmVkUHJvcGVydGllcy5oYXMocmVxdWlyZWRLZXkpKSB7XG4gICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoXG4gICAgICAgICAgY29uc3QgbXNnID0gYHJlcXVpcmVkIHByb3BlcnR5IFwiJHtyZXF1aXJlZEtleX1cIiBpcyBub3QgZGVmaW5lZCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0UmVxdWlyZWQpYFxuICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpOiB2b2lkIHtcbiAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKG5pbCwgbG9vcEFsbFJlcXVpcmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCk6IHZvaWQge1xuICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpXG4gICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKVxuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpXG4gICAgICAgIGN4dC5vayh2YWxpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihjaGVja01pc3NpbmdQcm9wKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSlcbiAgICAgICAgcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKVxuICAgICAgICBnZW4uZWxzZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCk6IHZvaWQge1xuICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlIGFzIENvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogcHJvcH0pXG4gICAgICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZzogTmFtZSwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogbWlzc2luZ30pXG4gICAgICBnZW4uZm9yT2YoXG4gICAgICAgIG1pc3NpbmcsXG4gICAgICAgIHNjaGVtYUNvZGUgYXMgQ29kZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSlcbiAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5icmVhaygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgbmlsXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBvcGVyYXRvcnN9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZSh7a2V5d29yZCwgc2NoZW1hQ29kZX0pIHtcbiAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heEl0ZW1zXCIsIFwibWluSXRlbXNcIl0sXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlfSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY3h0LmZhaWwkZGF0YShfYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICIvLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuaW1wb3J0ICogYXMgZXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbFwiXG5cbnR5cGUgRXF1YWwgPSB0eXBlb2YgZXF1YWwgJiB7Y29kZTogc3RyaW5nfVxuOyhlcXVhbCBhcyBFcXVhbCkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0J1xuXG5leHBvcnQgZGVmYXVsdCBlcXVhbCBhcyBFcXVhbFxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Y2hlY2tEYXRhVHlwZXMsIGdldFNjaGVtYVR5cGVzLCBEYXRhVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIlxuaW1wb3J0IHtfLCBzdHIsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIFVuaXF1ZUl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJ1bmlxdWVJdGVtc1wiLFxuICB7aTogbnVtYmVyOyBqOiBudW1iZXJ9LFxuICBib29sZWFuIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2ksIGp9fSkgPT5cbiAgICBzdHJgbXVzdCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICR7an0gYW5kICR7aX0gYXJlIGlkZW50aWNhbClgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7aSwgan19KSA9PiBfYHtpOiAke2l9LCBqOiAke2p9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyBnZXRTY2hlbWFUeXBlcyhwYXJlbnRTY2hlbWEuaXRlbXMpIDogW11cbiAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgX2Ake3NjaGVtYUNvZGV9ID09PSBmYWxzZWApXG4gICAgY3h0Lm9rKHZhbGlkKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKVxuICAgICAgY3h0LnNldFBhcmFtcyh7aSwgan0pXG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgZ2VuLmlmKF9gJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BOKGk6IE5hbWUsIGo6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIilcbiAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZylcbiAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsIF9ge31gKVxuICAgICAgZ2VuLmZvcihfYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICBnZW4ubGV0KGl0ZW0sIF9gJHtkYXRhfVske2l9XWApXG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsIF9gY29udGludWVgKVxuICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpIGdlbi5pZihfYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCBfYCR7aXRlbX0gKz0gXCJfXCJgKVxuICAgICAgICBnZW5cbiAgICAgICAgICAuaWYoX2B0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCBfYCR7aW5kaWNlc31bJHtpdGVtfV1gKVxuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY29kZShfYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcE4yKGk6IE5hbWUsIGo6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGVxbCA9IHVzZUZ1bmMoZ2VuLCBlcXVhbClcbiAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKVxuICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoX2A7JHtpfS0tO2AsICgpID0+XG4gICAgICAgIGdlbi5mb3IoX2Ake2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+XG4gICAgICAgICAgZ2VuLmlmKF9gJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcilcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge199IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIENvbnN0RXJyb3IgPSBFcnJvck9iamVjdDxcImNvbnN0XCIsIHthbGxvd2VkVmFsdWU6IGFueX0+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWF9ID0gY3h0XG4gICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgY3h0LmZhaWwkZGF0YShfYCEke3VzZUZ1bmMoZ2VuLCBlcXVhbCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYClcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0LmZhaWwoX2Ake3NjaGVtYX0gIT09ICR7ZGF0YX1gKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBvciwgTmFtZSwgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgRW51bUVycm9yID0gRXJyb3JPYmplY3Q8XCJlbnVtXCIsIHthbGxvd2VkVmFsdWVzOiBhbnlbXX0sIGFueVtdIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImVudW1cIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIilcbiAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtXG4gICAgbGV0IGVxbDogTmFtZSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IGdldEVxbCA9ICgpOiBOYW1lID0+IChlcWwgPz89IHVzZUZ1bmMoZ2VuLCBlcXVhbCkpXG5cbiAgICBsZXQgdmFsaWQ6IENvZGVcbiAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCBsb29wRW51bSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKVxuICAgICAgdmFsaWQgPSBvciguLi5zY2hlbWEubWFwKChfeDogdW5rbm93biwgaTogbnVtYmVyKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKVxuICAgIH1cbiAgICBjeHQucGFzcyh2YWxpZClcblxuICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCk6IHZvaWQge1xuICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUgYXMgQ29kZSwgKHYpID0+XG4gICAgICAgIGdlbi5pZihfYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVhbENvZGUodlNjaGVtYTogTmFtZSwgaTogbnVtYmVyKTogQ29kZSB7XG4gICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV1cbiAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICA/IF9gJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgIDogX2Ake2RhdGF9ID09PSAke3NjaH1gXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JPYmplY3QsIFZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgbGltaXROdW1iZXIsIHtMaW1pdE51bWJlckVycm9yfSBmcm9tIFwiLi9saW1pdE51bWJlclwiXG5pbXBvcnQgbXVsdGlwbGVPZiwge011bHRpcGxlT2ZFcnJvcn0gZnJvbSBcIi4vbXVsdGlwbGVPZlwiXG5pbXBvcnQgbGltaXRMZW5ndGggZnJvbSBcIi4vbGltaXRMZW5ndGhcIlxuaW1wb3J0IHBhdHRlcm4sIHtQYXR0ZXJuRXJyb3J9IGZyb20gXCIuL3BhdHRlcm5cIlxuaW1wb3J0IGxpbWl0UHJvcGVydGllcyBmcm9tIFwiLi9saW1pdFByb3BlcnRpZXNcIlxuaW1wb3J0IHJlcXVpcmVkLCB7UmVxdWlyZWRFcnJvcn0gZnJvbSBcIi4vcmVxdWlyZWRcIlxuaW1wb3J0IGxpbWl0SXRlbXMgZnJvbSBcIi4vbGltaXRJdGVtc1wiXG5pbXBvcnQgdW5pcXVlSXRlbXMsIHtVbmlxdWVJdGVtc0Vycm9yfSBmcm9tIFwiLi91bmlxdWVJdGVtc1wiXG5pbXBvcnQgY29uc3RLZXl3b3JkLCB7Q29uc3RFcnJvcn0gZnJvbSBcIi4vY29uc3RcIlxuaW1wb3J0IGVudW1LZXl3b3JkLCB7RW51bUVycm9yfSBmcm9tIFwiLi9lbnVtXCJcblxuY29uc3QgdmFsaWRhdGlvbjogVm9jYWJ1bGFyeSA9IFtcbiAgLy8gbnVtYmVyXG4gIGxpbWl0TnVtYmVyLFxuICBtdWx0aXBsZU9mLFxuICAvLyBzdHJpbmdcbiAgbGltaXRMZW5ndGgsXG4gIHBhdHRlcm4sXG4gIC8vIG9iamVjdFxuICBsaW1pdFByb3BlcnRpZXMsXG4gIHJlcXVpcmVkLFxuICAvLyBhcnJheVxuICBsaW1pdEl0ZW1zLFxuICB1bmlxdWVJdGVtcyxcbiAgLy8gYW55XG4gIHtrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl19LFxuICB7a2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIn0sXG4gIGNvbnN0S2V5d29yZCxcbiAgZW51bUtleXdvcmQsXG5dXG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRpb25cblxudHlwZSBMaW1pdEVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwibWF4SXRlbXNcIiB8IFwibWluSXRlbXNcIiB8IFwibWluUHJvcGVydGllc1wiIHwgXCJtYXhQcm9wZXJ0aWVzXCIgfCBcIm1pbkxlbmd0aFwiIHwgXCJtYXhMZW5ndGhcIixcbiAge2xpbWl0OiBudW1iZXJ9LFxuICBudW1iZXIgfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuZXhwb3J0IHR5cGUgVmFsaWRhdGlvbktleXdvcmRFcnJvciA9XG4gIHwgTGltaXRFcnJvclxuICB8IExpbWl0TnVtYmVyRXJyb3JcbiAgfCBNdWx0aXBsZU9mRXJyb3JcbiAgfCBQYXR0ZXJuRXJyb3JcbiAgfCBSZXF1aXJlZEVycm9yXG4gIHwgVW5pcXVlSXRlbXNFcnJvclxuICB8IENvbnN0RXJyb3JcbiAgfCBFbnVtRXJyb3JcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgbm90LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIEFkZGl0aW9uYWxJdGVtc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJhZGRpdGlvbmFsSXRlbXNcIiwge2xpbWl0OiBudW1iZXJ9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2xlbn19KSA9PiBzdHJgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2xlbn19KSA9PiBfYHtsaW1pdDogJHtsZW59fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiIGFzIGNvbnN0LFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7cGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7aXRlbXN9ID0gcGFyZW50U2NoZW1hXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0OiBLZXl3b3JkQ3h0LCBpdGVtczogQW55U2NoZW1hW10pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgaXQuaXRlbXMgPSB0cnVlXG4gIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICBjeHQuc2V0UGFyYW1zKHtsZW46IGl0ZW1zLmxlbmd0aH0pXG4gICAgY3h0LnBhc3MoX2Ake2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgX2Ake2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCkgLy8gVE9ETyB2YXJcbiAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZDogTmFtZSk6IHZvaWQge1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiBUeXBlLk51bX0sIHZhbGlkKVxuICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYSwgQW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7X30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBtZXJnZUV2YWx1YXRlZCwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7dmFsaWRhdGVBcnJheX0gZnJvbSBcIi4uL2NvZGVcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge3NjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpXG4gICAgaXQuaXRlbXMgPSB0cnVlXG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjeHQub2sodmFsaWRhdGVBcnJheShjeHQpKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShcbiAgY3h0OiBLZXl3b3JkQ3h0LFxuICBleHRyYUl0ZW1zOiBzdHJpbmcsXG4gIHNjaEFycjogQW55U2NoZW1hW10gPSBjeHQuc2NoZW1hXG4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpXG4gIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpXG4gIH1cbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgc2NoQXJyLmZvckVhY2goKHNjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHJldHVyblxuICAgIGdlbi5pZihfYCR7bGVufSA+ICR7aX1gLCAoKSA9PlxuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoOiBBbnlTY2hlbWFPYmplY3QpOiB2b2lkIHtcbiAgICBjb25zdCB7b3B0cywgZXJyU2NoZW1hUGF0aH0gPSBpdFxuICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoXG4gICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSlcbiAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYFxuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHt2YWxpZGF0ZVR1cGxlfSBmcm9tIFwiLi9pdGVtc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBjb2RlOiAoY3h0KSA9PiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJpdGVtc1wiKSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge3ZhbGlkYXRlQXJyYXl9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7dmFsaWRhdGVBZGRpdGlvbmFsSXRlbXN9IGZyb20gXCIuL2FkZGl0aW9uYWxJdGVtc1wiXG5cbmV4cG9ydCB0eXBlIEl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcIml0ZW1zXCIsIHtsaW1pdDogbnVtYmVyfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtsZW59fSkgPT4gc3RyYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtsZW59fSkgPT4gX2B7bGltaXQ6ICR7bGVufX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7c2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtwcmVmaXhJdGVtc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpdC5pdGVtcyA9IHRydWVcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGlmIChwcmVmaXhJdGVtcykgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBwcmVmaXhJdGVtcylcbiAgICBlbHNlIGN4dC5vayh2YWxpZGF0ZUFycmF5KGN4dCkpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIENvbnRhaW5zRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJjb250YWluc1wiLFxuICB7bWluQ29udGFpbnM6IG51bWJlcjsgbWF4Q29udGFpbnM/OiBudW1iZXJ9LFxuICBBbnlTY2hlbWFcbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bWluLCBtYXh9fSkgPT5cbiAgICBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgPyBzdHJgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgOiBzdHJgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge21pbiwgbWF4fX0pID0+XG4gICAgbWF4ID09PSB1bmRlZmluZWQgPyBfYHttaW5Db250YWluczogJHttaW59fWAgOiBfYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgbGV0IG1pbjogbnVtYmVyXG4gICAgbGV0IG1heDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgY29uc3Qge21pbkNvbnRhaW5zLCBtYXhDb250YWluc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zXG4gICAgICBtYXggPSBtYXhDb250YWluc1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW4gPSAxXG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICBjeHQuc2V0UGFyYW1zKHttaW4sIG1heH0pXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwibWluQ29udGFpbnNcIiA+IFwibWF4Q29udGFpbnNcIiBpcyBhbHdheXMgaW52YWxpZGApXG4gICAgICBjeHQuZmFpbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICBsZXQgY29uZCA9IF9gJHtsZW59ID49ICR7bWlufWBcbiAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkgY29uZCA9IF9gJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YFxuICAgICAgY3h0LnBhc3MoY29uZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGl0Lml0ZW1zID0gdHJ1ZVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKVxuICAgIH0gZWxzZSBpZiAobWluID09PSAwKSB7XG4gICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKVxuICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSBnZW4uaWYoX2Ake2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSlcbiAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKVxuICAgIH1cbiAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSlcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG4gICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKVxuICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkOiBOYW1lLCBibG9jazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIF92YWxpZFxuICAgICAgICApXG4gICAgICAgIGJsb2NrKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQ6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGdlbi5jb2RlKF9gJHtjb3VudH0rK2ApXG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2VuLmlmKF9gJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihfYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpXG4gICAgICAgIGlmIChtaW4gPT09IDEpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICAgIGVsc2UgZ2VuLmlmKF9gJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIFNjaGVtYU1hcCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtjaGVja1JlcG9ydE1pc3NpbmdQcm9wLCBjaGVja01pc3NpbmdQcm9wLCByZXBvcnRNaXNzaW5nUHJvcCwgcHJvcGVydHlJbkRhdGF9IGZyb20gXCIuLi9jb2RlXCJcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlEZXBlbmRlbmNpZXMgPSB7W0sgaW4gc3RyaW5nXT86IHN0cmluZ1tdfVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGVuZGVuY2llc0Vycm9yUGFyYW1zIHtcbiAgcHJvcGVydHk6IHN0cmluZ1xuICBtaXNzaW5nUHJvcGVydHk6IHN0cmluZ1xuICBkZXBzQ291bnQ6IG51bWJlclxuICBkZXBzOiBzdHJpbmcgLy8gVE9ETyBjaGFuZ2UgdG8gc3RyaW5nW11cbn1cblxudHlwZSBTY2hlbWFEZXBlbmRlbmNpZXMgPSBTY2hlbWFNYXBcblxuZXhwb3J0IHR5cGUgRGVwZW5kZW5jaWVzRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJkZXBlbmRlbmNpZXNcIixcbiAgRGVwZW5kZW5jaWVzRXJyb3JQYXJhbXMsXG4gIHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW10gfCBBbnlTY2hlbWF9XG4+XG5cbmV4cG9ydCBjb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzfX0pID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIlxuICAgIHJldHVybiBzdHJgbXVzdCBoYXZlICR7cHJvcGVydHlfaWVzfSAke2RlcHN9IHdoZW4gcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgcHJlc2VudGBcbiAgfSxcbiAgcGFyYW1zOiAoe3BhcmFtczoge3Byb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eX19KSA9PlxuICAgIF9ge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dClcbiAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKVxuICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpXG4gIH0sXG59XG5cbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHtzY2hlbWF9OiBLZXl3b3JkQ3h0KTogW1Byb3BlcnR5RGVwZW5kZW5jaWVzLCBTY2hlbWFEZXBlbmRlbmNpZXNdIHtcbiAgY29uc3QgcHJvcGVydHlEZXBzOiBQcm9wZXJ0eURlcGVuZGVuY2llcyA9IHt9XG4gIGNvbnN0IHNjaGVtYURlcHM6IFNjaGVtYURlcGVuZGVuY2llcyA9IHt9XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIGNvbnRpbnVlXG4gICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwc1xuICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldXG4gIH1cbiAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhcbiAgY3h0OiBLZXl3b3JkQ3h0LFxuICBwcm9wZXJ0eURlcHM6IHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW119ID0gY3h0LnNjaGVtYVxuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGl0fSA9IGN4dFxuICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApIHJldHVyblxuICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIilcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF0gYXMgc3RyaW5nW11cbiAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgY29uc3QgaGFzUHJvcGVydHkgPSBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcylcbiAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgIH0pXG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwUHJvcCBvZiBkZXBzKSB7XG4gICAgICAgICAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIGRlcFByb3ApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5pZihfYCR7aGFzUHJvcGVydHl9ICYmICgke2NoZWNrTWlzc2luZ1Byb3AoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYClcbiAgICAgIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZylcbiAgICAgIGdlbi5lbHNlKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQ6IEtleXdvcmRDeHQsIHNjaGVtYURlcHM6IFNjaGVtYU1hcCA9IGN4dC5zY2hlbWEpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hRGVwc1twcm9wXSBhcyBBbnlTY2hlbWEpKSBjb250aW51ZVxuICAgIGdlbi5pZihcbiAgICAgIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcH0sIHZhbGlkKVxuICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKVxuICAgICAgfSxcbiAgICAgICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIG5vdH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlOYW1lc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJwcm9wZXJ0eU5hbWVzXCIsIHtwcm9wZXJ0eU5hbWU6IHN0cmluZ30sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG5cbiAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgY3h0LnNldFBhcmFtcyh7cHJvcGVydHlOYW1lOiBrZXl9KVxuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgY3h0LmVycm9yKHRydWUpXG4gICAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uYnJlYWsoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7YWxsU2NoZW1hUHJvcGVydGllcywgdXNlUGF0dGVybiwgaXNPd25Qcm9wZXJ0eX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBuaWwsIG9yLCBub3QsIENvZGUsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHR5cGUge1N1YnNjaGVtYUFyZ3N9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBzY2hlbWFSZWZPclZhbCwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIEFkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICB7YWRkaXRpb25hbFByb3BlcnR5OiBzdHJpbmd9LFxuICBBbnlTY2hlbWFcbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge2FkZGl0aW9uYWxQcm9wZXJ0eTogJHtwYXJhbXMuYWRkaXRpb25hbFByb3BlcnR5fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiAmIEFkZGVkS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgdHlwZTogW1wib2JqZWN0XCJdLFxuICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0fSA9IGN4dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZXJyc0NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICBjb25zdCB7YWxsRXJyb3JzLCBvcHRzfSA9IGl0XG4gICAgaXQucHJvcHMgPSB0cnVlXG4gICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY29uc3QgcHJvcHMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKVxuICAgIGNvbnN0IHBhdFByb3BzID0gYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpXG4gICAgY3h0Lm9rKF9gJHtlcnJzQ291bnR9ID09PSAke04uZXJyb3JzfWApXG5cbiAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXk6IE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aCkgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpXG4gICAgICAgIGVsc2UgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXk6IE5hbWUpOiBDb2RlIHtcbiAgICAgIGxldCBkZWZpbmVkUHJvcDogQ29kZVxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gc2NoZW1hUmVmT3JWYWwoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIilcbiAgICAgICAgZGVmaW5lZFByb3AgPSBpc093blByb3BlcnR5KGdlbiwgcHJvcHNTY2hlbWEgYXMgQ29kZSwga2V5KVxuICAgICAgfSBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5lZFByb3AgPSBvciguLi5wcm9wcy5tYXAoKHApID0+IF9gJHtrZXl9ID09PSAke3B9YCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG5pbFxuICAgICAgfVxuICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG9yKGRlZmluZWRQcm9wLCAuLi5wYXRQcm9wcy5tYXAoKHApID0+IF9gJHt1c2VQYXR0ZXJuKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdChkZWZpbmVkUHJvcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVBZGRpdGlvbmFsKGtleTogTmFtZSk6IHZvaWQge1xuICAgICAgZ2VuLmNvZGUoX2BkZWxldGUgJHtkYXRhfVske2tleX1dYClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleTogTmFtZSk6IHZvaWQge1xuICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7YWRkaXRpb25hbFByb3BlcnR5OiBrZXl9KVxuICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmJyZWFrKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LnJlc2V0KClcbiAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpXG4gICAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXk6IE5hbWUsIHZhbGlkOiBOYW1lLCBlcnJvcnM/OiBmYWxzZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc3Vic2NoZW1hOiBTdWJzY2hlbWFBcmdzID0ge1xuICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5TdHIsXG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtwcm9wZXJ0eUluRGF0YSwgYWxsU2NoZW1hUHJvcGVydGllc30gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgdG9IYXNoLCBtZXJnZUV2YWx1YXRlZH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgYXBEZWYgZnJvbSBcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwRGVmLmNvZGUobmV3IEtleXdvcmRDeHQoaXQsIGFwRGVmLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKVxuICAgIH1cbiAgICBjb25zdCBhbGxQcm9wcyA9IGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHRvSGFzaChhbGxQcm9wcyksIGl0LnByb3BzKVxuICAgIH1cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSkpXG4gICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW4uaWYocHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKVxuICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApXG4gICAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSlcbiAgICAgICAgZ2VuLmVuZElmKClcbiAgICAgIH1cbiAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3A6IHN0cmluZyk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHthbGxTY2hlbWFQcm9wZXJ0aWVzLCB1c2VQYXR0ZXJufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIG5vdCwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtldmFsdWF0ZWRQcm9wc1RvTmFtZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge0FueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHN9ID0gaXRcbiAgICBjb25zdCBwYXR0ZXJucyA9IGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKVxuICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+XG4gICAgICBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdIGFzIEFueVNjaGVtYSlcbiAgICApXG5cbiAgICBpZiAoXG4gICAgICBwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPVxuICAgICAgb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXNcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIE5hbWUpKSB7XG4gICAgICBpdC5wcm9wcyA9IGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgaXQucHJvcHMpXG4gICAgfVxuICAgIGNvbnN0IHtwcm9wc30gPSBpdFxuICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdClcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KVxuICAgICAgICAgIGdlbi5pZih2YWxpZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgIGdlbi5pZihfYCR7dXNlUGF0dGVybihjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KVxuICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLlN0cixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihfYCR7cHJvcHN9WyR7a2V5fV1gLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yTm9QYXJhbXMsIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgTm90S2V5d29yZEVycm9yID0gRXJyb3JOb1BhcmFtczxcIm5vdFwiLCBBbnlTY2hlbWE+XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm5vdFwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgY3h0LmZhaWwoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgY3h0LnN1YnNjaGVtYShcbiAgICAgIHtcbiAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB2YWxpZFxuICAgIClcblxuICAgIGN4dC5mYWlsUmVzdWx0KFxuICAgICAgdmFsaWQsXG4gICAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcigpXG4gICAgKVxuICB9LFxuICBlcnJvcjoge21lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIn0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yTm9QYXJhbXMsIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7dmFsaWRhdGVVbmlvbn0gZnJvbSBcIi4uL2NvZGVcIlxuXG5leHBvcnQgdHlwZSBBbnlPZkVycm9yID0gRXJyb3JOb1BhcmFtczxcImFueU9mXCIsIEFueVNjaGVtYVtdPlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhbnlPZlwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBjb2RlOiB2YWxpZGF0ZVVuaW9uLFxuICBlcnJvcjoge21lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwifSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtTY2hlbWFDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcblxuZXhwb3J0IHR5cGUgT25lT2ZFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm9uZU9mXCIsXG4gIHtwYXNzaW5nU2NoZW1hczogW251bWJlciwgbnVtYmVyXSB8IG51bGx9LFxuICBBbnlTY2hlbWFbXVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgaWYgKGl0Lm9wdHMuZGlzY3JpbWluYXRvciAmJiBwYXJlbnRTY2hlbWEuZGlzY3JpbWluYXRvcikgcmV0dXJuXG4gICAgY29uc3Qgc2NoQXJyOiBBbnlTY2hlbWFbXSA9IHNjaGVtYVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICAgIGNvbnN0IHBhc3NpbmcgPSBnZW4ubGV0KFwicGFzc2luZ1wiLCBudWxsKVxuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcbiAgICBjeHQuc2V0UGFyYW1zKHtwYXNzaW5nfSlcbiAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuXG4gICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpXG5cbiAgICBjeHQucmVzdWx0KFxuICAgICAgdmFsaWQsXG4gICAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcih0cnVlKVxuICAgIClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoKTogdm9pZCB7XG4gICAgICBzY2hBcnIuZm9yRWFjaCgoc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgc2NoQ3h0OiBTY2hlbWFDeHQgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKSB7XG4gICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NoVmFsaWRcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBnZW5cbiAgICAgICAgICAgIC5pZihfYCR7c2NoVmFsaWR9ICYmICR7dmFsaWR9YClcbiAgICAgICAgICAgIC5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgICAgICAgLmFzc2lnbihwYXNzaW5nLCBfYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAuZWxzZSgpXG4gICAgICAgIH1cblxuICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSlcbiAgICAgICAgICBpZiAoc2NoQ3h0KSBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBOYW1lKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgaXR9ID0gY3h0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIHNjaGVtYS5mb3JFYWNoKChzY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHJldHVyblxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpfSwgdmFsaWQpXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KVxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBub3QsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgSWZLZXl3b3JkRXJyb3IgPSBFcnJvck9iamVjdDxcImlmXCIsIHtmYWlsaW5nS2V5d29yZDogc3RyaW5nfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXN9KSA9PiBzdHJgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImlmXCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJylcbiAgICB9XG4gICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpXG4gICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpXG4gICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKSByZXR1cm5cblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuICAgIHZhbGlkYXRlSWYoKVxuICAgIGN4dC5yZXNldCgpXG5cbiAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKVxuICAgICAgY3h0LnNldFBhcmFtcyh7aWZDbGF1c2V9KVxuICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKVxuICAgIH0gZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5pZihub3Qoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpXG4gICAgfVxuXG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSlcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBzY2hWYWxpZFxuICAgICAgKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkOiBzdHJpbmcsIGlmQ2xhdXNlPzogTmFtZSk6ICgpID0+IHZvaWQge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZH0sIHNjaFZhbGlkKVxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZClcbiAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZClcbiAgICAgICAgaWYgKGlmQ2xhdXNlKSBnZW4uYXNzaWduKGlmQ2xhdXNlLCBfYCR7a2V5d29yZH1gKVxuICAgICAgICBlbHNlIGN4dC5zZXRQYXJhbXMoe2lmQ2xhdXNlOiBrZXl3b3JkfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmZ1bmN0aW9uIGhhc1NjaGVtYShpdDogU2NoZW1hT2JqQ3h0LCBrZXl3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gIHJldHVybiBzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2NoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgY29kZSh7a2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdH06IEtleXdvcmRDeHQpIHtcbiAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JOb1BhcmFtcywgVm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBhZGRpdGlvbmFsSXRlbXMsIHtBZGRpdGlvbmFsSXRlbXNFcnJvcn0gZnJvbSBcIi4vYWRkaXRpb25hbEl0ZW1zXCJcbmltcG9ydCBwcmVmaXhJdGVtcyBmcm9tIFwiLi9wcmVmaXhJdGVtc1wiXG5pbXBvcnQgaXRlbXMgZnJvbSBcIi4vaXRlbXNcIlxuaW1wb3J0IGl0ZW1zMjAyMCwge0l0ZW1zRXJyb3J9IGZyb20gXCIuL2l0ZW1zMjAyMFwiXG5pbXBvcnQgY29udGFpbnMsIHtDb250YWluc0Vycm9yfSBmcm9tIFwiLi9jb250YWluc1wiXG5pbXBvcnQgZGVwZW5kZW5jaWVzLCB7RGVwZW5kZW5jaWVzRXJyb3J9IGZyb20gXCIuL2RlcGVuZGVuY2llc1wiXG5pbXBvcnQgcHJvcGVydHlOYW1lcywge1Byb3BlcnR5TmFtZXNFcnJvcn0gZnJvbSBcIi4vcHJvcGVydHlOYW1lc1wiXG5pbXBvcnQgYWRkaXRpb25hbFByb3BlcnRpZXMsIHtBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yfSBmcm9tIFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiXG5pbXBvcnQgcHJvcGVydGllcyBmcm9tIFwiLi9wcm9wZXJ0aWVzXCJcbmltcG9ydCBwYXR0ZXJuUHJvcGVydGllcyBmcm9tIFwiLi9wYXR0ZXJuUHJvcGVydGllc1wiXG5pbXBvcnQgbm90S2V5d29yZCwge05vdEtleXdvcmRFcnJvcn0gZnJvbSBcIi4vbm90XCJcbmltcG9ydCBhbnlPZiwge0FueU9mRXJyb3J9IGZyb20gXCIuL2FueU9mXCJcbmltcG9ydCBvbmVPZiwge09uZU9mRXJyb3J9IGZyb20gXCIuL29uZU9mXCJcbmltcG9ydCBhbGxPZiBmcm9tIFwiLi9hbGxPZlwiXG5pbXBvcnQgaWZLZXl3b3JkLCB7SWZLZXl3b3JkRXJyb3J9IGZyb20gXCIuL2lmXCJcbmltcG9ydCB0aGVuRWxzZSBmcm9tIFwiLi90aGVuRWxzZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpOiBWb2NhYnVsYXJ5IHtcbiAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAvLyBhbnlcbiAgICBub3RLZXl3b3JkLFxuICAgIGFueU9mLFxuICAgIG9uZU9mLFxuICAgIGFsbE9mLFxuICAgIGlmS2V5d29yZCxcbiAgICB0aGVuRWxzZSxcbiAgICAvLyBvYmplY3RcbiAgICBwcm9wZXJ0eU5hbWVzLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzLFxuICBdXG4gIC8vIGFycmF5XG4gIGlmIChkcmFmdDIwMjApIGFwcGxpY2F0b3IucHVzaChwcmVmaXhJdGVtcywgaXRlbXMyMDIwKVxuICBlbHNlIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXMsIGl0ZW1zKVxuICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnMpXG4gIHJldHVybiBhcHBsaWNhdG9yXG59XG5cbmV4cG9ydCB0eXBlIEFwcGxpY2F0b3JLZXl3b3JkRXJyb3IgPVxuICB8IEVycm9yTm9QYXJhbXM8XCJmYWxzZSBzY2hlbWFcIj5cbiAgfCBBZGRpdGlvbmFsSXRlbXNFcnJvclxuICB8IEl0ZW1zRXJyb3JcbiAgfCBDb250YWluc0Vycm9yXG4gIHwgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvclxuICB8IERlcGVuZGVuY2llc0Vycm9yXG4gIHwgSWZLZXl3b3JkRXJyb3JcbiAgfCBBbnlPZkVycm9yXG4gIHwgT25lT2ZFcnJvclxuICB8IE5vdEtleXdvcmRFcnJvclxuICB8IFByb3BlcnR5TmFtZXNFcnJvclxuIiwgImltcG9ydCB0eXBlIHtcbiAgQWRkZWRGb3JtYXQsXG4gIEZvcm1hdFZhbGlkYXRvcixcbiAgQXN5bmNGb3JtYXRWYWxpZGF0b3IsXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5pbCwgb3IsIENvZGUsIGdldFByb3BlcnR5LCByZWdleHBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxudHlwZSBGb3JtYXRWYWxpZGF0ZSA9XG4gIHwgRm9ybWF0VmFsaWRhdG9yPHN0cmluZz5cbiAgfCBGb3JtYXRWYWxpZGF0b3I8bnVtYmVyPlxuICB8IEFzeW5jRm9ybWF0VmFsaWRhdG9yPHN0cmluZz5cbiAgfCBBc3luY0Zvcm1hdFZhbGlkYXRvcjxudW1iZXI+XG4gIHwgUmVnRXhwXG4gIHwgc3RyaW5nXG4gIHwgdHJ1ZVxuXG5leHBvcnQgdHlwZSBGb3JtYXRFcnJvciA9IEVycm9yT2JqZWN0PFwiZm9ybWF0XCIsIHtmb3JtYXQ6IHN0cmluZ30sIHN0cmluZyB8IHskZGF0YTogc3RyaW5nfT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IG1hdGNoIGZvcm1hdCBcIiR7c2NoZW1hQ29kZX1cImAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQsIHJ1bGVUeXBlPzogc3RyaW5nKSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZn0gPSBpdFxuICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpIHJldHVyblxuXG4gICAgaWYgKCRkYXRhKSB2YWxpZGF0ZSREYXRhRm9ybWF0KClcbiAgICBlbHNlIHZhbGlkYXRlRm9ybWF0KClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKTogdm9pZCB7XG4gICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsIF9gJHtmbXRzfVske3NjaGVtYUNvZGV9XWApXG4gICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKVxuICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKVxuICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgZ2VuLmlmKFxuICAgICAgICBfYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsXG4gICAgICAgICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIF9gJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBfYCR7ZkRlZn0udmFsaWRhdGVgKSxcbiAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgX2BcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZilcbiAgICAgIClcbiAgICAgIGN4dC5mYWlsJGRhdGEob3IodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKVxuXG4gICAgICBmdW5jdGlvbiB1bmtub3duRm10KCk6IENvZGUge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSByZXR1cm4gbmlsXG4gICAgICAgIHJldHVybiBfYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWBcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpOiBDb2RlIHtcbiAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICA/IF9gKCR7ZkRlZn0uYXN5bmMgPyBhd2FpdCAke2Zvcm1hdH0oJHtkYXRhfSkgOiAke2Zvcm1hdH0oJHtkYXRhfSkpYFxuICAgICAgICAgIDogX2Ake2Zvcm1hdH0oJHtkYXRhfSlgXG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IF9gKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWBcbiAgICAgICAgcmV0dXJuIF9gJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZvcm1hdERlZjogQWRkZWRGb3JtYXQgfCB1bmRlZmluZWQgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXVxuICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgdW5rbm93bkZvcm1hdCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZilcbiAgICAgIGlmIChmbXRUeXBlID09PSBydWxlVHlwZSkgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSlcblxuICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpXG5cbiAgICAgICAgZnVuY3Rpb24gdW5rbm93bk1zZygpOiBzdHJpbmcge1xuICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYSBhcyBzdHJpbmd9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmOiBBZGRlZEZvcm1hdCk6IFtzdHJpbmcsIEZvcm1hdFZhbGlkYXRlLCBDb2RlXSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPVxuICAgICAgICAgIGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgPyByZWdleHBDb2RlKGZtdERlZilcbiAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgID8gX2Ake29wdHMuY29kZS5mb3JtYXRzfSR7Z2V0UHJvcGVydHkoc2NoZW1hKX1gXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge2tleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZX0pXG4gICAgICAgIGlmICh0eXBlb2YgZm10RGVmID09IFwib2JqZWN0XCIgJiYgIShmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsIF9gJHtmbXR9LnZhbGlkYXRlYF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCk6IENvZGUge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKVxuICAgICAgICAgIHJldHVybiBfYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyBfYCR7Zm10UmVmfSgke2RhdGF9KWAgOiBfYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYFxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgZm9ybWF0S2V5d29yZCBmcm9tIFwiLi9mb3JtYXRcIlxuXG5jb25zdCBmb3JtYXQ6IFZvY2FidWxhcnkgPSBbZm9ybWF0S2V5d29yZF1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0XG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi90eXBlc1wiXG5cbmV4cG9ydCBjb25zdCBtZXRhZGF0YVZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSBbXG4gIFwidGl0bGVcIixcbiAgXCJkZXNjcmlwdGlvblwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJkZXByZWNhdGVkXCIsXG4gIFwicmVhZE9ubHlcIixcbiAgXCJ3cml0ZU9ubHlcIixcbiAgXCJleGFtcGxlc1wiLFxuXVxuXG5leHBvcnQgY29uc3QgY29udGVudFZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSBbXG4gIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICBcImNvbnRlbnRTY2hlbWFcIixcbl1cbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCBjb3JlVm9jYWJ1bGFyeSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCB2YWxpZGF0aW9uVm9jYWJ1bGFyeSBmcm9tIFwiLi92YWxpZGF0aW9uXCJcbmltcG9ydCBnZXRBcHBsaWNhdG9yVm9jYWJ1bGFyeSBmcm9tIFwiLi9hcHBsaWNhdG9yXCJcbmltcG9ydCBmb3JtYXRWb2NhYnVsYXJ5IGZyb20gXCIuL2Zvcm1hdFwiXG5pbXBvcnQge21ldGFkYXRhVm9jYWJ1bGFyeSwgY29udGVudFZvY2FidWxhcnl9IGZyb20gXCIuL21ldGFkYXRhXCJcblxuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzOiBWb2NhYnVsYXJ5W10gPSBbXG4gIGNvcmVWb2NhYnVsYXJ5LFxuICB2YWxpZGF0aW9uVm9jYWJ1bGFyeSxcbiAgZ2V0QXBwbGljYXRvclZvY2FidWxhcnkoKSxcbiAgZm9ybWF0Vm9jYWJ1bGFyeSxcbiAgbWV0YWRhdGFWb2NhYnVsYXJ5LFxuICBjb250ZW50Vm9jYWJ1bGFyeSxcbl1cblxuZXhwb3J0IGRlZmF1bHQgZHJhZnQ3Vm9jYWJ1bGFyaWVzXG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuXG5leHBvcnQgZW51bSBEaXNjckVycm9yIHtcbiAgVGFnID0gXCJ0YWdcIixcbiAgTWFwcGluZyA9IFwibWFwcGluZ1wiLFxufVxuXG5leHBvcnQgdHlwZSBEaXNjckVycm9yT2JqPEUgZXh0ZW5kcyBEaXNjckVycm9yPiA9IEVycm9yT2JqZWN0PFxuICBcImRpc2NyaW1pbmF0b3JcIixcbiAge2Vycm9yOiBFOyB0YWc6IHN0cmluZzsgdGFnVmFsdWU6IHVua25vd259LFxuICBzdHJpbmdcbj5cbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBBbnlTY2hlbWFPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBnZXRQcm9wZXJ0eSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge0Rpc2NyRXJyb3IsIERpc2NyRXJyb3JPYmp9IGZyb20gXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCJcbmltcG9ydCB7cmVzb2x2ZVJlZiwgU2NoZW1hRW52fSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5pbXBvcnQge3NjaGVtYUhhc1J1bGVzQnV0UmVmfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgRGlzY3JpbWluYXRvckVycm9yID0gRGlzY3JFcnJvck9iajxEaXNjckVycm9yLlRhZz4gfCBEaXNjckVycm9yT2JqPERpc2NyRXJyb3IuTWFwcGluZz5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7ZGlzY3JFcnJvciwgdGFnTmFtZX19KSA9PlxuICAgIGRpc2NyRXJyb3IgPT09IERpc2NyRXJyb3IuVGFnXG4gICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtkaXNjckVycm9yLCB0YWcsIHRhZ05hbWV9fSkgPT5cbiAgICBfYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImRpc2NyaW1pbmF0b3JcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvbmVPZn0gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIilcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWVcbiAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpXG4gICAgaWYgKHNjaGVtYS5tYXBwaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIilcbiAgICBpZiAoIW9uZU9mKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpXG4gICAgY29uc3QgdGFnID0gZ2VuLmNvbnN0KFwidGFnXCIsIF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkodGFnTmFtZSl9YClcbiAgICBnZW4uaWYoXG4gICAgICBfYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsXG4gICAgICAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcihmYWxzZSwge2Rpc2NyRXJyb3I6IERpc2NyRXJyb3IuVGFnLCB0YWcsIHRhZ05hbWV9KVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcHBpbmcoKTogdm9pZCB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZygpXG4gICAgICBnZW4uaWYoZmFsc2UpXG4gICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgZ2VuLmVsc2VJZihfYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKVxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpXG4gICAgICB9XG4gICAgICBnZW4uZWxzZSgpXG4gICAgICBjeHQuZXJyb3IoZmFsc2UsIHtkaXNjckVycm9yOiBEaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZX0pXG4gICAgICBnZW4uZW5kSWYoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3A/OiBudW1iZXIpOiBOYW1lIHtcbiAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe2tleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcH0sIF92YWxpZClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIE5hbWUpXG4gICAgICByZXR1cm4gX3ZhbGlkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpOiB7W1QgaW4gc3RyaW5nXT86IG51bWJlcn0ge1xuICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nOiB7W1QgaW4gc3RyaW5nXT86IG51bWJlcn0gPSB7fVxuICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpXG4gICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzY2ggPSBvbmVPZltpXVxuICAgICAgICBpZiAoc2NoPy4kcmVmICYmICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2gsIGl0LnNlbGYuUlVMRVMpKSB7XG4gICAgICAgICAgc2NoID0gcmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHNjaD8uJHJlZilcbiAgICAgICAgICBpZiAoc2NoIGluc3RhbmNlb2YgU2NoZW1hRW52KSBzY2ggPSBzY2guc2NoZW1hXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcFNjaCA9IHNjaD8ucHJvcGVydGllcz8uW3RhZ05hbWVdXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRhZ1JlcXVpcmVkID0gdGFnUmVxdWlyZWQgJiYgKHRvcFJlcXVpcmVkIHx8IGhhc1JlcXVpcmVkKHNjaCkpXG4gICAgICAgIGFkZE1hcHBpbmdzKHByb3BTY2gsIGkpXG4gICAgICB9XG4gICAgICBpZiAoIXRhZ1JlcXVpcmVkKSB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgcmVxdWlyZWRgKVxuICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZ1xuXG4gICAgICBmdW5jdGlvbiBoYXNSZXF1aXJlZCh7cmVxdWlyZWR9OiBBbnlTY2hlbWFPYmplY3QpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaDogQW55U2NoZW1hT2JqZWN0LCBpOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgIGFkZE1hcHBpbmcoc2NoLmNvbnN0LCBpKVxuICAgICAgICB9IGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBvZiBzY2guZW51bSkge1xuICAgICAgICAgICAgYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWU6IHVua25vd24sIGk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUgc3RyaW5nc2ApXG4gICAgICAgIH1cbiAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgIntcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwiJGlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJDb3JlIHNjaGVtYSBtZXRhLXNjaGVtYVwiLFxuICBcImRlZmluaXRpb25zXCI6IHtcbiAgICBcInNjaGVtYUFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiOiB7XG4gICAgICBcImFsbE9mXCI6IFt7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sIHtcImRlZmF1bHRcIjogMH1dXG4gICAgfSxcbiAgICBcInNpbXBsZVR5cGVzXCI6IHtcbiAgICAgIFwiZW51bVwiOiBbXCJhcnJheVwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcIm9iamVjdFwiLCBcInN0cmluZ1wiXVxuICAgIH0sXG4gICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IFtdXG4gICAgfVxuICB9LFxuICBcInR5cGVcIjogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgfSxcbiAgICBcIiRyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkY29tbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJ0aXRsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgXCJyZWFkT25seVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZXhhbXBsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtdWx0aXBsZU9mXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtYXhMZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluTGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsSXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJpdGVtc1wiOiB7XG4gICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIFwibWF4SXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluSXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJ1bmlxdWVJdGVtc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiY29udGFpbnNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pblByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJyZXF1aXJlZFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCJmb3JtYXRcIjogXCJyZWdleFwifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9XVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiY29uc3RcIjogdHJ1ZSxcbiAgICBcImVudW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImlmXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwidGhlblwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImVsc2VcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJhbGxPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcImFueU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwib25lT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJub3RcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgfSxcbiAgXCJkZWZhdWx0XCI6IHRydWVcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgQWp2Q29yZSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCBkcmFmdDdWb2NhYnVsYXJpZXMgZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiXG5pbXBvcnQgZGlzY3JpbWluYXRvciBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvclwiXG5pbXBvcnQgKiBhcyBkcmFmdDdNZXRhU2NoZW1hIGZyb20gXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiXG5cbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl1cblxuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hXCJcblxuY2xhc3MgQWp2IGV4dGVuZHMgQWp2Q29yZSB7XG4gIF9hZGRWb2NhYnVsYXJpZXMoKTogdm9pZCB7XG4gICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpXG4gICAgZHJhZnQ3Vm9jYWJ1bGFyaWVzLmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSlcbiAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yKVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk6IHZvaWQge1xuICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpXG4gICAgaWYgKCF0aGlzLm9wdHMubWV0YSkgcmV0dXJuXG4gICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYVxuICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpXG4gICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRFxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pXG5cbmV4cG9ydCBkZWZhdWx0IEFqdlxuXG5leHBvcnQge1xuICBGb3JtYXQsXG4gIEZvcm1hdERlZmluaXRpb24sXG4gIEFzeW5jRm9ybWF0RGVmaW5pdGlvbixcbiAgS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxuICBWb2NhYnVsYXJ5LFxuICBTY2hlbWEsXG4gIFNjaGVtYU9iamVjdCxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBBc3luY1NjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIFNjaGVtYVZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBFcnJvck5vUGFyYW1zLFxufSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCB7UGx1Z2luLCBPcHRpb25zLCBDb2RlT3B0aW9ucywgSW5zdGFuY2VPcHRpb25zLCBMb2dnZXIsIEVycm9yc1RleHRPcHRpb25zfSBmcm9tIFwiLi9jb3JlXCJcbmV4cG9ydCB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuL2NvbXBpbGVcIlxuZXhwb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlXCJcbmV4cG9ydCB7RGVmaW5lZEVycm9yfSBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZXJyb3JzXCJcbmV4cG9ydCB7SlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuZXhwb3J0IHtKU09OU2NoZW1hVHlwZX0gZnJvbSBcIi4vdHlwZXMvanNvbi1zY2hlbWFcIlxuZXhwb3J0IHtfLCBzdHIsIHN0cmluZ2lmeSwgbmlsLCBOYW1lLCBDb2RlLCBDb2RlR2VuLCBDb2RlR2VuT3B0aW9uc30gZnJvbSBcIi4vY29tcGlsZS9jb2RlZ2VuXCJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWYWxpZGF0aW9uRXJyb3J9IGZyb20gXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiXG5leHBvcnQge2RlZmF1bHQgYXMgTWlzc2luZ1JlZkVycm9yfSBmcm9tIFwiLi9jb21waWxlL3JlZl9lcnJvclwiXG4iLCBudWxsLCBudWxsLCBudWxsLCAiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94XG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAyMyBIYXlkbiBQYXRlcnNvbiAoc2luY2xhaXIpIDxoYXlkbi5kZXZlbG9wZXJAZ21haWwuY29tPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGUgPSBleHBvcnRzLlN0YW5kYXJkVHlwZSA9IGV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IGV4cG9ydHMuU3RhbmRhcmRUeXBlQnVpbGRlciA9IGV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gZXhwb3J0cy5VbmlvblJlc29sdmVyID0gZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gZXhwb3J0cy5LZXlSZXNvbHZlciA9IGV4cG9ydHMuT2JqZWN0TWFwID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBleHBvcnRzLlR5cGVDbG9uZSA9IGV4cG9ydHMuVHlwZUV4dGVuZHMgPSBleHBvcnRzLlR5cGVFeHRlbmRzUmVzdWx0ID0gZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gZXhwb3J0cy5UeXBlR3VhcmQgPSBleHBvcnRzLlR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgPSBleHBvcnRzLkZvcm1hdFJlZ2lzdHJ5ID0gZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA9IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbkV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9IGV4cG9ydHMuS2luZCA9IGV4cG9ydHMuSGludCA9IGV4cG9ydHMuTW9kaWZpZXIgPSB2b2lkIDA7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3ltYm9sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuTW9kaWZpZXIgPSBTeW1ib2wuZm9yKCdUeXBlQm94Lk1vZGlmaWVyJyk7XG5leHBvcnRzLkhpbnQgPSBTeW1ib2wuZm9yKCdUeXBlQm94LkhpbnQnKTtcbmV4cG9ydHMuS2luZCA9IFN5bWJvbC5mb3IoJ1R5cGVCb3guS2luZCcpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhdHRlcm5zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9ICcodHJ1ZXxmYWxzZSknO1xuZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gJygwfFsxLTldWzAtOV0qKSc7XG5leHBvcnRzLlBhdHRlcm5TdHJpbmcgPSAnKC4qKSc7XG5leHBvcnRzLlBhdHRlcm5Cb29sZWFuRXhhY3QgPSBgXiR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn0kYDtcbmV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVybk51bWJlcn0kYDtcbmV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVyblN0cmluZ30kYDtcbi8qKiBBIHJlZ2lzdHJ5IGZvciB1c2VyIGRlZmluZWQgdHlwZXMgKi9cbnZhciBUeXBlUmVnaXN0cnk7XG4oZnVuY3Rpb24gKFR5cGVSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkVudHJpZXMgPSBFbnRyaWVzO1xuICAgIC8qKiBDbGVhcnMgYWxsIHVzZXIgZGVmaW5lZCB0eXBlcyAqL1xuICAgIGZ1bmN0aW9uIENsZWFyKCkge1xuICAgICAgICByZXR1cm4gbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5DbGVhciA9IENsZWFyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWdpc3RyeSBjb250YWlucyB0aGlzIGtpbmQgKi9cbiAgICBmdW5jdGlvbiBIYXMoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBTZXQoa2luZCwgZnVuYykge1xuICAgICAgICBtYXAuc2V0KGtpbmQsIGZ1bmMpO1xuICAgIH1cbiAgICBUeXBlUmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBHZXQoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmdldChraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkdldCA9IEdldDtcbn0pKFR5cGVSZWdpc3RyeSB8fCAoZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBUeXBlUmVnaXN0cnkgPSB7fSkpO1xuLyoqIEEgcmVnaXN0cnkgZm9yIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0cyAqL1xudmFyIEZvcm1hdFJlZ2lzdHJ5O1xuKGZ1bmN0aW9uIChGb3JtYXRSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuRW50cmllcyA9IEVudHJpZXM7XG4gICAgLyoqIENsZWFycyBhbGwgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXRzICovXG4gICAgZnVuY3Rpb24gQ2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBtYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuQ2xlYXIgPSBDbGVhcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCBleGlzdHMgKi9cbiAgICBmdW5jdGlvbiBIYXMoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBtYXAuaGFzKGZvcm1hdCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBTZXQoZm9ybWF0LCBmdW5jKSB7XG4gICAgICAgIG1hcC5zZXQoZm9ybWF0LCBmdW5jKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCAqL1xuICAgIGZ1bmN0aW9uIEdldChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoZm9ybWF0KTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuR2V0ID0gR2V0O1xufSkoRm9ybWF0UmVnaXN0cnkgfHwgKGV4cG9ydHMuRm9ybWF0UmVnaXN0cnkgPSBGb3JtYXRSZWdpc3RyeSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUd1YXJkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1R5cGVHdWFyZDogVW5rbm93biB0eXBlJyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciA9IFR5cGVHdWFyZFVua25vd25UeXBlRXJyb3I7XG4vKiogUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHRlc3QgaWYgSmF2YVNjcmlwdCB2YWx1ZXMgYXJlIFR5cGVCb3ggdHlwZXMgKi9cbnZhciBUeXBlR3VhcmQ7XG4oZnVuY3Rpb24gKFR5cGVHdWFyZCkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA+PSA3ICYmIGNvZGUgPD0gMTMpIHx8IGNvZGUgPT09IDI3IHx8IGNvZGUgPT09IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBZGRpdGlvbmFsUHJvcGVydGllcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXNPcHRpb25hbEJvb2xlYW4odmFsdWUpIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0JpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGdsb2JhbFRoaXMuTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEJpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc0JpZ0ludCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzQm9vbGVhbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSAmJiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSAmJiBJc1BhdHRlcm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEZvcm1hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkgJiYgSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU2NoZW1hKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEFueSAqL1xuICAgIGZ1bmN0aW9uIFRBbnkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQW55JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFueSA9IFRBbnk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0FycmF5JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW1zKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCb29sZWFuKHNjaGVtYS51bmlxdWVJdGVtcykpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFycmF5ID0gVEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQmlnSW50ICovXG4gICAgZnVuY3Rpb24gVEJpZ0ludChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdCaWdJbnQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnQmlnSW50JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCaWdJbnQgPSBUQmlnSW50O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQm9vbGVhbiAqL1xuICAgIGZ1bmN0aW9uIFRCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0Jvb2xlYW4nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCb29sZWFuID0gVEJvb2xlYW47XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRDb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIFRDb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRDb25zdHJ1Y3RvciA9IFRDb25zdHJ1Y3RvcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVERhdGUgKi9cbiAgICBmdW5jdGlvbiBURGF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0RhdGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRGF0ZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW1UaW1lc3RhbXApICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW1UaW1lc3RhbXApKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlREYXRlID0gVERhdGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRGdW5jdGlvbiAqL1xuICAgIGZ1bmN0aW9uIFRGdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRGdW5jdGlvbiA9IFRGdW5jdGlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVnZXIgKi9cbiAgICBmdW5jdGlvbiBUSW50ZWdlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVnZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2ludGVnZXInICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heGltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEludGVnZXIgPSBUSW50ZWdlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVyc2VjdCAqL1xuICAgIGZ1bmN0aW9uIFRJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcgJiZcbiAgICAgICAgICAgIElzQXJyYXkoc2NoZW1hLmFsbE9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEudHlwZSkgJiZcbiAgICAgICAgICAgIChJc09wdGlvbmFsQm9vbGVhbihzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBJc09wdGlvbmFsU2NoZW1hKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMpKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3R5cGUnIGluIHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5USW50ZXJzZWN0ID0gVEludGVyc2VjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEtpbmQgKi9cbiAgICBmdW5jdGlvbiBUS2luZChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0KHNjaGVtYSkgJiYgZXhwb3J0cy5LaW5kIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdzdHJpbmcnOyAvLyBUUyA0LjEuNTogYW55IHJlcXVpcmVkIGZvciBzeW1ib2wgaW5kZXhlclxuICAgIH1cbiAgICBUeXBlR3VhcmQuVEtpbmQgPSBUS2luZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWw8c3RyaW5nPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTGl0ZXJhbFN0cmluZyA9IFRMaXRlcmFsU3RyaW5nO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbDxudW1iZXI+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxOdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTGl0ZXJhbCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsTnVtYmVyID0gVExpdGVyYWxOdW1iZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRMaXRlcmFsPGJvb2xlYW4+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWxCb29sZWFuID0gVExpdGVyYWxCb29sZWFuO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbCAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpIHx8IFRMaXRlcmFsQm9vbGVhbihzY2hlbWEpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWwgPSBUTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5ldmVyICovXG4gICAgZnVuY3Rpb24gVE5ldmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ05ldmVyJyAmJiBJc09iamVjdChzY2hlbWEubm90KSAmJiBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROZXZlciA9IFROZXZlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5vdCAqL1xuICAgIGZ1bmN0aW9uIFROb3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90JyAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEubm90KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTm90ID0gVE5vdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE51bGwgKi9cbiAgICBmdW5jdGlvbiBUTnVsbChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOdWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTnVsbCA9IFROdWxsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTnVtYmVyICovXG4gICAgZnVuY3Rpb24gVE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROdW1iZXIgPSBUTnVtYmVyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUT2JqZWN0ICovXG4gICAgZnVuY3Rpb24gVE9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT2JqZWN0KHNjaGVtYS5wcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4UHJvcGVydGllcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAoIUlzQ29udHJvbENoYXJhY3RlckZyZWUoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPYmplY3QgPSBUT2JqZWN0O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUHJvbWlzZSAqL1xuICAgIGZ1bmN0aW9uIFRQcm9taXNlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnUHJvbWlzZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRQcm9taXNlID0gVFByb21pc2U7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWNvcmQgKi9cbiAgICBmdW5jdGlvbiBUUmVjb3JkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdSZWNvcmQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPYmplY3Qoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1BhdHRlcm4oa2V5c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVRTY2hlbWEoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2tleXNbMF1dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlY29yZCA9IFRSZWNvcmQ7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWYgKi9cbiAgICBmdW5jdGlvbiBUUmVmKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1JlZicgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzU3RyaW5nKHNjaGVtYS4kcmVmKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUmVmID0gVFJlZjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN0cmluZyAqL1xuICAgIGZ1bmN0aW9uIFRTdHJpbmcoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdTdHJpbmcnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heExlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxQYXR0ZXJuKHNjaGVtYS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEZvcm1hdChzY2hlbWEuZm9ybWF0KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU3RyaW5nID0gVFN0cmluZztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN5bWJvbCAqL1xuICAgIGZ1bmN0aW9uIFRTeW1ib2woc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnU3ltYm9sJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGVPZiA9PT0gJ1N5bWJvbCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFN5bWJvbCA9IFRTeW1ib2w7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRUZW1wbGF0ZUxpdGVyYWwgKi9cbiAgICBmdW5jdGlvbiBUVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RlbXBsYXRlTGl0ZXJhbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgSXNTdHJpbmcoc2NoZW1hLnBhdHRlcm4pICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVyblswXSA9PT0gJ14nICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVybltzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJyQnKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwgPSBUVGVtcGxhdGVMaXRlcmFsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVGhpcyAqL1xuICAgIGZ1bmN0aW9uIFRUaGlzKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RoaXMnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc1N0cmluZyhzY2hlbWEuJHJlZikpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFRoaXMgPSBUVGhpcztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFR1cGxlICovXG4gICAgZnVuY3Rpb24gVFR1cGxlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUdXBsZScgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWF4SXRlbXMpICYmXG4gICAgICAgICAgICBzY2hlbWEubWluSXRlbXMgPT09IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgJiYgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5taW5JdGVtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVHVwbGUgPSBUVHVwbGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmRlZmluZWQgKi9cbiAgICBmdW5jdGlvbiBUVW5kZWZpbmVkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdVbmRlZmluZWQnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmRlZmluZWQgPSBUVW5kZWZpbmVkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5pb248TGl0ZXJhbDxzdHJpbmcgfCBudW1iZXI+W10+ICovXG4gICAgZnVuY3Rpb24gVFVuaW9uTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRVbmlvbihzY2hlbWEpICYmIHNjaGVtYS5hbnlPZi5ldmVyeSgoc2NoZW1hKSA9PiBUTGl0ZXJhbFN0cmluZyhzY2hlbWEpIHx8IFRMaXRlcmFsTnVtYmVyKHNjaGVtYSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbCA9IFRVbmlvbkxpdGVyYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmlvbiAqL1xuICAgIGZ1bmN0aW9uIFRVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5hbnlPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uID0gVFVuaW9uO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVWludDhBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRVaW50OEFycmF5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VpbnQ4QXJyYXknICYmIHNjaGVtYS50eXBlID09PSAnb2JqZWN0JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnVWludDhBcnJheScgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluQnl0ZUxlbmd0aCkgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4Qnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVWludDhBcnJheSA9IFRVaW50OEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5rbm93biAqL1xuICAgIGZ1bmN0aW9uIFRVbmtub3duKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vua25vd24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmtub3duID0gVFVua25vd247XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIGEgcmF3IFRVbnNhZmUgKi9cbiAgICBmdW5jdGlvbiBUVW5zYWZlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vuc2FmZScpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuc2FmZSA9IFRVbnNhZmU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRWb2lkICovXG4gICAgZnVuY3Rpb24gVFZvaWQoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVm9pZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdWb2lkJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVm9pZCA9IFRWb2lkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzY2hlbWEgaGFzIHRoZSBSZWFkb25seU9wdGlvbmFsIG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVFJlYWRvbmx5T3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5T3B0aW9uYWwnO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlYWRvbmx5T3B0aW9uYWwgPSBUUmVhZG9ubHlPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgUmVhZG9ubHkgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUUmVhZG9ubHkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5JztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWFkb25seSA9IFRSZWFkb25seTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgT3B0aW9uYWwgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ09wdGlvbmFsJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPcHRpb25hbCA9IFRPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFRTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIChUQW55KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRCb29sZWFuKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQmlnSW50KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQ29uc3RydWN0b3Ioc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFREYXRlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBURnVuY3Rpb24oc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRJbnRlZ2VyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUSW50ZXJzZWN0KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTGl0ZXJhbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE5ldmVyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTm90KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTnVsbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE51bWJlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE9iamVjdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFByb21pc2Uoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWNvcmQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWYoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTdHJpbmcoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTeW1ib2woc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUaGlzKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVHVwbGUoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmRlZmluZWQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmlvbihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFVpbnQ4QXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmtub3duKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5zYWZlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVm9pZChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgKFRLaW5kKHNjaGVtYSkgJiYgVHlwZVJlZ2lzdHJ5LkhhcyhzY2hlbWFbZXhwb3J0cy5LaW5kXSkpKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU2NoZW1hID0gVFNjaGVtYTtcbn0pKFR5cGVHdWFyZCB8fCAoZXhwb3J0cy5UeXBlR3VhcmQgPSBUeXBlR3VhcmQgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZHNVbmRlZmluZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogRmFzdCB1bmRlZmluZWQgY2hlY2sgdXNlZCBmb3IgcHJvcGVydGllcyBvZiB0eXBlIHVuZGVmaW5lZCAqL1xudmFyIEV4dGVuZHNVbmRlZmluZWQ7XG4oZnVuY3Rpb24gKEV4dGVuZHNVbmRlZmluZWQpIHtcbiAgICBmdW5jdGlvbiBDaGVjayhzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gIUNoZWNrKHNjaGVtYS5ub3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3QuYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gQ2hlY2soc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiB1bmlvbi5hbnlPZi5zb21lKChzY2hlbWEpID0+IENoZWNrKHNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgRXh0ZW5kc1VuZGVmaW5lZC5DaGVjayA9IENoZWNrO1xufSkoRXh0ZW5kc1VuZGVmaW5lZCB8fCAoZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gRXh0ZW5kc1VuZGVmaW5lZCA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUV4dGVuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVHlwZUV4dGVuZHNSZXN1bHQ7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzUmVzdWx0KSB7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJVbmlvblwiXSA9IDBdID0gXCJVbmlvblwiO1xuICAgIFR5cGVFeHRlbmRzUmVzdWx0W1R5cGVFeHRlbmRzUmVzdWx0W1wiVHJ1ZVwiXSA9IDFdID0gXCJUcnVlXCI7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJGYWxzZVwiXSA9IDJdID0gXCJGYWxzZVwiO1xufSkoVHlwZUV4dGVuZHNSZXN1bHQgfHwgKGV4cG9ydHMuVHlwZUV4dGVuZHNSZXN1bHQgPSBUeXBlRXh0ZW5kc1Jlc3VsdCA9IHt9KSk7XG52YXIgVHlwZUV4dGVuZHM7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJbnRvQm9vbGVhblJlc3VsdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50b0Jvb2xlYW5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFueVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQW55UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFueShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpICYmIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVHlwZUd1YXJkLlRBbnkoc2NoZW1hKSB8fCBUeXBlR3VhcmQuVFVua25vd24oc2NoZW1hKSkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQXJyYXlSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQXJyYXkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkgJiYgSXNPYmplY3RBcnJheUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRBcnJheShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0Lml0ZW1zLCByaWdodC5pdGVtcykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpZ0ludFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQmlnSW50KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQmlnSW50KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb29sZWFuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiB0eXBlb2YgbGVmdC5jb25zdCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJvb2xlYW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UQ29uc3RydWN0b3IocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5wYXJhbWV0ZXJzLmxlbmd0aCA+IHJpZ2h0LnBhcmFtZXRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoIWxlZnQucGFyYW1ldGVycy5ldmVyeSgoc2NoZW1hLCBpbmRleCkgPT4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQocmlnaHQucGFyYW1ldGVyc1tpbmRleF0sIHNjaGVtYSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LnJldHVybnMsIHJpZ2h0LnJldHVybnMpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBEYXRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVERhdGUocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBGdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRGdW5jdGlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChsZWZ0LnBhcmFtZXRlcnMubGVuZ3RoID4gcmlnaHQucGFyYW1ldGVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmICghbGVmdC5wYXJhbWV0ZXJzLmV2ZXJ5KChzY2hlbWEsIGluZGV4KSA9PiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChyaWdodC5wYXJhbWV0ZXJzW2luZGV4XSwgc2NoZW1hKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQucmV0dXJucywgcmlnaHQucmV0dXJucykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEludGVnZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdW1iZXIobGVmdCkgfHwgVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlZ2VyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkgfHwgVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVyc2VjdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFsbE9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KGxlZnQsIHNjaGVtYSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuYWxsT2Yuc29tZSgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTGl0ZXJhbE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0xpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRMaXRlcmFsKHJpZ2h0KSAmJiByaWdodC5jb25zdCA9PT0gbGVmdC5jb25zdCA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOZXZlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gTmV2ZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5ldmVyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE5vdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW53cmFwTm90KHNjaGVtYSkge1xuICAgICAgICBsZXQgW2N1cnJlbnQsIGRlcHRoXSA9IFtzY2hlbWEsIDBdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFUeXBlR3VhcmQuVE5vdChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5vdDtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoICUgMiA9PT0gMCA/IGN1cnJlbnQgOiBleHBvcnRzLlR5cGUuVW5rbm93bigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOb3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBoYXMgbm8gY29uY2VwdCBvZiBuZWdhdGVkIHR5cGVzLCBhbmQgYXR0ZW1wdHMgdG8gY29ycmVjdGx5IGNoZWNrIHRoZSBuZWdhdGVkXG4gICAgICAgIC8vIHR5cGUgYXQgcnVudGltZSB3b3VsZCBwdXQgVHlwZUJveCBhdCBvZGRzIHdpdGggVHlwZVNjcmlwdHMgYWJpbGl0eSB0byBzdGF0aWNhbGx5IGluZmVyXG4gICAgICAgIC8vIHRoZSB0eXBlLiBJbnN0ZWFkIHdlIHVud3JhcCB0byBlaXRoZXIgdW5rbm93biBvciBUIGFuZCBjb250aW51ZSBldmFsdWF0aW5nLlxuICAgICAgICBpZiAoVHlwZUd1YXJkLlROb3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQoVW53cmFwTm90KGxlZnQpLCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5vdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVW53cmFwTm90KHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIE5vdGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE51bGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bGwobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdWxsKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOdW1iZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsTnVtYmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSB8fCBUeXBlR3VhcmQuVEludGVnZXIobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE51bWJlcihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBPYmplY3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPT09IGNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN0cmluZ0xpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdEFycmF5TGlrZShzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN5bWJvbExpa2Uoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICdkZXNjcmlwdGlvbicgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbikgJiYgc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2YubGVuZ3RoID09PSAyICYmICgoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMF0pICYmXG4gICAgICAgICAgICBUeXBlR3VhcmQuVFVuZGVmaW5lZChzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkpIHx8IChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkgJiZcbiAgICAgICAgICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzBdKSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3ROdW1iZXJMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Qm9vbGVhbkxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RCaWdJbnRMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RGF0ZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RVaW50OEFycmF5TGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RnVuY3Rpb25MaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvbWlzZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHRoZW4gPSBleHBvcnRzLlR5cGUuRnVuY3Rpb24oW2V4cG9ydHMuVHlwZS5BbnkoKV0sIGV4cG9ydHMuVHlwZS5BbnkoKSk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ3RoZW4nIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHNjaGVtYS5wcm9wZXJ0aWVzWyd0aGVuJ10sIHRoZW4pKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvcGVydHlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFByb3BlcnR5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChWaXNpdChsZWZ0LCByaWdodCkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPcHRpb25hbChsZWZ0KSAmJiAhVHlwZUd1YXJkLlRPcHRpb25hbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3RSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxOdW1iZXIobGVmdCkgJiYgSXNPYmplY3ROdW1iZXJMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQmlnSW50KGxlZnQpICYmIElzT2JqZWN0QmlnSW50TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpICYmIElzT2JqZWN0TnVtYmVyTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSAmJiBJc09iamVjdE51bWJlckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVWludDhBcnJheShsZWZ0KSAmJiBJc09iamVjdFVpbnQ4QXJyYXlMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpICYmIElzT2JqZWN0RGF0ZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVENvbnN0cnVjdG9yKGxlZnQpICYmIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSAmJiBJc09iamVjdEZ1bmN0aW9uTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpICYmIFR5cGVHdWFyZC5UU3RyaW5nKFJlY29yZEtleShsZWZ0KSkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZXhwcmVzc2luZyBhIFJlY29yZCB3aXRoIGxpdGVyYWwga2V5IHZhbHVlcywgdGhlIFJlY29yZCBpcyBjb252ZXJ0ZWQgaW50byBhIE9iamVjdCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgSGludCBhc3NpZ25lZCBhcyBgUmVjb3JkYC4gVGhpcyBpcyB1c2VkIHRvIGludmVydCB0aGUgZXh0ZW5kcyBsb2dpYy5cbiAgICAgICAgICAgIHJldHVybiByaWdodFtleHBvcnRzLkhpbnRdID09PSAnUmVjb3JkJyA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoUmVjb3JkS2V5KGxlZnQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChyaWdodCwgMCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhyaWdodC5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGxlZnQucHJvcGVydGllcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICAgICAgaWYgKFByb3BlcnR5KGxlZnQucHJvcGVydGllc1trZXldLCByaWdodC5wcm9wZXJ0aWVzW2tleV0pID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcm9taXNlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBQcm9taXNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpICYmIElzT2JqZWN0UHJvbWlzZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRQcm9taXNlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQuaXRlbSwgcmlnaHQuaXRlbSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlY29yZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gUmVjb3JkS2V5KHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuU3RyaW5nKCk7XG4gICAgICAgIHRocm93IEVycm9yKCdUeXBlRXh0ZW5kczogQ2Fubm90IGdldCByZWNvcmQga2V5Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZFZhbHVlKHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1tleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdF07XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2V4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0XTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVFeHRlbmRzOiBDYW5ub3QgZ2V0IHJlY29yZCB2YWx1ZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBLZXkgPSBSZWNvcmRLZXkocmlnaHQpO1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxTdHJpbmcobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LCBWYWx1ZSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVpbnQ4QXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFZhbHVlKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChsZWZ0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhsZWZ0LnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFByb3BlcnR5KFZhbHVlLCBsZWZ0LnByb3BlcnRpZXNba2V5XSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKGxlZnQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gVmlzaXQoVmFsdWUsIFJlY29yZFZhbHVlKHJpZ2h0KSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN0cmluZyhsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3ltYm9sXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTeW1ib2wobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTeW1ib2wocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRlbXBsYXRlTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vIFRlbXBsYXRlTGl0ZXJhbCB0eXBlcyBhcmUgcmVzb2x2ZWQgdG8gZWl0aGVyIHVuaW9ucyBmb3IgZmluaXRlIGV4cHJlc3Npb25zIG9yIHN0cmluZ1xuICAgICAgICAvLyBmb3IgaW5maW5pdGUgZXhwcmVzc2lvbnMuIEhlcmUgd2UgY2FsbCB0byBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciB0byByZXNvbHZlIGZvclxuICAgICAgICAvLyBlaXRoZXIgdHlwZSBhbmQgY29udGludWUgZXZhbHVhdGluZy5cbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUobGVmdCksIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIFRlbXBsYXRlTGl0ZXJhbGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFR1cGxlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBUdXBsZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5T2ZUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRBcnJheShyaWdodCkgJiYgbGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCByaWdodC5pdGVtcykgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSAmJiBJc09iamVjdEFycmF5TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpICYmIElzQXJyYXlPZlR1cGxlKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UVHVwbGUocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoKGxlZnQuaXRlbXMgPT09IHVuZGVmaW5lZCAmJiByaWdodC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB8fCAobGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSwgaW5kZXgpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQuaXRlbXNbaW5kZXhdKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVWludDhBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVWludDhBcnJheShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVaW50OEFycmF5KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmRlZmluZWRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuZGVmaW5lZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFZvaWQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5pb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVmlzaXQobGVmdCwgc2NoZW1hKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmFueU9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmtub3duXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGVSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBWb2lkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBWb2lkUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5kZWZpbmVkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFZvaWQocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChsZWZ0LCByaWdodCkge1xuICAgICAgICAvLyBSZXNvbHZhYmxlIFR5cGVzXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSB8fCBUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTm90KGxlZnQpIHx8IFR5cGVHdWFyZC5UTm90KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOb3QobGVmdCwgcmlnaHQpO1xuICAgICAgICAvLyBTdGFuZGFyZCBUeXBlc1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQW55KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCaWdJbnQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQ29uc3RydWN0b3IobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIERhdGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIExpdGVyYWwobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bGwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTnVsbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTeW1ib2wobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVHVwbGUobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRQcm9taXNlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVaW50OEFycmF5KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmRlZmluZWQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5kZWZpbmVkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRWb2lkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aHJvdyBFcnJvcihgVHlwZUV4dGVuZHM6IFVua25vd24gbGVmdCB0eXBlIG9wZXJhbmQgJyR7bGVmdFtleHBvcnRzLktpbmRdfSdgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRXh0ZW5kcyhsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBUeXBlRXh0ZW5kcy5FeHRlbmRzID0gRXh0ZW5kcztcbn0pKFR5cGVFeHRlbmRzIHx8IChleHBvcnRzLlR5cGVFeHRlbmRzID0gVHlwZUV4dGVuZHMgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVDbG9uZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBTcGVjaWFsaXplZCBDbG9uZSBmb3IgVHlwZXMgKi9cbnZhciBUeXBlQ2xvbmU7XG4oZnVuY3Rpb24gKFR5cGVDbG9uZSkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2YWx1ZSkgPT4gVmlzaXQodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFByb3BlcnRpZXMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtrZXldOiBWaXNpdCh2YWx1ZVtrZXldKSB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFN5bWJvbHMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IFZpc2l0KHZhbHVlW2tleV0pIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2xvbmVkUHJvcGVydGllcywgLi4uY2xvbmVkU3ltYm9scyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdCh2YWx1ZSkge1xuICAgICAgICBpZiAoSXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoSXNPYmplY3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIENsb25lcyBhIHR5cGUuICovXG4gICAgZnVuY3Rpb24gQ2xvbmUoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KHNjaGVtYSksIC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgVHlwZUNsb25lLkNsb25lID0gQ2xvbmU7XG59KShUeXBlQ2xvbmUgfHwgKGV4cG9ydHMuVHlwZUNsb25lID0gVHlwZUNsb25lID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbmRleGVkQWNjZXNzb3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgSW5kZXhlZEFjY2Vzc29yO1xuKGZ1bmN0aW9uIChJbmRleGVkQWNjZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBPcHRpb25hbFVud3JhcChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXAoKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBbZXhwb3J0cy5Nb2RpZmllcl06IF8sIC4uLmNsb25lIH0gPSBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0ludGVyc2VjdE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmV2ZXJ5KChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVW5pb25PcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zb21lKChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gSXNJbnRlcnNlY3RPcHRpb25hbChzY2hlbWEuYWxsT2YpO1xuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBleHBvcnRzLlR5cGUuT3B0aW9uYWwoZXhwb3J0cy5UeXBlLkludGVyc2VjdChPcHRpb25hbFVud3JhcChzY2hlbWEuYWxsT2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBJc1VuaW9uT3B0aW9uYWwoc2NoZW1hLmFueU9mKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gZXhwb3J0cy5UeXBlLk9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihPcHRpb25hbFVud3JhcChzY2hlbWEuYW55T2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlSW50ZXJzZWN0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlVW5pb24oc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWQgPSBWaXNpdChzY2hlbWEsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZFtleHBvcnRzLktpbmRdID09PSAnTmV2ZXInID8gYWNjIDogWy4uLmFjYywgaW5kZXhlZF07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHJlc29sdmVkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGtleSkpO1xuICAgICAgICByZXR1cm4gUmVzb2x2ZU9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihyZXNvbHZlZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzY2hlbWEucHJvcGVydGllc1trZXldO1xuICAgICAgICByZXR1cm4gcHJvcGVydHkgPT09IHVuZGVmaW5lZCA/IGV4cG9ydHMuVHlwZS5OZXZlcigpIDogZXhwb3J0cy5UeXBlLlVuaW9uKFtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgICAgaWYgKGl0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk5ldmVyKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpdGVtc1trZXldOyAvL1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24oc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIGtleSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1R1cGxlJylcbiAgICAgICAgICAgIHJldHVybiBUdXBsZShzY2hlbWEsIGtleSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVzb2x2ZShzY2hlbWEsIGtleXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGtleXMubWFwKChrZXkpID0+IFZpc2l0KHNjaGVtYSwga2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuVW5pb24ocmVzb2x2ZWQsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgSW5kZXhlZEFjY2Vzc29yLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoSW5kZXhlZEFjY2Vzc29yIHx8IChleHBvcnRzLkluZGV4ZWRBY2Nlc3NvciA9IEluZGV4ZWRBY2Nlc3NvciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0TWFwXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIE9iamVjdE1hcDtcbihmdW5jdGlvbiAoT2JqZWN0TWFwKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHNjaGVtYS5hbGxPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgY2FsbGJhY2spKSwgeyAuLi5zY2hlbWEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBjYWxsYmFjaykpLCB7IC4uLnNjaGVtYSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHVzZXJzIG5lZWQgdG8gbWFwIG9iamVjdHMgd2l0aCB1bnJlZ2lzdGVyZWQga2luZHMuIFVzaW5nIGEgVHlwZUd1YXJkIGhlcmUgd291bGRcbiAgICAgICAgLy8gcHJldmVudCBzdWIgc2NoZW1hIG1hcHBpbmcgYXMgdW5yZWdpc3RlcmVkIGtpbmRzIHdpbGwgbm90IHBhc3MgVFNjaGVtYSBjaGVja3MuIFRoaXMgaXMgbm90YWJsZSBpbiB0aGVcbiAgICAgICAgLy8gY2FzZSBvZiBUT2JqZWN0IHdoZXJlIHVucmVnaXN0ZXJlZCBwcm9wZXJ0eSBraW5kcyBjYXVzZSB0aGUgVE9iamVjdCBjaGVjayB0byBmYWlsLiBBcyBtYXBwaW5nIGlzIG9ubHlcbiAgICAgICAgLy8gdXNlZCBmb3IgY29tcG9zaXRpb24sIHdlIHVzZSBleHBsaWNpdCBjaGVja3MgaW5zdGVhZC5cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hcChzY2hlbWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgY2FsbGJhY2spLCAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIE9iamVjdE1hcC5NYXAgPSBNYXA7XG59KShPYmplY3RNYXAgfHwgKGV4cG9ydHMuT2JqZWN0TWFwID0gT2JqZWN0TWFwID0ge30pKTtcbnZhciBLZXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5UmVzb2x2ZXIpIHtcbiAgICBmdW5jdGlvbiBVbndyYXBQYXR0ZXJuKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5WzBdID09PSAnXicgJiYga2V5W2tleS5sZW5ndGggLSAxXSA9PT0gJyQnID8ga2V5LnNsaWNlKDEsIGtleS5sZW5ndGggLSAxKSA6IGtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IFsuLi5hY2MsIC4uLlZpc2l0KHNjaGVtYSwgb3B0aW9ucyldLCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXRzID0gc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBbLi4uc2V0cy5yZWR1Y2UoKHNldCwgb3V0ZXIpID0+IG91dGVyLm1hcCgoa2V5KSA9PiAoc2V0cy5ldmVyeSgoaW5uZXIpID0+IGlubmVyLmluY2x1ZGVzKGtleSkpID8gc2V0LmFkZChrZXkpIDogc2V0KSlbMF0sIG5ldyBTZXQoKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmNsdWRlUGF0dGVybnMgPyBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgOiBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmQoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKiogUmVzb2x2ZXMgYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIHNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVLZXlzKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoVmlzaXQoc2NoZW1hLCBvcHRpb25zKSldO1xuICAgIH1cbiAgICBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyA9IFJlc29sdmVLZXlzO1xuICAgIC8qKiBSZXNvbHZlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIG1hdGNoaW5nIGFsbCBrZXlzIGluIHRoaXMgc2NoZW1hICovXG4gICAgZnVuY3Rpb24gUmVzb2x2ZVBhdHRlcm4oc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBSZXNvbHZlS2V5cyhzY2hlbWEsIHsgaW5jbHVkZVBhdHRlcm5zOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0ga2V5cy5tYXAoKGtleSkgPT4gYCgke1Vud3JhcFBhdHRlcm4oa2V5KX0pYCk7XG4gICAgICAgIHJldHVybiBgXigke3BhdHRlcm4uam9pbignfCcpfSkkYDtcbiAgICB9XG4gICAgS2V5UmVzb2x2ZXIuUmVzb2x2ZVBhdHRlcm4gPSBSZXNvbHZlUGF0dGVybjtcbn0pKEtleVJlc29sdmVyIHx8IChleHBvcnRzLktleVJlc29sdmVyID0gS2V5UmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtleUFycmF5UmVzb2x2ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgS2V5QXJyYXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5QXJyYXlSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBzdHJpbmdbXSBrZXlzIGZyb20gdGhlIGdpdmVuIHNjaGVtYSBvciBhcnJheSB0eXBlLiAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUoc2NoZW1hKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gW3NjaGVtYS5jb25zdF07XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3Qoc2NoZW1hLnBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0tleUFycmF5UmVzb2x2ZXI6IENhbm5vdCByZXNvbHZlIGtleXMgZnJvbSBpbmZpbml0ZSB0ZW1wbGF0ZSBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvci5HZW5lcmF0ZShleHByZXNzaW9uKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoS2V5QXJyYXlSZXNvbHZlciB8fCAoZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gS2V5QXJyYXlSZXNvbHZlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVW5pb25SZXNvbHZlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBVbmlvblJlc29sdmVyO1xuKGZ1bmN0aW9uIChVbmlvblJlc29sdmVyKSB7XG4gICAgZnVuY3Rpb24qIFVuaW9uKHVuaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHVuaW9uLmFueU9mKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVW5pb24oc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJlc29sdmVkIHVuaW9uIHdpdGggaW50ZXJpb3IgdW5pb25zIGZsYXR0ZW5lZCAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUodW5pb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5VbmlvbihbLi4uVW5pb24odW5pb24pXSwgeyAuLi51bmlvbiB9KTtcbiAgICB9XG4gICAgVW5pb25SZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFVuaW9uUmVzb2x2ZXIgfHwgKGV4cG9ydHMuVW5pb25SZXNvbHZlciA9IFVuaW9uUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVGVtcGxhdGVMaXRlcmFsUGF0dGVybjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGF0dGVybikge1xuICAgIGZ1bmN0aW9uIEVzY2FwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBhY2MpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEucGF0dGVybi5zbGljZSgxLCBzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGFjYykpLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgIHJldHVybiBgKCR7dG9rZW5zfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEludGVnZXIoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FjY30ke2V4cG9ydHMuUGF0dGVybk51bWJlcn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQmlnSW50KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuU3RyaW5nfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtFc2NhcGUoc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5Cb29sZWFufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlROZXZlcihzY2hlbWEpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGVMaXRlcmFsUGF0dGVybjogVGVtcGxhdGVMaXRlcmFsIGNhbm5vdCBvcGVyYXRlIG9uIHR5cGVzIG9mIFROZXZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm46IFVuZXhwZWN0ZWQgS2luZCAnJHtzY2hlbWFbZXhwb3J0cy5LaW5kXX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ3JlYXRlKGtpbmRzKSB7XG4gICAgICAgIHJldHVybiBgXiR7a2luZHMubWFwKChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgJycpKS5qb2luKCcnKX1cXCRgO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSA9IENyZWF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gfHwgKGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGF0dGVybiA9IFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyO1xuKGZ1bmN0aW9uIChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYSBUVW5pb24gKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2VFeGFjdCh0ZW1wbGF0ZS5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLm1hcCgodmFsdWUpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24obGl0ZXJhbHMpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhcnNlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yO1xudmFyIFRlbXBsYXRlTGl0ZXJhbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCBjaGFyKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuW2luZGV4XSA9PT0gY2hhciAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoaW5kZXggLSAxKSAhPT0gOTI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBJc05vbkVzY2FwZWQocGF0dGVybiwgaW5kZXgsICcoJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnKScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnfCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0dyb3VwKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCEoSXNPcGVuUGFyZW4ocGF0dGVybiwgMCkgJiYgSXNDbG9zZVBhcmVuKHBhdHRlcm4sIHBhdHRlcm4ubGVuZ3RoIC0gMSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDAgJiYgaW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluR3JvdXAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkgJiYgY291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VBbmQocGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBbY291bnQsIHN0YXJ0XSA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoSXNDbG9zZVBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKElzU2VwYXJhdG9yKHBhdHRlcm4sIGluZGV4KSAmJiBjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29yJywgZXhwcjogZXhwcmVzc2lvbnMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQW5kKHBhdHRlcm4pIHtcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIUlzT3BlblBhcmVuKHZhbHVlLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yKGBUZW1wbGF0ZUxpdGVyYWxQYXJzZXI6IEluZGV4IG11c3QgcG9pbnQgdG8gb3BlbiBwYXJlbnNgKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCB2YWx1ZS5sZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcihgVGVtcGxhdGVMaXRlcmFsUGFyc2VyOiBVbmNsb3NlZCBncm91cCBwYXJlbnMgaW4gZXhwcmVzc2lvbmApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCBwYXR0ZXJuLmxlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5kZXgsIHBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBHcm91cChwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZShwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FuZCcsIGV4cHI6IGV4cHJlc3Npb25zIH07XG4gICAgfVxuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCByZXR1cm5zIGFuIGV4cHJlc3Npb24gdHJlZSAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKElzR3JvdXAocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gUGFyc2UoSW5Hcm91cChwYXR0ZXJuKSk7XG4gICAgICAgIGlmIChJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBPcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKElzUHJlY2VkZW5jZUFuZChwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBBbmQocGF0dGVybik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjb25zdCcsIGNvbnN0OiBwYXR0ZXJuIH07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCBzdHJpcHMgZm9yd2FyZCBhbmQgdHJhaWxpbmcgXiBhbmQgJCAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlRXhhY3QocGF0dGVybikge1xuICAgICAgICByZXR1cm4gUGFyc2UocGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3QgPSBQYXJzZUV4YWN0O1xufSkoVGVtcGxhdGVMaXRlcmFsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsRmluaXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZTtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRmluaXRlKSB7XG4gICAgZnVuY3Rpb24gSXNOdW1iZXIoZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uLnR5cGUgPT09ICdvcicgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwci5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0uY29uc3QgPT09ICcwJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS5jb25zdCA9PT0gJ1sxLTldWzAtOV0qJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQm9vbGVhbihleHByZXNzaW9uKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzBdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS5jb25zdCA9PT0gJ3RydWUnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMV0udHlwZSA9PT0gJ2NvbnN0JyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLmNvbnN0ID09PSAnZmFsc2UnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnICYmIGV4cHJlc3Npb24uY29uc3QgPT09ICcuKic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoZWNrKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKElzQm9vbGVhbihleHByZXNzaW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoSXNOdW1iZXIoZXhwcmVzc2lvbikgfHwgSXNTdHJpbmcoZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdhbmQnKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IEVycm9yKGBUZW1wbGF0ZUxpdGVyYWxGaW5pdGU6IFVua25vd24gZXhwcmVzc2lvbiB0eXBlYCk7XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayA9IENoZWNrO1xufSkoVGVtcGxhdGVMaXRlcmFsRmluaXRlIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24qIFJlZHVjZShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIGJ1ZmZlclswXTtcbiAgICAgICAgZm9yIChjb25zdCBsZWZ0IG9mIGJ1ZmZlclswXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByaWdodCBvZiBSZWR1Y2UoYnVmZmVyLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGAke2xlZnR9JHtyaWdodH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBBbmQoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geWllbGQqIFJlZHVjZShleHByZXNzaW9uLmV4cHIubWFwKChleHByKSA9PiBbLi4uR2VuZXJhdGUoZXhwcildKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBPcihleHByZXNzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXhwciBvZiBleHByZXNzaW9uLmV4cHIpXG4gICAgICAgICAgICB5aWVsZCogR2VuZXJhdGUoZXhwcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBDb25zdChleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBleHByZXNzaW9uLmNvbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiogR2VuZXJhdGUoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnYW5kJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQW5kKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBPcihleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQ29uc3QoZXhwcmVzc2lvbik7XG4gICAgICAgIHRocm93IEVycm9yKCdUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3I6IFVua25vd24gZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUgPSBHZW5lcmF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24qIFBhcnNlVW5pb24odGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3QgdHJpbSA9IHRlbXBsYXRlLnRyaW0oKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBleHBvcnRzLlR5cGUuQm9vbGVhbigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLkJpZ0ludCgpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IHRyaW0uc3BsaXQoJ3wnKS5tYXAoKGxpdGVyYWwpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKGxpdGVyYWwudHJpbSgpKSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBsaXRlcmFscy5sZW5ndGggPT09IDAgPyBleHBvcnRzLlR5cGUuTmV2ZXIoKSA6IGxpdGVyYWxzLmxlbmd0aCA9PT0gMSA/IGxpdGVyYWxzWzBdIDogZXhwb3J0cy5UeXBlLlVuaW9uKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFBhcnNlVGVybWluYWwodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlWzFdICE9PSAneycpIHtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBleHBvcnRzLlR5cGUuTGl0ZXJhbCgnJCcpO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIFtMLCAuLi5SXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHRlbXBsYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0gPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBQYXJzZVVuaW9uKHRlbXBsYXRlLnNsaWNlKDIsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VMaXRlcmFsKHRlbXBsYXRlLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbLi4uTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogUGFyc2VMaXRlcmFsKHRlbXBsYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVtpXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTCA9IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VUZXJtaW5hbCh0ZW1wbGF0ZS5zbGljZShpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXJzZSh0ZW1wbGF0ZV9kc2wpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5QYXJzZUxpdGVyYWwodGVtcGxhdGVfZHNsKV07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xufSkoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZU9yZGluYWw6IFVzZWQgZm9yIGF1dG8gJGlkIGdlbmVyYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5sZXQgVHlwZU9yZGluYWwgPSAwO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUJ1aWxkZXIge1xuICAgIC8qKiBgW1V0aWxpdHldYCBDcmVhdGVzIGEgc2NoZW1hIHdpdGhvdXQgYHN0YXRpY2AgYW5kIGBwYXJhbXNgIHR5cGVzICovXG4gICAgQ3JlYXRlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIE9taXRzIGNvbXBvc2l0aW5nIHN5bWJvbHMgZnJvbSB0aGlzIHNjaGVtYSAqL1xuICAgIFN0cmljdChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlQnVpbGRlciA9IFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YW5kYXJkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBTdGFuZGFyZFR5cGVCdWlsZGVyIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1vZGlmaWVyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIE9wdGlvbmFsIHByb3BlcnR5ICovXG4gICAgT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB7IFtleHBvcnRzLk1vZGlmaWVyXTogJ09wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5T3B0aW9uYWwgcHJvcGVydHkgKi9cbiAgICBSZWFkb25seU9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seU9wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5IG9iamVjdCBvciBwcm9wZXJ0eSAqL1xuICAgIFJlYWRvbmx5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seScsIC4uLnNjaGVtYSB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUeXBlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBBbnkgdHlwZSAqL1xuICAgIEFueShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBbnknIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gQXJyYXkgdHlwZSAqL1xuICAgIEFycmF5KGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBcnJheScsIHR5cGU6ICdhcnJheScsIGl0ZW1zOiBUeXBlQ2xvbmUuQ2xvbmUoaXRlbXMsIHt9KSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgQm9vbGVhbiB0eXBlICovXG4gICAgQm9vbGVhbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdCb29sZWFuJywgdHlwZTogJ2Jvb2xlYW4nIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBDb21wb3NpdGUgb2JqZWN0IHR5cGUuICovXG4gICAgQ29tcG9zaXRlKG9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gZXhwb3J0cy5UeXBlLkludGVyc2VjdChvYmplY3RzLCB7fSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyhpbnRlcnNlY3QsIHsgaW5jbHVkZVBhdHRlcm5zOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gKHsgLi4uYWNjLCBba2V5XTogZXhwb3J0cy5UeXBlLkluZGV4KGludGVyc2VjdCwgW2tleV0pIH0pLCB7fSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuT2JqZWN0KHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBFbnVtIHR5cGUgKi9cbiAgICBFbnVtKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhpdGVtKS5maWx0ZXIoKGtleSkgPT4gaXNOYU4oa2V5KSkubWFwKChrZXkpID0+IGl0ZW1ba2V5XSk7XG4gICAgICAgIGNvbnN0IGFueU9mID0gdmFsdWVzLm1hcCgodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8geyBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgY29uc3Q6IHZhbHVlIH0gOiB7IFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIHR5cGU6ICdudW1iZXInLCBjb25zdDogdmFsdWUgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VuaW9uJywgYW55T2YgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQSBjb25kaXRpb25hbCB0eXBlIGV4cHJlc3Npb24gdGhhdCB3aWxsIHJldHVybiB0aGUgdHJ1ZSB0eXBlIGlmIHRoZSBsZWZ0IHR5cGUgZXh0ZW5kcyB0aGUgcmlnaHQgKi9cbiAgICBFeHRlbmRzKGxlZnQsIHJpZ2h0LCB0cnVlVHlwZSwgZmFsc2VUeXBlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3dpdGNoIChUeXBlRXh0ZW5kcy5FeHRlbmRzKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgY2FzZSBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihbVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKSwgVHlwZUNsb25lLkNsb25lKGZhbHNlVHlwZSwgb3B0aW9ucyldKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShmYWxzZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXhjbHVkZXMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgbm90IGFzc2lnbmFibGUgdG8gdGhlIHJpZ2h0ICovXG4gICAgRXhjbHVkZShsZWZ0LCByaWdodCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4Y2x1ZGUoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShsZWZ0KSwgcmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXhjbHVkZShsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKSB7XG4gICAgICAgICAgICBjb25zdCBuYXJyb3dlZCA9IGxlZnQuYW55T2YuZmlsdGVyKChpbm5lcikgPT4gVHlwZUV4dGVuZHMuRXh0ZW5kcyhpbm5lciwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKG5hcnJvd2VkLmxlbmd0aCA9PT0gMSA/IFR5cGVDbG9uZS5DbG9uZShuYXJyb3dlZFswXSwgb3B0aW9ucykgOiB0aGlzLlVuaW9uKG5hcnJvd2VkLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFR5cGVFeHRlbmRzLkV4dGVuZHMobGVmdCwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IHRoaXMuTmV2ZXIob3B0aW9ucykgOiBUeXBlQ2xvbmUuQ2xvbmUobGVmdCwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXh0cmFjdHMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgYXNzaWduYWJsZSB0byB0aGUgcmlnaHQgKi9cbiAgICBFeHRyYWN0KGxlZnQsIHJpZ2h0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXh0cmFjdChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKGxlZnQpLCByaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeHRyYWN0KGxlZnQsIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUocmlnaHQpLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hcnJvd2VkID0gbGVmdC5hbnlPZi5maWx0ZXIoKGlubmVyKSA9PiBUeXBlRXh0ZW5kcy5FeHRlbmRzKGlubmVyLCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAobmFycm93ZWQubGVuZ3RoID09PSAxID8gVHlwZUNsb25lLkNsb25lKG5hcnJvd2VkWzBdLCBvcHRpb25zKSA6IHRoaXMuVW5pb24obmFycm93ZWQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoVHlwZUV4dGVuZHMuRXh0ZW5kcyhsZWZ0LCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUNsb25lLkNsb25lKGxlZnQsIG9wdGlvbnMpIDogdGhpcy5OZXZlcihvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBSZXR1cm5zIGluZGV4ZWQgcHJvcGVydHkgdHlwZXMgZm9yIHRoZSBnaXZlbiBrZXlzICovXG4gICAgSW5kZXgoc2NoZW1hLCB1bnJlc29sdmVkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShzY2hlbWEuaXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gaXRlbXMubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihjbG9uZWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleUFycmF5UmVzb2x2ZXIuUmVzb2x2ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIEluZGV4ZWRBY2Nlc3Nvci5SZXNvbHZlKGNsb25lLCBrZXlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gSW50ZWdlciB0eXBlICovXG4gICAgSW50ZWdlcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdJbnRlZ2VyJywgdHlwZTogJ2ludGVnZXInIH0pO1xuICAgIH1cbiAgICBJbnRlcnNlY3QoYWxsT2YsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShhbGxPZlswXSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBhbGxPZi5ldmVyeSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gYWxsT2YubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcyA9IFR5cGVHdWFyZC5UU2NoZW1hKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSA/IHsgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiBUeXBlQ2xvbmUuQ2xvbmUob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMsIHt9KSB9IDoge307XG4gICAgICAgIGlmIChvcHRpb25zLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UgfHwgVHlwZUd1YXJkLlRTY2hlbWEob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMpIHx8IG9iamVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCB0eXBlOiAnb2JqZWN0JywgYWxsT2Y6IGNsb25lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCBhbGxPZjogY2xvbmVkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIEtleU9mIHR5cGUgKi9cbiAgICBLZXlPZihzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylbMF07XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0cmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTdGFuZGFyZFR5cGVCdWlsZGVyOiBVbmFibGUgdG8gcmVzb2x2ZSBrZXkgdHlwZSBmcm9tIFJlY29yZCBrZXkgcGF0dGVybicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBpdGVtcy5tYXAoKF8sIGluZGV4KSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbChpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24obGl0ZXJhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleVJlc29sdmVyLlJlc29sdmVLZXlzKHNjaGVtYSwgeyBpbmNsdWRlUGF0dGVybnM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk5ldmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLkxpdGVyYWwoa2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihsaXRlcmFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTGl0ZXJhbCB0eXBlICovXG4gICAgTGl0ZXJhbCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIGNvbnN0OiB2YWx1ZSwgdHlwZTogdHlwZW9mIHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOZXZlciB0eXBlICovXG4gICAgTmV2ZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTmV2ZXInLCBub3Q6IHt9IH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOb3QgdHlwZSAqL1xuICAgIE5vdChub3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdOb3QnLCBub3QgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIE51bGwgdHlwZSAqL1xuICAgIE51bGwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVsbCcsIHR5cGU6ICdudWxsJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTnVtYmVyIHR5cGUgKi9cbiAgICBOdW1iZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVtYmVyJywgdHlwZTogJ251bWJlcicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBPYmplY3QgdHlwZSAqL1xuICAgIE9iamVjdChwcm9wZXJ0aWVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlLZXlzID0gZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxLZXlzID0gcHJvcGVydHlLZXlzLmZpbHRlcigoa2V5KSA9PiBUeXBlR3VhcmQuVE9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkgfHwgVHlwZUd1YXJkLlRSZWFkb25seU9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICBjb25zdCByZXF1aXJlZEtleXMgPSBwcm9wZXJ0eUtleXMuZmlsdGVyKChuYW1lKSA9PiAhb3B0aW9uYWxLZXlzLmluY2x1ZGVzKG5hbWUpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMgPSBUeXBlR3VhcmQuVFNjaGVtYShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA/IHsgYWRkaXRpb25hbFByb3BlcnRpZXM6IFR5cGVDbG9uZS5DbG9uZShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCB7fSkgfSA6IHt9O1xuICAgICAgICBjb25zdCBjbG9uZWRQcm9wZXJ0aWVzID0gcHJvcGVydHlLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShwcm9wZXJ0aWVzW2tleV0sIHt9KSB9KSwge30pO1xuICAgICAgICBpZiAocmVxdWlyZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBbZXhwb3J0cy5LaW5kXTogJ09iamVjdCcsIHR5cGU6ICdvYmplY3QnLCBwcm9wZXJ0aWVzOiBjbG9uZWRQcm9wZXJ0aWVzLCByZXF1aXJlZDogcmVxdWlyZWRLZXlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgLi4uY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnT2JqZWN0JywgdHlwZTogJ29iamVjdCcsIHByb3BlcnRpZXM6IGNsb25lZFByb3BlcnRpZXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT21pdChzY2hlbWEsIHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlKHVucmVzb2x2ZWQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLnJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkLmZpbHRlcigoa2V5KSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIG1hcHBlZCB0eXBlIHdoZXJlIGFsbCBwcm9wZXJ0aWVzIGFyZSBPcHRpb25hbCAqL1xuICAgIFBhcnRpYWwoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHkoc2NoZW1hKSB7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHlPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdSZWFkb25seU9wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHlPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ09wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3RNYXAuTWFwKFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goa2V5ID0+IEFwcGx5KHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBQaWNrKHNjaGVtYSwgdW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUodW5yZXNvbHZlZCk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEucmVxdWlyZWQgPSBzY2hlbWEucmVxdWlyZWQuZmlsdGVyKChrZXkpID0+IGtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZShzY2hlbWEpO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVjb3JkIHR5cGUgKi9cbiAgICBSZWNvcmQoa2V5LCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0KGtleS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayhleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgID8gKHRoaXMuT2JqZWN0KFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW2tleS5wYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRVbmlvbihrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IFVuaW9uUmVzb2x2ZXIuUmVzb2x2ZShrZXkpO1xuICAgICAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb25MaXRlcmFsKHVuaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB1bmlvbi5hbnlPZi5yZWR1Y2UoKGFjYywgbGl0ZXJhbCkgPT4gKHsgLi4uYWNjLCBbbGl0ZXJhbC5jb25zdF06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk9iamVjdChwcm9wZXJ0aWVzLCB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLkhpbnRdOiAnUmVjb3JkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVHlwZUJ1aWxkZXI6IFJlY29yZCBrZXkgb2YgdHlwZSB1bmlvbiBjb250YWlucyBub24tbGl0ZXJhbCB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChrZXkpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleS5jb25zdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGtleS5jb25zdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5PYmplY3QoeyBba2V5LmNvbnN0XTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUeXBlQnVpbGRlcjogUmVjb3JkIGtleSBvZiB0eXBlIGxpdGVyYWwgaXMgbm90IG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihrZXkpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtwYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGtleS5wYXR0ZXJuID09PSB1bmRlZmluZWQgPyBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA6IGtleS5wYXR0ZXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW3BhdHRlcm5dOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTdGFuZGFyZFR5cGVCdWlsZGVyOiBSZWNvcmQga2V5IGlzIGFuIGludmFsaWQgdHlwZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlY3Vyc2l2ZSB0eXBlICovXG4gICAgUmVjdXJzaXZlKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvcHRpb25zLiRpZCA9IGBUJHtUeXBlT3JkaW5hbCsrfWA7XG4gICAgICAgIGNvbnN0IHRoaXNUeXBlID0gY2FsbGJhY2soeyBbZXhwb3J0cy5LaW5kXTogJ1RoaXMnLCAkcmVmOiBgJHtvcHRpb25zLiRpZH1gIH0pO1xuICAgICAgICB0aGlzVHlwZS4kaWQgPSBvcHRpb25zLiRpZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuSGludF06ICdSZWN1cnNpdmUnLCAuLi50aGlzVHlwZSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVmIHR5cGUuIFRoZSByZWZlcmVuY2VkIHR5cGUgbXVzdCBjb250YWluIGEgJGlkICovXG4gICAgUmVmKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChzY2hlbWEuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU3RhbmRhcmRUeXBlQnVpbGRlci5SZWY6IFRhcmdldCB0eXBlIG11c3Qgc3BlY2lmeSBhbiAkaWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWYnLCAkcmVmOiBzY2hlbWEuJGlkIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBtYXBwZWQgdHlwZSB3aGVyZSBhbGwgcHJvcGVydGllcyBhcmUgUmVxdWlyZWQgKi9cbiAgICBSZXF1aXJlZChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBBcHBseShzY2hlbWEpIHtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgc3dpdGNoIChzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdSZWFkb25seU9wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykuZm9yRWFjaChrZXkgPT4gQXBwbHkoc2NoZW1hLnByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgUmV0dXJucyBhIHNjaGVtYSBhcnJheSB3aGljaCBhbGxvd3MgdHlwZXMgdG8gY29tcG9zZSB3aXRoIHRoZSBKYXZhU2NyaXB0IHNwcmVhZCBvcGVyYXRvciAqL1xuICAgIFJlc3Qoc2NoZW1hKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFN0cmluZyB0eXBlICovXG4gICAgU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHR5cGUgKi9cbiAgICBUZW1wbGF0ZUxpdGVyYWwodW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gKHR5cGVvZiB1bnJlc29sdmVkID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8gVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyLlBhcnNlKHVucmVzb2x2ZWQpKVxuICAgICAgICAgICAgOiBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdUZW1wbGF0ZUxpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgcGF0dGVybiB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgVHVwbGUgdHlwZSAqL1xuICAgIFR1cGxlKGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgW2FkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zXSA9IFtmYWxzZSwgaXRlbXMubGVuZ3RoLCBpdGVtcy5sZW5ndGhdO1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gVHlwZUNsb25lLkNsb25lKGl0ZW0sIHt9KSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBzY2hlbWEgPSAoaXRlbXMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVHVwbGUnLCB0eXBlOiAnYXJyYXknLCBpdGVtczogY2xvbmVkSXRlbXMsIGFkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zIH0gOlxuICAgICAgICAgICAgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1R1cGxlJywgdHlwZTogJ2FycmF5JywgbWluSXRlbXMsIG1heEl0ZW1zIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICB9XG4gICAgVW5pb24odW5pb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwodW5pb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZSh1bmlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbnlPZiA9IHVuaW9uO1xuICAgICAgICAgICAgaWYgKGFueU9mLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5OZXZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKFR5cGVDbG9uZS5DbG9uZShhbnlPZlswXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkQW55T2YgPSBhbnlPZi5tYXAoKHNjaGVtYSkgPT4gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5pb24nLCBhbnlPZjogY2xvbmVkQW55T2YgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIFVua25vd24gdHlwZSAqL1xuICAgIFVua25vd24ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5rbm93bicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFVuc2FmZSB0eXBlIHRoYXQgaW5mZXJzIGZvciB0aGUgZ2VuZXJpYyBhcmd1bWVudCAqL1xuICAgIFVuc2FmZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06IG9wdGlvbnNbZXhwb3J0cy5LaW5kXSB8fCAnVW5zYWZlJyB9KTtcbiAgICB9XG59XG5leHBvcnRzLlN0YW5kYXJkVHlwZUJ1aWxkZXIgPSBTdGFuZGFyZFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZGVkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBFeHRlbmRlZFR5cGVCdWlsZGVyIGV4dGVuZHMgU3RhbmRhcmRUeXBlQnVpbGRlciB7XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgQmlnSW50IHR5cGUgKi9cbiAgICBCaWdJbnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQmlnSW50JywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdCaWdJbnQnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBDb25zdHJ1Y3RvclBhcmFtZXRlcnMgZnJvbSB0aGUgZ2l2ZW4gQ29uc3RydWN0b3IgdHlwZSAqL1xuICAgIENvbnN0cnVjdG9yUGFyYW1ldGVycyhzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5UdXBsZShbLi4uc2NoZW1hLnBhcmFtZXRlcnNdLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIENvbnN0cnVjdG9yIHR5cGUgKi9cbiAgICBDb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCByZXR1cm5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFJldHVybnMgPSBUeXBlQ2xvbmUuQ2xvbmUocmV0dXJucywge30pO1xuICAgICAgICBjb25zdCBjbG9uZWRQYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5tYXAoKHBhcmFtZXRlcikgPT4gVHlwZUNsb25lLkNsb25lKHBhcmFtZXRlciwge30pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdDb25zdHJ1Y3RvcicsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnQ29uc3RydWN0b3InLCBwYXJhbWV0ZXJzOiBjbG9uZWRQYXJhbWV0ZXJzLCByZXR1cm5zOiBjbG9uZWRSZXR1cm5zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBEYXRlIHR5cGUgKi9cbiAgICBEYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0RhdGUnLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0RhdGUnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBGdW5jdGlvbiB0eXBlICovXG4gICAgRnVuY3Rpb24ocGFyYW1ldGVycywgcmV0dXJucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXR1cm5zID0gVHlwZUNsb25lLkNsb25lKHJldHVybnMsIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IFR5cGVDbG9uZS5DbG9uZShwYXJhbWV0ZXIsIHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnRnVuY3Rpb24nLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0Z1bmN0aW9uJywgcGFyYW1ldGVyczogY2xvbmVkUGFyYW1ldGVycywgcmV0dXJuczogY2xvbmVkUmV0dXJucyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgSW5zdGFuY2VUeXBlIGZyb20gdGhlIGdpdmVuIENvbnN0cnVjdG9yICovXG4gICAgSW5zdGFuY2VUeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBQYXJhbWV0ZXJzIGZyb20gdGhlIGdpdmVuIEZ1bmN0aW9uIHR5cGUgKi9cbiAgICBQYXJhbWV0ZXJzKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlR1cGxlKHNjaGVtYS5wYXJhbWV0ZXJzLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFByb21pc2UgdHlwZSAqL1xuICAgIFByb21pc2UoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUHJvbWlzZScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnUHJvbWlzZScsIGl0ZW06IFR5cGVDbG9uZS5DbG9uZShpdGVtLCB7fSkgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0eXBlICovXG4gICAgUmVnRXgocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnLCBwYXR0ZXJuOiByZWdleC5zb3VyY2UgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgRXh0cmFjdHMgdGhlIFJldHVyblR5cGUgZnJvbSB0aGUgZ2l2ZW4gRnVuY3Rpb24gKi9cbiAgICBSZXR1cm5UeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBTeW1ib2wgdHlwZSAqL1xuICAgIFN5bWJvbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnU3ltYm9sJywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdTeW1ib2wnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBVbmRlZmluZWQgdHlwZSAqL1xuICAgIFVuZGVmaW5lZChvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdVbmRlZmluZWQnLCB0eXBlOiAnbnVsbCcsIHR5cGVPZjogJ1VuZGVmaW5lZCcgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFVpbnQ4QXJyYXkgdHlwZSAqL1xuICAgIFVpbnQ4QXJyYXkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVWludDhBcnJheScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnVWludDhBcnJheScgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFZvaWQgdHlwZSAqL1xuICAgIFZvaWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVm9pZCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnVm9pZCcgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlbmRlZFR5cGVCdWlsZGVyID0gRXh0ZW5kZWRUeXBlQnVpbGRlcjtcbi8qKiBKU09OIFNjaGVtYSBUeXBlQnVpbGRlciB3aXRoIFN0YXRpYyBSZXNvbHV0aW9uIGZvciBUeXBlU2NyaXB0ICovXG5leHBvcnRzLlN0YW5kYXJkVHlwZSA9IG5ldyBTdGFuZGFyZFR5cGVCdWlsZGVyKCk7XG4vKiogSlNPTiBTY2hlbWEgVHlwZUJ1aWxkZXIgd2l0aCBTdGF0aWMgUmVzb2x1dGlvbiBmb3IgVHlwZVNjcmlwdCAqL1xuZXhwb3J0cy5UeXBlID0gbmV3IEV4dGVuZGVkVHlwZUJ1aWxkZXIoKTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJ7XG4gICAgXCJuYW1lXCI6IFwiQHBpbmVjb25lLWRhdGFiYXNlL3BpbmVjb25lXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjFcIlxufVxuIiwgbnVsbCwgInZhciBnbG9iYWwgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcztcbnZhciBfX3NlbGZfXyA9IChmdW5jdGlvbiAoKSB7XG5mdW5jdGlvbiBGKCkge1xudGhpcy5mZXRjaCA9IGZhbHNlO1xudGhpcy5ET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uXG59XG5GLnByb3RvdHlwZSA9IGdsb2JhbDtcbnJldHVybiBuZXcgRigpO1xufSkoKTtcbihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKHt9KTtcbn0pKF9fc2VsZl9fKTtcbl9fc2VsZl9fLmZldGNoLnBvbnlmaWxsID0gdHJ1ZTtcbi8vIFJlbW92ZSBcInBvbHlmaWxsXCIgcHJvcGVydHkgYWRkZWQgYnkgd2hhdHdnLWZldGNoXG5kZWxldGUgX19zZWxmX18uZmV0Y2gucG9seWZpbGw7XG4vLyBDaG9vc2UgYmV0d2VlbiBuYXRpdmUgaW1wbGVtZW50YXRpb24gKGdsb2JhbCkgb3IgY3VzdG9tIGltcGxlbWVudGF0aW9uIChfX3NlbGZfXylcbi8vIHZhciBjdHggPSBnbG9iYWwuZmV0Y2ggPyBnbG9iYWwgOiBfX3NlbGZfXztcbnZhciBjdHggPSBfX3NlbGZfXzsgLy8gdGhpcyBsaW5lIGRpc2FibGUgc2VydmljZSB3b3JrZXIgc3VwcG9ydCB0ZW1wb3JhcmlseVxuZXhwb3J0cyA9IGN0eC5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuZGVmYXVsdCA9IGN0eC5mZXRjaCAvLyBGb3IgVHlwZVNjcmlwdCBjb25zdW1lcnMgd2l0aG91dCBlc01vZHVsZUludGVyb3AuXG5leHBvcnRzLmZldGNoID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IHtmZXRjaH0gZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLkhlYWRlcnMgPSBjdHguSGVhZGVyc1xuZXhwb3J0cy5SZXF1ZXN0ID0gY3R4LlJlcXVlc3RcbmV4cG9ydHMuUmVzcG9uc2UgPSBjdHguUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0pKHt9KTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQge1xyXG5cdEFwcCxcclxuXHRFZGl0b3IsXHJcblx0SGVhZGluZ0NhY2hlLFxyXG5cdE1hcmtkb3duVmlldyxcclxuXHRNb2RhbCxcclxuXHROb3RpY2UsXHJcblx0UGx1Z2luLFxyXG5cdFBsdWdpblNldHRpbmdUYWIsXHJcblx0U2V0dGluZyxcclxuXHRUQWJzdHJhY3RGaWxlLFxyXG5cdFRGaWxlLFxyXG59IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuaW1wb3J0IHsgcmVhZEZpbGUgfSBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcclxuXHJcbmltcG9ydCB7IHJlYWRGaWxlU3luYywgcmVhZGRpclN5bmMgfSBmcm9tIFwiZnNcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSBcImh0dHBcIjtcclxuaW1wb3J0IHsgc3RhdHVzQ29sb3IgfSBmcm9tIFwidXRpbHMvc3R5bGluZ1wiO1xyXG5pbXBvcnQge1xyXG5cdGFkZFdhcm5pbmcsXHJcblx0YWRkRXJyb3IsXHJcblx0cmVtb3ZlV2FybmluZyxcclxuXHRyZW1vdmVFcnJvcixcclxuXHRnZXRTZWN0aW9uLFxyXG5cdGluc2VydE1hcmtkb3duVW5kZXJIZWFkaW5nLFxyXG5cdGFkZEljb25Ub05hbWUsXHJcblx0cmVtb3ZlSWNvbkZyb21OYW1lLFxyXG59IGZyb20gXCJ1dGlscy9maWxlc1wiO1xyXG5pbXBvcnQge1xyXG5cdGFkZEVtYmVkLFxyXG5cdGNvbXBhcmVSZXF1aXJlbWVudHMsXHJcblx0dGVzdHNUYWJsZSxcclxuXHRyZXF1aXJlbWVudHNUYWJsZTIsXHJcblx0aW50ZXJmYWNlc1RhYmxlLFxyXG59IGZyb20gXCJ1dGlscy9yZXF1aXJlbWVudHNcIjtcclxuaW1wb3J0IHBsdWdpbkhhbmRsZXIgZnJvbSBcInV0aWxzL2dsb2JhbEhhbmRsZXJzXCI7XHJcbmltcG9ydCB7XHJcblx0YWRkQ29tcG9uZW50LFxyXG5cdGFkZFJlcXVpcmVtZW50LFxyXG5cdGFkZFRvU3lzdGVtRGlhZ3JhbSxcclxufSBmcm9tIFwidXRpbHMvdGVtcGxhdGVzXCI7XHJcbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxyXG5cclxubGV0IGF1dG9tYXRpY1Jlc29sdmUgPSBmYWxzZTtcclxuXHJcbmludGVyZmFjZSBNeVBsdWdpblNldHRpbmdzIHtcclxuXHRteVNldHRpbmc6IHN0cmluZztcclxuXHRzeXN0ZW1fZGVzaWduX3Jvb3RfZm9sZGVyOiBzdHJpbmc7XHJcblx0dGVzdF9kb2N1bWVudGF0aW9uX3Jvb3RfZm9sZGVyOiBzdHJpbmc7XHJcblx0aW50ZXJmYWNlc19yb290X2ZvbGRlcjogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xyXG5cdG15U2V0dGluZzogXCJkZWZhdWx0XCIsXHJcblx0c3lzdGVtX2Rlc2lnbl9yb290X2ZvbGRlcjogXCIxMS1TeXN0ZW1zX2Rlc2lnblwiLFxyXG5cdHRlc3RfZG9jdW1lbnRhdGlvbl9yb290X2ZvbGRlcjogXCIwNS1UZXN0X2RvY3VtZW50YXRpb25cIixcclxuXHRpbnRlcmZhY2VzX3Jvb3RfZm9sZGVyOiBcIjEyLUludGVyZmFjZXNcIixcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcblx0XHRjcmVhdGVTZXJ2ZXIoYXN5bmMgKHJlcSwgcmVzKSA9PiB7XHJcblx0XHRcdGNvbnN0IHJlcVVybCA9IHJlcS51cmw7XHJcblx0XHRcdGNvbnNvbGUubG9nKHJlcVVybCk7XHJcblxyXG5cdFx0XHRpZiAoIXJlcVVybCkge1xyXG5cdFx0XHRcdHJlcy5lbmQoXCJObyB1cmwgcHJvdmlkZWRcIik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkaXNhYmxlIGNvcnNcclxuXHRcdFx0cmVzLndyaXRlSGVhZCgyMDAsIHtcclxuXHRcdFx0XHRcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIixcclxuXHRcdFx0XHRcIkFjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHNcIjogXCJHRVQsIFBPU1QsIE9QVElPTlNcIixcclxuXHRcdFx0XHRcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIjpcclxuXHRcdFx0XHRcdFwiT3JpZ2luLCBYLVJlcXVlc3RlZC1XaXRoLCBDb250ZW50LVR5cGUsIEFjY2VwdFwiLFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChcclxuXHRcdFx0XHRcIm1vZGVscy9XYWRkbGVzX3dtLnN0bFwiXHJcblx0XHRcdCkgYXMgYW55O1xyXG5cdFx0XHRjb25zdCB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheShcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGZpbGUpXHJcblx0XHRcdCk7XHJcblx0XHRcdHJlcy5lbmQodWludDhWaWV3KTtcclxuXHRcdFx0Ly8gcmVhZCBhIGxvY2FsIGZpbGVcclxuXHRcdH0pLmxpc3Rlbig1NTY2KTtcclxuXHJcblx0XHRwbHVnaW5IYW5kbGVyLmluaXQodGhpcy5hcHApO1xyXG5cclxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2codGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zKTtcclxuXHRcdFx0cGx1Z2luSGFuZGxlci5zZXRQbHVnaW5zKHtcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRkYXRhdmlldzogdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zW1wiZGF0YXZpZXdcIl0uYXBpLFxyXG5cdFx0XHRcdC8vQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGZyb250bWF0dGVyOiB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnNbXCJtZXRhZGF0YS1tZW51XCJdLmFwaSxcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRza2Ffc2U6IHRoaXMuYXBwLnBsdWdpbnMucGx1Z2luc1tcInNrYS1zZS1vYnNpZGlhbi1wbHVnaW5cIl0sXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHQvLyBUaGlzIGNyZWF0ZXMgYW4gaWNvbiBpbiB0aGUgbGVmdCByaWJib24uXHJcblx0XHRjb25zdCByaWJib25JY29uRWwgPSB0aGlzLmFkZFJpYmJvbkljb24oXHJcblx0XHRcdFwiZGljZVwiLFxyXG5cdFx0XHRcIlNLQSBTRVwiLFxyXG5cdFx0XHQoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcblx0XHRcdFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBpY29uLlxyXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJUaGlzIGlzIGEgbm90aWNlIVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHRcdC8vIFBlcmZvcm0gYWRkaXRpb25hbCB0aGluZ3Mgd2l0aCB0aGUgcmliYm9uXHJcblx0XHRyaWJib25JY29uRWwuYWRkQ2xhc3MoXCJteS1wbHVnaW4tcmliYm9uLWNsYXNzXCIpO1xyXG5cclxuXHRcdC8vIFRoaXMgYWRkcyBhIHN0YXR1cyBiYXIgaXRlbSB0byB0aGUgYm90dG9tIG9mIHRoZSBhcHAuIERvZXMgbm90IHdvcmsgb24gbW9iaWxlIGFwcHMuXHJcblx0XHRjb25zdCBzdGF0dXNCYXJJdGVtRWwgPSB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKTtcclxuXHRcdHN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KFwiU3RhdHVzIEJhciBUZXh0XCIpO1xyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcImFkZC1yZXF1aXJlbWVudHNcIixcclxuXHRcdFx0bmFtZTogXCJBZGQgcmVxdWlyZW1lbnRcIixcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBjdXJyZW50RmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblxyXG5cdFx0XHRcdGlmICghY3VycmVudEZpbGUpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJBY3RpdmUgZmlsZSBpcyBub3QgYSBjb21wb25lbnRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBzeXN0ZW0gPVxyXG5cdFx0XHRcdFx0YXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGN1cnJlbnRGaWxlKT8uZnJvbnRtYXR0ZXJcclxuXHRcdFx0XHRcdFx0Py5JRDtcclxuXHJcblx0XHRcdFx0aWYgKCFzeXN0ZW0pIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJBY3RpdmUgZmlsZSBpcyBub3QgYSBjb21wb25lbnRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBuZXdSZXF1aXJlbWVudCA9IGF3YWl0IGFkZFJlcXVpcmVtZW50KHtcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlwiLFxyXG5cdFx0XHRcdFx0c291cmNlOiBcIlwiLFxyXG5cdFx0XHRcdFx0c3lzdGVtLFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHQvLyBvcGVuIHRoZSBuZXcgZmlsZVxyXG5cdFx0XHRcdGFwcC53b3Jrc3BhY2VcclxuXHRcdFx0XHRcdC5jcmVhdGVMZWFmQnlTcGxpdChhcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpKVxyXG5cdFx0XHRcdFx0Lm9wZW5GaWxlKG5ld1JlcXVpcmVtZW50KTtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcImFkZC1jb21wb25lbnRcIixcclxuXHRcdFx0bmFtZTogXCJBZGQgY29tcG9uZW50XCIsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0bmV3IENyZWF0ZUNvbXBvbmVudE1vZGFsKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzKS5vcGVuKCk7XHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXHJcblx0XHRcdFwic3RscmVuZGVyXCIsXHJcblx0XHRcdGFzeW5jIChzb3VyY2UsIGVsLCBjdHgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XHJcblx0XHRcdFx0ZnJhbWUuaWQgPSBcInN0bGZyYW1lXCI7XHJcblx0XHRcdFx0ZWwuYXBwZW5kQ2hpbGQoZnJhbWUpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoXHJcblx0XHRcdFx0XHRhcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpICtcclxuXHRcdFx0XHRcdFx0XCIvLm9ic2lkaWFuL3BsdWdpbnMvc2thX3NlL3RlbXBsYXRlcy9pbmRleC5odG1sXCJcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBkb2MgPSBmcmFtZS5jb250ZW50V2luZG93Py5kb2N1bWVudDtcclxuXHRcdFx0XHRkb2M/Lm9wZW4oKTtcclxuXHRcdFx0XHRkb2M/LndyaXRlKGNvbnRlbnQudG9TdHJpbmcoKSk7XHJcblx0XHRcdFx0ZG9jPy5jbG9zZSgpO1xyXG5cclxuXHRcdFx0XHRmcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG5cdFx0XHRcdGZyYW1lLnN0eWxlLm1pbkhlaWdodCA9IFwiNDAwcHhcIjtcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRjb25zdCBmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGxmcmFtZVwiKTtcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRmLmNvbnRlbnRXaW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0Zi5jb250ZW50V2luZG93Py5zdGFydFJlbmRlcihcIi9cIiArIHNvdXJjZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhZGRzIGFuIGVkaXRvciBjb21tYW5kIHRoYXQgY2FuIHBlcmZvcm0gc29tZSBvcGVyYXRpb24gb24gdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogXCJzYW1wbGUtZWRpdG9yLWNvbW1hbmRcIixcclxuXHRcdFx0bmFtZTogXCJTYW1wbGUgZWRpdG9yIGNvbW1hbmRcIixcclxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcclxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihcIlNhbXBsZSBFZGl0b3IgQ29tbWFuZFwiKTtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXHJcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcblx0XHQvLyBJZiB0aGUgcGx1Z2luIGhvb2tzIHVwIGFueSBnbG9iYWwgRE9NIGV2ZW50cyAob24gcGFydHMgb2YgdGhlIGFwcCB0aGF0IGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgcGx1Z2luKVxyXG5cdFx0Ly8gVXNpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lciB3aGVuIHRoaXMgcGx1Z2luIGlzIGRpc2FibGVkLlxyXG5cdFx0Ly8gdGhpcy5yZWdpc3RlckRvbUV2ZW50KGRvY3VtZW50LCBcImNsaWNrXCIsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuXHRcdC8vIFx0Y29uc29sZS5sb2coXCJjbGlja1wiLCBldnQpO1xyXG5cdFx0Ly8gfSk7XHJcblxyXG5cdFx0Ly8gV2hlbiByZWdpc3RlcmluZyBpbnRlcnZhbHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBpbnRlcnZhbCB3aGVuIHRoZSBwbHVnaW4gaXMgZGlzYWJsZWQuXHJcblx0XHQvLyB0aGlzLnJlZ2lzdGVySW50ZXJ2YWwoXHJcblx0XHQvLyBcdHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiBjb25zb2xlLmxvZyhcInNldEludGVydmFsXCIpLCA1ICogNjAgKiAxMDAwKVxyXG5cdFx0Ly8gKTtcclxuXHJcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW9wZW5cIiwgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0aGlzRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHRcdGlmICghdGhpc0ZpbGUpIHJldHVybjtcclxuXHJcblx0XHRcdGlmICh0aGlzRmlsZS5leHRlbnNpb24gPT09IFwiY2FudmFzXCIpXHJcblx0XHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT5cclxuXHRcdFx0XHRcdGhhbmRsZUNhbnZhcyh0aGlzRmlsZSwgdGhpcylcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHQvLyBzeXN0ZW0gZGVzaWduXHJcblx0XHRcdGVsc2UgaWYgKFxyXG5cdFx0XHRcdHRoaXNGaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiICYmXHJcblx0XHRcdFx0dGhpc0ZpbGUucGF0aC5pbmNsdWRlcyhcclxuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3lzdGVtX2Rlc2lnbl9yb290X2ZvbGRlclxyXG5cdFx0XHRcdCkgJiZcclxuXHRcdFx0XHQhdGhpc0ZpbGUucGF0aC5pbmNsdWRlcyhcIlJlcXVpcmVtZW50c1wiKVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcInN5c3RlbSBkZXNpZ25cIik7XHJcblx0XHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xyXG5cdFx0XHRcdFx0aGFuZGxlU3lzdGVtKHRoaXNGaWxlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHQvLyBpbnRlcmZhY2VzXHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0dGhpc0ZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgJiZcclxuXHRcdFx0XHR0aGlzRmlsZS5wYXRoLmluY2x1ZGVzKHRoaXMuc2V0dGluZ3MuaW50ZXJmYWNlc19yb290X2ZvbGRlcilcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJpbnRlcmZhY2VzXCIpO1xyXG5cdFx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcclxuXHRcdFx0XHRcdGhhbmRsZUludGVyZmFjZSh0aGlzRmlsZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0dGhpc0ZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIgJiZcclxuXHRcdFx0XHR0aGlzRmlsZS5wYXRoLmluY2x1ZGVzKFwiUmVxdWlyZW1lbnRzXCIpICYmXHJcblx0XHRcdFx0dGhpc0ZpbGUuYmFzZW5hbWUgIT09IFwiUmVxdWlyZW1lbnRzXCJcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJoYW5kbGluZyByZXF1aXJlbWVudFwiKTtcclxuXHRcdFx0XHRoYW5kbGVSZXF1aXJlbWVudCh0aGlzRmlsZSwgdGhpcy5hcHApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW9wZW5cIiwgYXN5bmMgKGZpbGUpID0+IHtcclxuXHRcdFx0aWYgKCFmaWxlKSByZXR1cm47XHJcblx0XHRcdGlmIChmaWxlLmV4dGVuc2lvbiA9PT0gXCJtZFwiKSB7XHJcblx0XHRcdFx0Ly9AdHMtaWdub3JlXHJcblx0XHRcdFx0Y29uc3QgZHYgPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKS5kYXRhdmlldztcclxuXHRcdFx0XHRjb25zdCBwYWdlcyA9IFsuLi5kdi5wYWdlcygnXCJSZXF1aXJlbWVudHNcIicpXTtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhwYWdlcyk7XHJcblx0XHRcdFx0aWYgKCFwYWdlcykgcmV0dXJuO1xyXG5cdFx0XHRcdGNvbnN0IHBhZ2VDbGFzcyA9IE9iamVjdC5lbnRyaWVzKHBhZ2VzKS5maW5kKChbLCBwYWdlXSkgPT4ge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhZ2UuZmlsZS5wYXRoID09PSBmaWxlLnBhdGg7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChwYWdlQ2xhc3MgJiYgcGFnZUNsYXNzWzFdLkNsYXNzLmluY2x1ZGVzKFwiUmVxdWlyZW1lbnRcIikpIHtcclxuXHRcdFx0XHRcdGF3YWl0IGhhbmRsZVJlcXVpcmVtZW50KGZpbGUsIGFwcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCByZXNvbHZlZEZpbGVzOiAoKCkgPT4gUHJvbWlzZTx2b2lkPilbXSA9IFtdO1xyXG5cclxuXHRcdC8vIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oXCJyZXNvbHZlXCIsIGFzeW5jIChmaWxlKSA9PiB7XHJcblx0XHQvLyBcdGlmICghZmlsZSkgcmV0dXJuO1xyXG5cdFx0Ly8gXHRpZiAoYXV0b21hdGljUmVzb2x2ZSkge1xyXG5cdFx0Ly8gXHRcdGF1dG9tYXRpY1Jlc29sdmUgPSBmYWxzZTtcclxuXHRcdC8vIFx0XHRyZXR1cm47XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIFx0aWYgKGZpbGUucGF0aC5pbmNsdWRlcyhcIi5tZFwiKSkge1xyXG5cdFx0Ly8gXHRcdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoXCJSZXF1aXJlbWVudHNcIikpIHtcclxuXHRcdC8vIFx0XHRcdGNvbnN0IGZpbGVEYXRhID0gdGhpcy5hcHAudmF1bHRcclxuXHRcdC8vIFx0XHRcdFx0LmdldE1hcmtkb3duRmlsZXMoKVxyXG5cdFx0Ly8gXHRcdFx0XHQuZmluZCgoZikgPT4gZi5wYXRoID09PSBmaWxlLnBhdGgpO1xyXG5cclxuXHRcdC8vIFx0XHRcdGlmICghZmlsZURhdGEpIHJldHVybjtcclxuXHRcdC8vIFx0XHRcdGlmIChcclxuXHRcdC8vIFx0XHRcdFx0dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyXHJcblx0XHQvLyBcdFx0XHRcdFx0Py5TdGF0dXMgPT09IFwiQ29uZmxpY3RcIlxyXG5cdFx0Ly8gXHRcdFx0KVxyXG5cdFx0Ly8gXHRcdFx0XHRyZXR1cm47XHJcblx0XHQvLyBcdFx0XHRyZXNvbHZlZEZpbGVzLnB1c2goKCkgPT4gaGFuZGxlUmVxdWlyZW1lbnQoZmlsZURhdGEsIGFwcCkpO1xyXG5cdFx0Ly8gXHRcdH1cclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfSk7XHJcblxyXG5cdFx0dGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbihcInJlc29sdmVkXCIsIGFzeW5jICgpID0+IHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0YXdhaXQgcmVzb2x2ZWRGaWxlc1tpXSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdG9udW5sb2FkKCkge31cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXHJcblx0XHRcdHt9LFxyXG5cdFx0XHRERUZBVUxUX1NFVFRJTkdTLFxyXG5cdFx0XHRhd2FpdCB0aGlzLmxvYWREYXRhKClcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2FudmFzKGNhbnZhc0ZpbGU6IFRGaWxlLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcblx0Y29uc3QgYXBwID0gcGx1Z2luSGFuZGxlci5hcHA7XHJcblxyXG5cdGNvbnN0IGNhbnZhc0ZpbGVSYXcgPSBhd2FpdCBhcHAudmF1bHQucmVhZChjYW52YXNGaWxlKTtcclxuXHRjb25zdCBjYW52YXNKc29uID0gSlNPTi5wYXJzZShjYW52YXNGaWxlUmF3KTtcclxuXHJcblx0aWYgKGNhbnZhc0ZpbGUuYmFzZW5hbWUgIT09IFwiU3lzdGVtIERpYWdyYW1cIikgcmV0dXJuO1xyXG5cclxuXHRjb25zdCBub2RlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJjYW52YXMtbm9kZVwiKTtcclxuXHJcblx0QXJyYXkuZnJvbShub2RlcykuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG5cdFx0cmVzb2x2ZUNvbXBvbmVudChub2RlKTtcclxuXHR9KTtcclxuXHJcblx0Y29uc3QgZWRnZXMgPSBjYW52YXNKc29uLmVkZ2VzO1xyXG5cclxuXHRlZGdlcy5mb3JFYWNoKFxyXG5cdFx0KFxyXG5cdFx0XHRlZGdlOiB7XHJcblx0XHRcdFx0bGFiZWw6IGFueTtcclxuXHRcdFx0fSxcclxuXHRcdFx0aWR4OiBudW1iZXJcclxuXHRcdCkgPT4ge1xyXG5cdFx0XHRpZiAoIWVkZ2UubGFiZWwpIHtcclxuXHRcdFx0XHRjYW52YXNKc29uLmVkZ2VzW2lkeF0ubGFiZWwgPSBcIlx1MjZBMFx1RkUwRlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0KTtcclxuXHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KGNhbnZhc0ZpbGUsIEpTT04uc3RyaW5naWZ5KGNhbnZhc0pzb24pKTtcclxuXHJcblx0Y29uc3QgdXNlZEVkZ2VzOiBhbnlbXSA9IFtdO1xyXG5cdGNvbnN0IG5ld0Nvbm5lY3Rpb25zOiB7XHJcblx0XHRba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcclxuXHR9ID0ge307XHJcblx0Y29uc3QgZWRnZXNFbHMgPSBBcnJheS5mcm9tKFxyXG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNhbnZhcy1wYXRoLWxhYmVsXCIpXHJcblx0KTtcclxuXHRlZGdlcy5mb3JFYWNoKChlZGdlOiBhbnksIGlkeDogbnVtYmVyKSA9PiByZXNvbHZlRWRnZShlZGdlLCBpZHgpKTtcclxuXHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KGNhbnZhc0ZpbGUsIEpTT04uc3RyaW5naWZ5KGNhbnZhc0pzb24pKTtcclxuXHJcblx0Y29uc3QgaW50ID0gYXdhaXQgcGx1Z2luSGFuZGxlclxyXG5cdFx0LmdldFBsdWdpbnMoKVxyXG5cdFx0LmRhdGF2aWV3LnBhZ2VzKGBcIiR7cGx1Z2luLnNldHRpbmdzLmludGVyZmFjZXNfcm9vdF9mb2xkZXJ9XCJgKTtcclxuXHRpbnQuZm9yRWFjaChhc3luYyAoaTogYW55KSA9PiB7XHJcblx0XHRhd2FpdCBwbHVnaW5IYW5kbGVyXHJcblx0XHRcdC5nZXRQbHVnaW5zKClcclxuXHRcdFx0LmZyb250bWF0dGVyLnBvc3RWYWx1ZXMoaS5maWxlLnBhdGgsIFtcclxuXHRcdFx0XHR7IG5hbWU6IFwiQ29ubmVjdGlvbnNcIiwgcGF5bG9hZDogeyB2YWx1ZTogXCJcIiB9IH0sXHJcblx0XHRcdF0pO1xyXG5cdH0pO1xyXG5cclxuXHQvLyB1cGRhdGUgdGhlIGNvbm5lY3Rpb25zIHByb3BlcnR5IG9mIGVhY2ggaW50ZXJmYWNlXHJcblx0T2JqZWN0LmVudHJpZXMobmV3Q29ubmVjdGlvbnMpLmZvckVhY2goYXN5bmMgKFtmaWxlLCBjb25uZWN0aW9uc10pID0+IHtcclxuXHRcdGNvbnN0IGZpbGVDYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldENhY2hlKGZpbGUpO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHRmaWxlQ2FjaGUgJiZcclxuXHRcdFx0ZmlsZUNhY2hlLmZyb250bWF0dGVyICYmXHJcblx0XHRcdGZpbGVDYWNoZS5mcm9udG1hdHRlci5Db25uZWN0aW9uc1xyXG5cdFx0KSB7XHJcblx0XHRcdGF3YWl0IHBsdWdpbkhhbmRsZXIuZ2V0UGx1Z2lucygpLmZyb250bWF0dGVyLnBvc3RWYWx1ZXMoZmlsZSwgW1xyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdG5hbWU6IFwiQ29ubmVjdGlvbnNcIixcclxuXHRcdFx0XHRcdHBheWxvYWQ6IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IGNvbm5lY3Rpb25zXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgoYzogc3RyaW5nKSA9PiBgXFxuIC0gJHtjLnRyaW0oKX1gKVxyXG5cdFx0XHRcdFx0XHRcdC5qb2luKFwiXCIpLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0YXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChub2RlOiBFbGVtZW50KSB7XHJcblx0XHRsZXQgaXNHcm91cCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhcImNhbnZhcy1ub2RlLWdyb3VwXCIpKSBpc0dyb3VwID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBhZGQgY2xhc3MgdG8gZ3JvdXAgdG8gbWFrZSBpdCBjbGlja2FibGVcclxuXHRcdG5vZGUuY2xhc3NMaXN0LmFkZChcImNhbnZhcy1ub2RlLXN1YnN5c3RlbVwiKTtcclxuXHRcdGNvbnN0IGdyb3VwQ29udGVudCA9IG5vZGUuY2hpbGROb2Rlc1swXT8uY2hpbGROb2Rlc1swXTtcclxuXHRcdGNvbnN0IGdyb3VwTGFiZWwgPSBub2RlLmNoaWxkTm9kZXNbMV07XHJcblxyXG5cdFx0Y29uc3Qgbm9kZU5hbWUgPSBpc0dyb3VwXHJcblx0XHRcdD8gZ3JvdXBMYWJlbD8udGV4dENvbnRlbnRcclxuXHRcdFx0OiBncm91cENvbnRlbnQ/LnRleHRDb250ZW50O1xyXG5cclxuXHRcdGlmICghbm9kZU5hbWUpIHJldHVybjtcclxuXHJcblx0XHRjb25zdCBub2RlRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KG5vZGVOYW1lLCBcIlwiKTtcclxuXHJcblx0XHRpZiAoIW5vZGVGaWxlKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZG9tLWV2ZW50LXJlZ2lzdGVyZWRcIikpIHJldHVybjtcclxuXHRcdHBsdWdpbi5yZWdpc3RlckRvbUV2ZW50KG5vZGUgYXMgSFRNTEVsZW1lbnQsIFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xyXG5cdFx0XHRpZiAobm9kZUZpbGUgJiYgbm9kZUZpbGUuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcclxuXHRcdFx0XHRhcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChub2RlRmlsZS5wYXRoLCBcIlwiLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bm9kZS5jbGFzc0xpc3QuYWRkKFwiZG9tLWV2ZW50LXJlZ2lzdGVyZWRcIik7XHJcblxyXG5cdFx0bGV0IHVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzSnNvbi5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0Y2FudmFzSnNvbi5ub2Rlc1tpXS5sYWJlbCA9PT0gbm9kZU5hbWUgJiZcclxuXHRcdFx0XHRjYW52YXNKc29uLm5vZGVzW2ldLmZpbGUgIT09IG5vZGVGaWxlPy5wYXRoXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0Y2FudmFzSnNvbi5ub2Rlc1tpXS5maWxlID0gbm9kZUZpbGU/LnBhdGg7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHVwZGF0ZSAmJlxyXG5cdFx0XHQoYXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShjYW52YXNGaWxlLCBKU09OLnN0cmluZ2lmeShjYW52YXNKc29uKSkpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBoYW5kbGVycyBsb2dpY1xyXG5cdFx0aWYgKGlzR3JvdXApIHtcclxuXHRcdFx0cGx1Z2luLnJlZ2lzdGVyRG9tRXZlbnQoZ3JvdXBMYWJlbCBhcyBIVE1MRWxlbWVudCwgXCJmb2N1c291dFwiLCAoKSA9PlxyXG5cdFx0XHRcdHJlc29sdmVDb21wb25lbnQobm9kZSlcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBsdWdpbi5yZWdpc3RlckRvbUV2ZW50KFxyXG5cdFx0XHRcdGdyb3VwQ29udGVudCBhcyBIVE1MRWxlbWVudCxcclxuXHRcdFx0XHRcIm1vdXNlb3V0XCIsXHJcblx0XHRcdFx0KCkgPT4gcmVzb2x2ZUNvbXBvbmVudChub2RlKVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUVkZ2UoXHJcblx0XHRlZGdlSnNvbjoge1xyXG5cdFx0XHRsYWJlbDogYW55O1xyXG5cdFx0XHRjaGlsZE5vZGVzOiBhbnk7XHJcblx0XHRcdGZyb21Ob2RlOiBhbnk7XHJcblx0XHRcdHRvTm9kZTogYW55O1xyXG5cdFx0XHRpZDogc3RyaW5nO1xyXG5cdFx0fSxcclxuXHRcdGluZGV4OiBudW1iZXJcclxuXHQpIHtcclxuXHRcdGNvbnN0IGVkZ2UgPSBBcnJheS5mcm9tKGVkZ2VzRWxzKS5maW5kKChlZGdlKSA9PiB7XHJcblx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0ZWRnZUpzb24ubGFiZWwgPT09IGVkZ2UuY2hpbGROb2Rlc1swXT8udGV4dENvbnRlbnQgJiZcclxuXHRcdFx0XHQhdXNlZEVkZ2VzLmluY2x1ZGVzKGVkZ2UpXHJcblx0XHRcdCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWVkZ2UpIHJldHVybjtcclxuXHJcblx0XHQvLyBnZXQgdGhlIGVkZ2UgZnJvbSB0aGUgY2FudmFzIGZpbGVcclxuXHJcblx0XHRjb25zdCBlZGdlTmFtZSA9IGVkZ2UuY2hpbGROb2Rlc1swXT8udGV4dENvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKCFlZGdlTmFtZSB8fCBlZGdlTmFtZS5sZW5ndGggPD0gMykge1xyXG5cdFx0XHRjYW52YXNKc29uLmVkZ2VzW2luZGV4XS5sYWJlbCA9IFwiXHUyNkEwXHVGRTBGXCI7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYmVzdE1hdGNoID0gXCJcIjtcclxuXHJcblx0XHRPYmplY3QuZW50cmllcyhhcHAudmF1bHQuZmlsZU1hcCkuZm9yRWFjaCgoW3BhdGgsIGZpbGVdKSA9PiB7XHJcblx0XHRcdGlmIChwYXRoLmluY2x1ZGVzKFwiLm1kXCIpKSB7XHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0ZmlsZS5iYXNlbmFtZVxyXG5cdFx0XHRcdFx0XHQudG9Mb3dlckNhc2UoKVxyXG5cdFx0XHRcdFx0XHQuaW5jbHVkZXMoZWRnZU5hbWU/LnRvTG93ZXJDYXNlKCkpICYmXHJcblx0XHRcdFx0XHRmaWxlLmJhc2VuYW1lLmxlbmd0aCA+IGJlc3RNYXRjaC5sZW5ndGhcclxuXHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdGJlc3RNYXRjaCA9IGZpbGUuYmFzZW5hbWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBlZGdlRmlsZSA9IGVkZ2VOYW1lXHJcblx0XHRcdD8gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoYmVzdE1hdGNoLCBcIlwiKVxyXG5cdFx0XHQ6IG51bGw7XHJcblxyXG5cdFx0aWYgKCFlZGdlRmlsZSB8fCBlZGdlRmlsZS5leHRlbnNpb24gIT09IFwibWRcIikgcmV0dXJuO1xyXG5cclxuXHRcdGlmICghZWRnZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkb20tZXZlbnQtcmVnaXN0ZXJlZFwiKSkge1xyXG5cdFx0XHRwbHVnaW4ucmVnaXN0ZXJEb21FdmVudChlZGdlIGFzIEhUTUxFbGVtZW50LCBcImRibGNsaWNrXCIsICgpID0+IHtcclxuXHRcdFx0XHRhcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChlZGdlRmlsZS5wYXRoLCBcIlwiLCB0cnVlKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRlZGdlLmNsYXNzTGlzdC5hZGQoXCJkb20tZXZlbnQtcmVnaXN0ZXJlZFwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZXQgdGhlIGZyb20gYW5kIHRvIG5vZGVzXHJcblx0XHRjb25zdCBmcm9tTm9kZSA9IGNhbnZhc0pzb24ubm9kZXMuZmluZCgobm9kZTogYW55KSA9PiB7XHJcblx0XHRcdHJldHVybiBub2RlLmlkID09PSBlZGdlSnNvbi5mcm9tTm9kZTtcclxuXHRcdH0pLmZpbGU7XHJcblx0XHRjb25zdCB0b05vZGUgPSBjYW52YXNKc29uLm5vZGVzLmZpbmQoKG5vZGU6IGFueSkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5pZCA9PT0gZWRnZUpzb24udG9Ob2RlO1xyXG5cdFx0fSkuZmlsZTtcclxuXHJcblx0XHQvLyBnZXQgdGhlIGZyb20gYW5kIHRvIGZpbGVzXHJcblx0XHRjb25zdCBmcm9tRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGZyb21Ob2RlLCBcIlwiKTtcclxuXHRcdGNvbnN0IHRvRmlsZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHRvTm9kZSwgXCJcIik7XHJcblxyXG5cdFx0Ly8gZ2V0IHRoZSBmcm9tIGFuZCB0byBjb25uZWN0aW9uc1xyXG5cdFx0Y29uc3QgZnJvbUNvbmVuY3Rpb24gPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZnJvbUZpbGUgYXMgYW55KVxyXG5cdFx0XHQ/LmZyb250bWF0dGVyPy5JRDtcclxuXHRcdGNvbnN0IHRvQ29ubmVjdGlvbiA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0b0ZpbGUgYXMgYW55KVxyXG5cdFx0XHQ/LmZyb250bWF0dGVyPy5JRDtcclxuXHJcblx0XHRpZiAoZWRnZUZpbGUpIHtcclxuXHRcdFx0Ly8gZ2V0IHRoZSBlZGdlJ3MgZmlsZSBjYWNoZVxyXG5cdFx0XHRjb25zdCBlZGdlRmlsZUNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGUoZWRnZUZpbGUucGF0aCk7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRlZGdlRmlsZUNhY2hlICYmXHJcblx0XHRcdFx0ZWRnZUZpbGVDYWNoZS5mcm9udG1hdHRlciAmJlxyXG5cdFx0XHRcdGVkZ2VGaWxlQ2FjaGUuZnJvbnRtYXR0ZXIuQ29ubmVjdGlvbnNcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0aWYgKCFuZXdDb25uZWN0aW9uc1tlZGdlRmlsZS5wYXRoXSkge1xyXG5cdFx0XHRcdFx0bmV3Q29ubmVjdGlvbnNbZWRnZUZpbGUucGF0aF0gPSBbXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bmV3Q29ubmVjdGlvbnNbZWRnZUZpbGUucGF0aF0ucHVzaChcclxuXHRcdFx0XHRcdGAke2Zyb21Db25lbmN0aW9ufSA8PT4gJHt0b0Nvbm5lY3Rpb259YFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjYW52YXNKc29uLmVkZ2VzW2luZGV4XS5sYWJlbCA9IGVkZ2VGaWxlLmJhc2VuYW1lO1xyXG5cdFx0dXNlZEVkZ2VzLnB1c2goZWRnZSk7XHJcblx0fVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTeXN0ZW0oZmlsZTogVEZpbGUpIHtcclxuXHRpZiAoIWZpbGUpIHJldHVybjtcclxuXHJcblx0Y29uc3QgeyBmcm9udG1hdHRlciB9ID0gcGx1Z2luSGFuZGxlci5nZXRQbHVnaW5zKCk7XHJcblx0Y29uc3Qgc3lzdGVtID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcj8uU3lzdGVtO1xyXG5cdGNvbnN0IGFsaWFzID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcj8uYWxpYXNlcztcclxuXHRjb25zb2xlLmxvZyhcImFsaWFzXCIsIGFsaWFzKTtcclxuXHJcblx0YXdhaXQgZnJvbnRtYXR0ZXIucG9zdFZhbHVlcyhmaWxlLCBbXHJcblx0XHR7XHJcblx0XHRcdG5hbWU6IFwiSURcIixcclxuXHRcdFx0cGF5bG9hZDoge1xyXG5cdFx0XHRcdHZhbHVlOlxyXG5cdFx0XHRcdFx0c3lzdGVtICtcclxuXHRcdFx0XHRcdFwiLlwiICtcclxuXHRcdFx0XHRcdChhbGlhc1xyXG5cdFx0XHRcdFx0XHQ/IGFsaWFzWzBdLnRvVXBwZXJDYXNlKCkudHJpbSgpXHJcblx0XHRcdFx0XHRcdDogZmlsZS5iYXNlbmFtZVxyXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teXFx3LixcXHNdL2csIFwiXCIpXHJcblx0XHRcdFx0XHRcdFx0XHQudG9VcHBlckNhc2UoKVxyXG5cdFx0XHRcdFx0XHRcdFx0LnRyaW0oKVxyXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoLyAvZywgXCJfXCIpKSxcclxuXHRcdFx0fSxcclxuXHRcdH0sXHJcblx0XSk7XHJcblxyXG5cdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVIZWFkaW5nQ29tcG9uZW50KHJfZmlsZTogVEZpbGUpIHtcclxuXHRcdGlmIChyX2ZpbGUgIT09IGZpbGUpIHJldHVybjtcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcInJlc29sdmluZyBoZWFkaW5nIGNvbXBvbmVudFwiLCBpbmRleCk7XHJcblxyXG5cdFx0c3dpdGNoIChpbmRleCkge1xyXG5cdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0Y29uc3QgcnRtayA9IGF3YWl0IHJlcXVpcmVtZW50c1RhYmxlMihmaWxlKTtcclxuXHRcdFx0XHRhd2FpdCBpbnNlcnRNYXJrZG93blVuZGVySGVhZGluZyhmaWxlLCBcIlJlcXVpcmVtZW50c1wiLCBydG1rKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdGNvbnN0IHR0bWsgPSBhd2FpdCB0ZXN0c1RhYmxlKGZpbGUpO1xyXG5cdFx0XHRcdGF3YWl0IGluc2VydE1hcmtkb3duVW5kZXJIZWFkaW5nKGZpbGUsIFwiVGVzdHNcIiwgdHRtayk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0Y29uc3QgaXRtayA9IGF3YWl0IGludGVyZmFjZXNUYWJsZShmaWxlKTtcclxuXHRcdFx0XHRhd2FpdCBpbnNlcnRNYXJrZG93blVuZGVySGVhZGluZyhmaWxlLCBcIkludGVyZmFjZXNcIiwgaXRtayk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0aW5kZXgrKztcclxuXHJcblx0XHRpZiAoaW5kZXggPiAyKVxyXG5cdFx0XHRhcHAubWV0YWRhdGFDYWNoZS5vZmYoXCJyZXNvbHZlXCIsIHJlc29sdmVIZWFkaW5nQ29tcG9uZW50KTtcclxuXHR9XHJcblxyXG5cdGFwcC5tZXRhZGF0YUNhY2hlLm9uKFwicmVzb2x2ZVwiLCByZXNvbHZlSGVhZGluZ0NvbXBvbmVudCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUludGVyZmFjZShmaWxlOiBURmlsZSkge1xyXG5cdGNvbnN0IHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQgfSA9IGFwcDtcclxuXHRjb25zdCBmbSA9IG1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlciBhcyB1bmtub3duIGFzIHtcclxuXHRcdFR5cGU6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xyXG5cdH07XHJcblxyXG5cdGlmICghZm0uVHlwZSkgcmV0dXJuO1xyXG5cclxuXHRpZiAoZm0uVHlwZS5pbmNsdWRlcyhcIkVsZWN0cmljYWxcIikpIHtcclxuXHRcdGF3YWl0IGFkZEljb25Ub05hbWUoZmlsZSwgYXBwLCBcIlx1MjZBMVwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0YXdhaXQgcmVtb3ZlSWNvbkZyb21OYW1lKGZpbGUsIGFwcCwgXCJcdTI2QTFcIik7XHJcblx0fVxyXG5cdGlmIChmbS5UeXBlLmluY2x1ZGVzKFwiTWVjaGFuaWNhbFwiKSkge1xyXG5cdFx0YXdhaXQgYWRkSWNvblRvTmFtZShmaWxlLCBhcHAsIFwiXHVEODNEXHVERUUwXHVGRTBGXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRhd2FpdCByZW1vdmVJY29uRnJvbU5hbWUoZmlsZSwgYXBwLCBcIlx1RDgzRFx1REVFMFx1RkUwRlwiKTtcclxuXHR9XHJcblx0aWYgKGZtLlR5cGUuaW5jbHVkZXMoXCJTb2Z0d2FyZVwiKSkge1xyXG5cdFx0YXdhaXQgYWRkSWNvblRvTmFtZShmaWxlLCBhcHAsIFwiXHVEODNEXHVEQ0JCXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRhd2FpdCByZW1vdmVJY29uRnJvbU5hbWUoZmlsZSwgYXBwLCBcIlx1RDgzRFx1RENCQlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlcXVpcmVtZW50KGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdC8vIGF3YWl0IGFkZEVtYmVkKGNvbnRlbnQpO1xyXG5cclxuXHQvLzFzdCBjaGVjayBpZiB0aGUgcmVxdWlyZW1lbnQgaGFzIGEgc291cmNlXHJcblxyXG5cdGNvbnN0IHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQgfSA9IGFwcDtcclxuXHRjb25zdCBoZWFkaW5ncyA9IG1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5oZWFkaW5ncyA/PyBbXTtcclxuXHRsZXQgdGV4dCA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblxyXG5cdC8vIGFwcC5maWxlTWFuYWdlci5pbnNlcnRUZXh0SW50b0ZpbGUoZmlsZSwgXCIjIyB0ZXN0XCIsIFwiXCIsIFwiXCIsIGZhbHNlKTtcclxuXHJcblx0Y29uc3QgZElkeCA9IGhlYWRpbmdzLmZpbmRJbmRleChcclxuXHRcdCh7IGhlYWRpbmcgfTogSGVhZGluZ0NhY2hlKSA9PiBoZWFkaW5nID09PSBcIkRlc2NyaXB0aW9uXCJcclxuXHQpO1xyXG5cclxuXHRjb25zdCBoSWR4ID0gaGVhZGluZ3MuZmluZEluZGV4KFxyXG5cdFx0KHsgaGVhZGluZyB9OiBIZWFkaW5nQ2FjaGUpID0+IGhlYWRpbmcgPT09IFwiU291cmNlXCJcclxuXHQpO1xyXG5cdGlmIChoSWR4ID09PSAtMSkge1xyXG5cdFx0dGV4dCA9IFwiXCI7XHJcblx0XHQvLyBzZXQgZmlsZSdzIG5hbWUgdG8gbm8gc291cmNlXHJcblx0XHRhd2FpdCBhZGRXYXJuaW5nKGZpbGUsIGFwcCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRleHQgPSB0ZXh0XHJcblx0XHRcdC5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHQuc2xpY2UoXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeF0ucG9zaXRpb24uc3RhcnQubGluZSArIDEsXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeCArIDFdPy5wb3NpdGlvbj8uc3RhcnQ/LmxpbmVcclxuXHRcdFx0KVxyXG5cdFx0XHQuam9pbihcIlxcblwiKVxyXG5cdFx0XHQudHJpbSgpO1xyXG5cclxuXHRcdGlmICh0ZXh0ID09PSBcIlwiKSB7XHJcblx0XHRcdGF3YWl0IGFkZFdhcm5pbmcoZmlsZSwgYXBwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGF3YWl0IHJlbW92ZVdhcm5pbmcoZmlsZSwgYXBwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNvbnN0IHRleHQyID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcclxuXHRjb25zdCB2YWx1ZXMgPSB7XHJcblx0XHRpZDogZmlsZS5iYXNlbmFtZS5yZXBsYWNlKC9bXlxcdy4sXFxzXS9nLCBcIlwiKS50cmltKCksXHJcblx0XHRkZXNjcmlwdGlvbjogdGV4dDJcclxuXHRcdFx0LnNwbGl0KFwiXFxuXCIpXHJcblx0XHRcdC5zbGljZShcclxuXHRcdFx0XHRoZWFkaW5nc1tkSWR4XS5wb3NpdGlvbi5zdGFydC5saW5lICsgMSxcclxuXHRcdFx0XHRoZWFkaW5nc1tkSWR4ICsgMV0/LnBvc2l0aW9uPy5zdGFydD8ubGluZVxyXG5cdFx0XHQpXHJcblx0XHRcdC5qb2luKFwiXFxuXCIpXHJcblx0XHRcdC50cmltKCksXHJcblx0XHRzb3VyY2U6IHRleHQyXHJcblx0XHRcdC5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHQuc2xpY2UoXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeF0ucG9zaXRpb24uc3RhcnQubGluZSArIDEsXHJcblx0XHRcdFx0aGVhZGluZ3NbaElkeCArIDFdPy5wb3NpdGlvbj8uc3RhcnQ/LmxpbmVcclxuXHRcdFx0KVxyXG5cdFx0XHQuam9pbihcIlxcblwiKVxyXG5cdFx0XHQudHJpbSgpLFxyXG5cdFx0c3lzdGVtOlxyXG5cdFx0XHRtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI/LlN5c3RlbSA/P1xyXG5cdFx0XHRcIlVuc3BlY2lmaWVkL0dlbmVyYWxcIixcclxuXHR9O1xyXG5cclxuXHRhZGRFbWJlZCh2YWx1ZXMsIGZpbGUpLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xyXG5cdFx0Y29uc3QgZGF0YSA9IGF3YWl0IGZpbGUudmF1bHQucmVhZChmaWxlKTtcclxuXHRcdC8vIHJlbW92ZSBhbnkgY29uZmxpY3RzIGZyb20gdGhlIGZpbGVcclxuXHJcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBjb21wYXJlUmVxdWlyZW1lbnRzKHJlcyk7XHJcblx0XHRjb25zdCB7IGZyb250bWF0dGVyIH0gPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKTtcclxuXHRcdGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcblx0XHQvLyBIZXJlIHlvdSBjYW4gZGV0ZXJtaW5lIHdoYXQgaXMgdGhlIG91dHB1dCBvZiB0aGUgY29tcGFyaXNvbiBhbGdvcml0aG0gYW5kIHdoYXQgdG8gZG8gd2l0aCBpdFxyXG5cdFx0aWYgKHJlc3VsdD8uaW5jbHVkZXMoXCJZRVNcIikpIHtcclxuXHRcdFx0Y29uc3QgbmV3RGF0YSA9IGRhdGEucmVwbGFjZShcclxuXHRcdFx0XHRhd2FpdCBnZXRTZWN0aW9uKGZpbGUsIFwiQ29uZmxpY3RcIiksXHJcblx0XHRcdFx0XCJcIlxyXG5cdFx0XHQpO1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgbmV3RGF0YSk7XHJcblx0XHRcdGF3YWl0IGFkZEVycm9yKGZpbGUsIHRoaXMuYXBwKTtcclxuXHRcdFx0Ly8gYWRkIHJlc3VsdCB0byB0aGUgZmlsZVxyXG5cdFx0XHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KGZpbGUsIG5ld0RhdGEgKyBgJHtyZXN1bHR9YCk7XHJcblxyXG5cdFx0XHRmcm9udG1hdHRlci5wb3N0VmFsdWVzKGZpbGUsIFtcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRuYW1lOiBcIlN0YXR1c1wiLFxyXG5cdFx0XHRcdFx0cGF5bG9hZDoge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogXCJjb25mbGljdFwiLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdG5hbWU6IFwiQ29uZmxpY3RpbmcgV2l0aFwiLFxyXG5cdFx0XHRcdFx0cGF5bG9hZDoge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogcmVzdWx0LnN1YnN0cmluZyhcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQuaW5kZXhPZihcIltbXCIpICsgMixcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQuaW5kZXhPZihcIl1dXCIpXHJcblx0XHRcdFx0XHRcdCksXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YXdhaXQgcmVtb3ZlRXJyb3IoZmlsZSwgdGhpcy5hcHApO1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoXHJcblx0XHRcdFx0ZmlsZSxcclxuXHRcdFx0XHRkYXRhLnJlcGxhY2UoYXdhaXQgZ2V0U2VjdGlvbihmaWxlLCBcIkNvbmZsaWN0XCIpLCBcIlwiKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0ZnJvbnRtYXR0ZXIucG9zdFZhbHVlcyhmaWxlLCBbXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bmFtZTogXCJTdGF0dXNcIixcclxuXHRcdFx0XHRcdHBheWxvYWQ6IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IFwiaW4tcmV2aWV3XCIsXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bmFtZTogXCJDb25mbGljdGluZyBXaXRoXCIsXHJcblx0XHRcdFx0XHRwYXlsb2FkOiB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBcIlwiLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xyXG5cclxuXHQvLyBHZXQgYSBHUFQgZW1iZWRkaW5nIGFuZCBjb21wYXJlIHRvIG90aGVyIGVtYmVkZGluZ3Mgb2YgdGhlIHNhbWUgY2xhc3MgaW4gdGhlIGRhdGFiYXNlXHJcbn1cclxuXHJcbmNsYXNzIENyZWF0ZUNvbXBvbmVudE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cdHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzO1xyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncykge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHR9XHJcblxyXG5cdG9uT3BlbigpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgYXBwID0gdGhpcy5hcHA7XHJcblx0XHRjb25zdCBjdXJyZW50RmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHQvLyBpbnB1dCB3aXRoIGEgcHJvbXB0IGZvciBjb21wb25lbnQgbmFtZVxyXG5cdFx0Y29udGVudEVsLmlubmVySFRNTCA9IGBcclxuXHRcdDxoMj5DcmVhdGUgQ29tcG9uZW50PC9oMj5cclxuXHRcdDxwPkVudGVyIGNvbXBvbmVudCBuYW1lPC9wPlxyXG5cdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJjb21wb25lbnQtbmFtZVwiIHBsYWNlaG9sZGVyPVwiQ29tcG9uZW50IG5hbWVcIiAvPlxyXG5cdFx0PHA+U2VsZWN0IGlmIHRoaXMgaXMgYSBjb21wb25lbnQ8L3A+XHJcblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJpcy1jb21wb25lbnRcIiAvPlxyXG5cdFx0PGJyPlxyXG5cdFx0PGJ1dHRvbiBpZD1cImNyZWF0ZS1jb21wb25lbnRcIj5DcmVhdGU8L2J1dHRvbj5cclxuXHRcdGA7XHJcblxyXG5cdFx0Y29uc3QgYnV0dG9uID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXCIjY3JlYXRlLWNvbXBvbmVudFwiKTtcclxuXHRcdGNvbnN0IGlucHV0ID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXHJcblx0XHRcdFwiI2NvbXBvbmVudC1uYW1lXCJcclxuXHRcdCkgYXMgSFRNTElucHV0RWxlbWVudDtcclxuXHRcdGNvbnN0IGlzQ29tcG9uZW50ID0gY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoXHJcblx0XHRcdFwiI2lzLWNvbXBvbmVudFwiXHJcblx0XHQpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG5cdFx0Y29uc3QgaXNDYW52YXMgPSBjdXJyZW50RmlsZT8uZXh0ZW5zaW9uID09PSBcImNhbnZhc1wiO1xyXG5cclxuXHRcdGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNyZWF0ZSgpIHtcclxuXHRcdFx0aWYgKCFpbnB1dC52YWx1ZSkgcmV0dXJuO1xyXG5cdFx0XHRjb25zdCBuYW1lID0gaW5wdXQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAoIWN1cnJlbnRGaWxlKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIkFjdGl2ZSBmaWxlIGlzIG5vdCBhIGNvbXBvbmVudFwiKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHJvb3RQYXRoID0gY3VycmVudEZpbGUucGF0aC5zcGxpdChjdXJyZW50RmlsZS5uYW1lKVswXTtcclxuXHRcdFx0aWYgKGlzQ2FudmFzKSB7XHJcblx0XHRcdFx0cm9vdFBhdGggPSB0aGlzLnNldHRpbmdzLnN5c3RlbV9kZXNpZ25fcm9vdF9mb2xkZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG5ld0NvbXBvbmVudCA9IGF3YWl0IGFkZENvbXBvbmVudCh7XHJcblx0XHRcdFx0c3lzdGVtOiBcIlRXUjJcIixcclxuXHRcdFx0XHRwYXRoOiByb290UGF0aCxcclxuXHRcdFx0XHRmaWxlTmFtZTogbmFtZSxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRhd2FpdCBhZGRUb1N5c3RlbURpYWdyYW0oe1xyXG5cdFx0XHRcdGZpbGU6IG5ld0NvbXBvbmVudCxcclxuXHRcdFx0XHRpc0NvbXBvbmVudDogaXNDb21wb25lbnQuY2hlY2tlZCxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBuZXcgZmlsZVxyXG5cdFx0XHRhcHAud29ya3NwYWNlXHJcblx0XHRcdFx0LmNyZWF0ZUxlYWZCeVNwbGl0KGFwcC53b3Jrc3BhY2UuZ2V0TGVhZigpKVxyXG5cdFx0XHRcdC5vcGVuRmlsZShuZXdDb21wb25lbnQpO1xyXG5cclxuXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJ1dHRvbj8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNyZWF0ZS5iaW5kKHRoaXMpKTtcclxuXHRcdGNvbnRlbnRFbC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgKGUpID0+IHtcclxuXHRcdFx0aWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcclxuXHRcdFx0XHRoYW5kbGVDcmVhdGUuYmluZCh0aGlzKSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogTXlQbHVnaW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHR9XHJcblxyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiU2V0dGluZyAjMVwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcIkl0J3MgYSBzZWNyZXRcIilcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgeW91ciBzZWNyZXRcIilcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcpXHJcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZyA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiU3lzdGVtcyBkZXNpZ24gcm9vdCBmb2xkZXJcIilcclxuXHRcdFx0LnNldERlc2MoXCJUaGUgZm9sZGVyIHdoZXJlIHRoZSBzeXN0ZW1zIGRlc2lnbiBmaWxlcyBhcmUgc3RvcmVkXCIpXHJcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG5cdFx0XHRcdHRleHRcclxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHRoZSBmb2xkZXIgcGF0aFwiKVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKFwiMTEtU3lzdGVtX2Rlc2lnblwiKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5zeXN0ZW1fZGVzaWduX3Jvb3RfZm9sZGVyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHQvL2ZvbGRlciBmb3IgdGVzdHNcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIlRlc3RzIHJvb3QgZm9sZGVyXCIpXHJcblx0XHRcdC5zZXREZXNjKFwiVGhlIGZvbGRlciB3aGVyZSB0aGUgdGVzdHMgYXJlIHN0b3JlZFwiKVxyXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cclxuXHRcdFx0XHR0ZXh0XHJcblx0XHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciB0aGUgZm9sZGVyIHBhdGhcIilcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZShcIjA1LVRlc3RfZG9jdW1lbnRhdGlvblwiKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy50ZXN0X2RvY3VtZW50YXRpb25fcm9vdF9mb2xkZXIgPVxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0Ly9mb2xkZXIgZm9yIGludGVyZmFjZXNcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkludGVyZmFjZXMgcm9vdCBmb2xkZXJcIilcclxuXHRcdFx0LnNldERlc2MoXCJUaGUgZm9sZGVyIHdoZXJlIHRoZSBpbnRlcmZhY2VzIGFyZSBzdG9yZWRcIilcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgdGhlIGZvbGRlciBwYXRoXCIpXHJcblx0XHRcdFx0XHQuc2V0VmFsdWUoXCIxMi1JbnRlcmZhY2VzXCIpXHJcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmludGVyZmFjZXNfcm9vdF9mb2xkZXIgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5pbnRlcmZhY2UgUGx1Z2lucyB7XHJcblx0ZGF0YXZpZXc6IGFueTtcclxuXHRmcm9udG1hdHRlcjogYW55O1xyXG5cdHNrYV9zZToge1xyXG5cdFx0c2V0dGluZ3M6IHtcclxuXHRcdFx0bXlTZXR0aW5nOiBzdHJpbmc7XHJcblx0XHRcdHN5c3RlbV9kZXNpZ25fcm9vdF9mb2xkZXI6IHN0cmluZztcclxuXHRcdFx0dGVzdF9kb2N1bWVudGF0aW9uX3Jvb3RfZm9sZGVyOiBzdHJpbmc7XHJcblx0XHRcdGludGVyZmFjZXNfcm9vdF9mb2xkZXI6IHN0cmluZztcclxuXHRcdH07XHJcblx0fTtcclxufVxyXG5cclxuY2xhc3MgUGx1Z2luSGFuZGxlciB7XHJcblx0cGx1Z2luczogUGx1Z2lucztcclxuXHRhcHA6IEFwcDtcclxuXHRjb25zdHJ1Y3RvcigpIHt9XHJcblxyXG5cdGluaXQoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdH1cclxuXHJcblx0c2V0UGx1Z2lucyhwbHVnaW5zOiBQbHVnaW5zKSB7XHJcblx0XHR0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xyXG5cdH1cclxuXHJcblx0Z2V0UGx1Z2lucygpIHtcclxuXHRcdGlmICghdGhpcy5wbHVnaW5zKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Ly9AdHMtaWdub3JlXHJcblx0XHRcdFx0ZGF0YXZpZXc6IHRoaXMuYXBwLnBsdWdpbnMucGx1Z2luc1tcImRhdGF2aWV3XCJdLmFwaSxcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRmcm9udG1hdHRlcjogdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zW1wibWV0YWRhdGEtbWVudVwiXS5hcGksXHJcblx0XHRcdFx0c2thX3NlOiB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnNbXCJza2Etc2Utb2JzaWRpYW4tcGx1Z2luXCJdIC8vQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0LmFwaSBhcyBQbHVnaW5zW1wic2thX3NlXCJdLFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMucGx1Z2lucztcclxuXHR9XHJcbn1cclxuXHJcbmNvbnN0IHBsdWdpbkhhbmRsZXIgPSBuZXcgUGx1Z2luSGFuZGxlcigpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luSGFuZGxlcjtcclxuIiwgImltcG9ydCB7IFRGaWxlLCBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHBsdWdpbkhhbmRsZXIgZnJvbSBcIi4vZ2xvYmFsSGFuZGxlcnNcIjtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVFcnJvcihmaWxlOiBURmlsZSwgYXBwOiBBcHApIHtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCJcdTI3NENcIikuam9pbihcIlwiKS50cmltKClcclxuXHQpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVXYXJuaW5nKGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdGF3YWl0IGFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKFxyXG5cdFx0ZmlsZSxcclxuXHRcdGZpbGUucGF0aC5zcGxpdChcIlx1MjZBMFx1RkUwRlwiKS5qb2luKFwiXCIpLnRyaW0oKVxyXG5cdCk7XHJcbn1cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZEVycm9yKGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoXCJcdTI3NENcIikpIHJldHVybjtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCIubWRcIilbMF0udHJpbSgpICsgXCIgXHUyNzRDLm1kXCJcclxuXHQpO1xyXG59XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRXYXJuaW5nKGZpbGU6IFRGaWxlLCBhcHA6IEFwcCkge1xyXG5cdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoXCJcdTI2QTBcdUZFMEZcIikpIHJldHVybjtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCIubWRcIilbMF0udHJpbSgpICsgXCIgXHUyNkEwXHVGRTBGLm1kXCJcclxuXHQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkSWNvblRvTmFtZShmaWxlOiBURmlsZSwgYXBwOiBBcHAsIGljb246IHN0cmluZykge1xyXG5cdGlmIChmaWxlLnBhdGguaW5jbHVkZXMoaWNvbikpIHJldHVybjtcclxuXHRhd2FpdCBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShcclxuXHRcdGZpbGUsXHJcblx0XHRmaWxlLnBhdGguc3BsaXQoXCIubWRcIilbMF0udHJpbSgpICsgYCAke2ljb259Lm1kYFxyXG5cdCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVJY29uRnJvbU5hbWUoZmlsZTogVEZpbGUsIGFwcDogQXBwLCBpY29uOiBzdHJpbmcpIHtcclxuXHRpZiAoIWZpbGUucGF0aC5pbmNsdWRlcyhpY29uKSkgcmV0dXJuO1xyXG5cdGF3YWl0IGFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKFxyXG5cdFx0ZmlsZSxcclxuXHRcdGZpbGUucGF0aC5zcGxpdChpY29uKS5qb2luKFwiXCIpLnRyaW0oKVxyXG5cdCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZWN0aW9uKGZpbGU6IFRGaWxlLCBoZWFkaW5nVG9TZWFyY2g6IHN0cmluZykge1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cclxuXHRjb25zdCB7IG1ldGFkYXRhQ2FjaGUsIHZhdWx0IH0gPSBhcHA7XHJcblx0Y29uc3QgaGVhZGluZ3MgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uaGVhZGluZ3MgPz8gW107XHJcblx0bGV0IHRleHQgPSBhd2FpdCB2YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xyXG5cdGNvbnN0IGhJZHggPSBoZWFkaW5ncy5maW5kSW5kZXgoXHJcblx0XHQoeyBoZWFkaW5nIH06IGFueSkgPT4gaGVhZGluZyA9PT0gaGVhZGluZ1RvU2VhcmNoXHJcblx0KTtcclxuXHRpZiAoaElkeCA9PT0gLTEpIHtcclxuXHRcdHRleHQgPSBcIlwiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0ZXh0ID0gdGV4dFxyXG5cdFx0XHQuc3BsaXQoXCJcXG5cIilcclxuXHRcdFx0LnNsaWNlKFxyXG5cdFx0XHRcdGhlYWRpbmdzW2hJZHhdLnBvc2l0aW9uLnN0YXJ0LmxpbmUgKyAxLFxyXG5cdFx0XHRcdGhlYWRpbmdzW2hJZHggKyAxXT8ucG9zaXRpb24/LnN0YXJ0Py5saW5lXHJcblx0XHRcdClcclxuXHRcdFx0LmpvaW4oXCJcXG5cIilcclxuXHRcdFx0LnRyaW0oKTtcclxuXHR9XHJcblxyXG5cdGNvbnNvbGUubG9nKHRleHQpO1xyXG5cclxuXHRyZXR1cm4gdGV4dDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluc2VydE1hcmtkb3duVW5kZXJIZWFkaW5nKFxyXG5cdGZpbGU6IFRGaWxlLFxyXG5cdGhlYWRpbmdUb1NlYXJjaDogc3RyaW5nLFxyXG5cdG1hcmtkb3duOiBzdHJpbmcsXHJcblx0b2Zmc2V0OiBudW1iZXJbXSA9IFtdLFxyXG5cdG9mZnNldExpbmU6IG51bWJlcltdID0gW11cclxuKTogUHJvbWlzZTxudW1iZXJbXVtdPiB7XHJcblx0aWYgKCFtYXJrZG93bikgbWFya2Rvd24gPSBcIlwiO1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cclxuXHRjb25zdCB7IG1ldGFkYXRhQ2FjaGUsIHZhdWx0IH0gPSBhcHA7XHJcblx0Y29uc3QgY2FjaGUgPSBtZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcclxuXHRjb25zdCBoZWFkaW5ncyA9IGNhY2hlPy5oZWFkaW5ncyA/PyBbXTtcclxuXHRjb25zdCBzZWN0aW9ucyA9IGNhY2hlPy5zZWN0aW9ucyA/PyBbXTtcclxuXHRsZXQgdGV4dCA9IGF3YWl0IHZhdWx0LnJlYWQoZmlsZSk7XHJcblx0bGV0IGRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuXHJcblx0Y29uc3QgaGVhZGluZyA9IGhlYWRpbmdzLmZpbmQoXHJcblx0XHQoeyBoZWFkaW5nIH06IGFueSkgPT4gaGVhZGluZyA9PT0gaGVhZGluZ1RvU2VhcmNoXHJcblx0KTtcclxuXHRpZiAoIWhlYWRpbmcpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiTm8gaGVhZGluZyBmb3VuZFwiKTtcclxuXHRcdHJldHVybiBbb2Zmc2V0LCBvZmZzZXRMaW5lXTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGhJZHggPSBzZWN0aW9ucy5maW5kSW5kZXgoXHJcblx0XHQoeyBwb3NpdGlvbiB9OiBhbnkpID0+XHJcblx0XHRcdHBvc2l0aW9uLmVuZC5vZmZzZXQgPT09IGhlYWRpbmcucG9zaXRpb24uZW5kLm9mZnNldFxyXG5cdCk7XHJcblx0Ly8gY2FsY3VsYXRlIHRoZSB0b3RhbCBvZmZzZXQgYnkgY2hlY2tpbmcgaWYgdGhlIGhlYWRpbmcgaXMgYmVsb3cgdGhlIG9mZnNldExpbmUgYW5kIGlmIHNvLCBhZGQgdGhlIG9mZnNldFxyXG5cdC8vIHRvIHRoZSB0b3RhbCBvZmZzZXRcclxuXHRjb25zdCB0b3RhbE9mZnNldCA9IG9mZnNldD8ucmVkdWNlKChhY2MsIGN1cnIsIGlkeCkgPT4ge1xyXG5cdFx0aWYgKG9mZnNldExpbmUgJiYgaGVhZGluZy5wb3NpdGlvbi5zdGFydC5saW5lID49IG9mZnNldExpbmVbaWR4XSkge1xyXG5cdFx0XHRyZXR1cm4gYWNjICsgY3VycjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhY2M7XHJcblx0fSwgMCk7XHJcblxyXG5cdGlmICghc2VjdGlvbnNbaElkeCArIDFdIHx8IHNlY3Rpb25zW2hJZHggKyAxXS50eXBlID09PSBcImhlYWRpbmdcIikge1xyXG5cdFx0Y29uc29sZS5sb2coXCJoZXJlXCIpO1xyXG5cdFx0Ly8gcHV0IHRoZSBkYXRhIGRpcmVjdGx5IHVuZGVyIHRoZSBoZWFkaW5nXHJcblx0XHR0ZXh0ID1cclxuXHRcdFx0dGV4dC5zbGljZSgwLCBoZWFkaW5nLnBvc2l0aW9uLmVuZC5vZmZzZXQgKyB0b3RhbE9mZnNldCkgK1xyXG5cdFx0XHRtYXJrZG93biArXHJcblx0XHRcdHRleHQuc2xpY2UoaGVhZGluZy5wb3NpdGlvbi5lbmQub2Zmc2V0ICsgdG90YWxPZmZzZXQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyByZW1vdmUgdGhlIGRhdGEgaW4gdGhpcyBzZWN0aW9uIGFuZCBwdXQgdGhlIG5ldyBkYXRhIHVuZGVyIHRoZSBoZWFkaW5nXHJcblx0XHR0ZXh0ID1cclxuXHRcdFx0dGV4dC5zbGljZSgwLCBoZWFkaW5nLnBvc2l0aW9uLmVuZC5vZmZzZXQgKyB0b3RhbE9mZnNldCkgK1xyXG5cdFx0XHRtYXJrZG93biArXHJcblx0XHRcdHRleHQuc2xpY2UoXHJcblx0XHRcdFx0c2VjdGlvbnNbaElkeCArIDFdLnBvc2l0aW9uLmVuZC5vZmZzZXQgKyAxICsgdG90YWxPZmZzZXRcclxuXHRcdFx0KTtcclxuXHR9XHJcblxyXG5cdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkoZmlsZSwgdGV4dCk7XHJcblxyXG5cdC8vIHVwZGF0ZSB0aGUgb2Zmc2V0cyBhbmQgcmV0dXJuXHJcblx0b2Zmc2V0LnB1c2godGV4dC5sZW5ndGggLSBkTGVuZ3RoKTtcclxuXHRvZmZzZXRMaW5lPy5wdXNoKGhlYWRpbmcucG9zaXRpb24uc3RhcnQubGluZSk7XHJcblxyXG5cdHJldHVybiBbb2Zmc2V0LCBvZmZzZXRMaW5lXTtcclxufVxyXG4iLCAiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4xMS4wJzsgLy8geC1yZWxlYXNlLXBsZWFzZS12ZXJzaW9uXG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0IHsgY2FzdFRvRXJyb3IsIEhlYWRlcnMgfSBmcm9tICcuL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgT3BlbkFJRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gIHJlYWRvbmx5IHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkO1xuXG4gIHJlYWRvbmx5IGNvZGU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IHBhcmFtOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgZXJyb3I6IE9iamVjdCB8IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgaGVhZGVyczogSGVhZGVycyB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgc3VwZXIoYCR7c3RhdHVzfSAke0FQSUVycm9yLm1ha2VNZXNzYWdlKGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXG4gICAgY29uc3QgZGF0YSA9IGVycm9yIGFzIFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgdGhpcy5jb2RlID0gZGF0YT8uWydjb2RlJ107XG4gICAgdGhpcy5wYXJhbSA9IGRhdGE/LlsncGFyYW0nXTtcbiAgICB0aGlzLnR5cGUgPSBkYXRhPy5bJ3R5cGUnXTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG1ha2VNZXNzYWdlKGVycm9yOiBhbnksIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvcj8ubWVzc2FnZSA/XG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyA/IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKVxuICAgICAgOiBlcnJvciA/IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgOiBtZXNzYWdlIHx8ICdzdGF0dXMgY29kZSAobm8gYm9keSknXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZShcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvclJlc3BvbnNlOiBPYmplY3QgfCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICByZXR1cm4gbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiBjYXN0VG9FcnJvcihlcnJvclJlc3BvbnNlKSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IChlcnJvclJlc3BvbnNlIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pPy5bJ2Vycm9yJ107XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICAgIHJldHVybiBuZXcgQmFkUmVxdWVzdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwMSkge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgICAgcmV0dXJuIG5ldyBQZXJtaXNzaW9uRGVuaWVkRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICByZXR1cm4gbmV3IENvbmZsaWN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDIyKSB7XG4gICAgICByZXR1cm4gbmV3IFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA+PSA1MDApIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFQSUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElVc2VyQWJvcnRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH06IHsgbWVzc2FnZT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnUmVxdWVzdCB3YXMgYWJvcnRlZC4nLCB1bmRlZmluZWQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY2F1c2UgfTogeyBtZXNzYWdlPzogc3RyaW5nOyBjYXVzZT86IEVycm9yIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnQ29ubmVjdGlvbiBlcnJvci4nLCB1bmRlZmluZWQpO1xuICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzIHRoZSAnY2F1c2UnIHByb3BlcnR5IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGNhdXNlKSB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBBUElDb25uZWN0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbWVzc2FnZTogbWVzc2FnZSA/PyAnUmVxdWVzdCB0aW1lZCBvdXQuJyB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBvdmVycmlkZSByZWFkb25seSBzdGF0dXM6IDQwMCA9IDQwMDtcbn1cblxuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDAxID0gNDAxO1xufVxuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBvdmVycmlkZSByZWFkb25seSBzdGF0dXM6IDQwMyA9IDQwMztcbn1cblxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDA0ID0gNDA0O1xufVxuXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiA0MDkgPSA0MDk7XG59XG5cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDIyID0gNDIyO1xufVxuXG5leHBvcnQgY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDI5ID0gNDI5O1xufVxuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTZXJ2ZXJFcnJvciBleHRlbmRzIEFQSUVycm9yIHt9XG4iLCAiaW1wb3J0IHsgdHlwZSBSZXNwb25zZSB9IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5cbnR5cGUgQnl0ZXMgPSBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG50eXBlIFNlcnZlclNlbnRFdmVudCA9IHtcbiAgZXZlbnQ6IHN0cmluZyB8IG51bGw7XG4gIGRhdGE6IHN0cmluZztcbiAgcmF3OiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCBjbGFzcyBTdHJlYW08SXRlbT4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+IHtcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xuXG4gIHByaXZhdGUgcmVzcG9uc2U6IFJlc3BvbnNlO1xuICBwcml2YXRlIGRlY29kZXI6IFNTRURlY29kZXI7XG5cbiAgY29uc3RydWN0b3IocmVzcG9uc2U6IFJlc3BvbnNlLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU1NFRGVjb2RlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyAqaXRlck1lc3NhZ2VzKCk6IEFzeW5jR2VuZXJhdG9yPFNlcnZlclNlbnRFdmVudCwgdm9pZCwgdW5rbm93bj4ge1xuICAgIGlmICghdGhpcy5yZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgIH1cbiAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuXG4gICAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZTxCeXRlcz4odGhpcy5yZXNwb25zZS5ib2R5KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoY2h1bmspKSB7XG4gICAgICAgIGNvbnN0IHNzZSA9IHRoaXMuZGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgY29uc3Qgc3NlID0gdGhpcy5kZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhdG9yPEl0ZW0sIGFueSwgdW5kZWZpbmVkPiB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBzc2Ugb2YgdGhpcy5pdGVyTWVzc2FnZXMoKSkge1xuICAgICAgICBpZiAoZG9uZSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHNzZS5kYXRhLnN0YXJ0c1dpdGgoJ1tET05FXScpKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3NlLmV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHJldHVybjtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgaWYgKCFkb25lKSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU1NFRGVjb2RlciB7XG4gIHByaXZhdGUgZGF0YTogc3RyaW5nW107XG4gIHByaXZhdGUgZXZlbnQ6IHN0cmluZyB8IG51bGw7XG4gIHByaXZhdGUgY2h1bmtzOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICB9XG5cbiAgZGVjb2RlKGxpbmU6IHN0cmluZykge1xuICAgIGlmIChsaW5lLmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKCFsaW5lKSB7XG4gICAgICAvLyBlbXB0eSBsaW5lIGFuZCB3ZSBkaWRuJ3QgcHJldmlvdXNseSBlbmNvdW50ZXIgYW55IG1lc3NhZ2VzXG4gICAgICBpZiAoIXRoaXMuZXZlbnQgJiYgIXRoaXMuZGF0YS5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25zdCBzc2U6IFNlcnZlclNlbnRFdmVudCA9IHtcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YS5qb2luKCdcXG4nKSxcbiAgICAgICAgcmF3OiB0aGlzLmNodW5rcyxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gICAgICByZXR1cm4gc3NlO1xuICAgIH1cblxuICAgIHRoaXMuY2h1bmtzLnB1c2gobGluZSk7XG5cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCc6JykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBbZmllbGRuYW1lLCBfLCB2YWx1ZV0gPSBwYXJ0aXRpb24obGluZSwgJzonKTtcblxuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGlmIChmaWVsZG5hbWUgPT09ICdldmVudCcpIHtcbiAgICAgIHRoaXMuZXZlbnQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkbmFtZSA9PT0gJ2RhdGEnKSB7XG4gICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlLWltcGxlbWVudGF0aW9uIG9mIGh0dHB4J3MgYExpbmVEZWNvZGVyYCBpbiBQeXRob24gdGhhdCBoYW5kbGVzIGluY3JlbWVudGFsbHlcbiAqIHJlYWRpbmcgbGluZXMgZnJvbSB0ZXh0LlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmNvZGUvaHR0cHgvYmxvYi85MjAzMzNlYTk4MTE4ZTljZjYxN2YyNDY5MDVkN2IyMDI1MTA5NDFjL2h0dHB4L19kZWNvZGVycy5weSNMMjU4XG4gKi9cbmNsYXNzIExpbmVEZWNvZGVyIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInLCAnXFx4MGInLCAnXFx4MGMnLCAnXFx4MWMnLCAnXFx4MWQnLCAnXFx4MWUnLCAnXFx4ODUnLCAnXFx1MjAyOCcsICdcXHUyMDI5J10pO1xuICBzdGF0aWMgTkVXTElORV9SRUdFWFAgPSAvXFxyXFxufFtcXG5cXHJcXHgwYlxceDBjXFx4MWNcXHgxZFxceDFlXFx4ODVcXHUyMDI4XFx1MjAyOV0vZztcblxuICBidWZmZXI6IHN0cmluZ1tdO1xuICB0cmFpbGluZ0NSOiBib29sZWFuO1xuICB0ZXh0RGVjb2RlcjogYW55OyAvLyBUZXh0RGVjb2RlciBmb3VuZCBpbiBicm93c2Vyczsgbm90IHR5cGVkIHRvIGF2b2lkIHB1bGxpbmcgaW4gZWl0aGVyIFwiZG9tXCIgb3IgXCJub2RlXCIgdHlwZXMuXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgfVxuXG4gIGRlY29kZShjaHVuazogQnl0ZXMpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHRleHQgPSB0aGlzLmRlY29kZVRleHQoY2h1bmspO1xuXG4gICAgaWYgKHRoaXMudHJhaWxpbmdDUikge1xuICAgICAgdGV4dCA9ICdcXHInICsgdGV4dDtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGV4dC5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgIHRoaXMudHJhaWxpbmdDUiA9IHRydWU7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdHJhaWxpbmdOZXdsaW5lID0gTGluZURlY29kZXIuTkVXTElORV9DSEFSUy5oYXModGV4dFt0ZXh0Lmxlbmd0aCAtIDFdIHx8ICcnKTtcbiAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KExpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQKTtcblxuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEgJiYgIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChsaW5lc1swXSEpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKSArIGxpbmVzWzBdLCAuLi5saW5lcy5zbGljZSgxKV07XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cblxuICAgIGlmICghdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtsaW5lcy5wb3AoKSB8fCAnJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZGVjb2RlVGV4dChieXRlczogQnl0ZXMpOiBzdHJpbmcge1xuICAgIGlmIChieXRlcyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHJldHVybiBieXRlcztcblxuICAgIC8vIE5vZGU6XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkgKCR7Ynl0ZXMuY29uc3RydWN0b3IubmFtZX0pIHN0cmVhbSBjaHVuayBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsIFwiQnVmZmVyXCIgZGVmaW5lZCwgd2hpY2ggdGhpcyBsaWJyYXJ5IGFzc3VtZXMgdG8gYmUgTm9kZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJyb3dzZXJcbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPz89IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheS9BcnJheUJ1ZmZlciAoJHtcbiAgICAgICAgICAoYnl0ZXMgYXMgYW55KS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgIH0pIGluIGEgd2ViIHBsYXRmb3JtLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgYFVuZXhwZWN0ZWQ6IG5laXRoZXIgQnVmZmVyIG5vciBUZXh0RGVjb2RlciBhcmUgYXZhaWxhYmxlIGFzIGdsb2JhbHMuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gLFxuICAgICk7XG4gIH1cblxuICBmbHVzaCgpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXMudHJhaWxpbmdDUikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVzID0gW3RoaXMuYnVmZmVyLmpvaW4oJycpXTtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oc3RyOiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddIHtcbiAgY29uc3QgaW5kZXggPSBzdHIuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSwgZGVsaW1pdGVyLCBzdHIuc3Vic3RyaW5nKGluZGV4ICsgZGVsaW1pdGVyLmxlbmd0aCldO1xuICB9XG5cbiAgcmV0dXJuIFtzdHIsICcnLCAnJ107XG59XG5cbi8qKlxuICogTW9zdCBicm93c2VycyBkb24ndCB5ZXQgaGF2ZSBhc3luYyBpdGVyYWJsZSBzdXBwb3J0IGZvciBSZWFkYWJsZVN0cmVhbSxcbiAqIGFuZCBOb2RlIGhhcyBhIHZlcnkgZGlmZmVyZW50IHdheSBvZiByZWFkaW5nIGJ5dGVzIGZyb20gaXRzIFwiUmVhZGFibGVTdHJlYW1cIi5cbiAqXG4gKiBUaGlzIHBvbHlmaWxsIHdhcyBwdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbTogYW55KTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHJldHVybiBzdHJlYW07XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0Py5kb25lKSByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBhd2FpdCBjYW5jZWxQcm9taXNlO1xuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH07XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hpbXMge1xuICBraW5kOiBzdHJpbmc7XG4gIGZldGNoOiBhbnk7XG4gIFJlcXVlc3Q6IGFueTtcbiAgUmVzcG9uc2U6IGFueTtcbiAgSGVhZGVyczogYW55O1xuICBGb3JtRGF0YTogYW55O1xuICBCbG9iOiBhbnk7XG4gIEZpbGU6IGFueTtcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IDxUIGV4dGVuZHMge30gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgZm9ybTogU2hpbXNbJ0Zvcm1EYXRhJ10sXG4gICAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4gICkgPT4gUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUPj47XG4gIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiBhbnk7XG4gIGZpbGVGcm9tUGF0aDpcbiAgICB8ICgocGF0aDogc3RyaW5nLCBmaWxlbmFtZT86IHN0cmluZywgb3B0aW9ucz86IHt9KSA9PiBQcm9taXNlPFNoaW1zWydGaWxlJ10+KVxuICAgIHwgKChwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7fSkgPT4gUHJvbWlzZTxTaGltc1snRmlsZSddPik7XG4gIGlzRnNSZWFkU3RyZWFtOiAodmFsdWU6IGFueSkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGxldCBhdXRvID0gZmFsc2U7XG5leHBvcnQgbGV0IGtpbmQ6IFNoaW1zWydraW5kJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZldGNoOiBTaGltc1snZmV0Y2gnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVxdWVzdDogU2hpbXNbJ1JlcXVlc3QnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVzcG9uc2U6IFNoaW1zWydSZXNwb25zZSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBIZWFkZXJzOiBTaGltc1snSGVhZGVycyddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBGb3JtRGF0YTogU2hpbXNbJ0Zvcm1EYXRhJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEJsb2I6IFNoaW1zWydCbG9iJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZpbGU6IFNoaW1zWydGaWxlJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiBTaGltc1snZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0RGVmYXVsdEFnZW50OiBTaGltc1snZ2V0RGVmYXVsdEFnZW50J10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZpbGVGcm9tUGF0aDogU2hpbXNbJ2ZpbGVGcm9tUGF0aCddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBpc0ZzUmVhZFN0cmVhbTogU2hpbXNbJ2lzRnNSZWFkU3RyZWFtJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTaGltcyhzaGltczogU2hpbXMsIG9wdGlvbnM6IHsgYXV0bzogYm9vbGVhbiB9ID0geyBhdXRvOiBmYWxzZSB9KSB7XG4gIGlmIChhdXRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHlvdSBtdXN0IFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zLyR7c2hpbXMua2luZH0nXFxgIGJlZm9yZSBpbXBvcnRpbmcgYW55dGhpbmcgZWxzZSBmcm9tIG9wZW5haWAsXG4gICAgKTtcbiAgfVxuICBpZiAoa2luZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtzaGltcy5raW5kfSdcXGAgYWZ0ZXIgXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvJHtraW5kfSdcXGBgKTtcbiAgfVxuICBhdXRvID0gb3B0aW9ucy5hdXRvO1xuICBraW5kID0gc2hpbXMua2luZDtcbiAgZmV0Y2ggPSBzaGltcy5mZXRjaDtcbiAgUmVxdWVzdCA9IHNoaW1zLlJlcXVlc3Q7XG4gIFJlc3BvbnNlID0gc2hpbXMuUmVzcG9uc2U7XG4gIEhlYWRlcnMgPSBzaGltcy5IZWFkZXJzO1xuICBGb3JtRGF0YSA9IHNoaW1zLkZvcm1EYXRhO1xuICBCbG9iID0gc2hpbXMuQmxvYjtcbiAgRmlsZSA9IHNoaW1zLkZpbGU7XG4gIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zID0gc2hpbXMuZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM7XG4gIGdldERlZmF1bHRBZ2VudCA9IHNoaW1zLmdldERlZmF1bHRBZ2VudDtcbiAgZmlsZUZyb21QYXRoID0gc2hpbXMuZmlsZUZyb21QYXRoO1xuICBpc0ZzUmVhZFN0cmVhbSA9IHNoaW1zLmlzRnNSZWFkU3RyZWFtO1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpcGFydEJvZHkge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgYm9keTogYW55KSB7fVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ011bHRpcGFydEJvZHknO1xuICB9XG59XG4iLCAiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5pbXBvcnQgeyBNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi9NdWx0aXBhcnRCb2R5JztcbmltcG9ydCB7IHR5cGUgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcbmltcG9ydCB7IHR5cGUgU2hpbXMgfSBmcm9tICcuL3JlZ2lzdHJ5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bnRpbWUoeyBtYW51YWxseUltcG9ydGVkIH06IHsgbWFudWFsbHlJbXBvcnRlZD86IGJvb2xlYW4gfSA9IHt9KTogU2hpbXMge1xuICBjb25zdCByZWNvbW1lbmRhdGlvbiA9XG4gICAgbWFudWFsbHlJbXBvcnRlZCA/XG4gICAgICBgWW91IG1heSBuZWVkIHRvIHVzZSBwb2x5ZmlsbHNgXG4gICAgOiBgQWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IFxcYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ1xcYDpcbi0gXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdcXGAgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4tIFxcYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidcXGAgKG90aGVyd2lzZSlcbmA7XG5cbiAgbGV0IF9mZXRjaCwgX1JlcXVlc3QsIF9SZXNwb25zZSwgX0hlYWRlcnM7XG4gIHRyeSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIF9SZXNwb25zZSA9IFJlc3BvbnNlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfSGVhZGVycyA9IEhlYWRlcnM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHRoaXMgZW52aXJvbm1lbnQgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIFdlYiBGZXRjaCBBUEkgdHlwZTogJHtcbiAgICAgICAgKGVycm9yIGFzIGFueSkubWVzc2FnZVxuICAgICAgfS4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtpbmQ6ICd3ZWInLFxuICAgIGZldGNoOiBfZmV0Y2gsXG4gICAgUmVxdWVzdDogX1JlcXVlc3QsXG4gICAgUmVzcG9uc2U6IF9SZXNwb25zZSxcbiAgICBIZWFkZXJzOiBfSGVhZGVycyxcbiAgICBGb3JtRGF0YTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IChcbiAgICAgICAgY2xhc3MgRm9ybURhdGEge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGb3JtRGF0YScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBCbG9iOlxuICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IChcbiAgICAgICAgY2xhc3MgQmxvYiB7XG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnQmxvYicgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICBGaWxlOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnID8gRmlsZSA6IChcbiAgICAgICAgY2xhc3MgRmlsZSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0ZpbGUnIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IGFzeW5jIDxUIGV4dGVuZHMge30gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBmb3JtOiBGb3JtRGF0YSxcbiAgICAgIG9wdHM6IFJlcXVlc3RPcHRpb25zPFQ+LFxuICAgICk6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VD4+ID0+ICh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgYm9keTogbmV3IE11bHRpcGFydEJvZHkoZm9ybSkgYXMgYW55LFxuICAgIH0pLFxuICAgIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiB1bmRlZmluZWQsXG4gICAgZmlsZUZyb21QYXRoOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgYGZpbGVGcm9tUGF0aGAgZnVuY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gTm9kZS4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgZGV0YWlsczogaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUjZmlsZS11cGxvYWRzJyxcbiAgICAgICk7XG4gICAgfSxcbiAgICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlOiBhbnkpID0+IGZhbHNlLFxuICB9O1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0ICogYXMgc2hpbXMgZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuaW1wb3J0ICogYXMgYXV0byBmcm9tICdvcGVuYWkvX3NoaW1zL2F1dG8vcnVudGltZSc7XG5pZiAoIXNoaW1zLmtpbmQpIHNoaW1zLnNldFNoaW1zKGF1dG8uZ2V0UnVudGltZSgpLCB7IGF1dG86IHRydWUgfSk7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG4iLCAiaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQge1xuICBGb3JtRGF0YSxcbiAgRmlsZSxcbiAgdHlwZSBCbG9iLFxuICB0eXBlIEZpbGVQcm9wZXJ0eUJhZyxcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMsXG4gIHR5cGUgRnNSZWFkU3RyZWFtLFxuICBpc0ZzUmVhZFN0cmVhbSxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vX3NoaW1zL011bHRpcGFydEJvZHknO1xuZXhwb3J0IHsgZmlsZUZyb21QYXRoIH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuXG50eXBlIEJsb2JMaWtlUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYkxpa2UgfCBVaW50OEFycmF5IHwgRGF0YVZpZXc7XG5leHBvcnQgdHlwZSBCbG9iUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYiB8IFVpbnQ4QXJyYXkgfCBEYXRhVmlldztcblxuLyoqXG4gKiBUeXBpY2FsbHksIHRoaXMgaXMgYSBuYXRpdmUgXCJGaWxlXCIgY2xhc3MuXG4gKlxuICogV2UgcHJvdmlkZSB0aGUge0BsaW5rIHRvRmlsZX0gdXRpbGl0eSB0byBjb252ZXJ0IGEgdmFyaWV0eSBvZiBvYmplY3RzXG4gKiBpbnRvIHRoZSBGaWxlIGNsYXNzLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBmZXRjaCBSZXNwb25zZSwgb3IgaW4gTm9kZSxcbiAqIHRoZSByZXN1bHQgb2YgZnMuY3JlYXRlUmVhZFN0cmVhbSgpLlxuICovXG5leHBvcnQgdHlwZSBVcGxvYWRhYmxlID0gRmlsZUxpa2UgfCBSZXNwb25zZUxpa2UgfCBGc1JlYWRTdHJlYW07XG5cbi8qKlxuICogSW50ZW5kZWQgdG8gbWF0Y2ggd2ViLkJsb2IsIG5vZGUuQmxvYiwgbm9kZS1mZXRjaC5CbG9iLCBldGMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvYkxpa2Uge1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3NpemUpICovXG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi90eXBlKSAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2IvdGV4dCkgKi9cbiAgdGV4dCgpOiBQcm9taXNlPHN0cmluZz47XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2Ivc2xpY2UpICovXG4gIHNsaWNlKHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpOiBCbG9iTGlrZTtcbiAgLy8gdW5mb3J0dW5hdGVseSBAdHlwZXMvbm9kZS1mZXRjaEBeMi42LjQgZG9lc24ndCB0eXBlIHRoZSBhcnJheUJ1ZmZlciBtZXRob2Rcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuRmlsZSwgbm9kZS5GaWxlLCBub2RlLWZldGNoLkZpbGUsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlTGlrZSBleHRlbmRzIEJsb2JMaWtlIHtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRmlsZS9sYXN0TW9kaWZpZWQpICovXG4gIHJlYWRvbmx5IGxhc3RNb2RpZmllZDogbnVtYmVyO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GaWxlL25hbWUpICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuUmVzcG9uc2UsIG5vZGUuUmVzcG9uc2UsIG5vZGUtZmV0Y2guUmVzcG9uc2UsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUxpa2Uge1xuICB1cmw6IHN0cmluZztcbiAgYmxvYigpOiBQcm9taXNlPEJsb2JMaWtlPjtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZXNwb25zZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS5ibG9iID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgRmlsZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS5uYW1lID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICBpc0Jsb2JMaWtlKHZhbHVlKTtcblxuLyoqXG4gKiBUaGUgQmxvYkxpa2UgdHlwZSBvbWl0cyBhcnJheUJ1ZmZlcigpIGJlY2F1c2UgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGxhY2tzIGl0OyBidXQgdGhpcyBjaGVja1xuICogYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2JMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBCbG9iTGlrZSAmIHsgYXJyYXlCdWZmZXIoKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gfSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInICYmXG4gIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgdmFsdWUuc2xpY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNVcGxvYWRhYmxlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBVcGxvYWRhYmxlID0+IHtcbiAgcmV0dXJuIGlzRmlsZUxpa2UodmFsdWUpIHx8IGlzUmVzcG9uc2VMaWtlKHZhbHVlKSB8fCBpc0ZzUmVhZFN0cmVhbSh2YWx1ZSk7XG59O1xuXG5leHBvcnQgdHlwZSBUb0ZpbGVJbnB1dCA9IFVwbG9hZGFibGUgfCBFeGNsdWRlPEJsb2JMaWtlUGFydCwgc3RyaW5nPiB8IEFzeW5jSXRlcmFibGU8QmxvYkxpa2VQYXJ0PjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNyZWF0aW5nIGEge0BsaW5rIEZpbGV9IHRvIHBhc3MgdG8gYW4gU0RLIHVwbG9hZCBtZXRob2QgZnJvbSBhIHZhcmlldHkgb2YgZGlmZmVyZW50IGRhdGEgZm9ybWF0c1xuICogQHBhcmFtIHZhbHVlIHRoZSByYXcgY29udGVudCBvZiB0aGUgZmlsZS4gIENhbiBiZSBhbiB7QGxpbmsgVXBsb2FkYWJsZX0sIHtAbGluayBCbG9iTGlrZVBhcnR9LCBvciB7QGxpbmsgQXN5bmNJdGVyYWJsZX0gb2Yge0BsaW5rIEJsb2JMaWtlUGFydH1zXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUuIElmIG9taXR0ZWQsIHRvRmlsZSB3aWxsIHRyeSB0byBkZXRlcm1pbmUgYSBmaWxlIG5hbWUgZnJvbSBiaXRzIGlmIHBvc3NpYmxlXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudHlwZSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubGFzdE1vZGlmaWVkIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWVzdGFtcFxuICogQHJldHVybnMgYSB7QGxpbmsgRmlsZX0gd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9GaWxlKFxuICB2YWx1ZTogVG9GaWxlSW5wdXQgfCBQcm9taXNlTGlrZTxUb0ZpbGVJbnB1dD4sXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBvcHRpb25zOiBGaWxlUHJvcGVydHlCYWcgfCB1bmRlZmluZWQgPSB7fSxcbik6IFByb21pc2U8RmlsZUxpa2U+IHtcbiAgLy8gSWYgaXQncyBhIHByb21pc2UsIHJlc29sdmUgaXQuXG4gIHZhbHVlID0gYXdhaXQgdmFsdWU7XG5cbiAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB2YWx1ZS5ibG9iKCk7XG4gICAgbmFtZSB8fD0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgPz8gJ3Vua25vd25fZmlsZSc7XG5cbiAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2IgYXMgYW55XSwgbmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBiaXRzID0gYXdhaXQgZ2V0Qnl0ZXModmFsdWUpO1xuXG4gIG5hbWUgfHw9IGdldE5hbWUodmFsdWUpID8/ICd1bmtub3duX2ZpbGUnO1xuXG4gIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IChiaXRzWzBdIGFzIGFueSk/LnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRmlsZShiaXRzLCBuYW1lLCBvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWU6IFRvRmlsZUlucHV0KTogUHJvbWlzZTxBcnJheTxCbG9iUGFydD4+IHtcbiAgbGV0IHBhcnRzOiBBcnJheTxCbG9iUGFydD4gPSBbXTtcbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgKSB7XG4gICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICBwYXJ0cy5wdXNoKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKFxuICAgIGlzQXN5bmNJdGVyYWJsZUl0ZXJhdG9yKHZhbHVlKSAvLyBpbmNsdWRlcyBSZWFkYWJsZSwgUmVhZGFibGVTdHJlYW0sIGV0Yy5cbiAgKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB2YWx1ZSkge1xuICAgICAgcGFydHMucHVzaChjaHVuayBhcyBCbG9iUGFydCk7IC8vIFRPRE8sIGNvbnNpZGVyIHZhbGlkYXRpbmc/XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkIGRhdGEgdHlwZTogJHt0eXBlb2YgdmFsdWV9OyBjb25zdHJ1Y3RvcjogJHtcbiAgICAgICAgdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lXG4gICAgICB9OyBwcm9wczogJHtwcm9wc0ZvckVycm9yKHZhbHVlKX1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICByZXR1cm4gYFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cblxuZnVuY3Rpb24gZ2V0TmFtZSh2YWx1ZTogYW55KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUubmFtZSkgfHxcbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUuZmlsZW5hbWUpIHx8XG4gICAgLy8gRm9yIGZzLlJlYWRTdHJlYW1cbiAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUucGF0aCk/LnNwbGl0KC9bXFxcXC9dLykucG9wKClcbiAgKTtcbn1cblxuY29uc3QgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyID0gKHg6IHN0cmluZyB8IEJ1ZmZlciB8IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSByZXR1cm4geDtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBCdWZmZXIpIHJldHVybiBTdHJpbmcoeCk7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBpc0FzeW5jSXRlcmFibGVJdGVyYXRvciA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPHVua25vd24+ID0+XG4gIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNNdWx0aXBhcnRCb2R5ID0gKGJvZHk6IGFueSk6IGJvZHkgaXMgTXVsdGlwYXJ0Qm9keSA9PlxuICBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiBib2R5LmJvZHkgJiYgYm9keVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTXVsdGlwYXJ0Qm9keSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG11bHRpcGFydC9mb3JtLWRhdGEgcmVxdWVzdCBpZiBhbnkgcGFydCBvZiB0aGUgZ2l2ZW4gcmVxdWVzdCBib2R5IGNvbnRhaW5zIGEgRmlsZSAvIEJsb2IgdmFsdWUuXG4gKiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcmVxdWVzdCBhcyBpcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1heWJlTXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgZXh0ZW5kcyB7fSA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBpZiAoIWhhc1VwbG9hZGFibGVWYWx1ZShvcHRzLmJvZHkpKSByZXR1cm4gb3B0cztcblxuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgPFQgZXh0ZW5kcyB7fSA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRm9ybSA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KGJvZHk6IFQgfCB1bmRlZmluZWQpOiBQcm9taXNlPEZvcm1EYXRhPiA9PiB7XG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoYm9keSB8fCB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXksIHZhbHVlKSkpO1xuICByZXR1cm4gZm9ybTtcbn07XG5cbmNvbnN0IGhhc1VwbG9hZGFibGVWYWx1ZSA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLnNvbWUoaGFzVXBsb2FkYWJsZVZhbHVlKTtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChoYXNVcGxvYWRhYmxlVmFsdWUoKHZhbHVlIGFzIGFueSlba10pKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgYWRkRm9ybVZhbHVlID0gYXN5bmMgKGZvcm06IEZvcm1EYXRhLCBrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFJlY2VpdmVkIG51bGwgZm9yIFwiJHtrZXl9XCI7IHRvIHBhc3MgbnVsbCBpbiBGb3JtRGF0YSwgeW91IG11c3QgdXNlIHRoZSBzdHJpbmcgJ251bGwnYCxcbiAgICApO1xuICB9XG5cbiAgLy8gVE9ETzogbWFrZSBuZXN0ZWQgZm9ybWF0cyBjb25maWd1cmFibGVcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkge1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0b0ZpbGUodmFsdWUpO1xuICAgIGZvcm0uYXBwZW5kKGtleSwgZmlsZSBhcyBGaWxlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoZW50cnkpID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXkgKyAnW10nLCBlbnRyeSkpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbbmFtZSwgcHJvcF0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBgJHtrZXl9WyR7bmFtZX1dYCwgcHJvcCkpLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGdpdmVuIHRvIGZvcm0sIGV4cGVjdGVkIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCwgQXJyYXksIEZpbGUgb3IgQmxvYiBidXQgZ290ICR7dmFsdWV9IGluc3RlYWRgLFxuICAgICk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vdmVyc2lvbic7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuL3N0cmVhbWluZyc7XG5pbXBvcnQge1xuICBPcGVuQUlFcnJvcixcbiAgQVBJRXJyb3IsXG4gIEFQSUNvbm5lY3Rpb25FcnJvcixcbiAgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcixcbiAgQVBJVXNlckFib3J0RXJyb3IsXG59IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHtcbiAga2luZCBhcyBzaGltc0tpbmQsXG4gIHR5cGUgUmVhZGFibGUsXG4gIGdldERlZmF1bHRBZ2VudCxcbiAgdHlwZSBBZ2VudCxcbiAgZmV0Y2gsXG4gIHR5cGUgUmVxdWVzdEluZm8sXG4gIHR5cGUgUmVxdWVzdEluaXQsXG4gIHR5cGUgUmVzcG9uc2UsXG4gIHR5cGUgSGVhZGVyc0luaXQsXG59IGZyb20gJy4vX3NoaW1zL2luZGV4JztcbmV4cG9ydCB7IHR5cGUgUmVzcG9uc2UgfTtcbmltcG9ydCB7IGlzTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vdXBsb2Fkcyc7XG5leHBvcnQge1xuICBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyxcbiAgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLFxuICBjcmVhdGVGb3JtLFxuICB0eXBlIFVwbG9hZGFibGUsXG59IGZyb20gJy4vdXBsb2Fkcyc7XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gMjtcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSAodXJsOiBSZXF1ZXN0SW5mbywgaW5pdD86IFJlcXVlc3RJbml0KSA9PiBQcm9taXNlPFJlc3BvbnNlPjtcblxudHlwZSBQcm9taXNlT3JWYWx1ZTxUPiA9IFQgfCBQcm9taXNlPFQ+O1xuXG50eXBlIEFQSVJlc3BvbnNlUHJvcHMgPSB7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdFBhcnNlUmVzcG9uc2U8VD4ocHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXNwb25zZSB9ID0gcHJvcHM7XG4gIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFuIGludmFyaWFudCBoZXJlIHRoYXQgaXNuJ3QgcmVwcmVzZW50ZWQgaW4gdGhlIHR5cGUgc3lzdGVtXG4gICAgLy8gdGhhdCBpZiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgIHRoZSByZXNwb25zZSB0eXBlIG11c3QgYWxzbyBiZSBgU3RyZWFtPFQ+YFxuICAgIHJldHVybiBuZXcgU3RyZWFtKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKSBhcyBhbnk7XG4gIH1cblxuICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsLCByZXNwb25zZS5oZWFkZXJzLCBqc29uKTtcblxuICAgIHJldHVybiBqc29uIGFzIFQ7XG4gIH1cblxuICAvLyBUT0RPIGhhbmRsZSBibG9iLCBhcnJheWJ1ZmZlciwgb3RoZXIgY29udGVudCB0eXBlcywgZXRjLlxuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgdGV4dCk7XG4gIHJldHVybiB0ZXh0IGFzIGFueSBhcyBUO1xufVxuXG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgYFByb21pc2VgIHByb3ZpZGluZyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzXG4gKiBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgU0RLLlxuICovXG5leHBvcnQgY2xhc3MgQVBJUHJvbWlzZTxUPiBleHRlbmRzIFByb21pc2U8VD4ge1xuICBwcml2YXRlIHBhcnNlZFByb21pc2U6IFByb21pc2U8VD4gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZXNwb25zZVByb21pc2U6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4sXG4gICAgcHJpdmF0ZSBwYXJzZVJlc3BvbnNlOiAocHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpID0+IFByb21pc2VPclZhbHVlPFQ+ID0gZGVmYXVsdFBhcnNlUmVzcG9uc2UsXG4gICkge1xuICAgIHN1cGVyKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyB0aGlzIGlzIG1heWJlIGEgYml0IHdlaXJkIGJ1dCB0aGlzIGhhcyB0byBiZSBhIG5vLW9wIHRvIG5vdCBpbXBsaWNpdGx5XG4gICAgICAvLyBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keTsgaW5zdGVhZCAudGhlbiwgLmNhdGNoLCAuZmluYWxseSBhcmUgb3ZlcnJpZGRlblxuICAgICAgLy8gdG8gcGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgICByZXNvbHZlKG51bGwgYXMgYW55KTtcbiAgICB9KTtcbiAgfVxuXG4gIF90aGVuVW53cmFwPFU+KHRyYW5zZm9ybTogKGRhdGE6IFQpID0+IFUpOiBBUElQcm9taXNlPFU+IHtcbiAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcy5yZXNwb25zZVByb21pc2UsIGFzeW5jIChwcm9wcykgPT4gdHJhbnNmb3JtKGF3YWl0IHRoaXMucGFyc2VSZXNwb25zZShwcm9wcykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAqIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzUmVzcG9uc2UoKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKChwKSA9PiBwLnJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcGFyc2VkIHJlc3BvbnNlIGRhdGEgYW5kIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZS5cbiAgICpcbiAgICogSWYgeW91IGp1c3Qgd2FudCB0byBnZXQgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIHdpdGhvdXQgcGFyc2luZyBpdCxcbiAgICogeW91IGNhbiB1c2Uge0BsaW5rIGFzUmVzcG9uc2UoKX0uXG4gICAqXG4gICAqXG4gICAqIFx1RDgzRFx1REM0QiBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCBcdTIwMjYgZnJvbSAnb3BlbmFpJ2A6XG4gICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbiAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICovXG4gIGFzeW5jIHdpdGhSZXNwb25zZSgpOiBQcm9taXNlPHsgZGF0YTogVDsgcmVzcG9uc2U6IFJlc3BvbnNlIH0+IHtcbiAgICBjb25zdCBbZGF0YSwgcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICByZXR1cm4geyBkYXRhLCByZXNwb25zZSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZSgpOiBQcm9taXNlPFQ+IHtcbiAgICBpZiAoIXRoaXMucGFyc2VkUHJvbWlzZSkge1xuICAgICAgdGhpcy5wYXJzZWRQcm9taXNlID0gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbih0aGlzLnBhcnNlUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZWRQcm9taXNlO1xuICB9XG5cbiAgb3ZlcnJpZGUgdGhlbjxUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICAgIG9uZnVsZmlsbGVkPzogKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBvbnJlamVjdGVkPzogKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PikgfCB1bmRlZmluZWQgfCBudWxsLFxuICApOiBQcm9taXNlPFQgfCBUUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGZpbmFsbHkob25maW5hbGx5PzogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkIHwgbnVsbCk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBUElDbGllbnQge1xuICBiYXNlVVJMOiBzdHJpbmc7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgdGltZW91dDogbnVtYmVyO1xuICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgZmV0Y2g6IEZldGNoO1xuICBwcm90ZWN0ZWQgaWRlbXBvdGVuY3lIZWFkZXI/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVUkwsXG4gICAgbWF4UmV0cmllcyxcbiAgICB0aW1lb3V0ID0gNjAwMDAwLCAvLyAxMCBtaW51dGVzXG4gICAgaHR0cEFnZW50LFxuICAgIGZldGNoOiBvdmVycmlkZW5GZXRjaCxcbiAgfToge1xuICAgIGJhc2VVUkw6IHN0cmluZztcbiAgICBtYXhSZXRyaWVzPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIHRpbWVvdXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBodHRwQWdlbnQ6IEFnZW50IHwgdW5kZWZpbmVkO1xuICAgIGZldGNoOiBGZXRjaCB8IHVuZGVmaW5lZDtcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgdGhpcy5tYXhSZXRyaWVzID0gdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ21heFJldHJpZXMnLCBtYXhSZXRyaWVzID8/IE1BWF9SRVRSSUVTKTtcbiAgICB0aGlzLnRpbWVvdXQgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIHRpbWVvdXQpO1xuICAgIHRoaXMuaHR0cEFnZW50ID0gaHR0cEFnZW50O1xuXG4gICAgdGhpcy5mZXRjaCA9IG92ZXJyaWRlbkZldGNoID8/IGZldGNoO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF1dGhIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHtcbiAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICogICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAxMjMnLFxuICAgKiAgfVxuICAgKi9cbiAgcHJvdGVjdGVkIGRlZmF1bHRIZWFkZXJzKG9wdHM6IEZpbmFsUmVxdWVzdE9wdGlvbnMpOiBIZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ1VzZXItQWdlbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLFxuICAgICAgLi4uZ2V0UGxhdGZvcm1IZWFkZXJzKCksXG4gICAgICAuLi50aGlzLmF1dGhIZWFkZXJzKG9wdHMpLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZGVmYXVsdFF1ZXJ5KCk6IERlZmF1bHRRdWVyeSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gaGVhZGVycyB2YWxpZGF0aW9uOlxuICAgKi9cbiAgcHJvdGVjdGVkIHZhbGlkYXRlSGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzLCBjdXN0b21IZWFkZXJzOiBIZWFkZXJzKSB7fVxuXG4gIHByb3RlY3RlZCBkZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICB9XG5cbiAgZ2V0PFJlcSBleHRlbmRzIHt9LCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBvc3Q8UmVxIGV4dGVuZHMge30sIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBhdGNoPFJlcSBleHRlbmRzIHt9LCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcHV0PFJlcSBleHRlbmRzIHt9LCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIGRlbGV0ZTxSZXEgZXh0ZW5kcyB7fSwgUnNwPihwYXRoOiBzdHJpbmcsIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+Pik6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwcml2YXRlIG1ldGhvZFJlcXVlc3Q8UmVxIGV4dGVuZHMge30sIFJzcD4oXG4gICAgbWV0aG9kOiBIVFRQTWV0aG9kLFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChQcm9taXNlLnJlc29sdmUob3B0cykudGhlbigob3B0cykgPT4gKHsgbWV0aG9kLCBwYXRoLCAuLi5vcHRzIH0pKSk7XG4gIH1cblxuICBnZXRBUElMaXN0PEl0ZW0sIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiA9IEFic3RyYWN0UGFnZTxJdGVtPj4oXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFBhZ2VDbGFzcyxcbiAgICBvcHRzPzogUmVxdWVzdE9wdGlvbnM8YW55PixcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFQSUxpc3QoUGFnZSwgeyBtZXRob2Q6ICdnZXQnLCBwYXRoLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHk6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHksICd1dGY4JykudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUoYm9keSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYnVpbGRSZXF1ZXN0PFJlcSBleHRlbmRzIHt9PihcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4sXG4gICk6IHsgcmVxOiBSZXF1ZXN0SW5pdDsgdXJsOiBzdHJpbmc7IHRpbWVvdXQ6IG51bWJlciB9IHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGhlYWRlcnM6IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJvZHkgPVxuICAgICAgaXNNdWx0aXBhcnRCb2R5KG9wdGlvbnMuYm9keSkgPyBvcHRpb25zLmJvZHkuYm9keVxuICAgICAgOiBvcHRpb25zLmJvZHkgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHksIG51bGwsIDIpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXMuY2FsY3VsYXRlQ29udGVudExlbmd0aChib2R5KTtcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVUkwocGF0aCEsIHF1ZXJ5KTtcbiAgICBpZiAoJ3RpbWVvdXQnIGluIG9wdGlvbnMpIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0Jywgb3B0aW9ucy50aW1lb3V0KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICBjb25zdCBodHRwQWdlbnQgPSBvcHRpb25zLmh0dHBBZ2VudCA/PyB0aGlzLmh0dHBBZ2VudCA/PyBnZXREZWZhdWx0QWdlbnQodXJsKTtcbiAgICBjb25zdCBtaW5BZ2VudFRpbWVvdXQgPSB0aW1lb3V0ICsgMTAwMDtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgKGh0dHBBZ2VudCBhcyBhbnkpPy5vcHRpb25zPy50aW1lb3V0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgbWluQWdlbnRUaW1lb3V0ID4gKChodHRwQWdlbnQgYXMgYW55KS5vcHRpb25zLnRpbWVvdXQgPz8gMClcbiAgICApIHtcbiAgICAgIC8vIEFsbG93IGFueSBnaXZlbiByZXF1ZXN0IHRvIGJ1bXAgb3VyIGFnZW50IGFjdGl2ZSBzb2NrZXQgdGltZW91dC5cbiAgICAgIC8vIFRoaXMgbWF5IHNlZW0gc3RyYW5nZSwgYnV0IGxlYWtpbmcgYWN0aXZlIHNvY2tldHMgc2hvdWxkIGJlIHJhcmUgYW5kIG5vdCBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMsXG4gICAgICAvLyBhbmQgd2l0aG91dCBtdXRhdGluZyBhZ2VudCB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBtb3JlIG9mIHRoZW0uXG4gICAgICAvLyBUaGlzIHRyYWRlb2ZmIG9wdGltaXplcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAoaHR0cEFnZW50IGFzIGFueSkub3B0aW9ucy50aW1lb3V0ID0gbWluQWdlbnRUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlkZW1wb3RlbmN5SGVhZGVyICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgIGlmICghb3B0aW9ucy5pZGVtcG90ZW5jeUtleSkgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICBoZWFkZXJzW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gb3B0aW9ucy5pZGVtcG90ZW5jeUtleTtcbiAgICB9XG5cbiAgICBjb25zdCByZXFIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgLi4uKGNvbnRlbnRMZW5ndGggJiYgeyAnQ29udGVudC1MZW5ndGgnOiBjb250ZW50TGVuZ3RoIH0pLFxuICAgICAgLi4udGhpcy5kZWZhdWx0SGVhZGVycyhvcHRpb25zKSxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfTtcbiAgICAvLyBsZXQgYnVpbHRpbiBmZXRjaCBzZXQgdGhlIENvbnRlbnQtVHlwZSBmb3IgbXVsdGlwYXJ0IGJvZGllc1xuICAgIGlmIChpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSAmJiBzaGltc0tpbmQgIT09ICdub2RlJykge1xuICAgICAgZGVsZXRlIHJlcUhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIGFueSBoZWFkZXJzIGJlaW5nIGV4cGxpY2l0bHkgb21pdHRlZCB3aXRoIG51bGxcbiAgICBPYmplY3Qua2V5cyhyZXFIZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHJlcUhlYWRlcnNba2V5XSA9PT0gbnVsbCAmJiBkZWxldGUgcmVxSGVhZGVyc1trZXldKTtcblxuICAgIGNvbnN0IHJlcTogUmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICAuLi4oYm9keSAmJiB7IGJvZHk6IGJvZHkgYXMgYW55IH0pLFxuICAgICAgaGVhZGVyczogcmVxSGVhZGVycyxcbiAgICAgIC4uLihodHRwQWdlbnQgJiYgeyBhZ2VudDogaHR0cEFnZW50IH0pLFxuICAgICAgLy8gQHRzLWlnbm9yZSBub2RlLWZldGNoIHVzZXMgYSBjdXN0b20gQWJvcnRTaWduYWwgdHlwZSB0aGF0IGlzXG4gICAgICAvLyBub3QgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkIHdlYiB0eXBlc1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCA/PyBudWxsLFxuICAgIH07XG5cbiAgICB0aGlzLnZhbGlkYXRlSGVhZGVycyhyZXFIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0IH07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYFJlcXVlc3RJbml0YCBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3Ugd2FudCB0byBhZGQgY2VydGFpbiBoZWFkZXJzIGJhc2VkIG9mZiBvZlxuICAgKiB0aGUgcmVxdWVzdCBwcm9wZXJ0aWVzLCBlLmcuIGBtZXRob2RgIG9yIGB1cmxgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHByZXBhcmVSZXF1ZXN0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3RJbml0LFxuICAgIHsgdXJsLCBvcHRpb25zIH06IHsgdXJsOiBzdHJpbmc7IG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMgfSxcbiAgKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIHByb3RlY3RlZCBwYXJzZUhlYWRlcnMoaGVhZGVyczogSGVhZGVyc0luaXQgfCBudWxsIHwgdW5kZWZpbmVkKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgICFoZWFkZXJzID8ge31cbiAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIGhlYWRlcnMgP1xuICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShoZWFkZXJzIGFzIEl0ZXJhYmxlPHN0cmluZ1tdPikubWFwKChoZWFkZXIpID0+IFsuLi5oZWFkZXJdKSlcbiAgICAgIDogeyAuLi5oZWFkZXJzIH1cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1ha2VTdGF0dXNFcnJvcihcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICByZXR1cm4gQVBJRXJyb3IuZ2VuZXJhdGUoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cblxuICByZXF1ZXN0PFJlcSBleHRlbmRzIHt9LCBSc3A+KFxuICAgIG9wdGlvbnM6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICAgcmVtYWluaW5nUmV0cmllczogbnVtYmVyIHwgbnVsbCA9IG51bGwsXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdChcbiAgICBvcHRpb25zSW5wdXQ6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM+LFxuICAgIHJldHJpZXNSZW1haW5pbmc6IG51bWJlciB8IG51bGwsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zSW5wdXQ7XG4gICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZXEsIHVybCwgdGltZW91dCB9ID0gdGhpcy5idWlsZFJlcXVlc3Qob3B0aW9ucyk7XG5cbiAgICBhd2FpdCB0aGlzLnByZXBhcmVSZXF1ZXN0KHJlcSwgeyB1cmwsIG9wdGlvbnMgfSk7XG5cbiAgICBkZWJ1ZygncmVxdWVzdCcsIHVybCwgb3B0aW9ucywgcmVxLmhlYWRlcnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgcmVxLCB0aW1lb3V0LCBjb250cm9sbGVyKS5jYXRjaChjYXN0VG9FcnJvcik7XG5cbiAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBjcmVhdGVSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmV0cmllc1JlbWFpbmluZyAmJiB0aGlzLnNob3VsZFJldHJ5KHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZywgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZSkgPT4gY2FzdFRvRXJyb3IoZSkubWVzc2FnZSk7XG4gICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG5cbiAgICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMsIGVyck1lc3NhZ2UpO1xuXG4gICAgICBjb25zdCBlcnIgPSB0aGlzLm1ha2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIGVyckpTT04sIGVyck1lc3NhZ2UsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcmVzcG9uc2UsIG9wdGlvbnMsIGNvbnRyb2xsZXIgfTtcbiAgfVxuXG4gIHJlcXVlc3RBUElMaXN0PEl0ZW0gPSB1bmtub3duLCBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4gPSBBYnN0cmFjdFBhZ2U8SXRlbT4+KFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyxcbiAgKTogUGFnZVByb21pc2U8UGFnZUNsYXNzLCBJdGVtPiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgbnVsbCk7XG4gICAgcmV0dXJuIG5ldyBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+KHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICB9XG5cbiAgYnVpbGRVUkw8UmVxIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KHBhdGg6IHN0cmluZywgcXVlcnk6IFJlcSB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybCA9XG4gICAgICBpc0Fic29sdXRlVVJMKHBhdGgpID9cbiAgICAgICAgbmV3IFVSTChwYXRoKVxuICAgICAgOiBuZXcgVVJMKHRoaXMuYmFzZVVSTCArICh0aGlzLmJhc2VVUkwuZW5kc1dpdGgoJy8nKSAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdGguc2xpY2UoMSkgOiBwYXRoKSk7XG5cbiAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgIGlmICghaXNFbXB0eU9iaihkZWZhdWx0UXVlcnkpKSB7XG4gICAgICBxdWVyeSA9IHsgLi4uZGVmYXVsdFF1ZXJ5LCAuLi5xdWVyeSB9IGFzIFJlcTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RyaW5naWZ5UXVlcnkocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocXVlcnkpXG4gICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBzdHJpbmdpZnkgdHlwZSAke3R5cGVvZiB2YWx1ZX07IEV4cGVjdGVkIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsLiBJZiB5b3UgbmVlZCB0byBwYXNzIG5lc3RlZCBxdWVyeSBwYXJhbWV0ZXJzLCB5b3UgY2FuIG1hbnVhbGx5IGVuY29kZSB0aGVtLCBlLmcuIHsgcXVlcnk6IHsgJ2Zvb1trZXkxXSc6IHZhbHVlMSwgJ2Zvb1trZXkyXSc6IHZhbHVlMiB9IH0sIGFuZCBwbGVhc2Ugb3BlbiBhIEdpdEh1YiBpc3N1ZSByZXF1ZXN0aW5nIGJldHRlciBzdXBwb3J0IGZvciB5b3VyIHVzZSBjYXNlLmAsXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQoXG4gICAgdXJsOiBSZXF1ZXN0SW5mbyxcbiAgICBpbml0OiBSZXF1ZXN0SW5pdCB8IHVuZGVmaW5lZCxcbiAgICBtczogbnVtYmVyLFxuICAgIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbiAgKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgc2lnbmFsLCAuLi5vcHRpb25zIH0gPSBpbml0IHx8IHt9O1xuICAgIGlmIChzaWduYWwpIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG5cbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIG1zKTtcblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmdldFJlcXVlc3RDbGllbnQoKVxuICAgICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgICAuZmV0Y2guY2FsbCh1bmRlZmluZWQsIHVybCwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIGFzIGFueSwgLi4ub3B0aW9ucyB9KVxuICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0UmVxdWVzdENsaWVudCgpOiBSZXF1ZXN0Q2xpZW50IHtcbiAgICByZXR1cm4geyBmZXRjaDogdGhpcy5mZXRjaCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRSZXRyeShyZXNwb25zZTogUmVzcG9uc2UpOiBib29sZWFuIHtcbiAgICAvLyBOb3RlIHRoaXMgaXMgbm90IGEgc3RhbmRhcmQgaGVhZGVyLlxuICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG5cbiAgICAvLyBJZiB0aGUgc2VydmVyIGV4cGxpY2l0bHkgc2F5cyB3aGV0aGVyIG9yIG5vdCB0byByZXRyeSwgb2JleS5cbiAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAnZmFsc2UnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBSZXRyeSBvbiByZXF1ZXN0IHRpbWVvdXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSZXRyeSBvbiByYXRlIGxpbWl0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgaW50ZXJuYWwgZXJyb3JzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmV0cnlSZXF1ZXN0KFxuICAgIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnMsXG4gICAgcmV0cmllc1JlbWFpbmluZzogbnVtYmVyLFxuICAgIHJlc3BvbnNlSGVhZGVycz86IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICk6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4ge1xuICAgIHJldHJpZXNSZW1haW5pbmcgLT0gMTtcblxuICAgIC8vIEFib3V0IHRoZSBSZXRyeS1BZnRlciBoZWFkZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZXRyeS1BZnRlclxuICAgIGxldCB0aW1lb3V0TWlsbGlzOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IHJlc3BvbnNlSGVhZGVycz8uWydyZXRyeS1hZnRlciddO1xuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7XG4gICAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IHBhcnNlSW50KHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0U2Vjb25kcyAqIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0TWlsbGlzID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVySGVhZGVyKSAtIERhdGUubm93KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIEFQSSBhc2tzIHVzIHRvIHdhaXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChhbmQgaXQncyBhIHJlYXNvbmFibGUgYW1vdW50KSxcbiAgICAvLyBqdXN0IGRvIHdoYXQgaXQgc2F5cywgYnV0IG90aGVyd2lzZSBjYWxjdWxhdGUgYSBkZWZhdWx0XG4gICAgaWYgKFxuICAgICAgIXRpbWVvdXRNaWxsaXMgfHxcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHRpbWVvdXRNaWxsaXMpIHx8XG4gICAgICB0aW1lb3V0TWlsbGlzIDw9IDAgfHxcbiAgICAgIHRpbWVvdXRNaWxsaXMgPiA2MCAqIDEwMDBcbiAgICApIHtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gdGhpcy5tYXhSZXRyaWVzO1xuICAgICAgdGltZW91dE1pbGxpcyA9IHRoaXMuY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nLCBtYXhSZXRyaWVzKTtcbiAgICB9XG4gICAgYXdhaXQgc2xlZXAodGltZW91dE1pbGxpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nOiBudW1iZXIsIG1heFJldHJpZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaW5pdGlhbFJldHJ5RGVsYXkgPSAwLjU7XG4gICAgY29uc3QgbWF4UmV0cnlEZWxheSA9IDI7XG5cbiAgICBjb25zdCBudW1SZXRyaWVzID0gbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmc7XG5cbiAgICAvLyBBcHBseSBleHBvbmVudGlhbCBiYWNrb2ZmLCBidXQgbm90IG1vcmUgdGhhbiB0aGUgbWF4LlxuICAgIGNvbnN0IHNsZWVwU2Vjb25kcyA9IE1hdGgubWluKGluaXRpYWxSZXRyeURlbGF5ICogTWF0aC5wb3cobnVtUmV0cmllcyAtIDEsIDIpLCBtYXhSZXRyeURlbGF5KTtcblxuICAgIC8vIEFwcGx5IHNvbWUgaml0dGVyLCBwbHVzLW9yLW1pbnVzIGhhbGYgYSBzZWNvbmQuXG4gICAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAtIDAuNTtcblxuICAgIHJldHVybiAoc2xlZXBTZWNvbmRzICsgaml0dGVyKSAqIDEwMDA7XG4gIH1cblxuICBwcml2YXRlIGdldFVzZXJBZ2VudCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7VkVSU0lPTn1gO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElSZXNvdXJjZSB7XG4gIHByb3RlY3RlZCBjbGllbnQ6IEFQSUNsaWVudDtcbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcblxuICAgIHRoaXMuZ2V0ID0gY2xpZW50LmdldC5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5wb3N0ID0gY2xpZW50LnBvc3QuYmluZChjbGllbnQpO1xuICAgIHRoaXMucGF0Y2ggPSBjbGllbnQucGF0Y2guYmluZChjbGllbnQpO1xuICAgIHRoaXMucHV0ID0gY2xpZW50LnB1dC5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5kZWxldGUgPSBjbGllbnQuZGVsZXRlLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLmdldEFQSUxpc3QgPSBjbGllbnQuZ2V0QVBJTGlzdC5iaW5kKGNsaWVudCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0OiBBUElDbGllbnRbJ2dldCddO1xuICBwcm90ZWN0ZWQgcG9zdDogQVBJQ2xpZW50Wydwb3N0J107XG4gIHByb3RlY3RlZCBwYXRjaDogQVBJQ2xpZW50WydwYXRjaCddO1xuICBwcm90ZWN0ZWQgcHV0OiBBUElDbGllbnRbJ3B1dCddO1xuICBwcm90ZWN0ZWQgZGVsZXRlOiBBUElDbGllbnRbJ2RlbGV0ZSddO1xuICBwcm90ZWN0ZWQgZ2V0QVBJTGlzdDogQVBJQ2xpZW50WydnZXRBUElMaXN0J107XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VJbmZvID0geyB1cmw6IFVSTCB9IHwgeyBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCB9O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPiB7XG4gICNjbGllbnQ6IEFQSUNsaWVudDtcbiAgcHJvdGVjdGVkIG9wdGlvbnM6IEZpbmFsUmVxdWVzdE9wdGlvbnM7XG5cbiAgcHJvdGVjdGVkIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgcHJvdGVjdGVkIGJvZHk6IHVua25vd247XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogdW5rbm93biwgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucykge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBuZXh0UGFnZUluZm8gaW5zdGVhZFxuICAgKi9cbiAgYWJzdHJhY3QgbmV4dFBhZ2VQYXJhbXMoKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gfCBudWxsO1xuICBhYnN0cmFjdCBuZXh0UGFnZUluZm8oKTogUGFnZUluZm8gfCBudWxsO1xuXG4gIGFic3RyYWN0IGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXTtcblxuICBoYXNOZXh0UGFnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm5leHRQYWdlSW5mbygpICE9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXROZXh0UGFnZSgpOiBQcm9taXNlPHRoaXM+IHtcbiAgICBjb25zdCBuZXh0SW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgaWYgKCFuZXh0SW5mbykge1xuICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKFxuICAgICAgICAnTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBuZXh0T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG4gICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvKSB7XG4gICAgICBuZXh0T3B0aW9ucy5xdWVyeSA9IHsgLi4ubmV4dE9wdGlvbnMucXVlcnksIC4uLm5leHRJbmZvLnBhcmFtcyB9O1xuICAgIH0gZWxzZSBpZiAoJ3VybCcgaW4gbmV4dEluZm8pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsuLi5PYmplY3QuZW50cmllcyhuZXh0T3B0aW9ucy5xdWVyeSB8fCB7fSksIC4uLm5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuZW50cmllcygpXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICBuZXh0SW5mby51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlIGFzIGFueSk7XG4gICAgICB9XG4gICAgICBuZXh0T3B0aW9ucy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgIG5leHRPcHRpb25zLnBhdGggPSBuZXh0SW5mby51cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NsaWVudC5yZXF1ZXN0QVBJTGlzdCh0aGlzLmNvbnN0cnVjdG9yIGFzIGFueSwgbmV4dE9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgKml0ZXJQYWdlcygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBsZXQgcGFnZTogQWJzdHJhY3RQYWdlPEl0ZW0+ID0gdGhpcztcbiAgICB5aWVsZCBwYWdlO1xuICAgIHdoaWxlIChwYWdlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgIHBhZ2UgPSBhd2FpdCBwYWdlLmdldE5leHRQYWdlKCk7XG4gICAgICB5aWVsZCBwYWdlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFnZSBvZiB0aGlzLml0ZXJQYWdlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFnZS5nZXRQYWdpbmF0ZWRJdGVtcygpKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBzdWJjbGFzcyBvZiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB0byBhbiBpbnN0YW50aWF0ZWQgUGFnZSBvbmNlIHRoZSByZXF1ZXN0IGNvbXBsZXRlcy5cbiAqXG4gKiBJdCBhbHNvIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZSB0byBhbGxvdyBhdXRvLXBhZ2luYXRpbmcgaXRlcmF0aW9uIG9uIGFuIHVuYXdhaXRlZCBsaXN0IGNhbGwsIGVnOlxuICpcbiAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gKiAgICAgIGNvbnNvbGUubG9nKGl0ZW0pXG4gKiAgICB9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlUHJvbWlzZTxcbiAgICBQYWdlQ2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT4sXG4gICAgSXRlbSA9IFJldHVyblR5cGU8UGFnZUNsYXNzWydnZXRQYWdpbmF0ZWRJdGVtcyddPltudW1iZXJdLFxuICA+XG4gIGV4dGVuZHMgQVBJUHJvbWlzZTxQYWdlQ2xhc3M+XG4gIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxJdGVtPlxue1xuICBjb25zdHJ1Y3RvcihcbiAgICBjbGllbnQ6IEFQSUNsaWVudCxcbiAgICByZXF1ZXN0OiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+LFxuICAgIFBhZ2U6IG5ldyAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFBhZ2U+KSA9PiBQYWdlQ2xhc3MsXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGFzeW5jIChwcm9wcykgPT4gbmV3IFBhZ2UoY2xpZW50LCBwcm9wcy5yZXNwb25zZSwgYXdhaXQgZGVmYXVsdFBhcnNlUmVzcG9uc2UocHJvcHMpLCBwcm9wcy5vcHRpb25zKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAqXG4gICAqICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBjbGllbnQuaXRlbXMubGlzdCgpKSB7XG4gICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICogICAgfVxuICAgKi9cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXM7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHBhZ2UpIHtcbiAgICAgIHlpZWxkIGl0ZW07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNwb25zZUhlYWRlcnMgPSAoXG4gIGhlYWRlcnM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTxGZXRjaD4+WydoZWFkZXJzJ10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBoZWFkZXJzLmVudHJpZXMoKSxcbiAgICApLFxuICAgIHtcbiAgICAgIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleS50b0xvd2VyQ2FzZSgpXSB8fCB0YXJnZXRba2V5XTtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcbn07XG5cbnR5cGUgSFRUUE1ldGhvZCA9ICdnZXQnIHwgJ3Bvc3QnIHwgJ3B1dCcgfCAncGF0Y2gnIHwgJ2RlbGV0ZSc7XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RDbGllbnQgPSB7IGZldGNoOiBGZXRjaCB9O1xuZXhwb3J0IHR5cGUgSGVhZGVycyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgRGVmYXVsdFF1ZXJ5ID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcbmV4cG9ydCB0eXBlIEtleXNFbnVtPFQ+ID0geyBbUCBpbiBrZXlvZiBSZXF1aXJlZDxUPl06IHRydWUgfTtcblxuZXhwb3J0IHR5cGUgUmVxdWVzdE9wdGlvbnM8UmVxIGV4dGVuZHMge30gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlYWRhYmxlPiA9IHtcbiAgbWV0aG9kPzogSFRUUE1ldGhvZDtcbiAgcGF0aD86IHN0cmluZztcbiAgcXVlcnk/OiBSZXEgfCB1bmRlZmluZWQ7XG4gIGJvZHk/OiBSZXEgfCB1bmRlZmluZWQ7XG4gIGhlYWRlcnM/OiBIZWFkZXJzIHwgdW5kZWZpbmVkO1xuXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIHN0cmVhbT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIGh0dHBBZ2VudD86IEFnZW50O1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbCB8IHVuZGVmaW5lZCB8IG51bGw7XG4gIGlkZW1wb3RlbmN5S2V5Pzogc3RyaW5nO1xufTtcblxuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzOiBLZXlzRW51bTxSZXF1ZXN0T3B0aW9ucz4gPSB7XG4gIG1ldGhvZDogdHJ1ZSxcbiAgcGF0aDogdHJ1ZSxcbiAgcXVlcnk6IHRydWUsXG4gIGJvZHk6IHRydWUsXG4gIGhlYWRlcnM6IHRydWUsXG5cbiAgbWF4UmV0cmllczogdHJ1ZSxcbiAgc3RyZWFtOiB0cnVlLFxuICB0aW1lb3V0OiB0cnVlLFxuICBodHRwQWdlbnQ6IHRydWUsXG4gIHNpZ25hbDogdHJ1ZSxcbiAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgaXNSZXF1ZXN0T3B0aW9ucyA9IChvYmo6IHVua25vd24pOiBvYmogaXMgUmVxdWVzdE9wdGlvbnM8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBSZWFkYWJsZT4gPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgb2JqICE9PSBudWxsICYmXG4gICAgIWlzRW1wdHlPYmoob2JqKSAmJlxuICAgIE9iamVjdC5rZXlzKG9iaikuZXZlcnkoKGspID0+IGhhc093bihyZXF1ZXN0T3B0aW9uc0tleXMsIGspKVxuICApO1xufTtcblxuZXhwb3J0IHR5cGUgRmluYWxSZXF1ZXN0T3B0aW9uczxSZXEgZXh0ZW5kcyB7fSA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgUmVhZGFibGU+ID0gUmVxdWVzdE9wdGlvbnM8UmVxPiAmIHtcbiAgbWV0aG9kOiBIVFRQTWV0aG9kO1xuICBwYXRoOiBzdHJpbmc7XG59O1xuXG5kZWNsYXJlIGNvbnN0IERlbm86IGFueTtcbmRlY2xhcmUgY29uc3QgRWRnZVJ1bnRpbWU6IGFueTtcbnR5cGUgQXJjaCA9ICd4MzInIHwgJ3g2NCcgfCAnYXJtJyB8ICdhcm02NCcgfCBgb3RoZXI6JHtzdHJpbmd9YCB8ICd1bmtub3duJztcbnR5cGUgUGxhdGZvcm1OYW1lID1cbiAgfCAnTWFjT1MnXG4gIHwgJ0xpbnV4J1xuICB8ICdXaW5kb3dzJ1xuICB8ICdGcmVlQlNEJ1xuICB8ICdPcGVuQlNEJ1xuICB8ICdpT1MnXG4gIHwgJ0FuZHJvaWQnXG4gIHwgYE90aGVyOiR7c3RyaW5nfWBcbiAgfCAnVW5rbm93bic7XG50eXBlIEJyb3dzZXIgPSAnaWUnIHwgJ2VkZ2UnIHwgJ2Nocm9tZScgfCAnZmlyZWZveCcgfCAnc2FmYXJpJztcbnR5cGUgUGxhdGZvcm1Qcm9wZXJ0aWVzID0ge1xuICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcyc7XG4gICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBzdHJpbmc7XG4gICdYLVN0YWlubGVzcy1PUyc6IFBsYXRmb3JtTmFtZTtcbiAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBBcmNoO1xuICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyB8ICdkZW5vJyB8ICdlZGdlJyB8IGBicm93c2VyOiR7QnJvd3Nlcn1gIHwgJ3Vua25vd24nO1xuICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogc3RyaW5nO1xufTtcbmNvbnN0IGdldFBsYXRmb3JtUHJvcGVydGllcyA9ICgpOiBQbGF0Zm9ybVByb3BlcnRpZXMgPT4ge1xuICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIERlbm8uYnVpbGQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKERlbm8uYnVpbGQub3MpLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKERlbm8uYnVpbGQuYXJjaCksXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdkZW5vJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBEZW5vLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICB9O1xuICB9XG4gIC8vIENoZWNrIGlmIE5vZGUuanNcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKHByb2Nlc3MucGxhdGZvcm0pLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKHByb2Nlc3MuYXJjaCksXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGJyb3dzZXJJbmZvID0gZ2V0QnJvd3NlckluZm8oKTtcbiAgaWYgKGJyb3dzZXJJbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiAndW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6IGBicm93c2VyOiR7YnJvd3NlckluZm8uYnJvd3Nlcn1gLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IGJyb3dzZXJJbmZvLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE8gYWRkIHN1cHBvcnQgZm9yIENsb3VkZmxhcmUgd29ya2VycywgZXRjLlxuICByZXR1cm4ge1xuICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiAndW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAndW5rbm93bicsXG4gICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6ICd1bmtub3duJyxcbiAgfTtcbn07XG5cbnR5cGUgQnJvd3NlckluZm8gPSB7XG4gIGJyb3dzZXI6IEJyb3dzZXI7XG4gIHZlcnNpb246IHN0cmluZztcbn07XG5cbmRlY2xhcmUgY29uc3QgbmF2aWdhdG9yOiB7IHVzZXJBZ2VudDogc3RyaW5nIH0gfCB1bmRlZmluZWQ7XG5cbi8vIE5vdGU6IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0pTLURldlRvb2xzL2hvc3QtZW52aXJvbm1lbnQvYmxvYi9iMWFiNzllY2RlMzdkYjVkNmUxNjNjMDUwZTU0ZmU3ZDI4N2Q3YzkyL3NyYy9pc29tb3JwaGljLmJyb3dzZXIudHNcbmZ1bmN0aW9uIGdldEJyb3dzZXJJbmZvKCk6IEJyb3dzZXJJbmZvIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOT1RFOiBUaGUgb3JkZXIgbWF0dGVycyBoZXJlIVxuICBjb25zdCBicm93c2VyUGF0dGVybnMgPSBbXG4gICAgeyBrZXk6ICdlZGdlJyBhcyBjb25zdCwgcGF0dGVybjogL0VkZ2UoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2llJyBhcyBjb25zdCwgcGF0dGVybjogL01TSUUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2llJyBhcyBjb25zdCwgcGF0dGVybjogL1RyaWRlbnQoPzouKnJ2XFw6KFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2Nocm9tZScgYXMgY29uc3QsIHBhdHRlcm46IC9DaHJvbWUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ2ZpcmVmb3gnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvRmlyZWZveCg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgIHsga2V5OiAnc2FmYXJpJyBhcyBjb25zdCwgcGF0dGVybjogLyg/OlZlcnNpb25cXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPyg/OlxcVytNb2JpbGVcXFMqKT9cXFcrU2FmYXJpLyB9LFxuICBdO1xuXG4gIC8vIEZpbmQgdGhlIEZJUlNUIG1hdGNoaW5nIGJyb3dzZXJcbiAgZm9yIChjb25zdCB7IGtleSwgcGF0dGVybiB9IG9mIGJyb3dzZXJQYXR0ZXJucykge1xuICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbWFqb3IgPSBtYXRjaFsxXSB8fCAwO1xuICAgICAgY29uc3QgbWlub3IgPSBtYXRjaFsyXSB8fCAwO1xuICAgICAgY29uc3QgcGF0Y2ggPSBtYXRjaFszXSB8fCAwO1xuXG4gICAgICByZXR1cm4geyBicm93c2VyOiBrZXksIHZlcnNpb246IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3Qgbm9ybWFsaXplQXJjaCA9IChhcmNoOiBzdHJpbmcpOiBBcmNoID0+IHtcbiAgLy8gTm9kZSBkb2NzOlxuICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NhcmNoXG4gIC8vIERlbm8gZG9jczpcbiAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gIGlmIChhcmNoID09PSAneDMyJykgcmV0dXJuICd4MzInO1xuICBpZiAoYXJjaCA9PT0gJ3g4Nl82NCcgfHwgYXJjaCA9PT0gJ3g2NCcpIHJldHVybiAneDY0JztcbiAgaWYgKGFyY2ggPT09ICdhcm0nKSByZXR1cm4gJ2FybSc7XG4gIGlmIChhcmNoID09PSAnYWFyY2g2NCcgfHwgYXJjaCA9PT0gJ2FybTY0JykgcmV0dXJuICdhcm02NCc7XG4gIGlmIChhcmNoKSByZXR1cm4gYG90aGVyOiR7YXJjaH1gO1xuICByZXR1cm4gJ3Vua25vd24nO1xufTtcblxuY29uc3Qgbm9ybWFsaXplUGxhdGZvcm0gPSAocGxhdGZvcm06IHN0cmluZyk6IFBsYXRmb3JtTmFtZSA9PiB7XG4gIC8vIE5vZGUgcGxhdGZvcm1zOlxuICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NwbGF0Zm9ybVxuICAvLyBEZW5vIHBsYXRmb3JtczpcbiAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzE0Nzk5XG5cbiAgcGxhdGZvcm0gPSBwbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIE5PVEU6IHRoaXMgaU9TIGNoZWNrIGlzIHVudGVzdGVkIGFuZCBtYXkgbm90IHdvcmtcbiAgLy8gTm9kZSBkb2VzIG5vdCB3b3JrIG5hdGl2ZWx5IG9uIElPUywgdGhlcmUgaXMgYSBmb3JrIGF0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMtbW9iaWxlL25vZGVqcy1tb2JpbGVcbiAgLy8gaG93ZXZlciBpdCBpcyB1bmtub3duIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaG93IHRvIGRldGVjdCBpZiBpdCBpcyBydW5uaW5nXG4gIGlmIChwbGF0Zm9ybS5pbmNsdWRlcygnaW9zJykpIHJldHVybiAnaU9TJztcbiAgaWYgKHBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHJldHVybiAnQW5kcm9pZCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHJldHVybiAnTWFjT1MnO1xuICBpZiAocGxhdGZvcm0gPT09ICd3aW4zMicpIHJldHVybiAnV2luZG93cyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKSByZXR1cm4gJ0ZyZWVCU0QnO1xuICBpZiAocGxhdGZvcm0gPT09ICdvcGVuYnNkJykgcmV0dXJuICdPcGVuQlNEJztcbiAgaWYgKHBsYXRmb3JtID09PSAnbGludXgnKSByZXR1cm4gJ0xpbnV4JztcbiAgaWYgKHBsYXRmb3JtKSByZXR1cm4gYE90aGVyOiR7cGxhdGZvcm19YDtcbiAgcmV0dXJuICdVbmtub3duJztcbn07XG5cbmxldCBfcGxhdGZvcm1IZWFkZXJzOiBQbGF0Zm9ybVByb3BlcnRpZXM7XG5jb25zdCBnZXRQbGF0Zm9ybUhlYWRlcnMgPSAoKSA9PiB7XG4gIHJldHVybiAoX3BsYXRmb3JtSGVhZGVycyA/Pz0gZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNhZmVKU09OID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk3MDk4NDZcbmNvbnN0IHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAgPSBuZXcgUmVnRXhwKCdeKD86W2Etel0rOik/Ly8nLCAnaScpO1xuY29uc3QgaXNBYnNvbHV0ZVVSTCA9ICh1cmw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gc3RhcnRzV2l0aFNjaGVtZVJlZ2V4cC50ZXN0KHVybCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuY29uc3QgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIgPSAobmFtZTogc3RyaW5nLCBuOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgfVxuICBpZiAobiA8IDApIHtcbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXN0VG9FcnJvciA9IChlcnI6IGFueSk6IEVycm9yID0+IHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICByZXR1cm4gbmV3IEVycm9yKGVycik7XG59O1xuXG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9IDxUPih2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBUID0+IHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBPcGVuQUlFcnJvcihgRXhwZWN0ZWQgYSB2YWx1ZSB0byBiZSBnaXZlbiBidXQgcmVjZWl2ZWQgJHt2YWx1ZX0gaW5zdGVhZC5gKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgZG9lc24ndCBleGlzdCBvciBjYW5ub3QgYmUgYWNjZXNzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRW52ID0gKGVudjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudj8uW2Vudl0gPz8gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gRGVuby5lbnY/LmdldD8uKGVudik7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQ291bGQgbm90IGNvZXJjZSAke3ZhbHVlfSAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSBpbnRvIGEgbnVtYmVyYCk7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlRmxvYXQgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQ291bGQgbm90IGNvZXJjZSAke3ZhbHVlfSAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSBpbnRvIGEgbnVtYmVyYCk7XG59O1xuXG5leHBvcnQgY29uc3QgY29lcmNlQm9vbGVhbiA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnO1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VJbnRlZ2VyKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUZsb2F0ID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VGbG9hdCh2YWx1ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VCb29sZWFuID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29lcmNlQm9vbGVhbih2YWx1ZSk7XG59O1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODdcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iajogT2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICBpZiAoIW9iaikgcmV0dXJuIHRydWU7XG4gIGZvciAoY29uc3QgX2sgaW4gb2JqKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwczovL2VzbGludC5vcmcvZG9jcy9sYXRlc3QvcnVsZXMvbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iajogT2JqZWN0LCBrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKGFjdGlvbjogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydERUJVRyddID09PSAndHJ1ZScpIHtcbiAgICBjb25zb2xlLmxvZyhgT3BlbkFJOkRFQlVHOiR7YWN0aW9ufWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqL1xuY29uc3QgdXVpZDQgPSAoKSA9PiB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMDtcbiAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUnVubmluZ0luQnJvd3NlciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGVyc1Byb3RvY29sIHtcbiAgZ2V0OiAoaGVhZGVyOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5leHBvcnQgdHlwZSBIZWFkZXJzTGlrZSA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPiB8IEhlYWRlcnNQcm90b2NvbDtcblxuZXhwb3J0IGNvbnN0IGlzSGVhZGVyc1Byb3RvY29sID0gKGhlYWRlcnM6IGFueSk6IGhlYWRlcnMgaXMgSGVhZGVyc1Byb3RvY29sID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBoZWFkZXJzPy5nZXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SGVhZGVyID0gKGhlYWRlcnM6IEhlYWRlcnNMaWtlLCBrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoaXNIZWFkZXJzUHJvdG9jb2woaGVhZGVycykpIHJldHVybiBoZWFkZXJzLmdldChrZXkpIHx8IGhlYWRlcnMuZ2V0KGxvd2VyS2V5KTtcbiAgY29uc3QgdmFsdWUgPSBoZWFkZXJzW2tleV0gfHwgaGVhZGVyc1tsb3dlcktleV07XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMSkgcmV0dXJuIHZhbHVlWzBdO1xuICAgIGNvbnNvbGUud2FybihgUmVjZWl2ZWQgJHt2YWx1ZS5sZW5ndGh9IGVudHJpZXMgZm9yIHRoZSAke2tleX0gaGVhZGVyLCB1c2luZyB0aGUgZmlyc3QgZW50cnkuYCk7XG4gICAgcmV0dXJuIHZhbHVlWzBdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB0byBCYXNlNjQgZm9ybWF0LlxuICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjQgPSAoc3RyOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nID0+IHtcbiAgaWYgKCFzdHIpIHJldHVybiAnJztcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBidG9hKHN0cik7XG4gIH1cblxuICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSBiNjQgc3RyaW5nOyBFeHBlY3RlZCBgQnVmZmVyYCBvciBgYnRvYWAgdG8gYmUgZGVmaW5lZCcpO1xufTtcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBBYnN0cmFjdFBhZ2UsIFJlc3BvbnNlLCBBUElDbGllbnQsIEZpbmFsUmVxdWVzdE9wdGlvbnMsIFBhZ2VJbmZvIH0gZnJvbSAnLi9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdlUmVzcG9uc2U8SXRlbT4ge1xuICBkYXRhOiBBcnJheTxJdGVtPjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3RlOiBubyBwYWdpbmF0aW9uIGFjdHVhbGx5IG9jY3VycyB5ZXQsIHRoaXMgaXMgZm9yIGZvcndhcmRzLWNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlPEl0ZW0+IGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+IGltcGxlbWVudHMgUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiBBUElDbGllbnQsIHJlc3BvbnNlOiBSZXNwb25zZSwgYm9keTogUGFnZVJlc3BvbnNlPEl0ZW0+LCBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKSB7XG4gICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9iamVjdCA9IGJvZHkub2JqZWN0O1xuICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YTtcbiAgfVxuXG4gIGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIC8qKlxuICAgKiBUaGlzIHBhZ2UgcmVwcmVzZW50cyBhIHJlc3BvbnNlIHRoYXQgaXNuJ3QgYWN0dWFsbHkgcGFnaW5hdGVkIGF0IHRoZSBBUEkgbGV2ZWxcbiAgICogc28gdGhlcmUgd2lsbCBuZXZlciBiZSBhbnkgbmV4dCBwYWdlIHBhcmFtcy5cbiAgICovXG4gIG5leHRQYWdlUGFyYW1zKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbmV4dFBhZ2VJbmZvKCk6IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3Vyc29yUGFnZVJlc3BvbnNlPEl0ZW0+IHtcbiAgZGF0YTogQXJyYXk8SXRlbT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3Vyc29yUGFnZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgbGFzdCBqb2IgZnJvbSB0aGUgcHJldmlvdXMgcGFnaW5hdGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgYWZ0ZXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBmaW5lLXR1bmluZyBqb2JzIHRvIHJldHJpZXZlLlxuICAgKi9cbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDdXJzb3JQYWdlPEl0ZW0gZXh0ZW5kcyB7IGlkOiBzdHJpbmcgfT5cbiAgZXh0ZW5kcyBBYnN0cmFjdFBhZ2U8SXRlbT5cbiAgaW1wbGVtZW50cyBDdXJzb3JQYWdlUmVzcG9uc2U8SXRlbT5cbntcbiAgZGF0YTogQXJyYXk8SXRlbT47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2xpZW50OiBBUElDbGllbnQsXG4gICAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICAgIGJvZHk6IEN1cnNvclBhZ2VSZXNwb25zZTxJdGVtPixcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihjbGllbnQsIHJlc3BvbnNlLCBib2R5LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YTtcbiAgfVxuXG4gIGdldFBhZ2luYXRlZEl0ZW1zKCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuXG4gIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gIG5leHRQYWdlUGFyYW1zKCk6IFBhcnRpYWw8Q3Vyc29yUGFnZVBhcmFtcz4gfCBudWxsIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5uZXh0UGFnZUluZm8oKTtcbiAgICBpZiAoIWluZm8pIHJldHVybiBudWxsO1xuICAgIGlmICgncGFyYW1zJyBpbiBpbmZvKSByZXR1cm4gaW5mby5wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKGluZm8udXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIG5leHRQYWdlSW5mbygpOiBQYWdlSW5mbyB8IG51bGwge1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdPy5pZDtcbiAgICBpZiAoIW5leHQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7IHBhcmFtczogeyBhZnRlcjogbmV4dCB9IH07XG4gIH1cbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgdHlwZSB7IE9wZW5BSSB9IGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgQVBJUmVzb3VyY2Uge1xuICBwcm90ZWN0ZWQgY2xpZW50OiBPcGVuQUk7XG4gIGNvbnN0cnVjdG9yKGNsaWVudDogT3BlbkFJKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG5cbiAgICB0aGlzLmdldCA9IGNsaWVudC5nZXQuYmluZChjbGllbnQpO1xuICAgIHRoaXMucG9zdCA9IGNsaWVudC5wb3N0LmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLnBhdGNoID0gY2xpZW50LnBhdGNoLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLnB1dCA9IGNsaWVudC5wdXQuYmluZChjbGllbnQpO1xuICAgIHRoaXMuZGVsZXRlID0gY2xpZW50LmRlbGV0ZS5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5nZXRBUElMaXN0ID0gY2xpZW50LmdldEFQSUxpc3QuYmluZChjbGllbnQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldDogT3BlbkFJWydnZXQnXTtcbiAgcHJvdGVjdGVkIHBvc3Q6IE9wZW5BSVsncG9zdCddO1xuICBwcm90ZWN0ZWQgcGF0Y2g6IE9wZW5BSVsncGF0Y2gnXTtcbiAgcHJvdGVjdGVkIHB1dDogT3BlbkFJWydwdXQnXTtcbiAgcHJvdGVjdGVkIGRlbGV0ZTogT3BlbkFJWydkZWxldGUnXTtcbiAgcHJvdGVjdGVkIGdldEFQSUxpc3Q6IE9wZW5BSVsnZ2V0QVBJTGlzdCddO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyB0eXBlIFVwbG9hZGFibGUsIG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi9jb3JlXCI7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zY3JpYmVzIGF1ZGlvIGludG8gdGhlIGlucHV0IGxhbmd1YWdlLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb24ge1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRvIHRyYW5zY3JpYmUsIGluIG9uZSBvZiB0aGVzZSBmb3JtYXRzOlxuICAgKiBmbGFjLCBtcDMsIG1wNCwgbXBlZywgbXBnYSwgbTRhLCBvZ2csIHdhdiwgb3Igd2VibS5cbiAgICovXG4gIGZpbGU6IFVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIE9ubHkgYHdoaXNwZXItMWAgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3doaXNwZXItMSc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgaW5wdXQgYXVkaW8uIFN1cHBseWluZyB0aGUgaW5wdXQgbGFuZ3VhZ2UgaW5cbiAgICogW0lTTy02MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpIGZvcm1hdCB3aWxsXG4gICAqIGltcHJvdmUgYWNjdXJhY3kgYW5kIGxhdGVuY3kuXG4gICAqL1xuICBsYW5ndWFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgdGV4dCB0byBndWlkZSB0aGUgbW9kZWwncyBzdHlsZSBvciBjb250aW51ZSBhIHByZXZpb3VzIGF1ZGlvXG4gICAqIHNlZ21lbnQuIFRoZVxuICAgKiBbcHJvbXB0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc3BlZWNoLXRvLXRleHQvcHJvbXB0aW5nKVxuICAgKiBzaG91bGQgbWF0Y2ggdGhlIGF1ZGlvIGxhbmd1YWdlLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSB0cmFuc2NyaXB0IG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGpzb24sIHRleHQsIHNydCxcbiAgICogdmVyYm9zZV9qc29uLCBvciB2dHQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAnanNvbicgfCAndGV4dCcgfCAnc3J0JyB8ICd2ZXJib3NlX2pzb24nIHwgJ3Z0dCc7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhbnNjcmlwdGlvbnMge1xuICBleHBvcnQgaW1wb3J0IFRyYW5zY3JpcHRpb24gPSBBUEkuVHJhbnNjcmlwdGlvbjtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLlRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IHR5cGUgVXBsb2FkYWJsZSwgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcblxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgYXVkaW8gaW50byBFbmdsaXNoLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxUcmFuc2xhdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9hdWRpby90cmFuc2xhdGlvbnMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uIHtcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBmaWxlIG9iamVjdCAobm90IGZpbGUgbmFtZSkgdHJhbnNsYXRlLCBpbiBvbmUgb2YgdGhlc2UgZm9ybWF0czogZmxhYyxcbiAgICogbXAzLCBtcDQsIG1wZWcsIG1wZ2EsIG00YSwgb2dnLCB3YXYsIG9yIHdlYm0uXG4gICAqL1xuICBmaWxlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBPbmx5IGB3aGlzcGVyLTFgIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqL1xuICBtb2RlbDogKHN0cmluZyAmIHt9KSB8ICd3aGlzcGVyLTEnO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCB0ZXh0IHRvIGd1aWRlIHRoZSBtb2RlbCdzIHN0eWxlIG9yIGNvbnRpbnVlIGEgcHJldmlvdXMgYXVkaW9cbiAgICogc2VnbWVudC4gVGhlXG4gICAqIFtwcm9tcHRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zcGVlY2gtdG8tdGV4dC9wcm9tcHRpbmcpXG4gICAqIHNob3VsZCBiZSBpbiBFbmdsaXNoLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSB0cmFuc2NyaXB0IG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGpzb24sIHRleHQsIHNydCxcbiAgICogdmVyYm9zZV9qc29uLCBvciB2dHQuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGluZyB0ZW1wZXJhdHVyZSwgYmV0d2VlbiAwIGFuZCAxLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGwgbWFrZSB0aGVcbiAgICogb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmUgZm9jdXNlZCBhbmRcbiAgICogZGV0ZXJtaW5pc3RpYy4gSWYgc2V0IHRvIDAsIHRoZSBtb2RlbCB3aWxsIHVzZVxuICAgKiBbbG9nIHByb2JhYmlsaXR5XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dfcHJvYmFiaWxpdHkpIHRvXG4gICAqIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2UgdGhlIHRlbXBlcmF0dXJlIHVudGlsIGNlcnRhaW4gdGhyZXNob2xkcyBhcmUgaGl0LlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhbnNsYXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbiA9IEFQSS5UcmFuc2xhdGlvbjtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5UcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZVwiO1xuaW1wb3J0IHsgVHJhbnNjcmlwdGlvbnMgfSBmcm9tICcuL3RyYW5zY3JpcHRpb25zJztcbmltcG9ydCB7IFRyYW5zbGF0aW9ucyB9IGZyb20gJy4vdHJhbnNsYXRpb25zJztcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICB0cmFuc2NyaXB0aW9uczogVHJhbnNjcmlwdGlvbnMgPSBuZXcgVHJhbnNjcmlwdGlvbnModGhpcy5jbGllbnQpO1xuICB0cmFuc2xhdGlvbnM6IFRyYW5zbGF0aW9ucyA9IG5ldyBUcmFuc2xhdGlvbnModGhpcy5jbGllbnQpO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEF1ZGlvIHtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2NyaXB0aW9ucyA9IEFQSS5UcmFuc2NyaXB0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2NyaXB0aW9uID0gQVBJLlRyYW5zY3JpcHRpb247XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5UcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zO1xuXG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNsYXRpb25zID0gQVBJLlRyYW5zbGF0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbiA9IEFQSS5UcmFuc2xhdGlvbjtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5UcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi8uLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc18gZnJvbSBcIi4uL2NvbXBsZXRpb25zXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi4vLi4vc3RyZWFtaW5nXCI7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtb2RlbCByZXNwb25zZSBmb3IgdGhlIGdpdmVuIGNoYXQgY29udmVyc2F0aW9uLlxuICAgKi9cbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8U3RyZWFtPENoYXRDb21wbGV0aW9uQ2h1bms+IHwgQ2hhdENvbXBsZXRpb24+O1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+IHwgQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvY2hhdC9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENoYXRDb21wbGV0aW9uPlxuICAgICAgfCBBUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBjb21wbGV0aW9uIHJlc3BvbnNlIHJldHVybmVkIGJ5IG1vZGVsLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMuIENhbiBiZSBtb3JlIHRoYW4gb25lIGlmIGBuYCBpcyBncmVhdGVyXG4gICAqIHRoYW4gMS5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uLkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBjaGF0LmNvbXBsZXRpb25gLlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25zXy5Db21wbGV0aW9uVXNhZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdENvbXBsZXRpb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgb3IgYGZ1bmN0aW9uX2NhbGxgXG4gICAgICogaWYgdGhlIG1vZGVsIGNhbGxlZCBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2hvaWNlIGluIHRoZSBsaXN0IG9mIGNob2ljZXMuXG4gICAgICovXG4gICAgaW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEEgY2hhdCBjb21wbGV0aW9uIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBtZXNzYWdlOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RyZWFtZWQgY2h1bmsgb2YgYSBjaGF0IGNvbXBsZXRpb24gcmVzcG9uc2UgcmV0dXJuZWQgYnkgbW9kZWwsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uIGNodW5rLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGNoYXQgY29tcGxldGlvbiBjaG9pY2VzLiBDYW4gYmUgbW9yZSB0aGFuIG9uZSBpZiBgbmAgaXMgZ3JlYXRlclxuICAgKiB0aGFuIDEuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbkNodW5rLkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgb2Ygd2hlbiB0aGUgY2hhdCBjb21wbGV0aW9uIGNodW5rIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdG8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBgY2hhdC5jb21wbGV0aW9uLmNodW5rYC5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICBleHBvcnQgaW50ZXJmYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBkZWx0YTogQ2hvaWNlLkRlbHRhO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLCBgY29udGVudF9maWx0ZXJgIGlmXG4gICAgICogY29udGVudCB3YXMgb21pdHRlZCBkdWUgdG8gYSBmbGFnIGZyb20gb3VyIGNvbnRlbnQgZmlsdGVycywgb3IgYGZ1bmN0aW9uX2NhbGxgXG4gICAgICogaWYgdGhlIG1vZGVsIGNhbGxlZCBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2Z1bmN0aW9uX2NhbGwnIHwgJ2NvbnRlbnRfZmlsdGVyJyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgLyoqXG4gICAgICogQSBjaGF0IGNvbXBsZXRpb24gZGVsdGEgZ2VuZXJhdGVkIGJ5IHN0cmVhbWVkIG1vZGVsIHJlc3BvbnNlcy5cbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIERlbHRhIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBjaHVuayBtZXNzYWdlLlxuICAgICAgICovXG4gICAgICBjb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAgICAgKiBtb2RlbC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb25fY2FsbD86IERlbHRhLkZ1bmN0aW9uQ2FsbDtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICAgICAqL1xuICAgICAgcm9sZT86IENoYXRDb21wbGV0aW9uUm9sZTtcbiAgICB9XG5cbiAgICBleHBvcnQgbmFtZXNwYWNlIERlbHRhIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgICAgICogbW9kZWwuXG4gICAgICAgKi9cbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICAgICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgICAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSBjaGF0IGNvbXBsZXRpb24gbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIHJvbGU6IENoYXRDb21wbGV0aW9uUm9sZTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgKiBtb2RlbC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuRnVuY3Rpb25DYWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGwge1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBtZXNzYWdlLiBgY29udGVudGAgaXMgcmVxdWlyZWQgZm9yIGFsbCBtZXNzYWdlcywgYW5kIG1heSBiZVxuICAgKiBudWxsIGZvciBhc3Npc3RhbnQgbWVzc2FnZXMgd2l0aCBmdW5jdGlvbiBjYWxscy5cbiAgICovXG4gIGNvbnRlbnQ6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBtZXNzYWdlcyBhdXRob3IuIE9uZSBvZiBgc3lzdGVtYCwgYHVzZXJgLCBgYXNzaXN0YW50YCwgb3JcbiAgICogYGZ1bmN0aW9uYC5cbiAgICovXG4gIHJvbGU6ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAnZnVuY3Rpb24nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtLkZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuIGBuYW1lYCBpcyByZXF1aXJlZCBpZiByb2xlIGlzXG4gICAqIGBmdW5jdGlvbmAsIGFuZCBpdCBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHdob3NlIHJlc3BvbnNlIGlzIGluIHRoZVxuICAgKiBgY29udGVudGAuIE1heSBjb250YWluIGEteiwgQS1aLCAwLTksIGFuZCB1bmRlcnNjb3Jlcywgd2l0aCBhIG1heGltdW0gbGVuZ3RoIG9mXG4gICAqIDY0IGNoYXJhY3RlcnMuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uTWVzc2FnZVBhcmFtIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGVcbiAgICogbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbCB7XG4gICAgLyoqXG4gICAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXJndW1lbnRzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25Sb2xlID0gJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICdmdW5jdGlvbic7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICovXG5leHBvcnQgdHlwZSBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlID0gQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW07XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID1cbiAgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZ1xuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgbWVzc2FnZXMgY29tcHJpc2luZyB0aGUgY29udmVyc2F0aW9uIHNvIGZhci5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLWNvb2tib29rL2Jsb2IvbWFpbi9leGFtcGxlcy9Ib3dfdG9fZm9ybWF0X2lucHV0c190b19DaGF0R1BUX21vZGVscy5pcHluYikuXG4gICAqL1xuICBtZXNzYWdlczogQXJyYXk8Q2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBTZWUgdGhlXG4gICAqIFttb2RlbCBlbmRwb2ludCBjb21wYXRpYmlsaXR5XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvbW9kZWwtZW5kcG9pbnQtY29tcGF0aWJpbGl0eSlcbiAgICogdGFibGUgZm9yIGRldGFpbHMgb24gd2hpY2ggbW9kZWxzIHdvcmsgd2l0aCB0aGUgQ2hhdCBBUEkuXG4gICAqL1xuICBtb2RlbDpcbiAgICB8IChzdHJpbmcgJiB7fSlcbiAgICB8ICdncHQtNCdcbiAgICB8ICdncHQtNC0wMzE0J1xuICAgIHwgJ2dwdC00LTA2MTMnXG4gICAgfCAnZ3B0LTQtMzJrJ1xuICAgIHwgJ2dwdC00LTMyay0wMzE0J1xuICAgIHwgJ2dwdC00LTMyay0wNjEzJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8nXG4gICAgfCAnZ3B0LTMuNS10dXJiby0xNmsnXG4gICAgfCAnZ3B0LTMuNS10dXJiby0wMzAxJ1xuICAgIHwgJ2dwdC0zLjUtdHVyYm8tMDYxMydcbiAgICB8ICdncHQtMy41LXR1cmJvLTE2ay0wNjEzJztcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvbiB0aGVpclxuICAgKiBleGlzdGluZyBmcmVxdWVuY3kgaW4gdGhlIHRleHQgc28gZmFyLCBkZWNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogcmVwZWF0IHRoZSBzYW1lIGxpbmUgdmVyYmF0aW0uXG4gICAqXG4gICAqIFtTZWUgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBmcmVxdWVuY3kgYW5kIHByZXNlbmNlIHBlbmFsdGllcy5dKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9ncHQvcGFyYW1ldGVyLWRldGFpbHMpXG4gICAqL1xuICBmcmVxdWVuY3lfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgbW9kZWwgcmVzcG9uZHMgdG8gZnVuY3Rpb24gY2FsbHMuIGBub25lYCBtZWFucyB0aGUgbW9kZWwgZG9lc1xuICAgKiBub3QgY2FsbCBhIGZ1bmN0aW9uLCBhbmQgcmVzcG9uZHMgdG8gdGhlIGVuZC11c2VyLiBgYXV0b2AgbWVhbnMgdGhlIG1vZGVsIGNhblxuICAgKiBwaWNrIGJldHdlZW4gYW4gZW5kLXVzZXIgb3IgY2FsbGluZyBhIGZ1bmN0aW9uLiBTcGVjaWZ5aW5nIGEgcGFydGljdWxhciBmdW5jdGlvblxuICAgKiB2aWEgYHtcIm5hbWVcIjogXCJteV9mdW5jdGlvblwifWAgZm9yY2VzIHRoZSBtb2RlbCB0byBjYWxsIHRoYXQgZnVuY3Rpb24uIGBub25lYCBpc1xuICAgKiB0aGUgZGVmYXVsdCB3aGVuIG5vIGZ1bmN0aW9ucyBhcmUgcHJlc2VudC4gYGF1dG9gIGlzIHRoZSBkZWZhdWx0IGlmIGZ1bmN0aW9uc1xuICAgKiBhcmUgcHJlc2VudC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiAnbm9uZScgfCAnYXV0bycgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbkNhbGxPcHRpb247XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBmdW5jdGlvbnMgdGhlIG1vZGVsIG1heSBnZW5lcmF0ZSBKU09OIGlucHV0cyBmb3IuXG4gICAqL1xuICBmdW5jdGlvbnM/OiBBcnJheTxDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5GdW5jdGlvbj47XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgbGlrZWxpaG9vZCBvZiBzcGVjaWZpZWQgdG9rZW5zIGFwcGVhcmluZyBpbiB0aGUgY29tcGxldGlvbi5cbiAgICpcbiAgICogQWNjZXB0cyBhIGpzb24gb2JqZWN0IHRoYXQgbWFwcyB0b2tlbnMgKHNwZWNpZmllZCBieSB0aGVpciB0b2tlbiBJRCBpbiB0aGVcbiAgICogdG9rZW5pemVyKSB0byBhbiBhc3NvY2lhdGVkIGJpYXMgdmFsdWUgZnJvbSAtMTAwIHRvIDEwMC4gTWF0aGVtYXRpY2FsbHksIHRoZVxuICAgKiBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0byBzYW1wbGluZy4gVGhlIGV4YWN0XG4gICAqIGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLCBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDEgc2hvdWxkIGRlY3JlYXNlIG9yXG4gICAqIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uOyB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMCBzaG91bGQgcmVzdWx0IGluIGEgYmFuXG4gICAqIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlIHJlbGV2YW50IHRva2VuLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgW3Rva2Vuc10oL3Rva2VuaXplcikgdG8gZ2VuZXJhdGUgaW4gdGhlIGNoYXQgY29tcGxldGlvbi5cbiAgICpcbiAgICogVGhlIHRvdGFsIGxlbmd0aCBvZiBpbnB1dCB0b2tlbnMgYW5kIGdlbmVyYXRlZCB0b2tlbnMgaXMgbGltaXRlZCBieSB0aGUgbW9kZWwnc1xuICAgKiBjb250ZXh0IGxlbmd0aC5cbiAgICogW0V4YW1wbGUgUHl0aG9uIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLWNvb2tib29rL2Jsb2IvbWFpbi9leGFtcGxlcy9Ib3dfdG9fY291bnRfdG9rZW5zX3dpdGhfdGlrdG9rZW4uaXB5bmIpXG4gICAqIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAqL1xuICBtYXhfdG9rZW5zPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSG93IG1hbnkgY2hhdCBjb21wbGV0aW9uIGNob2ljZXMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggaW5wdXQgbWVzc2FnZS5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAtMi4wIGFuZCAyLjAuIFBvc2l0aXZlIHZhbHVlcyBwZW5hbGl6ZSBuZXcgdG9rZW5zIGJhc2VkIG9uXG4gICAqIHdoZXRoZXIgdGhleSBhcHBlYXIgaW4gdGhlIHRleHQgc28gZmFyLCBpbmNyZWFzaW5nIHRoZSBtb2RlbCdzIGxpa2VsaWhvb2QgdG9cbiAgICogdGFsayBhYm91dCBuZXcgdG9waWNzLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZ3B0L3BhcmFtZXRlci1kZXRhaWxzKVxuICAgKi9cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzL2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIHtcbiAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGxPcHRpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQuIE11c3QgYmUgYS16LCBBLVosIDAtOSwgb3IgY29udGFpblxuICAgICAqIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMsIHdpdGggYSBtYXhpbXVtIGxlbmd0aCBvZiA2NC5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyYW1ldGVycyB0aGUgZnVuY3Rpb25zIGFjY2VwdHMsIGRlc2NyaWJlZCBhcyBhIEpTT04gU2NoZW1hIG9iamVjdC4gU2VlIHRoZVxuICAgICAqIFtndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2dwdC9mdW5jdGlvbi1jYWxsaW5nKSBmb3JcbiAgICAgKiBleGFtcGxlcywgYW5kIHRoZVxuICAgICAqIFtKU09OIFNjaGVtYSByZWZlcmVuY2VdKGh0dHBzOi8vanNvbi1zY2hlbWEub3JnL3VuZGVyc3RhbmRpbmctanNvbi1zY2hlbWEvKSBmb3JcbiAgICAgKiBkb2N1bWVudGF0aW9uIGFib3V0IHRoZSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBUbyBkZXNjcmliZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBubyBwYXJhbWV0ZXJzLCBwcm92aWRlIHRoZSB2YWx1ZVxuICAgICAqIGB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwicHJvcGVydGllc1wiOiB7fX1gLlxuICAgICAqL1xuICAgIHBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBmdW5jdGlvbiBkb2VzLCB1c2VkIGJ5IHRoZSBtb2RlbCB0byBjaG9vc2Ugd2hlbiBhbmRcbiAgICAgKiBob3cgdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgdHlwZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IEFQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IHR5cGUgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW0/OiBmYWxzZSB8IG51bGw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElmIHNldCwgcGFydGlhbCBtZXNzYWdlIGRlbHRhcyB3aWxsIGJlIHNlbnQsIGxpa2UgaW4gQ2hhdEdQVC4gVG9rZW5zIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbiA9IEFQSS5DaGF0Q29tcGxldGlvbjtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbkNodW5rID0gQVBJLkNoYXRDb21wbGV0aW9uQ2h1bms7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25NZXNzYWdlID0gQVBJLkNoYXRDb21wbGV0aW9uTWVzc2FnZTtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbSA9IEFQSS5DaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbTtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvblJvbGUgPSBBUEkuQ2hhdENvbXBsZXRpb25Sb2xlO1xuICBleHBvcnQgaW1wb3J0IENyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2UgPSBBUEkuQ3JlYXRlQ2hhdENvbXBsZXRpb25SZXF1ZXN0TWVzc2FnZTtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZVwiO1xuaW1wb3J0IHsgQ29tcGxldGlvbnMgfSBmcm9tICcuL2NvbXBsZXRpb25zJztcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIENoYXQgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIGNvbXBsZXRpb25zOiBDb21wbGV0aW9ucyA9IG5ldyBDb21wbGV0aW9ucyh0aGlzLmNsaWVudCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdCB7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBBUEkuQ29tcGxldGlvbnM7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb24gPSBBUEkuQ2hhdENvbXBsZXRpb247XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25DaHVuayA9IEFQSS5DaGF0Q29tcGxldGlvbkNodW5rO1xuICBleHBvcnQgaW1wb3J0IENoYXRDb21wbGV0aW9uTWVzc2FnZSA9IEFQSS5DaGF0Q29tcGxldGlvbk1lc3NhZ2U7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gPSBBUEkuQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW07XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25Sb2xlID0gQVBJLkNoYXRDb21wbGV0aW9uUm9sZTtcbiAgZXhwb3J0IGltcG9ydCBDcmVhdGVDaGF0Q29tcGxldGlvblJlcXVlc3RNZXNzYWdlID0gQVBJLkNyZWF0ZUNoYXRDb21wbGV0aW9uUmVxdWVzdE1lc3NhZ2U7XG4gIGV4cG9ydCBpbXBvcnQgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBBUEkuQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkNoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IEFQSS5DaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmc7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUHJvbWlzZSB9IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSBcIi4uL3N0cmVhbWluZ1wiO1xuXG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcGxldGlvbiBmb3IgdGhlIHByb3ZpZGVkIHByb21wdCBhbmQgcGFyYW1ldGVycy5cbiAgICovXG4gIGNyZWF0ZShib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IEFQSVByb21pc2U8Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08Q29tcGxldGlvbj4gfCBDb21wbGV0aW9uPjtcbiAgY3JlYXRlKFxuICAgIGJvZHk6IENvbXBsZXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8Q29tcGxldGlvbj4gfCBBUElQcm9taXNlPFN0cmVhbTxDb21wbGV0aW9uPj4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBBUElQcm9taXNlPENvbXBsZXRpb24+XG4gICAgICB8IEFQSVByb21pc2U8U3RyZWFtPENvbXBsZXRpb24+PjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wbGV0aW9uIHJlc3BvbnNlIGZyb20gdGhlIEFQSS4gTm90ZTogYm90aCB0aGUgc3RyZWFtZWQgYW5kXG4gKiBub24tc3RyZWFtZWQgcmVzcG9uc2Ugb2JqZWN0cyBzaGFyZSB0aGUgc2FtZSBzaGFwZSAodW5saWtlIHRoZSBjaGF0IGVuZHBvaW50KS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY29tcGxldGlvbiBjaG9pY2VzIHRoZSBtb2RlbCBnZW5lcmF0ZWQgZm9yIHRoZSBpbnB1dCBwcm9tcHQuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDb21wbGV0aW9uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBvZiB3aGVuIHRoZSBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwidGV4dF9jb21wbGV0aW9uXCJcbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U/OiBDb21wbGV0aW9uVXNhZ2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgb3IgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgKiBjb250ZW50IHdhcyBvbWl0dGVkIGR1ZSB0byBhIGZsYWcgZnJvbSBvdXIgY29udGVudCBmaWx0ZXJzLlxuICAgKi9cbiAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCcgfCAnY29udGVudF9maWx0ZXInO1xuXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgbG9ncHJvYnM6IENvbXBsZXRpb25DaG9pY2UuTG9ncHJvYnMgfCBudWxsO1xuXG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBDb21wbGV0aW9uQ2hvaWNlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgdGV4dF9vZmZzZXQ/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgdG9rZW5fbG9ncHJvYnM/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgdG9rZW5zPzogQXJyYXk8c3RyaW5nPjtcblxuICAgIHRvcF9sb2dwcm9icz86IEFycmF5PFJlY29yZDxzdHJpbmcsIG51bWJlcj4+O1xuICB9XG59XG5cbi8qKlxuICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uVXNhZ2Uge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2VuZXJhdGVkIGNvbXBsZXRpb24uXG4gICAqL1xuICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcmVxdWVzdCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAqL1xuICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyA9IENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIElEIG9mIHRoZSBtb2RlbCB0byB1c2UuIFlvdSBjYW4gdXNlIHRoZVxuICAgKiBbTGlzdCBtb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvbW9kZWxzL2xpc3QpIEFQSSB0b1xuICAgKiBzZWUgYWxsIG9mIHlvdXIgYXZhaWxhYmxlIG1vZGVscywgb3Igc2VlIG91clxuICAgKiBbTW9kZWwgb3ZlcnZpZXddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscy9vdmVydmlldykgZm9yXG4gICAqIGRlc2NyaXB0aW9ucyBvZiB0aGVtLlxuICAgKi9cbiAgbW9kZWw6XG4gICAgfCAoc3RyaW5nICYge30pXG4gICAgfCAnYmFiYmFnZS0wMDInXG4gICAgfCAnZGF2aW5jaS0wMDInXG4gICAgfCAnZ3B0LTMuNS10dXJiby1pbnN0cnVjdCdcbiAgICB8ICd0ZXh0LWRhdmluY2ktMDAzJ1xuICAgIHwgJ3RleHQtZGF2aW5jaS0wMDInXG4gICAgfCAndGV4dC1kYXZpbmNpLTAwMSdcbiAgICB8ICdjb2RlLWRhdmluY2ktMDAyJ1xuICAgIHwgJ3RleHQtY3VyaWUtMDAxJ1xuICAgIHwgJ3RleHQtYmFiYmFnZS0wMDEnXG4gICAgfCAndGV4dC1hZGEtMDAxJztcblxuICAvKipcbiAgICogVGhlIHByb21wdChzKSB0byBnZW5lcmF0ZSBjb21wbGV0aW9ucyBmb3IsIGVuY29kZWQgYXMgYSBzdHJpbmcsIGFycmF5IG9mXG4gICAqIHN0cmluZ3MsIGFycmF5IG9mIHRva2Vucywgb3IgYXJyYXkgb2YgdG9rZW4gYXJyYXlzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgPHxlbmRvZnRleHR8PiBpcyB0aGUgZG9jdW1lbnQgc2VwYXJhdG9yIHRoYXQgdGhlIG1vZGVsIHNlZXMgZHVyaW5nXG4gICAqIHRyYWluaW5nLCBzbyBpZiBhIHByb21wdCBpcyBub3Qgc3BlY2lmaWVkIHRoZSBtb2RlbCB3aWxsIGdlbmVyYXRlIGFzIGlmIGZyb20gdGhlXG4gICAqIGJlZ2lubmluZyBvZiBhIG5ldyBkb2N1bWVudC5cbiAgICovXG4gIHByb21wdDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IEFycmF5PG51bWJlcj4gfCBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBgYmVzdF9vZmAgY29tcGxldGlvbnMgc2VydmVyLXNpZGUgYW5kIHJldHVybnMgdGhlIFwiYmVzdFwiICh0aGUgb25lIHdpdGhcbiAgICogdGhlIGhpZ2hlc3QgbG9nIHByb2JhYmlsaXR5IHBlciB0b2tlbikuIFJlc3VsdHMgY2Fubm90IGJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBXaGVuIHVzZWQgd2l0aCBgbmAsIGBiZXN0X29mYCBjb250cm9scyB0aGUgbnVtYmVyIG9mIGNhbmRpZGF0ZSBjb21wbGV0aW9ucyBhbmRcbiAgICogYG5gIHNwZWNpZmllcyBob3cgbWFueSB0byByZXR1cm4gXHUyMDEzIGBiZXN0X29mYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgbmAuXG4gICAqXG4gICAqICoqTm90ZToqKiBCZWNhdXNlIHRoaXMgcGFyYW1ldGVyIGdlbmVyYXRlcyBtYW55IGNvbXBsZXRpb25zLCBpdCBjYW4gcXVpY2tseVxuICAgKiBjb25zdW1lIHlvdXIgdG9rZW4gcXVvdGEuIFVzZSBjYXJlZnVsbHkgYW5kIGVuc3VyZSB0aGF0IHlvdSBoYXZlIHJlYXNvbmFibGVcbiAgICogc2V0dGluZ3MgZm9yIGBtYXhfdG9rZW5zYCBhbmQgYHN0b3BgLlxuICAgKi9cbiAgYmVzdF9vZj86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVjaG8gYmFjayB0aGUgcHJvbXB0IGluIGFkZGl0aW9uIHRvIHRoZSBjb21wbGV0aW9uXG4gICAqL1xuICBlY2hvPzogYm9vbGVhbiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE51bWJlciBiZXR3ZWVuIC0yLjAgYW5kIDIuMC4gUG9zaXRpdmUgdmFsdWVzIHBlbmFsaXplIG5ldyB0b2tlbnMgYmFzZWQgb24gdGhlaXJcbiAgICogZXhpc3RpbmcgZnJlcXVlbmN5IGluIHRoZSB0ZXh0IHNvIGZhciwgZGVjcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHJlcGVhdCB0aGUgc2FtZSBsaW5lIHZlcmJhdGltLlxuICAgKlxuICAgKiBbU2VlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZnJlcXVlbmN5IGFuZCBwcmVzZW5jZSBwZW5hbHRpZXMuXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZ3B0L3BhcmFtZXRlci1kZXRhaWxzKVxuICAgKi9cbiAgZnJlcXVlbmN5X3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpa2VsaWhvb2Qgb2Ygc3BlY2lmaWVkIHRva2VucyBhcHBlYXJpbmcgaW4gdGhlIGNvbXBsZXRpb24uXG4gICAqXG4gICAqIEFjY2VwdHMgYSBqc29uIG9iamVjdCB0aGF0IG1hcHMgdG9rZW5zIChzcGVjaWZpZWQgYnkgdGhlaXIgdG9rZW4gSUQgaW4gdGhlIEdQVFxuICAgKiB0b2tlbml6ZXIpIHRvIGFuIGFzc29jaWF0ZWQgYmlhcyB2YWx1ZSBmcm9tIC0xMDAgdG8gMTAwLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAqIFt0b2tlbml6ZXIgdG9vbF0oL3Rva2VuaXplcj92aWV3PWJwZSkgKHdoaWNoIHdvcmtzIGZvciBib3RoIEdQVC0yIGFuZCBHUFQtMykgdG9cbiAgICogY29udmVydCB0ZXh0IHRvIHRva2VuIElEcy4gTWF0aGVtYXRpY2FsbHksIHRoZSBiaWFzIGlzIGFkZGVkIHRvIHRoZSBsb2dpdHNcbiAgICogZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBwcmlvciB0byBzYW1wbGluZy4gVGhlIGV4YWN0IGVmZmVjdCB3aWxsIHZhcnkgcGVyIG1vZGVsLFxuICAgKiBidXQgdmFsdWVzIGJldHdlZW4gLTEgYW5kIDEgc2hvdWxkIGRlY3JlYXNlIG9yIGluY3JlYXNlIGxpa2VsaWhvb2Qgb2Ygc2VsZWN0aW9uO1xuICAgKiB2YWx1ZXMgbGlrZSAtMTAwIG9yIDEwMCBzaG91bGQgcmVzdWx0IGluIGEgYmFuIG9yIGV4Y2x1c2l2ZSBzZWxlY3Rpb24gb2YgdGhlXG4gICAqIHJlbGV2YW50IHRva2VuLlxuICAgKlxuICAgKiBBcyBhbiBleGFtcGxlLCB5b3UgY2FuIHBhc3MgYHtcIjUwMjU2XCI6IC0xMDB9YCB0byBwcmV2ZW50IHRoZSA8fGVuZG9mdGV4dHw+IHRva2VuXG4gICAqIGZyb20gYmVpbmcgZ2VuZXJhdGVkLlxuICAgKi9cbiAgbG9naXRfYmlhcz86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHRoZSBsb2cgcHJvYmFiaWxpdGllcyBvbiB0aGUgYGxvZ3Byb2JzYCBtb3N0IGxpa2VseSB0b2tlbnMsIGFzIHdlbGwgdGhlXG4gICAqIGNob3NlbiB0b2tlbnMuIEZvciBleGFtcGxlLCBpZiBgbG9ncHJvYnNgIGlzIDUsIHRoZSBBUEkgd2lsbCByZXR1cm4gYSBsaXN0IG9mXG4gICAqIHRoZSA1IG1vc3QgbGlrZWx5IHRva2Vucy4gVGhlIEFQSSB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIGBsb2dwcm9iYCBvZiB0aGVcbiAgICogc2FtcGxlZCB0b2tlbiwgc28gdGhlcmUgbWF5IGJlIHVwIHRvIGBsb2dwcm9icysxYCBlbGVtZW50cyBpbiB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBgbG9ncHJvYnNgIGlzIDUuXG4gICAqL1xuICBsb2dwcm9icz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBbdG9rZW5zXSgvdG9rZW5pemVyKSB0byBnZW5lcmF0ZSBpbiB0aGUgY29tcGxldGlvbi5cbiAgICpcbiAgICogVGhlIHRva2VuIGNvdW50IG9mIHlvdXIgcHJvbXB0IHBsdXMgYG1heF90b2tlbnNgIGNhbm5vdCBleGNlZWQgdGhlIG1vZGVsJ3NcbiAgICogY29udGV4dCBsZW5ndGguXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX2NvdW50X3Rva2Vuc193aXRoX3Rpa3Rva2VuLmlweW5iKVxuICAgKiBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgKi9cbiAgbWF4X3Rva2Vucz86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IGNvbXBsZXRpb25zIHRvIGdlbmVyYXRlIGZvciBlYWNoIHByb21wdC5cbiAgICpcbiAgICogKipOb3RlOioqIEJlY2F1c2UgdGhpcyBwYXJhbWV0ZXIgZ2VuZXJhdGVzIG1hbnkgY29tcGxldGlvbnMsIGl0IGNhbiBxdWlja2x5XG4gICAqIGNvbnN1bWUgeW91ciB0b2tlbiBxdW90YS4gVXNlIGNhcmVmdWxseSBhbmQgZW5zdXJlIHRoYXQgeW91IGhhdmUgcmVhc29uYWJsZVxuICAgKiBzZXR0aW5ncyBmb3IgYG1heF90b2tlbnNgIGFuZCBgc3RvcGAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gLTIuMCBhbmQgMi4wLiBQb3NpdGl2ZSB2YWx1ZXMgcGVuYWxpemUgbmV3IHRva2VucyBiYXNlZCBvblxuICAgKiB3aGV0aGVyIHRoZXkgYXBwZWFyIGluIHRoZSB0ZXh0IHNvIGZhciwgaW5jcmVhc2luZyB0aGUgbW9kZWwncyBsaWtlbGlob29kIHRvXG4gICAqIHRhbGsgYWJvdXQgbmV3IHRvcGljcy5cbiAgICpcbiAgICogW1NlZSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGZyZXF1ZW5jeSBhbmQgcHJlc2VuY2UgcGVuYWx0aWVzLl0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2dwdC9wYXJhbWV0ZXItZGV0YWlscylcbiAgICovXG4gIHByZXNlbmNlX3BlbmFsdHk/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBVcCB0byA0IHNlcXVlbmNlcyB3aGVyZSB0aGUgQVBJIHdpbGwgc3RvcCBnZW5lcmF0aW5nIGZ1cnRoZXIgdG9rZW5zLiBUaGVcbiAgICogcmV0dXJuZWQgdGV4dCB3aWxsIG5vdCBjb250YWluIHRoZSBzdG9wIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RvcD86IHN0cmluZyB8IG51bGwgfCBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN1ZmZpeCB0aGF0IGNvbWVzIGFmdGVyIGEgY29tcGxldGlvbiBvZiBpbnNlcnRlZCB0ZXh0LlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogV2hhdCBzYW1wbGluZyB0ZW1wZXJhdHVyZSB0byB1c2UsIGJldHdlZW4gMCBhbmQgMi4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsXG4gICAqIG1ha2UgdGhlIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlXG4gICAqIGZvY3VzZWQgYW5kIGRldGVybWluaXN0aWMuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdG9wX3BgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogQW4gYWx0ZXJuYXRpdmUgdG8gc2FtcGxpbmcgd2l0aCB0ZW1wZXJhdHVyZSwgY2FsbGVkIG51Y2xldXMgc2FtcGxpbmcsIHdoZXJlIHRoZVxuICAgKiBtb2RlbCBjb25zaWRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHRva2VucyB3aXRoIHRvcF9wIHByb2JhYmlsaXR5IG1hc3MuIFNvIDAuMVxuICAgKiBtZWFucyBvbmx5IHRoZSB0b2tlbnMgY29tcHJpc2luZyB0aGUgdG9wIDEwJSBwcm9iYWJpbGl0eSBtYXNzIGFyZSBjb25zaWRlcmVkLlxuICAgKlxuICAgKiBXZSBnZW5lcmFsbHkgcmVjb21tZW5kIGFsdGVyaW5nIHRoaXMgb3IgYHRlbXBlcmF0dXJlYCBidXQgbm90IGJvdGguXG4gICAqL1xuICB0b3BfcD86IG51bWJlciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIHlvdXIgZW5kLXVzZXIsIHdoaWNoIGNhbiBoZWxwIE9wZW5BSSB0byBtb25pdG9yXG4gICAqIGFuZCBkZXRlY3QgYWJ1c2UuXG4gICAqIFtMZWFybiBtb3JlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvc2FmZXR5LWJlc3QtcHJhY3RpY2VzL2VuZC11c2VyLWlkcykuXG4gICAqL1xuICB1c2VyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXMge1xuICBleHBvcnQgdHlwZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICAvKipcbiAgICogV2hldGhlciB0byBzdHJlYW0gYmFjayBwYXJ0aWFsIHByb2dyZXNzLiBJZiBzZXQsIHRva2VucyB3aWxsIGJlIHNlbnQgYXNcbiAgICogZGF0YS1vbmx5XG4gICAqIFtzZXJ2ZXItc2VudCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2ZXItc2VudF9ldmVudHMvVXNpbmdfc2VydmVyLXNlbnRfZXZlbnRzI0V2ZW50X3N0cmVhbV9mb3JtYXQpXG4gICAqIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSwgd2l0aCB0aGUgc3RyZWFtIHRlcm1pbmF0ZWQgYnkgYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktY29va2Jvb2svYmxvYi9tYWluL2V4YW1wbGVzL0hvd190b19zdHJlYW1fY29tcGxldGlvbnMuaXB5bmIpLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBiYWNrIHBhcnRpYWwgcHJvZ3Jlc3MuIElmIHNldCwgdG9rZW5zIHdpbGwgYmUgc2VudCBhc1xuICAgKiBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLCB3aXRoIHRoZSBzdHJlYW0gdGVybWluYXRlZCBieSBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2UuXG4gICAqIFtFeGFtcGxlIFB5dGhvbiBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1jb29rYm9vay9ibG9iL21haW4vZXhhbXBsZXMvSG93X3RvX3N0cmVhbV9jb21wbGV0aW9ucy5pcHluYikuXG4gICAqL1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29tcGxldGlvbnMge1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb24gPSBBUEkuQ29tcGxldGlvbjtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ2hvaWNlID0gQVBJLkNvbXBsZXRpb25DaG9pY2U7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvblVzYWdlID0gQVBJLkNvbXBsZXRpb25Vc2FnZTtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgRW1iZWRkaW5ncyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1iZWRkaW5nIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogRW1iZWRkaW5nQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8Q3JlYXRlRW1iZWRkaW5nUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvZW1iZWRkaW5ncycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUVtYmVkZGluZ1Jlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGVtYmVkZGluZ3MgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbC5cbiAgICovXG4gIGRhdGE6IEFycmF5PEVtYmVkZGluZz47XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBlbWJlZGRpbmcuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImVtYmVkZGluZ1wiLlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB1c2FnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZTogQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2UuVXNhZ2U7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ3JlYXRlRW1iZWRkaW5nUmVzcG9uc2Uge1xuICAvKipcbiAgICogVGhlIHVzYWdlIGluZm9ybWF0aW9uIGZvciB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVXNhZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgYnkgdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGJ5IHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJldHVybmVkIGJ5IGVtYmVkZGluZyBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmcge1xuICAvKipcbiAgICogVGhlIGVtYmVkZGluZyB2ZWN0b3IsIHdoaWNoIGlzIGEgbGlzdCBvZiBmbG9hdHMuIFRoZSBsZW5ndGggb2YgdmVjdG9yIGRlcGVuZHMgb25cbiAgICogdGhlIG1vZGVsIGFzIGxpc3RlZCBpbiB0aGVcbiAgICogW2VtYmVkZGluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2VtYmVkZGluZ3MpLlxuICAgKi9cbiAgZW1iZWRkaW5nOiBBcnJheTxudW1iZXI+O1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGVtYmVkZGluZyBpbiB0aGUgbGlzdCBvZiBlbWJlZGRpbmdzLlxuICAgKi9cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJlbWJlZGRpbmdcIi5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBJbnB1dCB0ZXh0IHRvIGVtYmVkLCBlbmNvZGVkIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHRva2Vucy4gVG8gZW1iZWQgbXVsdGlwbGVcbiAgICogaW5wdXRzIGluIGEgc2luZ2xlIHJlcXVlc3QsIHBhc3MgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBhcnJheSBvZiB0b2tlbiBhcnJheXMuXG4gICAqIEVhY2ggaW5wdXQgbXVzdCBub3QgZXhjZWVkIHRoZSBtYXggaW5wdXQgdG9rZW5zIGZvciB0aGUgbW9kZWwgKDgxOTEgdG9rZW5zIGZvclxuICAgKiBgdGV4dC1lbWJlZGRpbmctYWRhLTAwMmApIGFuZCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgKiBbRXhhbXBsZSBQeXRob24gY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktY29va2Jvb2svYmxvYi9tYWluL2V4YW1wbGVzL0hvd190b19jb3VudF90b2tlbnNfd2l0aF90aWt0b2tlbi5pcHluYilcbiAgICogZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgQXJyYXk8bnVtYmVyPiB8IEFycmF5PEFycmF5PG51bWJlcj4+O1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBZb3UgY2FuIHVzZSB0aGVcbiAgICogW0xpc3QgbW9kZWxzXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL21vZGVscy9saXN0KSBBUEkgdG9cbiAgICogc2VlIGFsbCBvZiB5b3VyIGF2YWlsYWJsZSBtb2RlbHMsIG9yIHNlZSBvdXJcbiAgICogW01vZGVsIG92ZXJ2aWV3XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9tb2RlbHMvb3ZlcnZpZXcpIGZvclxuICAgKiBkZXNjcmlwdGlvbnMgb2YgdGhlbS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcy9lbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFbWJlZGRpbmdzIHtcbiAgZXhwb3J0IGltcG9ydCBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSA9IEFQSS5DcmVhdGVFbWJlZGRpbmdSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBFbWJlZGRpbmcgPSBBUEkuRW1iZWRkaW5nO1xuICBleHBvcnQgaW1wb3J0IEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyA9IEFQSS5FbWJlZGRpbmdDcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zIGZyb20gXCIuL2NvbXBsZXRpb25zXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBFZGl0cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZWRpdCBmb3IgdGhlIHByb3ZpZGVkIGlucHV0LCBpbnN0cnVjdGlvbiwgYW5kIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBFZGl0cyBBUEkgaXMgZGVwcmVjYXRlZDsgcGxlYXNlIHVzZSBDaGF0IENvbXBsZXRpb25zIGluc3RlYWQuXG4gICAqXG4gICAqIGh0dHBzOi8vb3BlbmFpLmNvbS9ibG9nL2dwdC00LWFwaS1nZW5lcmFsLWF2YWlsYWJpbGl0eSNkZXByZWNhdGlvbi1vZi10aGUtZWRpdHMtYXBpXG4gICAqL1xuICBjcmVhdGUoYm9keTogRWRpdENyZWF0ZVBhcmFtcywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RWRpdD4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9lZGl0cycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXQge1xuICAvKipcbiAgICogQSBsaXN0IG9mIGVkaXQgY2hvaWNlcy4gQ2FuIGJlIG1vcmUgdGhhbiBvbmUgaWYgYG5gIGlzIGdyZWF0ZXIgdGhhbiAxLlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8RWRpdC5DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIG9mIHdoZW4gdGhlIGVkaXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIGBlZGl0YC5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U6IENvbXBsZXRpb25zLkNvbXBsZXRpb25Vc2FnZTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFZGl0IHtcbiAgZXhwb3J0IGludGVyZmFjZSBDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZCwgb3IgYGNvbnRlbnRfZmlsdGVyYCBpZlxuICAgICAqIGNvbnRlbnQgd2FzIG9taXR0ZWQgZHVlIHRvIGEgZmxhZyBmcm9tIG91ciBjb250ZW50IGZpbHRlcnMuXG4gICAgICovXG4gICAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNob2ljZSBpbiB0aGUgbGlzdCBvZiBjaG9pY2VzLlxuICAgICAqL1xuICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0ZXh0OiBzdHJpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFZGl0Q3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBpbnN0cnVjdGlvbiB0aGF0IHRlbGxzIHRoZSBtb2RlbCBob3cgdG8gZWRpdCB0aGUgcHJvbXB0LlxuICAgKi9cbiAgaW5zdHJ1Y3Rpb246IHN0cmluZztcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gWW91IGNhbiB1c2UgdGhlIGB0ZXh0LWRhdmluY2ktZWRpdC0wMDFgIG9yXG4gICAqIGBjb2RlLWRhdmluY2ktZWRpdC0wMDFgIG1vZGVsIHdpdGggdGhpcyBlbmRwb2ludC5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3RleHQtZGF2aW5jaS1lZGl0LTAwMScgfCAnY29kZS1kYXZpbmNpLWVkaXQtMDAxJztcblxuICAvKipcbiAgICogVGhlIGlucHV0IHRleHQgdG8gdXNlIGFzIGEgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBlZGl0LlxuICAgKi9cbiAgaW5wdXQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBlZGl0cyB0byBnZW5lcmF0ZSBmb3IgdGhlIGlucHV0IGFuZCBpbnN0cnVjdGlvbi5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGF0IHNhbXBsaW5nIHRlbXBlcmF0dXJlIHRvIHVzZSwgYmV0d2VlbiAwIGFuZCAyLiBIaWdoZXIgdmFsdWVzIGxpa2UgMC44IHdpbGxcbiAgICogbWFrZSB0aGUgb3V0cHV0IG1vcmUgcmFuZG9tLCB3aGlsZSBsb3dlciB2YWx1ZXMgbGlrZSAwLjIgd2lsbCBtYWtlIGl0IG1vcmVcbiAgICogZm9jdXNlZCBhbmQgZGV0ZXJtaW5pc3RpYy5cbiAgICpcbiAgICogV2UgZ2VuZXJhbGx5IHJlY29tbWVuZCBhbHRlcmluZyB0aGlzIG9yIGB0b3BfcGAgYnV0IG5vdCBib3RoLlxuICAgKi9cbiAgdGVtcGVyYXR1cmU/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBzYW1wbGluZyB3aXRoIHRlbXBlcmF0dXJlLCBjYWxsZWQgbnVjbGV1cyBzYW1wbGluZywgd2hlcmUgdGhlXG4gICAqIG1vZGVsIGNvbnNpZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgdG9rZW5zIHdpdGggdG9wX3AgcHJvYmFiaWxpdHkgbWFzcy4gU28gMC4xXG4gICAqIG1lYW5zIG9ubHkgdGhlIHRva2VucyBjb21wcmlzaW5nIHRoZSB0b3AgMTAlIHByb2JhYmlsaXR5IG1hc3MgYXJlIGNvbnNpZGVyZWQuXG4gICAqXG4gICAqIFdlIGdlbmVyYWxseSByZWNvbW1lbmQgYWx0ZXJpbmcgdGhpcyBvciBgdGVtcGVyYXR1cmVgIGJ1dCBub3QgYm90aC5cbiAgICovXG4gIHRvcF9wPzogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBFZGl0cyB7XG4gIGV4cG9ydCBpbXBvcnQgRWRpdCA9IEFQSS5FZGl0O1xuICBleHBvcnQgaW1wb3J0IEVkaXRDcmVhdGVQYXJhbXMgPSBBUEkuRWRpdENyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciB9IGZyb20gXCIuLi9lcnJvclwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgdHlwZSBVcGxvYWRhYmxlLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFVwbG9hZCBhIGZpbGUgdGhhdCBjb250YWlucyBkb2N1bWVudChzKSB0byBiZSB1c2VkIGFjcm9zcyB2YXJpb3VzXG4gICAqIGVuZHBvaW50cy9mZWF0dXJlcy4gQ3VycmVudGx5LCB0aGUgc2l6ZSBvZiBhbGwgdGhlIGZpbGVzIHVwbG9hZGVkIGJ5IG9uZVxuICAgKiBvcmdhbml6YXRpb24gY2FuIGJlIHVwIHRvIDEgR0IuIFBsZWFzZSBjb250YWN0IHVzIGlmIHlvdSBuZWVkIHRvIGluY3JlYXNlIHRoZVxuICAgKiBzdG9yYWdlIGxpbWl0LlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IEZpbGVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KCcvZmlsZXMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZmlsZS5cbiAgICovXG4gIHJldHJpZXZlKGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHVzZXIncyBvcmdhbml6YXRpb24uXG4gICAqL1xuICBsaXN0KG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5QYWdlUHJvbWlzZTxGaWxlT2JqZWN0c1BhZ2UsIEZpbGVPYmplY3Q+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KCcvZmlsZXMnLCBGaWxlT2JqZWN0c1BhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbGUuXG4gICAqL1xuICBkZWwoZmlsZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbGVEZWxldGVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlKGAvZmlsZXMvJHtmaWxlSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgKi9cbiAgcmV0cmlldmVDb250ZW50KGZpbGVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBnaXZlbiBmaWxlIHRvIGJlIHByb2Nlc3NlZCwgZGVmYXVsdCB0aW1lb3V0IGlzIDMwIG1pbnMuXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yUHJvY2Vzc2luZyhcbiAgICBpZDogc3RyaW5nLFxuICAgIHsgcG9sbEludGVydmFsID0gNTAwMCwgbWF4V2FpdCA9IDMwICogNjAgKiAxMDAwIH06IHsgcG9sbEludGVydmFsPzogbnVtYmVyOyBtYXhXYWl0PzogbnVtYmVyIH0gPSB7fSxcbiAgKTogUHJvbWlzZTxGaWxlT2JqZWN0PiB7XG4gICAgY29uc3QgVEVSTUlOQUxfU1RBVEVTID0gbmV3IFNldChbJ3Byb2Nlc3NlZCcsICdlcnJvcicsICdkZWxldGVkJ10pO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBmaWxlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZShpZCk7XG5cbiAgICB3aGlsZSAoIWZpbGUuc3RhdHVzIHx8ICFURVJNSU5BTF9TVEFURVMuaGFzKGZpbGUuc3RhdHVzKSkge1xuICAgICAgYXdhaXQgc2xlZXAocG9sbEludGVydmFsKTtcblxuICAgICAgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IG1heFdhaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBHaXZpbmcgdXAgb24gd2FpdGluZyBmb3IgZmlsZSAke2lkfSB0byBmaW5pc2ggcHJvY2Vzc2luZyBhZnRlciAke21heFdhaXR9IG1pbGxpc2Vjb25kcy5gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVPYmplY3RzUGFnZSBleHRlbmRzIFBhZ2U8RmlsZU9iamVjdD4ge31cbi8vIGFsaWFzIHNvIHdlIGNhbiBleHBvcnQgaXQgaW4gdGhlIG5hbWVzcGFjZVxudHlwZSBfRmlsZU9iamVjdHNQYWdlID0gRmlsZU9iamVjdHNQYWdlO1xuXG5leHBvcnQgdHlwZSBGaWxlQ29udGVudCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBGaWxlRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGUgYEZpbGVgIG9iamVjdCByZXByZXNlbnRzIGEgZG9jdW1lbnQgdGhhdCBoYXMgYmVlbiB1cGxvYWRlZCB0byBPcGVuQUkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZU9iamVjdCB7XG4gIC8qKlxuICAgKiBUaGUgZmlsZSBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLlxuICAgKi9cbiAgYnl0ZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKSBmb3Igd2hlbiB0aGUgZmlsZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBmaWxlbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbGVcIi5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgZmlsZS4gQ3VycmVudGx5LCBvbmx5IFwiZmluZS10dW5lXCIgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgcHVycG9zZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGZpbGUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYHVwbG9hZGVkYCwgYHByb2Nlc3NlZGAsXG4gICAqIGBwZW5kaW5nYCwgYGVycm9yYCwgYGRlbGV0aW5nYCBvciBgZGVsZXRlZGAuXG4gICAqL1xuICBzdGF0dXM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgc3RhdHVzIG9mIHRoZSBmaWxlLiBJZiB0aGUgZmlsZSBpcyBpbiB0aGUgYGVycm9yYFxuICAgKiBzdGF0ZSwgdGhpcyB3aWxsIGluY2x1ZGUgYSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGVycm9yLlxuICAgKi9cbiAgc3RhdHVzX2RldGFpbHM/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgW0pTT04gTGluZXNdKGh0dHBzOi8vanNvbmxpbmVzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC8pIGZpbGUgdG8gYmVcbiAgICogdXBsb2FkZWQuXG4gICAqXG4gICAqIElmIHRoZSBgcHVycG9zZWAgaXMgc2V0IHRvIFwiZmluZS10dW5lXCIsIHRoZSBmaWxlIHdpbGwgYmUgdXNlZCBmb3IgZmluZS10dW5pbmcuXG4gICAqL1xuICBmaWxlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGUgdXBsb2FkZWQgZG9jdW1lbnRzLlxuICAgKlxuICAgKiBVc2UgXCJmaW5lLXR1bmVcIiBmb3JcbiAgICogW2ZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nKS4gVGhpc1xuICAgKiBhbGxvd3MgdXMgdG8gdmFsaWRhdGUgdGhlIGZvcm1hdCBvZiB0aGUgdXBsb2FkZWQgZmlsZS5cbiAgICovXG4gIHB1cnBvc2U6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaWxlcyB7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZUNvbnRlbnQgPSBBUEkuRmlsZUNvbnRlbnQ7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZURlbGV0ZWQgPSBBUEkuRmlsZURlbGV0ZWQ7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZU9iamVjdCA9IEFQSS5GaWxlT2JqZWN0O1xuICBleHBvcnQgdHlwZSBGaWxlT2JqZWN0c1BhZ2UgPSBfRmlsZU9iamVjdHNQYWdlO1xuICBleHBvcnQgaW1wb3J0IEZpbGVDcmVhdGVQYXJhbXMgPSBBUEkuRmlsZUNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBGaWxlcyBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uXCI7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi4vc3RyZWFtaW5nXCI7XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgam9iIHRoYXQgZmluZS10dW5lcyBhIHNwZWNpZmllZCBtb2RlbCBmcm9tIGEgZ2l2ZW4gZGF0YXNldC5cbiAgICpcbiAgICogUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZVxuICAgKiBvZiB0aGUgZmluZS10dW5lZCBtb2RlbHMgb25jZSBjb21wbGV0ZS5cbiAgICpcbiAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9sZWdhY3ktZmluZS10dW5pbmcpXG4gICAqL1xuICBjcmVhdGUoYm9keTogRmluZVR1bmVDcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5lPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ZpbmUtdHVuZXMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBpbmZvIGFib3V0IHRoZSBmaW5lLXR1bmUgam9iLlxuICAgKlxuICAgKiBbTGVhcm4gbW9yZSBhYm91dCBmaW5lLXR1bmluZ10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZylcbiAgICovXG4gIHJldHJpZXZlKGZpbmVUdW5lSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmU+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9maW5lLXR1bmVzLyR7ZmluZVR1bmVJZH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHlvdXIgb3JnYW5pemF0aW9uJ3MgZmluZS10dW5pbmcgam9ic1xuICAgKi9cbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmVzUGFnZSwgRmluZVR1bmU+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KCcvZmluZS10dW5lcycsIEZpbmVUdW5lc1BhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZmluZVR1bmVJZDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuZT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9maW5lLXR1bmVzLyR7ZmluZVR1bmVJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZpbmUtZ3JhaW5lZCBzdGF0dXMgdXBkYXRlcyBmb3IgYSBmaW5lLXR1bmUgam9iLlxuICAgKi9cbiAgbGlzdEV2ZW50cyhcbiAgICBmaW5lVHVuZUlkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IEFQSVByb21pc2U8RmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2U+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5lSWQ6IHN0cmluZyxcbiAgICBxdWVyeTogRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zU3RyZWFtaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPFN0cmVhbTxGaW5lVHVuZUV2ZW50Pj47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmVJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zQmFzZSB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQVBJUHJvbWlzZTxTdHJlYW08RmluZVR1bmVFdmVudD4gfCBGaW5lVHVuZUV2ZW50c0xpc3RSZXNwb25zZT47XG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmVJZDogc3RyaW5nLFxuICAgIHF1ZXJ5PzogRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBBUElQcm9taXNlPEZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlPiB8IEFQSVByb21pc2U8U3RyZWFtPEZpbmVUdW5lRXZlbnQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvZmluZS10dW5lcy8ke2ZpbmVUdW5lSWR9L2V2ZW50c2AsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgdGltZW91dDogODY0MDAwMDAsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc3RyZWFtOiBxdWVyeT8uc3RyZWFtID8/IGZhbHNlLFxuICAgIH0pIGFzIEFQSVByb21pc2U8RmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2U+IHwgQVBJUHJvbWlzZTxTdHJlYW08RmluZVR1bmVFdmVudD4+O1xuICB9XG59XG5cbi8qKlxuICogTm90ZTogbm8gcGFnaW5hdGlvbiBhY3R1YWxseSBvY2N1cnMgeWV0LCB0aGlzIGlzIGZvciBmb3J3YXJkcy1jb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgRmluZVR1bmVzUGFnZSBleHRlbmRzIFBhZ2U8RmluZVR1bmU+IHt9XG4vLyBhbGlhcyBzbyB3ZSBjYW4gZXhwb3J0IGl0IGluIHRoZSBuYW1lc3BhY2VcbnR5cGUgX0ZpbmVUdW5lc1BhZ2UgPSBGaW5lVHVuZXNQYWdlO1xuXG4vKipcbiAqIFRoZSBgRmluZVR1bmVgIG9iamVjdCByZXByZXNlbnRzIGEgbGVnYWN5IGZpbmUtdHVuZSBqb2IgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG4gKiB0aHJvdWdoIHRoZSBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmUge1xuICAvKipcbiAgICogVGhlIG9iamVjdCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgZm9yIHdoZW4gdGhlIGZpbmUtdHVuaW5nIGpvYiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWwgdGhhdCBpcyBiZWluZyBjcmVhdGVkLlxuICAgKi9cbiAgZmluZV90dW5lZF9tb2RlbDogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBTZWUgdGhlXG4gICAqIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9oeXBlcnBhcmFtZXRlcnMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBoeXBlcnBhcmFtczogRmluZVR1bmUuSHlwZXJwYXJhbXM7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIG1vZGVsIHRoYXQgaXMgYmVpbmcgZmluZS10dW5lZC5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwiZmluZS10dW5lXCIuXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9yZ2FuaXphdGlvbiB0aGF0IG93bnMgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIG9yZ2FuaXphdGlvbl9pZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29tcGlsZWQgcmVzdWx0cyBmaWxlcyBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIHJlc3VsdF9maWxlczogQXJyYXk8RmlsZXMuRmlsZU9iamVjdD47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZmluZS10dW5pbmcgam9iLCB3aGljaCBjYW4gYmUgZWl0aGVyIGBjcmVhdGVkYCxcbiAgICogYHJ1bm5pbmdgLCBgc3VjY2VlZGVkYCwgYGZhaWxlZGAsIG9yIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGZpbGVzIHVzZWQgZm9yIHRyYWluaW5nLlxuICAgKi9cbiAgdHJhaW5pbmdfZmlsZXM6IEFycmF5PEZpbGVzLkZpbGVPYmplY3Q+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGxhc3QgdXBkYXRlZC5cbiAgICovXG4gIHVwZGF0ZWRfYXQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZmlsZXMgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZXM6IEFycmF5PEZpbGVzLkZpbGVPYmplY3Q+O1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBldmVudHMgdGhhdCBoYXZlIGJlZW4gb2JzZXJ2ZWQgaW4gdGhlIGxpZmVjeWNsZSBvZiB0aGUgRmluZVR1bmUgam9iLlxuICAgKi9cbiAgZXZlbnRzPzogQXJyYXk8RmluZVR1bmVFdmVudD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRmluZVR1bmUge1xuICAvKipcbiAgICogVGhlIGh5cGVycGFyYW1ldGVycyB1c2VkIGZvciB0aGUgZmluZS10dW5pbmcgam9iLiBTZWUgdGhlXG4gICAqIFtmaW5lLXR1bmluZyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9oeXBlcnBhcmFtZXRlcnMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1zIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmF0Y2ggc2l6ZSB0byB1c2UgZm9yIHRyYWluaW5nLiBUaGUgYmF0Y2ggc2l6ZSBpcyB0aGUgbnVtYmVyIG9mIHRyYWluaW5nXG4gICAgICogZXhhbXBsZXMgdXNlZCB0byB0cmFpbiBhIHNpbmdsZSBmb3J3YXJkIGFuZCBiYWNrd2FyZCBwYXNzLlxuICAgICAqL1xuICAgIGJhdGNoX3NpemU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsZWFybmluZyByYXRlIG11bHRpcGxpZXIgdG8gdXNlIGZvciB0cmFpbmluZy5cbiAgICAgKi9cbiAgICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgICAqIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGFzZXQuXG4gICAgICovXG4gICAgbl9lcG9jaHM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3ZWlnaHQgdG8gdXNlIGZvciBsb3NzIG9uIHRoZSBwcm9tcHQgdG9rZW5zLlxuICAgICAqL1xuICAgIHByb21wdF9sb3NzX3dlaWdodDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjbGFzc2VzIHRvIHVzZSBmb3IgY29tcHV0aW5nIGNsYXNzaWZpY2F0aW9uIG1ldHJpY3MuXG4gICAgICovXG4gICAgY2xhc3NpZmljYXRpb25fbl9jbGFzc2VzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aXZlIGNsYXNzIHRvIHVzZSBmb3IgY29tcHV0aW5nIGNsYXNzaWZpY2F0aW9uIG1ldHJpY3MuXG4gICAgICovXG4gICAgY2xhc3NpZmljYXRpb25fcG9zaXRpdmVfY2xhc3M/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3NpZmljYXRpb24gbWV0cmljcyB0byBjb21wdXRlIHVzaW5nIHRoZSB2YWxpZGF0aW9uIGRhdGFzZXQgYXQgdGhlIGVuZCBvZlxuICAgICAqIGV2ZXJ5IGVwb2NoLlxuICAgICAqL1xuICAgIGNvbXB1dGVfY2xhc3NpZmljYXRpb25fbWV0cmljcz86IGJvb2xlYW47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuZUV2ZW50IHtcbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGxldmVsOiBzdHJpbmc7XG5cbiAgbWVzc2FnZTogc3RyaW5nO1xuXG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlIHtcbiAgZGF0YTogQXJyYXk8RmluZVR1bmVFdmVudD47XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmVDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyB0cmFpbmluZyBkYXRhLlxuICAgKlxuICAgKiBTZWUgW3VwbG9hZCBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3VwbG9hZClcbiAgICogZm9yIGhvdyB0byB1cGxvYWQgYSBmaWxlLlxuICAgKlxuICAgKiBZb3VyIGRhdGFzZXQgbXVzdCBiZSBmb3JtYXR0ZWQgYXMgYSBKU09OTCBmaWxlLCB3aGVyZSBlYWNoIHRyYWluaW5nIGV4YW1wbGUgaXMgYVxuICAgKiBKU09OIG9iamVjdCB3aXRoIHRoZSBrZXlzIFwicHJvbXB0XCIgYW5kIFwiY29tcGxldGlvblwiLiBBZGRpdGlvbmFsbHksIHlvdSBtdXN0XG4gICAqIHVwbG9hZCB5b3VyIGZpbGUgd2l0aCB0aGUgcHVycG9zZSBgZmluZS10dW5lYC5cbiAgICpcbiAgICogU2VlIHRoZVxuICAgKiBbZmluZS10dW5pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9sZWdhY3ktZmluZS10dW5pbmcvY3JlYXRpbmctdHJhaW5pbmctZGF0YSlcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHRyYWluaW5nX2ZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGJhdGNoIHNpemUgdG8gdXNlIGZvciB0cmFpbmluZy4gVGhlIGJhdGNoIHNpemUgaXMgdGhlIG51bWJlciBvZiB0cmFpbmluZ1xuICAgKiBleGFtcGxlcyB1c2VkIHRvIHRyYWluIGEgc2luZ2xlIGZvcndhcmQgYW5kIGJhY2t3YXJkIHBhc3MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBiYXRjaCBzaXplIHdpbGwgYmUgZHluYW1pY2FsbHkgY29uZmlndXJlZCB0byBiZSB+MC4yJSBvZiB0aGVcbiAgICogbnVtYmVyIG9mIGV4YW1wbGVzIGluIHRoZSB0cmFpbmluZyBzZXQsIGNhcHBlZCBhdCAyNTYgLSBpbiBnZW5lcmFsLCB3ZSd2ZSBmb3VuZFxuICAgKiB0aGF0IGxhcmdlciBiYXRjaCBzaXplcyB0ZW5kIHRvIHdvcmsgYmV0dGVyIGZvciBsYXJnZXIgZGF0YXNldHMuXG4gICAqL1xuICBiYXRjaF9zaXplPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgdGhpcyBpcyBwcm92aWRlZCwgd2UgY2FsY3VsYXRlIEYtYmV0YSBzY29yZXMgYXQgdGhlIHNwZWNpZmllZCBiZXRhIHZhbHVlcy5cbiAgICogVGhlIEYtYmV0YSBzY29yZSBpcyBhIGdlbmVyYWxpemF0aW9uIG9mIEYtMSBzY29yZS4gVGhpcyBpcyBvbmx5IHVzZWQgZm9yIGJpbmFyeVxuICAgKiBjbGFzc2lmaWNhdGlvbi5cbiAgICpcbiAgICogV2l0aCBhIGJldGEgb2YgMSAoaS5lLiB0aGUgRi0xIHNjb3JlKSwgcHJlY2lzaW9uIGFuZCByZWNhbGwgYXJlIGdpdmVuIHRoZSBzYW1lXG4gICAqIHdlaWdodC4gQSBsYXJnZXIgYmV0YSBzY29yZSBwdXRzIG1vcmUgd2VpZ2h0IG9uIHJlY2FsbCBhbmQgbGVzcyBvbiBwcmVjaXNpb24uIEFcbiAgICogc21hbGxlciBiZXRhIHNjb3JlIHB1dHMgbW9yZSB3ZWlnaHQgb24gcHJlY2lzaW9uIGFuZCBsZXNzIG9uIHJlY2FsbC5cbiAgICovXG4gIGNsYXNzaWZpY2F0aW9uX2JldGFzPzogQXJyYXk8bnVtYmVyPiB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY2xhc3NlcyBpbiBhIGNsYXNzaWZpY2F0aW9uIHRhc2suXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGZvciBtdWx0aWNsYXNzIGNsYXNzaWZpY2F0aW9uLlxuICAgKi9cbiAgY2xhc3NpZmljYXRpb25fbl9jbGFzc2VzPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHBvc2l0aXZlIGNsYXNzIGluIGJpbmFyeSBjbGFzc2lmaWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHRvIGdlbmVyYXRlIHByZWNpc2lvbiwgcmVjYWxsLCBhbmQgRjEgbWV0cmljcyB3aGVuXG4gICAqIGRvaW5nIGJpbmFyeSBjbGFzc2lmaWNhdGlvbi5cbiAgICovXG4gIGNsYXNzaWZpY2F0aW9uX3Bvc2l0aXZlX2NsYXNzPzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogSWYgc2V0LCB3ZSBjYWxjdWxhdGUgY2xhc3NpZmljYXRpb24tc3BlY2lmaWMgbWV0cmljcyBzdWNoIGFzIGFjY3VyYWN5IGFuZCBGLTFcbiAgICogc2NvcmUgdXNpbmcgdGhlIHZhbGlkYXRpb24gc2V0IGF0IHRoZSBlbmQgb2YgZXZlcnkgZXBvY2guIFRoZXNlIG1ldHJpY3MgY2FuIGJlXG4gICAqIHZpZXdlZCBpbiB0aGVcbiAgICogW3Jlc3VsdHMgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9hbmFseXppbmcteW91ci1maW5lLXR1bmVkLW1vZGVsKS5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gY29tcHV0ZSBjbGFzc2lmaWNhdGlvbiBtZXRyaWNzLCB5b3UgbXVzdCBwcm92aWRlIGFcbiAgICogYHZhbGlkYXRpb25fZmlsZWAuIEFkZGl0aW9uYWxseSwgeW91IG11c3Qgc3BlY2lmeSBgY2xhc3NpZmljYXRpb25fbl9jbGFzc2VzYCBmb3JcbiAgICogbXVsdGljbGFzcyBjbGFzc2lmaWNhdGlvbiBvciBgY2xhc3NpZmljYXRpb25fcG9zaXRpdmVfY2xhc3NgIGZvciBiaW5hcnlcbiAgICogY2xhc3NpZmljYXRpb24uXG4gICAqL1xuICBjb21wdXRlX2NsYXNzaWZpY2F0aW9uX21ldHJpY3M/OiBib29sZWFuIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGxlYXJuaW5nIHJhdGUgbXVsdGlwbGllciB0byB1c2UgZm9yIHRyYWluaW5nLiBUaGUgZmluZS10dW5pbmcgbGVhcm5pbmcgcmF0ZVxuICAgKiBpcyB0aGUgb3JpZ2luYWwgbGVhcm5pbmcgcmF0ZSB1c2VkIGZvciBwcmV0cmFpbmluZyBtdWx0aXBsaWVkIGJ5IHRoaXMgdmFsdWUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBsZWFybmluZyByYXRlIG11bHRpcGxpZXIgaXMgdGhlIDAuMDUsIDAuMSwgb3IgMC4yIGRlcGVuZGluZyBvblxuICAgKiBmaW5hbCBgYmF0Y2hfc2l6ZWAgKGxhcmdlciBsZWFybmluZyByYXRlcyB0ZW5kIHRvIHBlcmZvcm0gYmV0dGVyIHdpdGggbGFyZ2VyXG4gICAqIGJhdGNoIHNpemVzKS4gV2UgcmVjb21tZW5kIGV4cGVyaW1lbnRpbmcgd2l0aCB2YWx1ZXMgaW4gdGhlIHJhbmdlIDAuMDIgdG8gMC4yIHRvXG4gICAqIHNlZSB3aGF0IHByb2R1Y2VzIHRoZSBiZXN0IHJlc3VsdHMuXG4gICAqL1xuICBsZWFybmluZ19yYXRlX211bHRpcGxpZXI/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgYmFzZSBtb2RlbCB0byBmaW5lLXR1bmUuIFlvdSBjYW4gc2VsZWN0IG9uZSBvZiBcImFkYVwiLCBcImJhYmJhZ2VcIixcbiAgICogXCJjdXJpZVwiLCBcImRhdmluY2lcIiwgb3IgYSBmaW5lLXR1bmVkIG1vZGVsIGNyZWF0ZWQgYWZ0ZXIgMjAyMi0wNC0yMSBhbmQgYmVmb3JlXG4gICAqIDIwMjMtMDgtMjIuIFRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlc2UgbW9kZWxzLCBzZWUgdGhlXG4gICAqIFtNb2RlbHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL21vZGVscykgZG9jdW1lbnRhdGlvbi5cbiAgICovXG4gIG1vZGVsPzogKHN0cmluZyAmIHt9KSB8ICdhZGEnIHwgJ2JhYmJhZ2UnIHwgJ2N1cmllJyB8ICdkYXZpbmNpJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZXBvY2hzIHRvIHRyYWluIHRoZSBtb2RlbCBmb3IuIEFuIGVwb2NoIHJlZmVycyB0byBvbmUgZnVsbCBjeWNsZVxuICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgKi9cbiAgbl9lcG9jaHM/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0IHRvIHVzZSBmb3IgbG9zcyBvbiB0aGUgcHJvbXB0IHRva2Vucy4gVGhpcyBjb250cm9scyBob3cgbXVjaCB0aGVcbiAgICogbW9kZWwgdHJpZXMgdG8gbGVhcm4gdG8gZ2VuZXJhdGUgdGhlIHByb21wdCAoYXMgY29tcGFyZWQgdG8gdGhlIGNvbXBsZXRpb24gd2hpY2hcbiAgICogYWx3YXlzIGhhcyBhIHdlaWdodCBvZiAxLjApLCBhbmQgY2FuIGFkZCBhIHN0YWJpbGl6aW5nIGVmZmVjdCB0byB0cmFpbmluZyB3aGVuXG4gICAqIGNvbXBsZXRpb25zIGFyZSBzaG9ydC5cbiAgICpcbiAgICogSWYgcHJvbXB0cyBhcmUgZXh0cmVtZWx5IGxvbmcgKHJlbGF0aXZlIHRvIGNvbXBsZXRpb25zKSwgaXQgbWF5IG1ha2Ugc2Vuc2UgdG9cbiAgICogcmVkdWNlIHRoaXMgd2VpZ2h0IHNvIGFzIHRvIGF2b2lkIG92ZXItcHJpb3JpdGl6aW5nIGxlYXJuaW5nIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfbG9zc193ZWlnaHQ/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB1cCB0byA0MCBjaGFyYWN0ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB5b3VyIGZpbmUtdHVuZWQgbW9kZWxcbiAgICogbmFtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgYHN1ZmZpeGAgb2YgXCJjdXN0b20tbW9kZWwtbmFtZVwiIHdvdWxkIHByb2R1Y2UgYSBtb2RlbCBuYW1lIGxpa2VcbiAgICogYGFkYTpmdC15b3VyLW9yZzpjdXN0b20tbW9kZWwtbmFtZS0yMDIyLTAyLTE1LTA0LTIxLTA0YC5cbiAgICovXG4gIHN1ZmZpeD86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgdmFsaWRhdGlvbiBkYXRhLlxuICAgKlxuICAgKiBJZiB5b3UgcHJvdmlkZSB0aGlzIGZpbGUsIHRoZSBkYXRhIGlzIHVzZWQgdG8gZ2VuZXJhdGUgdmFsaWRhdGlvbiBtZXRyaWNzXG4gICAqIHBlcmlvZGljYWxseSBkdXJpbmcgZmluZS10dW5pbmcuIFRoZXNlIG1ldHJpY3MgY2FuIGJlIHZpZXdlZCBpbiB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIHJlc3VsdHMgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2xlZ2FjeS1maW5lLXR1bmluZy9hbmFseXppbmcteW91ci1maW5lLXR1bmVkLW1vZGVsKS5cbiAgICogWW91ciB0cmFpbiBhbmQgdmFsaWRhdGlvbiBkYXRhIHNob3VsZCBiZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUsIHdoZXJlIGVhY2ggdmFsaWRhdGlvbiBleGFtcGxlIGlzXG4gICAqIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUga2V5cyBcInByb21wdFwiIGFuZCBcImNvbXBsZXRpb25cIi4gQWRkaXRpb25hbGx5LCB5b3UgbXVzdFxuICAgKiB1cGxvYWQgeW91ciBmaWxlIHdpdGggdGhlIHB1cnBvc2UgYGZpbmUtdHVuZWAuXG4gICAqXG4gICAqIFNlZSB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvbGVnYWN5LWZpbmUtdHVuaW5nL2NyZWF0aW5nLXRyYWluaW5nLWRhdGEpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB2YWxpZGF0aW9uX2ZpbGU/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXMgPVxuICB8IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc05vblN0cmVhbWluZ1xuICB8IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc1N0cmVhbWluZztcblxuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNCYXNlIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RyZWFtIGV2ZW50cyBmb3IgdGhlIGZpbmUtdHVuZSBqb2IuIElmIHNldCB0byB0cnVlLCBldmVudHMgd2lsbCBiZVxuICAgKiBzZW50IGFzIGRhdGEtb25seVxuICAgKiBbc2VydmVyLXNlbnQgZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzL1VzaW5nX3NlcnZlci1zZW50X2V2ZW50cyNFdmVudF9zdHJlYW1fZm9ybWF0KVxuICAgKiBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUuIFRoZSBzdHJlYW0gd2lsbCB0ZXJtaW5hdGUgd2l0aCBhIGBkYXRhOiBbRE9ORV1gXG4gICAqIG1lc3NhZ2Ugd2hlbiB0aGUgam9iIGlzIGZpbmlzaGVkIChzdWNjZWVkZWQsIGNhbmNlbGxlZCwgb3IgZmFpbGVkKS5cbiAgICpcbiAgICogSWYgc2V0IHRvIGZhbHNlLCBvbmx5IGV2ZW50cyBnZW5lcmF0ZWQgc28gZmFyIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBzdHJlYW0/OiBib29sZWFuO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtcyB7XG4gIGV4cG9ydCB0eXBlIEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc05vblN0cmVhbWluZyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCB0eXBlIEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc1N0cmVhbWluZyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNTdHJlYW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBldmVudHMgZm9yIHRoZSBmaW5lLXR1bmUgam9iLiBJZiBzZXQgdG8gdHJ1ZSwgZXZlbnRzIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLiBUaGUgc3RyZWFtIHdpbGwgdGVybWluYXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlIHdoZW4gdGhlIGpvYiBpcyBmaW5pc2hlZCAoc3VjY2VlZGVkLCBjYW5jZWxsZWQsIG9yIGZhaWxlZCkuXG4gICAqXG4gICAqIElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgZ2VuZXJhdGVkIHNvIGZhciB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgc3RyZWFtPzogZmFsc2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zU3RyZWFtaW5nIGV4dGVuZHMgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zQmFzZSB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN0cmVhbSBldmVudHMgZm9yIHRoZSBmaW5lLXR1bmUgam9iLiBJZiBzZXQgdG8gdHJ1ZSwgZXZlbnRzIHdpbGwgYmVcbiAgICogc2VudCBhcyBkYXRhLW9ubHlcbiAgICogW3NlcnZlci1zZW50IGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZlci1zZW50X2V2ZW50cy9Vc2luZ19zZXJ2ZXItc2VudF9ldmVudHMjRXZlbnRfc3RyZWFtX2Zvcm1hdClcbiAgICogYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLiBUaGUgc3RyZWFtIHdpbGwgdGVybWluYXRlIHdpdGggYSBgZGF0YTogW0RPTkVdYFxuICAgKiBtZXNzYWdlIHdoZW4gdGhlIGpvYiBpcyBmaW5pc2hlZCAoc3VjY2VlZGVkLCBjYW5jZWxsZWQsIG9yIGZhaWxlZCkuXG4gICAqXG4gICAqIElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgZ2VuZXJhdGVkIHNvIGZhciB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgc3RyZWFtOiB0cnVlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEZpbmVUdW5lcyB7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmUgPSBBUEkuRmluZVR1bmU7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVFdmVudCA9IEFQSS5GaW5lVHVuZUV2ZW50O1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlID0gQVBJLkZpbmVUdW5lRXZlbnRzTGlzdFJlc3BvbnNlO1xuICBleHBvcnQgdHlwZSBGaW5lVHVuZXNQYWdlID0gX0ZpbmVUdW5lc1BhZ2U7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVDcmVhdGVQYXJhbXMgPSBBUEkuRmluZVR1bmVDcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zID0gQVBJLkZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNOb25TdHJlYW1pbmcgPSBBUEkuRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zTm9uU3RyZWFtaW5nO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc1N0cmVhbWluZyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNTdHJlYW1pbmc7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSwgQ3Vyc29yUGFnZVBhcmFtcyB9IGZyb20gXCIuLi8uLi9wYWdpbmF0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBKb2JzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGpvYiB0aGF0IGZpbmUtdHVuZXMgYSBzcGVjaWZpZWQgbW9kZWwgZnJvbSBhIGdpdmVuIGRhdGFzZXQuXG4gICAqXG4gICAqIFJlc3BvbnNlIGluY2x1ZGVzIGRldGFpbHMgb2YgdGhlIGVucXVldWVkIGpvYiBpbmNsdWRpbmcgam9iIHN0YXR1cyBhbmQgdGhlIG5hbWVcbiAgICogb2YgdGhlIGZpbmUtdHVuZWQgbW9kZWxzIG9uY2UgY29tcGxldGUuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICBjcmVhdGUoYm9keTogSm9iQ3JlYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxGaW5lVHVuaW5nSm9iPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ZpbmVfdHVuaW5nL2pvYnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm8gYWJvdXQgYSBmaW5lLXR1bmluZyBqb2IuXG4gICAqXG4gICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqL1xuICByZXRyaWV2ZShmaW5lVHVuaW5nSm9iSWQ6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8RmluZVR1bmluZ0pvYj4ge1xuICAgIHJldHVybiB0aGlzLmdldChgL2ZpbmVfdHVuaW5nL2pvYnMvJHtmaW5lVHVuaW5nSm9iSWR9YCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB5b3VyIG9yZ2FuaXphdGlvbidzIGZpbmUtdHVuaW5nIGpvYnNcbiAgICovXG4gIGxpc3QoXG4gICAgcXVlcnk/OiBKb2JMaXN0UGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj47XG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JzUGFnZSwgRmluZVR1bmluZ0pvYj47XG4gIGxpc3QoXG4gICAgcXVlcnk6IEpvYkxpc3RQYXJhbXMgfCBDb3JlLlJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuUGFnZVByb21pc2U8RmluZVR1bmluZ0pvYnNQYWdlLCBGaW5lVHVuaW5nSm9iPiB7XG4gICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEFQSUxpc3QoJy9maW5lX3R1bmluZy9qb2JzJywgRmluZVR1bmluZ0pvYnNQYWdlLCB7IHF1ZXJ5LCAuLi5vcHRpb25zIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAqL1xuICBjYW5jZWwoZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEZpbmVUdW5pbmdKb2I+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0YXR1cyB1cGRhdGVzIGZvciBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGxpc3RFdmVudHMoXG4gICAgZmluZVR1bmluZ0pvYklkOiBzdHJpbmcsXG4gICAgcXVlcnk/OiBKb2JMaXN0RXZlbnRzUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+O1xuICBsaXN0RXZlbnRzKFxuICAgIGZpbmVUdW5pbmdKb2JJZDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBKb2JMaXN0RXZlbnRzUGFyYW1zIHwgQ29yZS5SZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLlBhZ2VQcm9taXNlPEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlLCBGaW5lVHVuaW5nSm9iRXZlbnQ+IHtcbiAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RFdmVudHMoZmluZVR1bmluZ0pvYklkLCB7fSwgcXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH0vZXZlbnRzYCwgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UsIHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYnNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZTxGaW5lVHVuaW5nSm9iPiB7fVxuLy8gYWxpYXMgc28gd2UgY2FuIGV4cG9ydCBpdCBpbiB0aGUgbmFtZXNwYWNlXG50eXBlIF9GaW5lVHVuaW5nSm9ic1BhZ2UgPSBGaW5lVHVuaW5nSm9ic1BhZ2U7XG5cbmV4cG9ydCBjbGFzcyBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2U8RmluZVR1bmluZ0pvYkV2ZW50PiB7fVxuLy8gYWxpYXMgc28gd2UgY2FuIGV4cG9ydCBpdCBpbiB0aGUgbmFtZXNwYWNlXG50eXBlIF9GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEZpbmVUdW5pbmdKb2JFdmVudHNQYWdlO1xuXG4vKipcbiAqIFRoZSBgZmluZV90dW5pbmcuam9iYCBvYmplY3QgcmVwcmVzZW50cyBhIGZpbmUtdHVuaW5nIGpvYiB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcbiAqIHRocm91Z2ggdGhlIEFQSS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgaWRlbnRpZmllciwgd2hpY2ggY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIEFQSSBlbmRwb2ludHMuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkX2F0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBlcnJvcjogRmluZVR1bmluZ0pvYi5FcnJvciB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVsIHRoYXQgaXMgYmVpbmcgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmUgbnVsbFxuICAgKiBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICBmaW5lX3R1bmVkX21vZGVsOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpIGZvciB3aGVuIHRoZSBmaW5lLXR1bmluZyBqb2Igd2FzIGZpbmlzaGVkLiBUaGVcbiAgICogdmFsdWUgd2lsbCBiZSBudWxsIGlmIHRoZSBmaW5lLXR1bmluZyBqb2IgaXMgc3RpbGwgcnVubmluZy5cbiAgICovXG4gIGZpbmlzaGVkX2F0OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFNlZSB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpIGZvclxuICAgKiBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBoeXBlcnBhcmFtZXRlcnM6IEZpbmVUdW5pbmdKb2IuSHlwZXJwYXJhbWV0ZXJzO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBtb2RlbCB0aGF0IGlzIGJlaW5nIGZpbmUtdHVuZWQuXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcImZpbmVfdHVuaW5nLmpvYlwiLlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmdhbml6YXRpb24gdGhhdCBvd25zIHRoZSBmaW5lLXR1bmluZyBqb2IuXG4gICAqL1xuICBvcmdhbml6YXRpb25faWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbXBpbGVkIHJlc3VsdHMgZmlsZSBJRChzKSBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi4gWW91IGNhbiByZXRyaWV2ZSB0aGVcbiAgICogcmVzdWx0cyB3aXRoIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHJlc3VsdF9maWxlczogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBmaW5lLXR1bmluZyBqb2IsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICogYHZhbGlkYXRpbmdfZmlsZXNgLCBgcXVldWVkYCwgYHJ1bm5pbmdgLCBgc3VjY2VlZGVkYCwgYGZhaWxlZGAsIG9yIGBjYW5jZWxsZWRgLlxuICAgKi9cbiAgc3RhdHVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYmlsbGFibGUgdG9rZW5zIHByb2Nlc3NlZCBieSB0aGlzIGZpbmUtdHVuaW5nIGpvYi4gVGhlIHZhbHVlXG4gICAqIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmluZS10dW5pbmcgam9iIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICB0cmFpbmVkX3Rva2VuczogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZpbGUgSUQgdXNlZCBmb3IgdHJhaW5pbmcuIFlvdSBjYW4gcmV0cmlldmUgdGhlIHRyYWluaW5nIGRhdGEgd2l0aCB0aGVcbiAgICogW0ZpbGVzIEFQSV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9yZXRyaWV2ZS1jb250ZW50cykuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmaWxlIElEIHVzZWQgZm9yIHZhbGlkYXRpb24uIFlvdSBjYW4gcmV0cmlldmUgdGhlIHZhbGlkYXRpb24gcmVzdWx0cyB3aXRoXG4gICAqIHRoZVxuICAgKiBbRmlsZXMgQVBJXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL3JldHJpZXZlLWNvbnRlbnRzKS5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZTogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nSm9iIHtcbiAgLyoqXG4gICAqIEZvciBmaW5lLXR1bmluZyBqb2JzIHRoYXQgaGF2ZSBgZmFpbGVkYCwgdGhpcyB3aWxsIGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgKiB0aGUgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBBIG1hY2hpbmUtcmVhZGFibGUgZXJyb3IgY29kZS5cbiAgICAgKi9cbiAgICBjb2RlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmFtZXRlciB0aGF0IHdhcyBpbnZhbGlkLCB1c3VhbGx5IGB0cmFpbmluZ19maWxlYCBvciBgdmFsaWRhdGlvbl9maWxlYC5cbiAgICAgKiBUaGlzIGZpZWxkIHdpbGwgYmUgbnVsbCBpZiB0aGUgZmFpbHVyZSB3YXMgbm90IHBhcmFtZXRlci1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBwYXJhbTogc3RyaW5nIHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaHlwZXJwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBmaW5lLXR1bmluZyBqb2IuIFNlZSB0aGVcbiAgICogW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpIGZvclxuICAgKiBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEh5cGVycGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBlcG9jaHMgdG8gdHJhaW4gdGhlIG1vZGVsIGZvci4gQW4gZXBvY2ggcmVmZXJzIHRvIG9uZSBmdWxsIGN5Y2xlXG4gICAgICogdGhyb3VnaCB0aGUgdHJhaW5pbmcgZGF0YXNldC4gXCJhdXRvXCIgZGVjaWRlcyB0aGUgb3B0aW1hbCBudW1iZXIgb2YgZXBvY2hzIGJhc2VkXG4gICAgICogb24gdGhlIHNpemUgb2YgdGhlIGRhdGFzZXQuIElmIHNldHRpbmcgdGhlIG51bWJlciBtYW51YWxseSwgd2Ugc3VwcG9ydCBhbnlcbiAgICAgKiBudW1iZXIgYmV0d2VlbiAxIGFuZCA1MCBlcG9jaHMuXG4gICAgICovXG4gICAgbl9lcG9jaHM6ICdhdXRvJyB8IG51bWJlcjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbmVUdW5pbmdKb2JFdmVudCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgY3JlYXRlZF9hdDogbnVtYmVyO1xuXG4gIGxldmVsOiAnaW5mbycgfCAnd2FybicgfCAnZXJyb3InO1xuXG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2JDcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIGZpbmUtdHVuZS4gWW91IGNhbiBzZWxlY3Qgb25lIG9mIHRoZVxuICAgKiBbc3VwcG9ydGVkIG1vZGVsc10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL2ZpbmUtdHVuaW5nL3doYXQtbW9kZWxzLWNhbi1iZS1maW5lLXR1bmVkKS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ2JhYmJhZ2UtMDAyJyB8ICdkYXZpbmNpLTAwMicgfCAnZ3B0LTMuNS10dXJibyc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiB1cGxvYWRlZCBmaWxlIHRoYXQgY29udGFpbnMgdHJhaW5pbmcgZGF0YS5cbiAgICpcbiAgICogU2VlIFt1cGxvYWQgZmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy91cGxvYWQpXG4gICAqIGZvciBob3cgdG8gdXBsb2FkIGEgZmlsZS5cbiAgICpcbiAgICogWW91ciBkYXRhc2V0IG11c3QgYmUgZm9ybWF0dGVkIGFzIGEgSlNPTkwgZmlsZS4gQWRkaXRpb25hbGx5LCB5b3UgbXVzdCB1cGxvYWRcbiAgICogeW91ciBmaWxlIHdpdGggdGhlIHB1cnBvc2UgYGZpbmUtdHVuZWAuXG4gICAqXG4gICAqIFNlZSB0aGUgW2ZpbmUtdHVuaW5nIGd1aWRlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB0cmFpbmluZ19maWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGh5cGVycGFyYW1ldGVycz86IEpvYkNyZWF0ZVBhcmFtcy5IeXBlcnBhcmFtZXRlcnM7XG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHVwIHRvIDE4IGNoYXJhY3RlcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHlvdXIgZmluZS10dW5lZCBtb2RlbFxuICAgKiBuYW1lLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgYSBgc3VmZml4YCBvZiBcImN1c3RvbS1tb2RlbC1uYW1lXCIgd291bGQgcHJvZHVjZSBhIG1vZGVsIG5hbWUgbGlrZVxuICAgKiBgZnQ6Z3B0LTMuNS10dXJibzpvcGVuYWk6Y3VzdG9tLW1vZGVsLW5hbWU6N3A0bFVSZWxgLlxuICAgKi9cbiAgc3VmZml4Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIHVwbG9hZGVkIGZpbGUgdGhhdCBjb250YWlucyB2YWxpZGF0aW9uIGRhdGEuXG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIHRoaXMgZmlsZSwgdGhlIGRhdGEgaXMgdXNlZCB0byBnZW5lcmF0ZSB2YWxpZGF0aW9uIG1ldHJpY3NcbiAgICogcGVyaW9kaWNhbGx5IGR1cmluZyBmaW5lLXR1bmluZy4gVGhlc2UgbWV0cmljcyBjYW4gYmUgdmlld2VkIGluIHRoZSBmaW5lLXR1bmluZ1xuICAgKiByZXN1bHRzIGZpbGUuIFRoZSBzYW1lIGRhdGEgc2hvdWxkIG5vdCBiZSBwcmVzZW50IGluIGJvdGggdHJhaW4gYW5kIHZhbGlkYXRpb25cbiAgICogZmlsZXMuXG4gICAqXG4gICAqIFlvdXIgZGF0YXNldCBtdXN0IGJlIGZvcm1hdHRlZCBhcyBhIEpTT05MIGZpbGUuIFlvdSBtdXN0IHVwbG9hZCB5b3VyIGZpbGUgd2l0aFxuICAgKiB0aGUgcHVycG9zZSBgZmluZS10dW5lYC5cbiAgICpcbiAgICogU2VlIHRoZSBbZmluZS10dW5pbmcgZ3VpZGVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHZhbGlkYXRpb25fZmlsZT86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgSm9iQ3JlYXRlUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBoeXBlcnBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIGZpbmUtdHVuaW5nIGpvYi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSHlwZXJwYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVwb2NocyB0byB0cmFpbiB0aGUgbW9kZWwgZm9yLiBBbiBlcG9jaCByZWZlcnMgdG8gb25lIGZ1bGwgY3ljbGVcbiAgICAgKiB0aHJvdWdoIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgICAqL1xuICAgIG5fZXBvY2hzPzogJ2F1dG8nIHwgbnVtYmVyO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9iTGlzdFBhcmFtcyBleHRlbmRzIEN1cnNvclBhZ2VQYXJhbXMge31cblxuZXhwb3J0IGludGVyZmFjZSBKb2JMaXN0RXZlbnRzUGFyYW1zIGV4dGVuZHMgQ3Vyc29yUGFnZVBhcmFtcyB7fVxuXG5leHBvcnQgbmFtZXNwYWNlIEpvYnMge1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5pbmdKb2IgPSBBUEkuRmluZVR1bmluZ0pvYjtcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuaW5nSm9iRXZlbnQgPSBBUEkuRmluZVR1bmluZ0pvYkV2ZW50O1xuICBleHBvcnQgdHlwZSBGaW5lVHVuaW5nSm9ic1BhZ2UgPSBfRmluZVR1bmluZ0pvYnNQYWdlO1xuICBleHBvcnQgdHlwZSBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IF9GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBKb2JDcmVhdGVQYXJhbXMgPSBBUEkuSm9iQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEpvYkxpc3RQYXJhbXMgPSBBUEkuSm9iTGlzdFBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBKb2JMaXN0RXZlbnRzUGFyYW1zID0gQVBJLkpvYkxpc3RFdmVudHNQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCB7IEpvYnMgfSBmcm9tICcuL2pvYnMnO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgRmluZVR1bmluZyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgam9iczogSm9icyA9IG5ldyBKb2JzKHRoaXMuY2xpZW50KTtcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBGaW5lVHVuaW5nIHtcbiAgZXhwb3J0IGltcG9ydCBKb2JzID0gQVBJLkpvYnM7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmluZ0pvYiA9IEFQSS5GaW5lVHVuaW5nSm9iO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5pbmdKb2JFdmVudCA9IEFQSS5GaW5lVHVuaW5nSm9iRXZlbnQ7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmluZ0pvYnNQYWdlID0gQVBJLkZpbmVUdW5pbmdKb2JzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEFQSS5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBKb2JDcmVhdGVQYXJhbXMgPSBBUEkuSm9iQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEpvYkxpc3RQYXJhbXMgPSBBUEkuSm9iTGlzdFBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBKb2JMaXN0RXZlbnRzUGFyYW1zID0gQVBJLkpvYkxpc3RFdmVudHNQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIEFQSSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IHR5cGUgVXBsb2FkYWJsZSwgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuZXhwb3J0IGNsYXNzIEltYWdlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB2YXJpYXRpb24gb2YgYSBnaXZlbiBpbWFnZS5cbiAgICovXG4gIGNyZWF0ZVZhcmlhdGlvbihcbiAgICBib2R5OiBJbWFnZUNyZWF0ZVZhcmlhdGlvblBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ltYWdlcy92YXJpYXRpb25zJywgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlZGl0ZWQgb3IgZXh0ZW5kZWQgaW1hZ2UgZ2l2ZW4gYW4gb3JpZ2luYWwgaW1hZ2UgYW5kIGEgcHJvbXB0LlxuICAgKi9cbiAgZWRpdChib2R5OiBJbWFnZUVkaXRQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPEltYWdlc1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL2ltYWdlcy9lZGl0cycsIG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW1hZ2UgZ2l2ZW4gYSBwcm9tcHQuXG4gICAqL1xuICBnZW5lcmF0ZShib2R5OiBJbWFnZUdlbmVyYXRlUGFyYW1zLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxJbWFnZXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QoJy9pbWFnZXMvZ2VuZXJhdGlvbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB1cmwgb3IgdGhlIGNvbnRlbnQgb2YgYW4gaW1hZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBPcGVuQUkgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlNjQtZW5jb2RlZCBKU09OIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2UsIGlmIGByZXNwb25zZV9mb3JtYXRgIGlzXG4gICAqIGBiNjRfanNvbmAuXG4gICAqL1xuICBiNjRfanNvbj86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlLCBpZiBgcmVzcG9uc2VfZm9ybWF0YCBpcyBgdXJsYCAoZGVmYXVsdCkuXG4gICAqL1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VzUmVzcG9uc2Uge1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgZGF0YTogQXJyYXk8SW1hZ2U+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zIHtcbiAgLyoqXG4gICAqIFRoZSBpbWFnZSB0byB1c2UgYXMgdGhlIGJhc2lzIGZvciB0aGUgdmFyaWF0aW9uKHMpLiBNdXN0IGJlIGEgdmFsaWQgUE5HIGZpbGUsXG4gICAqIGxlc3MgdGhhbiA0TUIsIGFuZCBzcXVhcmUuXG4gICAqL1xuICBpbWFnZTogVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcy9lbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUVkaXRQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGltYWdlIHRvIGVkaXQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuIDRNQiwgYW5kIHNxdWFyZS4gSWYgbWFza1xuICAgKiBpcyBub3QgcHJvdmlkZWQsIGltYWdlIG11c3QgaGF2ZSB0cmFuc3BhcmVuY3ksIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgbWFzay5cbiAgICovXG4gIGltYWdlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gYWRkaXRpb25hbCBpbWFnZSB3aG9zZSBmdWxseSB0cmFuc3BhcmVudCBhcmVhcyAoZS5nLiB3aGVyZSBhbHBoYSBpcyB6ZXJvKVxuICAgKiBpbmRpY2F0ZSB3aGVyZSBgaW1hZ2VgIHNob3VsZCBiZSBlZGl0ZWQuIE11c3QgYmUgYSB2YWxpZCBQTkcgZmlsZSwgbGVzcyB0aGFuXG4gICAqIDRNQiwgYW5kIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyBgaW1hZ2VgLlxuICAgKi9cbiAgbWFzaz86IFVwbG9hZGFibGU7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlLiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgMTAuXG4gICAqL1xuICBuPzogbnVtYmVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIGZvcm1hdCBpbiB3aGljaCB0aGUgZ2VuZXJhdGVkIGltYWdlcyBhcmUgcmV0dXJuZWQuIE11c3QgYmUgb25lIG9mIGB1cmxgIG9yXG4gICAqIGBiNjRfanNvbmAuXG4gICAqL1xuICByZXNwb25zZV9mb3JtYXQ/OiAndXJsJyB8ICdiNjRfanNvbicgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGltYWdlcy4gTXVzdCBiZSBvbmUgb2YgYDI1NngyNTZgLCBgNTEyeDUxMmAsIG9yXG4gICAqIGAxMDI0eDEwMjRgLlxuICAgKi9cbiAgc2l6ZT86ICcyNTZ4MjU2JyB8ICc1MTJ4NTEyJyB8ICcxMDI0eDEwMjQnIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciByZXByZXNlbnRpbmcgeW91ciBlbmQtdXNlciwgd2hpY2ggY2FuIGhlbHAgT3BlbkFJIHRvIG1vbml0b3JcbiAgICogYW5kIGRldGVjdCBhYnVzZS5cbiAgICogW0xlYXJuIG1vcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9zYWZldHktYmVzdC1wcmFjdGljZXMvZW5kLXVzZXItaWRzKS5cbiAgICovXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VHZW5lcmF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBBIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UocykuIFRoZSBtYXhpbXVtIGxlbmd0aCBpcyAxMDAwXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqL1xuICBwcm9tcHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUuIE11c3QgYmUgYmV0d2VlbiAxIGFuZCAxMC5cbiAgICovXG4gIG4/OiBudW1iZXIgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGFyZSByZXR1cm5lZC4gTXVzdCBiZSBvbmUgb2YgYHVybGAgb3JcbiAgICogYGI2NF9qc29uYC5cbiAgICovXG4gIHJlc3BvbnNlX2Zvcm1hdD86ICd1cmwnIHwgJ2I2NF9qc29uJyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzLiBNdXN0IGJlIG9uZSBvZiBgMjU2eDI1NmAsIGA1MTJ4NTEyYCwgb3JcbiAgICogYDEwMjR4MTAyNGAuXG4gICAqL1xuICBzaXplPzogJzI1NngyNTYnIHwgJzUxMng1MTInIHwgJzEwMjR4MTAyNCcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHJlcHJlc2VudGluZyB5b3VyIGVuZC11c2VyLCB3aGljaCBjYW4gaGVscCBPcGVuQUkgdG8gbW9uaXRvclxuICAgKiBhbmQgZGV0ZWN0IGFidXNlLlxuICAgKiBbTGVhcm4gbW9yZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvZ3VpZGVzL3NhZmV0eS1iZXN0LXByYWN0aWNlcy9lbmQtdXNlci1pZHMpLlxuICAgKi9cbiAgdXNlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBJbWFnZXMge1xuICBleHBvcnQgaW1wb3J0IEltYWdlID0gQVBJLkltYWdlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlc1Jlc3BvbnNlID0gQVBJLkltYWdlc1Jlc3BvbnNlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zID0gQVBJLkltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEltYWdlRWRpdFBhcmFtcyA9IEFQSS5JbWFnZUVkaXRQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgSW1hZ2VHZW5lcmF0ZVBhcmFtcyA9IEFQSS5JbWFnZUdlbmVyYXRlUGFyYW1zO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSBcIi4uL3BhZ2luYXRpb25cIjtcblxuZXhwb3J0IGNsYXNzIE1vZGVscyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIG1vZGVsIGluc3RhbmNlLCBwcm92aWRpbmcgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGVsIHN1Y2ggYXNcbiAgICogdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgKi9cbiAgcmV0cmlldmUobW9kZWw6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBtb2RlbHMsIGFuZCBwcm92aWRlcyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBlYWNoXG4gICAqIG9uZSBzdWNoIGFzIHRoZSBvd25lciBhbmQgYXZhaWxhYmlsaXR5LlxuICAgKi9cbiAgbGlzdChvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuUGFnZVByb21pc2U8TW9kZWxzUGFnZSwgTW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRBUElMaXN0KCcvbW9kZWxzJywgTW9kZWxzUGFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZmluZS10dW5lZCBtb2RlbC4gWW91IG11c3QgaGF2ZSB0aGUgT3duZXIgcm9sZSBpbiB5b3VyIG9yZ2FuaXphdGlvbiB0b1xuICAgKiBkZWxldGUgYSBtb2RlbC5cbiAgICovXG4gIGRlbChtb2RlbDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTxNb2RlbERlbGV0ZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5kZWxldGUoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsc1BhZ2UgZXh0ZW5kcyBQYWdlPE1vZGVsPiB7fVxuLy8gYWxpYXMgc28gd2UgY2FuIGV4cG9ydCBpdCBpbiB0aGUgbmFtZXNwYWNlXG50eXBlIF9Nb2RlbHNQYWdlID0gTW9kZWxzUGFnZTtcblxuLyoqXG4gKiBEZXNjcmliZXMgYW4gT3BlbkFJIG1vZGVsIG9mZmVyaW5nIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgQVBJLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsIHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBpZGVudGlmaWVyLCB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgQVBJIGVuZHBvaW50cy5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykgd2hlbiB0aGUgbW9kZWwgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwibW9kZWxcIi5cbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JnYW5pemF0aW9uIHRoYXQgb3ducyB0aGUgbW9kZWwuXG4gICAqL1xuICBvd25lZF9ieTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsRGVsZXRlZCB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgZGVsZXRlZDogYm9vbGVhbjtcblxuICBvYmplY3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RlbHMge1xuICBleHBvcnQgaW1wb3J0IE1vZGVsID0gQVBJLk1vZGVsO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsRGVsZXRlZCA9IEFQSS5Nb2RlbERlbGV0ZWQ7XG4gIGV4cG9ydCB0eXBlIE1vZGVsc1BhZ2UgPSBfTW9kZWxzUGFnZTtcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZVwiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgTW9kZXJhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDbGFzc2lmaWVzIGlmIHRleHQgdmlvbGF0ZXMgT3BlbkFJJ3MgQ29udGVudCBQb2xpY3lcbiAgICovXG4gIGNyZWF0ZShcbiAgICBib2R5OiBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zLFxuICAgIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zLFxuICApOiBDb3JlLkFQSVByb21pc2U8TW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL21vZGVyYXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIGZsYWdnZWQgb3Igbm90LlxuICAgKi9cbiAgY2F0ZWdvcmllczogTW9kZXJhdGlvbi5DYXRlZ29yaWVzO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMgYWxvbmcgd2l0aCB0aGVpciBzY29yZXMgYXMgcHJlZGljdGVkIGJ5IG1vZGVsLlxuICAgKi9cbiAgY2F0ZWdvcnlfc2NvcmVzOiBNb2RlcmF0aW9uLkNhdGVnb3J5U2NvcmVzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb250ZW50IHZpb2xhdGVzXG4gICAqIFtPcGVuQUkncyB1c2FnZSBwb2xpY2llc10oL3BvbGljaWVzL3VzYWdlLXBvbGljaWVzKS5cbiAgICovXG4gIGZsYWdnZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgTW9kZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIGNhdGVnb3JpZXMsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIGZsYWdnZWQgb3Igbm90LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yaWVzIHtcbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgZXhwcmVzc2VzLCBpbmNpdGVzLCBvciBwcm9tb3RlcyBoYXJhc3NpbmcgbGFuZ3VhZ2UgdG93YXJkcyBhbnlcbiAgICAgKiB0YXJnZXQuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhhcmFzc21lbnQgY29udGVudCB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2Ugb3Igc2VyaW91cyBoYXJtIHRvd2FyZHMgYW55XG4gICAgICogdGFyZ2V0LlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBleHByZXNzZXMsIGluY2l0ZXMsIG9yIHByb21vdGVzIGhhdGUgYmFzZWQgb24gcmFjZSwgZ2VuZGVyLFxuICAgICAqIGV0aG5pY2l0eSwgcmVsaWdpb24sIG5hdGlvbmFsaXR5LCBzZXh1YWwgb3JpZW50YXRpb24sIGRpc2FiaWxpdHkgc3RhdHVzLCBvclxuICAgICAqIGNhc3RlLiBIYXRlZnVsIGNvbnRlbnQgYWltZWQgYXQgbm9uLXByb3RlY3RlZCBncm91cHMgKGUuZy4sIGNoZXNzIHBsYXllcnMpIGlzXG4gICAgICogaGFycmFzc21lbnQuXG4gICAgICovXG4gICAgaGF0ZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhhdGVmdWwgY29udGVudCB0aGF0IGFsc28gaW5jbHVkZXMgdmlvbGVuY2Ugb3Igc2VyaW91cyBoYXJtIHRvd2FyZHMgdGhlIHRhcmdldGVkXG4gICAgICogZ3JvdXAgYmFzZWQgb24gcmFjZSwgZ2VuZGVyLCBldGhuaWNpdHksIHJlbGlnaW9uLCBuYXRpb25hbGl0eSwgc2V4dWFsXG4gICAgICogb3JpZW50YXRpb24sIGRpc2FiaWxpdHkgc3RhdHVzLCBvciBjYXN0ZS5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHRoYXQgcHJvbW90ZXMsIGVuY291cmFnZXMsIG9yIGRlcGljdHMgYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXNcbiAgICAgKiBzdWljaWRlLCBjdXR0aW5nLCBhbmQgZWF0aW5nIGRpc29yZGVycy5cbiAgICAgKi9cbiAgICAnc2VsZi1oYXJtJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBlbmNvdXJhZ2VzIHBlcmZvcm1pbmcgYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXMgc3VpY2lkZSwgY3V0dGluZyxcbiAgICAgKiBhbmQgZWF0aW5nIGRpc29yZGVycywgb3IgdGhhdCBnaXZlcyBpbnN0cnVjdGlvbnMgb3IgYWR2aWNlIG9uIGhvdyB0byBjb21taXQgc3VjaFxuICAgICAqIGFjdHMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB3aGVyZSB0aGUgc3BlYWtlciBleHByZXNzZXMgdGhhdCB0aGV5IGFyZSBlbmdhZ2luZyBvciBpbnRlbmQgdG8gZW5nYWdlXG4gICAgICogaW4gYWN0cyBvZiBzZWxmLWhhcm0sIHN1Y2ggYXMgc3VpY2lkZSwgY3V0dGluZywgYW5kIGVhdGluZyBkaXNvcmRlcnMuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBtZWFudCB0byBhcm91c2Ugc2V4dWFsIGV4Y2l0ZW1lbnQsIHN1Y2ggYXMgdGhlIGRlc2NyaXB0aW9uIG9mIHNleHVhbFxuICAgICAqIGFjdGl2aXR5LCBvciB0aGF0IHByb21vdGVzIHNleHVhbCBzZXJ2aWNlcyAoZXhjbHVkaW5nIHNleCBlZHVjYXRpb24gYW5kXG4gICAgICogd2VsbG5lc3MpLlxuICAgICAqL1xuICAgIHNleHVhbDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNleHVhbCBjb250ZW50IHRoYXQgaW5jbHVkZXMgYW4gaW5kaXZpZHVhbCB3aG8gaXMgdW5kZXIgMTggeWVhcnMgb2xkLlxuICAgICAqL1xuICAgICdzZXh1YWwvbWlub3JzJzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgdGhhdCBkZXBpY3RzIGRlYXRoLCB2aW9sZW5jZSwgb3IgcGh5c2ljYWwgaW5qdXJ5LlxuICAgICAqL1xuICAgIHZpb2xlbmNlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCB0aGF0IGRlcGljdHMgZGVhdGgsIHZpb2xlbmNlLCBvciBwaHlzaWNhbCBpbmp1cnkgaW4gZ3JhcGhpYyBkZXRhaWwuXG4gICAgICovXG4gICAgJ3Zpb2xlbmNlL2dyYXBoaWMnOiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgY2F0ZWdvcmllcyBhbG9uZyB3aXRoIHRoZWlyIHNjb3JlcyBhcyBwcmVkaWN0ZWQgYnkgbW9kZWwuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5U2NvcmVzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnaGFyYXNzbWVudCcuXG4gICAgICovXG4gICAgaGFyYXNzbWVudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhcmFzc21lbnQvdGhyZWF0ZW5pbmcnLlxuICAgICAqL1xuICAgICdoYXJhc3NtZW50L3RocmVhdGVuaW5nJzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3JlIGZvciB0aGUgY2F0ZWdvcnkgJ2hhdGUnLlxuICAgICAqL1xuICAgIGhhdGU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdoYXRlL3RocmVhdGVuaW5nJy5cbiAgICAgKi9cbiAgICAnaGF0ZS90aHJlYXRlbmluZyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZWxmLWhhcm0nLlxuICAgICAqL1xuICAgICdzZWxmLWhhcm0nOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2luc3RydWN0aW9ucycuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnN0cnVjdGlvbnMnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2VsZi1oYXJtL2ludGVudCcuXG4gICAgICovXG4gICAgJ3NlbGYtaGFybS9pbnRlbnQnOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NvcmUgZm9yIHRoZSBjYXRlZ29yeSAnc2V4dWFsJy5cbiAgICAgKi9cbiAgICBzZXh1YWw6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICdzZXh1YWwvbWlub3JzJy5cbiAgICAgKi9cbiAgICAnc2V4dWFsL21pbm9ycyc6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZScuXG4gICAgICovXG4gICAgdmlvbGVuY2U6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY29yZSBmb3IgdGhlIGNhdGVnb3J5ICd2aW9sZW5jZS9ncmFwaGljJy5cbiAgICAgKi9cbiAgICAndmlvbGVuY2UvZ3JhcGhpYyc6IG51bWJlcjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgcG9saWN5IGNvbXBsaWFuY2UgcmVwb3J0IGJ5IE9wZW5BSSdzIGNvbnRlbnQgbW9kZXJhdGlvbiBtb2RlbCBhZ2FpbnN0XG4gKiBhIGdpdmVuIGlucHV0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25DcmVhdGVSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBtb2RlcmF0aW9uIHJlcXVlc3QuXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCB0byBnZW5lcmF0ZSB0aGUgbW9kZXJhdGlvbiByZXN1bHRzLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogQSBsaXN0IG9mIG1vZGVyYXRpb24gb2JqZWN0cy5cbiAgICovXG4gIHJlc3VsdHM6IEFycmF5PE1vZGVyYXRpb24+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVyYXRpb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGlucHV0IHRleHQgdG8gY2xhc3NpZnlcbiAgICovXG4gIGlucHV0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBUd28gY29udGVudCBtb2RlcmF0aW9ucyBtb2RlbHMgYXJlIGF2YWlsYWJsZTogYHRleHQtbW9kZXJhdGlvbi1zdGFibGVgIGFuZFxuICAgKiBgdGV4dC1tb2RlcmF0aW9uLWxhdGVzdGAuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGlzIGB0ZXh0LW1vZGVyYXRpb24tbGF0ZXN0YCB3aGljaCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXBncmFkZWRcbiAgICogb3ZlciB0aW1lLiBUaGlzIGVuc3VyZXMgeW91IGFyZSBhbHdheXMgdXNpbmcgb3VyIG1vc3QgYWNjdXJhdGUgbW9kZWwuIElmIHlvdSB1c2VcbiAgICogYHRleHQtbW9kZXJhdGlvbi1zdGFibGVgLCB3ZSB3aWxsIHByb3ZpZGUgYWR2YW5jZWQgbm90aWNlIGJlZm9yZSB1cGRhdGluZyB0aGVcbiAgICogbW9kZWwuIEFjY3VyYWN5IG9mIGB0ZXh0LW1vZGVyYXRpb24tc3RhYmxlYCBtYXkgYmUgc2xpZ2h0bHkgbG93ZXIgdGhhbiBmb3JcbiAgICogYHRleHQtbW9kZXJhdGlvbi1sYXRlc3RgLlxuICAgKi9cbiAgbW9kZWw/OiAoc3RyaW5nICYge30pIHwgJ3RleHQtbW9kZXJhdGlvbi1sYXRlc3QnIHwgJ3RleHQtbW9kZXJhdGlvbi1zdGFibGUnO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1vZGVyYXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uID0gQVBJLk1vZGVyYXRpb247XG4gIGV4cG9ydCBpbXBvcnQgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlID0gQVBJLk1vZGVyYXRpb25DcmVhdGVSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLk1vZGVyYXRpb25DcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0ICogYXMgUGFnaW5hdGlvbiBmcm9tICcuL3BhZ2luYXRpb24nO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gJy4vcmVzb3VyY2VzL2luZGV4JztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IHR5cGUgQWdlbnQgfSBmcm9tICcuL19zaGltcy9pbmRleCc7XG5pbXBvcnQgKiBhcyBVcGxvYWRzIGZyb20gJy4vdXBsb2Fkcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudltcIk9QRU5BSV9BUElfS0VZXCJdLlxuICAgKi9cbiAgYXBpS2V5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSSwgZS5nLiwgXCJodHRwczovL2FwaS5leGFtcGxlLmNvbS92Mi9cIlxuICAgKi9cbiAgYmFzZVVSTD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB3YWl0IGZvciBhIHJlc3BvbnNlXG4gICAqIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgdGltaW5nIG91dCBhIHNpbmdsZSByZXF1ZXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcmVxdWVzdCB0aW1lb3V0cyBhcmUgcmV0cmllZCBieSBkZWZhdWx0LCBzbyBpbiBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8geW91IG1heSB3YWl0XG4gICAqIG11Y2ggbG9uZ2VyIHRoYW4gdGhpcyB0aW1lb3V0IGJlZm9yZSB0aGUgcHJvbWlzZSBzdWNjZWVkcyBvciBmYWlscy5cbiAgICovXG4gIHRpbWVvdXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChTKSBjb25uZWN0aW9ucy5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCBhbiBhZ2VudCB3aWxsIGJlIGNvbnN0cnVjdGVkIGJ5IGRlZmF1bHQgaW4gdGhlIE5vZGUuanMgZW52aXJvbm1lbnQsXG4gICAqIG90aGVyd2lzZSBubyBhZ2VudCBpcyB1c2VkLlxuICAgKi9cbiAgaHR0cEFnZW50PzogQWdlbnQ7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB3ZSB1c2UgYG5vZGUtZmV0Y2hgIG9uIE5vZGUuanMgYW5kIG90aGVyd2lzZSBleHBlY3QgdGhhdCBgZmV0Y2hgIGlzXG4gICAqIGRlZmluZWQgZ2xvYmFsbHkuXG4gICAqL1xuICBmZXRjaD86IENvcmUuRmV0Y2ggfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QgaW4gY2FzZSBvZiBhXG4gICAqIHRlbXBvcmFyeSBmYWlsdXJlLCBsaWtlIGEgbmV0d29yayBlcnJvciBvciBhIDVYWCBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgcmVtb3ZlZCBpbiBpbmRpdmlkdWFsIHJlcXVlc3RzIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB0aGVcbiAgICogaGVhZGVyIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAqL1xuICBkZWZhdWx0SGVhZGVycz86IENvcmUuSGVhZGVycztcblxuICAvKipcbiAgICogRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSByZW1vdmVkIGluIGluZGl2aWR1YWwgcmVxdWVzdHMgYnkgZXhwbGljaXRseSBzZXR0aW5nIHRoZVxuICAgKiBwYXJhbSB0byBgdW5kZWZpbmVkYCBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAqL1xuICBkZWZhdWx0UXVlcnk/OiBDb3JlLkRlZmF1bHRRdWVyeTtcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICogT25seSBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB1bmRlcnN0YW5kIHRoZSByaXNrcyBhbmQgaGF2ZSBhcHByb3ByaWF0ZSBtaXRpZ2F0aW9ucyBpbiBwbGFjZS5cbiAgICovXG4gIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyPzogYm9vbGVhbjtcblxuICBvcmdhbml6YXRpb24/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQUkgZXh0ZW5kcyBDb3JlLkFQSUNsaWVudCB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBvcmdhbml6YXRpb24/OiBzdHJpbmcgfCBudWxsO1xuXG4gIHByaXZhdGUgX29wdGlvbnM6IENsaWVudE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ09QRU5BSV9BUElfS0VZJ11dIC0gVGhlIEFQSSBLZXkgdG8gc2VuZCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFzZVVSTF0gLSBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MTAgbWludXRlc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmh0dHBBZ2VudF0gLSBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAocykgY29ubmVjdGlvbnMuXG4gICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge0NvcmUuSGVhZGVyc30gb3B0cy5kZWZhdWx0SGVhZGVycyAtIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW29wdHMub3JnYW5pemF0aW9uXVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGFwaUtleSA9IENvcmUucmVhZEVudignT1BFTkFJX0FQSV9LRVknKSxcbiAgICBvcmdhbml6YXRpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9PUkdfSUQnKSA/PyBudWxsLFxuICAgIC4uLm9wdHNcbiAgfTogQ2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIlRoZSBPUEVOQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nIG9yIGVtcHR5OyBlaXRoZXIgcHJvdmlkZSBpdCwgb3IgaW5zdGFudGlhdGUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlLZXkgb3B0aW9uLCBsaWtlIG5ldyBPcGVuQUkoeyBhcGlLZXk6ICdteSBhcGlLZXknIH0pLlwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBDbGllbnRPcHRpb25zID0ge1xuICAgICAgYXBpS2V5LFxuICAgICAgb3JnYW5pemF0aW9uLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIGJhc2VVUkw6IG9wdHMuYmFzZVVSTCA/PyBgaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MWAsXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93QnJvd3NlciAmJiBDb3JlLmlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFxuICAgICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyLWxpa2UgZW52aXJvbm1lbnQuXFxuXFxuVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxcbklmIHlvdSB1bmRlcnN0YW5kIHRoZSByaXNrcyBhbmQgaGF2ZSBhcHByb3ByaWF0ZSBtaXRpZ2F0aW9ucyBpbiBwbGFjZSxcXG55b3UgY2FuIHNldCB0aGUgYGRhbmdlcm91c2x5QWxsb3dCcm93c2VyYCBvcHRpb24gdG8gYHRydWVgLCBlLmcuLFxcblxcbm5ldyBPcGVuQUkoeyBhcGlLZXksIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlIH0pO1xcblxcbmh0dHBzOi8vaGVscC5vcGVuYWkuY29tL2VuL2FydGljbGVzLzUxMTI1OTUtYmVzdC1wcmFjdGljZXMtZm9yLWFwaS1rZXktc2FmZXR5XFxuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIHN1cGVyKHtcbiAgICAgIGJhc2VVUkw6IG9wdGlvbnMuYmFzZVVSTCEsXG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgPz8gNjAwMDAwIC8qIDEwIG1pbnV0ZXMgKi8sXG4gICAgICBodHRwQWdlbnQ6IG9wdGlvbnMuaHR0cEFnZW50LFxuICAgICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgfSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB0aGlzLm9yZ2FuaXphdGlvbiA9IG9yZ2FuaXphdGlvbjtcbiAgfVxuXG4gIGNvbXBsZXRpb25zOiBBUEkuQ29tcGxldGlvbnMgPSBuZXcgQVBJLkNvbXBsZXRpb25zKHRoaXMpO1xuICBjaGF0OiBBUEkuQ2hhdCA9IG5ldyBBUEkuQ2hhdCh0aGlzKTtcbiAgZWRpdHM6IEFQSS5FZGl0cyA9IG5ldyBBUEkuRWRpdHModGhpcyk7XG4gIGVtYmVkZGluZ3M6IEFQSS5FbWJlZGRpbmdzID0gbmV3IEFQSS5FbWJlZGRpbmdzKHRoaXMpO1xuICBmaWxlczogQVBJLkZpbGVzID0gbmV3IEFQSS5GaWxlcyh0aGlzKTtcbiAgaW1hZ2VzOiBBUEkuSW1hZ2VzID0gbmV3IEFQSS5JbWFnZXModGhpcyk7XG4gIGF1ZGlvOiBBUEkuQXVkaW8gPSBuZXcgQVBJLkF1ZGlvKHRoaXMpO1xuICBtb2RlcmF0aW9uczogQVBJLk1vZGVyYXRpb25zID0gbmV3IEFQSS5Nb2RlcmF0aW9ucyh0aGlzKTtcbiAgbW9kZWxzOiBBUEkuTW9kZWxzID0gbmV3IEFQSS5Nb2RlbHModGhpcyk7XG4gIGZpbmVUdW5pbmc6IEFQSS5GaW5lVHVuaW5nID0gbmV3IEFQSS5GaW5lVHVuaW5nKHRoaXMpO1xuICBmaW5lVHVuZXM6IEFQSS5GaW5lVHVuZXMgPSBuZXcgQVBJLkZpbmVUdW5lcyh0aGlzKTtcblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdFF1ZXJ5KCk6IENvcmUuRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5kZWZhdWx0UXVlcnk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMob3B0cyksXG4gICAgICAnT3BlbkFJLU9yZ2FuaXphdGlvbic6IHRoaXMub3JnYW5pemF0aW9uLFxuICAgICAgLi4udGhpcy5fb3B0aW9ucy5kZWZhdWx0SGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGF1dGhIZWFkZXJzKG9wdHM6IENvcmUuRmluYWxSZXF1ZXN0T3B0aW9ucyk6IENvcmUuSGVhZGVycyB7XG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWAgfTtcbiAgfVxuXG4gIHN0YXRpYyBPcGVuQUkgPSB0aGlzO1xuXG4gIHN0YXRpYyBPcGVuQUlFcnJvciA9IEVycm9ycy5PcGVuQUlFcnJvcjtcbiAgc3RhdGljIEFQSUVycm9yID0gRXJyb3JzLkFQSUVycm9yO1xuICBzdGF0aWMgQVBJQ29ubmVjdGlvbkVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25FcnJvcjtcbiAgc3RhdGljIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgPSBFcnJvcnMuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbiAgc3RhdGljIEFQSVVzZXJBYm9ydEVycm9yID0gRXJyb3JzLkFQSVVzZXJBYm9ydEVycm9yO1xuICBzdGF0aWMgTm90Rm91bmRFcnJvciA9IEVycm9ycy5Ob3RGb3VuZEVycm9yO1xuICBzdGF0aWMgQ29uZmxpY3RFcnJvciA9IEVycm9ycy5Db25mbGljdEVycm9yO1xuICBzdGF0aWMgUmF0ZUxpbWl0RXJyb3IgPSBFcnJvcnMuUmF0ZUxpbWl0RXJyb3I7XG4gIHN0YXRpYyBCYWRSZXF1ZXN0RXJyb3IgPSBFcnJvcnMuQmFkUmVxdWVzdEVycm9yO1xuICBzdGF0aWMgQXV0aGVudGljYXRpb25FcnJvciA9IEVycm9ycy5BdXRoZW50aWNhdGlvbkVycm9yO1xuICBzdGF0aWMgSW50ZXJuYWxTZXJ2ZXJFcnJvciA9IEVycm9ycy5JbnRlcm5hbFNlcnZlckVycm9yO1xuICBzdGF0aWMgUGVybWlzc2lvbkRlbmllZEVycm9yID0gRXJyb3JzLlBlcm1pc3Npb25EZW5pZWRFcnJvcjtcbiAgc3RhdGljIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciA9IEVycm9ycy5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3I7XG59XG5cbmV4cG9ydCBjb25zdCB7XG4gIE9wZW5BSUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgQ29uZmxpY3RFcnJvcixcbiAgUmF0ZUxpbWl0RXJyb3IsXG4gIEJhZFJlcXVlc3RFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvcixcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgUGVybWlzc2lvbkRlbmllZEVycm9yLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IsXG59ID0gRXJyb3JzO1xuXG5leHBvcnQgaW1wb3J0IHRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuZXhwb3J0IGltcG9ydCBmaWxlRnJvbVBhdGggPSBVcGxvYWRzLmZpbGVGcm9tUGF0aDtcblxuZXhwb3J0IG5hbWVzcGFjZSBPcGVuQUkge1xuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIGV4cG9ydCBpbXBvcnQgdG9GaWxlID0gVXBsb2Fkcy50b0ZpbGU7XG4gIGV4cG9ydCBpbXBvcnQgZmlsZUZyb21QYXRoID0gVXBsb2Fkcy5maWxlRnJvbVBhdGg7XG5cbiAgZXhwb3J0IGltcG9ydCBSZXF1ZXN0T3B0aW9ucyA9IENvcmUuUmVxdWVzdE9wdGlvbnM7XG5cbiAgZXhwb3J0IGltcG9ydCBQYWdlID0gUGFnaW5hdGlvbi5QYWdlO1xuICBleHBvcnQgaW1wb3J0IFBhZ2VSZXNwb25zZSA9IFBhZ2luYXRpb24uUGFnZVJlc3BvbnNlO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ3Vyc29yUGFnZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBDdXJzb3JQYWdlUGFyYW1zID0gUGFnaW5hdGlvbi5DdXJzb3JQYWdlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEN1cnNvclBhZ2VSZXNwb25zZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZVJlc3BvbnNlO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBBUEkuQ29tcGxldGlvbnM7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbiA9IEFQSS5Db21wbGV0aW9uO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DaG9pY2UgPSBBUEkuQ29tcGxldGlvbkNob2ljZTtcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uVXNhZ2UgPSBBUEkuQ29tcGxldGlvblVzYWdlO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBBUEkuQ29tcGxldGlvbkNyZWF0ZVBhcmFtcztcbiAgZXhwb3J0IGltcG9ydCBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkNvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmc7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyA9IEFQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ2hhdCA9IEFQSS5DaGF0O1xuXG4gIGV4cG9ydCBpbXBvcnQgRWRpdHMgPSBBUEkuRWRpdHM7XG4gIGV4cG9ydCBpbXBvcnQgRWRpdCA9IEFQSS5FZGl0O1xuICBleHBvcnQgaW1wb3J0IEVkaXRDcmVhdGVQYXJhbXMgPSBBUEkuRWRpdENyZWF0ZVBhcmFtcztcblxuICBleHBvcnQgaW1wb3J0IEVtYmVkZGluZ3MgPSBBUEkuRW1iZWRkaW5ncztcbiAgZXhwb3J0IGltcG9ydCBDcmVhdGVFbWJlZGRpbmdSZXNwb25zZSA9IEFQSS5DcmVhdGVFbWJlZGRpbmdSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBFbWJlZGRpbmcgPSBBUEkuRW1iZWRkaW5nO1xuICBleHBvcnQgaW1wb3J0IEVtYmVkZGluZ0NyZWF0ZVBhcmFtcyA9IEFQSS5FbWJlZGRpbmdDcmVhdGVQYXJhbXM7XG5cbiAgZXhwb3J0IGltcG9ydCBGaWxlcyA9IEFQSS5GaWxlcztcbiAgZXhwb3J0IGltcG9ydCBGaWxlQ29udGVudCA9IEFQSS5GaWxlQ29udGVudDtcbiAgZXhwb3J0IGltcG9ydCBGaWxlRGVsZXRlZCA9IEFQSS5GaWxlRGVsZXRlZDtcbiAgZXhwb3J0IGltcG9ydCBGaWxlT2JqZWN0ID0gQVBJLkZpbGVPYmplY3Q7XG4gIGV4cG9ydCBpbXBvcnQgRmlsZU9iamVjdHNQYWdlID0gQVBJLkZpbGVPYmplY3RzUGFnZTtcbiAgZXhwb3J0IGltcG9ydCBGaWxlQ3JlYXRlUGFyYW1zID0gQVBJLkZpbGVDcmVhdGVQYXJhbXM7XG5cbiAgZXhwb3J0IGltcG9ydCBJbWFnZXMgPSBBUEkuSW1hZ2VzO1xuICBleHBvcnQgaW1wb3J0IEltYWdlID0gQVBJLkltYWdlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlc1Jlc3BvbnNlID0gQVBJLkltYWdlc1Jlc3BvbnNlO1xuICBleHBvcnQgaW1wb3J0IEltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zID0gQVBJLkltYWdlQ3JlYXRlVmFyaWF0aW9uUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEltYWdlRWRpdFBhcmFtcyA9IEFQSS5JbWFnZUVkaXRQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgSW1hZ2VHZW5lcmF0ZVBhcmFtcyA9IEFQSS5JbWFnZUdlbmVyYXRlUGFyYW1zO1xuXG4gIGV4cG9ydCBpbXBvcnQgQXVkaW8gPSBBUEkuQXVkaW87XG5cbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9ucyA9IEFQSS5Nb2RlcmF0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uID0gQVBJLk1vZGVyYXRpb247XG4gIGV4cG9ydCBpbXBvcnQgTW9kZXJhdGlvbkNyZWF0ZVJlc3BvbnNlID0gQVBJLk1vZGVyYXRpb25DcmVhdGVSZXNwb25zZTtcbiAgZXhwb3J0IGltcG9ydCBNb2RlcmF0aW9uQ3JlYXRlUGFyYW1zID0gQVBJLk1vZGVyYXRpb25DcmVhdGVQYXJhbXM7XG5cbiAgZXhwb3J0IGltcG9ydCBNb2RlbHMgPSBBUEkuTW9kZWxzO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsID0gQVBJLk1vZGVsO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsRGVsZXRlZCA9IEFQSS5Nb2RlbERlbGV0ZWQ7XG4gIGV4cG9ydCBpbXBvcnQgTW9kZWxzUGFnZSA9IEFQSS5Nb2RlbHNQYWdlO1xuXG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmluZyA9IEFQSS5GaW5lVHVuaW5nO1xuXG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVzID0gQVBJLkZpbmVUdW5lcztcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZSA9IEFQSS5GaW5lVHVuZTtcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZUV2ZW50ID0gQVBJLkZpbmVUdW5lRXZlbnQ7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2UgPSBBUEkuRmluZVR1bmVFdmVudHNMaXN0UmVzcG9uc2U7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVzUGFnZSA9IEFQSS5GaW5lVHVuZXNQYWdlO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lQ3JlYXRlUGFyYW1zID0gQVBJLkZpbmVUdW5lQ3JlYXRlUGFyYW1zO1xuICBleHBvcnQgaW1wb3J0IEZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtcyA9IEFQSS5GaW5lVHVuZUxpc3RFdmVudHNQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zTm9uU3RyZWFtaW5nID0gQVBJLkZpbmVUdW5lTGlzdEV2ZW50c1BhcmFtc05vblN0cmVhbWluZztcbiAgZXhwb3J0IGltcG9ydCBGaW5lVHVuZUxpc3RFdmVudHNQYXJhbXNTdHJlYW1pbmcgPSBBUEkuRmluZVR1bmVMaXN0RXZlbnRzUGFyYW1zU3RyZWFtaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBPcGVuQUk7XG4iLCAiaW1wb3J0IE9wZW5BSSBmcm9tIFwib3BlbmFpXCI7XHJcblxyXG5pbXBvcnQge1xyXG5cdFBpbmVjb25lLFxyXG5cdFBpbmVjb25lUmVjb3JkLFxyXG5cdFJlY29yZE1ldGFkYXRhLFxyXG59IGZyb20gXCJAcGluZWNvbmUtZGF0YWJhc2UvcGluZWNvbmVcIjtcclxuaW1wb3J0IHBsdWdpbkhhbmRsZXIgZnJvbSBcIi4vZ2xvYmFsSGFuZGxlcnNcIjtcclxuaW1wb3J0IHsgTWFya2Rvd25WaWV3LCBURmlsZSwgcGFyc2VMaW5rdGV4dCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBhZGRSZXF1aXJlbWVudCB9IGZyb20gXCIuL3RlbXBsYXRlc1wiO1xyXG5pbXBvcnQgeyBpbnNlcnRNYXJrZG93blVuZGVySGVhZGluZyB9IGZyb20gXCIuL2ZpbGVzXCI7XHJcbi8vIGltcG9ydCB7IHJlcXVpcmVtZW50c0RCIH0gZnJvbSBcIi4vZGF0YWJhc2VBZGFwdGVyXCI7XHJcblxyXG5jb25zdCBwaW5lY29uZSA9IG5ldyBQaW5lY29uZSh7XHJcblx0YXBpS2V5OiBcIjgxZjU2ZDgxLWI2ZmYtNGFmNC1iM2Y1LTMxMDhkNzMwYmI4OFwiLFxyXG5cdGVudmlyb25tZW50OiBcImdjcC1zdGFydGVyXCIsXHJcbn0pO1xyXG5cclxuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7XHJcblx0YXBpS2V5OiBcInNrLUpqaEQ1M1Q0bUpHQmVCNmlJS0ZrVDNCbGJrRkpCYmpsZ0N6RUxpdFJFSlB4amx2Q1wiLCAvLyBkZWZhdWx0cyB0byBwcm9jZXNzLmVudltcIk9QRU5BSV9BUElfS0VZXCJdXHJcblx0ZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUsXHJcbn0pO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0RW1iZWRNYXJrZG93bih7XHJcblx0cGF0aCxcclxuXHRzdWJwYXRoLFxyXG59OiB7XHJcblx0cGF0aDogc3RyaW5nO1xyXG5cdHN1YnBhdGg6IHN0cmluZztcclxufSkge1xyXG5cdGNvbnN0IHsgbWV0YWRhdGFDYWNoZSwgdmF1bHQgfSA9IGFwcDtcclxuXHRjb25zdCBmaWxlID0gbWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCBcIlwiKSBhcyBURmlsZTtcclxuXHRjb25zdCBoZWFkaW5ncyA9IG1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5oZWFkaW5ncyA/PyBbXTtcclxuXHRsZXQgdGV4dCA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblx0aWYgKHN1YnBhdGgpIHtcclxuXHRcdGNvbnN0IGhJZHggPSBoZWFkaW5ncy5maW5kSW5kZXgoXHJcblx0XHRcdCh7IGhlYWRpbmcgfTogYW55KSA9PiBoZWFkaW5nID09PSBzdWJwYXRoXHJcblx0XHQpO1xyXG5cdFx0aWYgKGhJZHggPT09IC0xKSB7XHJcblx0XHRcdHRleHQgPSBcIlwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGV4dCA9IHRleHRcclxuXHRcdFx0XHQuc3BsaXQoXCJcXG5cIilcclxuXHRcdFx0XHQuc2xpY2UoXHJcblx0XHRcdFx0XHRoZWFkaW5nc1toSWR4XS5wb3NpdGlvbi5zdGFydC5saW5lICsgMSxcclxuXHRcdFx0XHRcdGhlYWRpbmdzW2hJZHggKyAxXT8ucG9zaXRpb24/LnN0YXJ0Py5saW5lXHJcblx0XHRcdFx0KVxyXG5cdFx0XHRcdC5qb2luKFwiXFxuXCIpXHJcblx0XHRcdFx0LnRyaW0oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRleHRcclxuXHRcdC5zcGxpdChcIlxcblwiKVxyXG5cdFx0Lm1hcCgobGluZTogc3RyaW5nKSA9PiBgJHtsaW5lfWApXHJcblx0XHQuam9pbihcIlxcblwiKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGludGVyZmFjZXNUYWJsZShmaWxlOiBURmlsZSkge1xyXG5cdGNvbnN0IHsgZGF0YXZpZXc6IGR2IH0gPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKTtcclxuXHRjb25zdCBhcHAgPSBwbHVnaW5IYW5kbGVyLmFwcDtcclxuXHJcblx0Y29uc3QgcmVuZGVyID0gW107XHJcblxyXG5cdGNvbnN0IGNvbm5lY3Rpb25zSnNvbiA9IEpTT04ucGFyc2UoXHJcblx0XHRhd2FpdCBhcHAudmF1bHQucmVhZChcclxuXHRcdFx0YXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoXHJcblx0XHRcdFx0XCJTeXN0ZW0gRGlhZ3JhbS5jYW52YXNcIixcclxuXHRcdFx0XHRcIlwiXHJcblx0XHRcdCkgYXMgVEZpbGVcclxuXHRcdClcclxuXHQpO1xyXG5cclxuXHQvLyB7XCJpZFwiOlwiOThmMzJhYTljZmVkZTliNVwiLFwidHlwZVwiOlwiZ3JvdXBcIixcImZpbGVcIjpcIlJvY2tldCBTeXN0ZW1zL1JlY292ZXJ5L05vc2Vjb25lIEVqZWN0aW9uIFN5c3RlbS5tZFwiLFwieFwiOjc0MCxcInlcIjotNDIwLFwid2lkdGhcIjoyNjAsXCJoZWlnaHRcIjoxMjAsXCJsYWJlbFwiOlwiTm9zZWNvbmUgRWplY3Rpb24gU3lzdGVtXCJ9LFxyXG5cdGNvbnN0IHRoaXNOb2RlID0gY29ubmVjdGlvbnNKc29uLm5vZGVzLmZpbmQoKG5vZGU6IGFueSkgPT5cclxuXHRcdGZpbGUucGF0aC5pbmNsdWRlcyhub2RlLmZpbGUpXHJcblx0KTtcclxuXHJcblx0Ly8ge1wiaWRcIjpcIjc3NDNiYjQzNWQ4MzExYTdcIixcImZyb21Ob2RlXCI6XCI5OGYzMmFhOWNmZWRlOWI1XCIsXCJmcm9tU2lkZVwiOlwiYm90dG9tXCIsXCJ0b05vZGVcIjpcIjJjMmJmZWUzNGM4YjU0NzZcIixcInRvU2lkZVwiOlwicmlnaHRcIixcImxhYmVsXCI6XCJcdTI2QTBcdUZFMEZcIn0sXHJcblxyXG5cdGNvbnN0IGNvbm5lY3RpbmdUbyA9IGNvbm5lY3Rpb25zSnNvbi5lZGdlcy5maWx0ZXIoXHJcblx0XHQoZWRnZTogYW55KSA9PiBlZGdlLmZyb21Ob2RlID09PSB0aGlzTm9kZS5pZFxyXG5cdCk7XHJcblx0Y29uc3QgY29ubmVjdGluZ0Zyb20gPSBjb25uZWN0aW9uc0pzb24uZWRnZXMuZmlsdGVyKFxyXG5cdFx0KGVkZ2U6IGFueSkgPT4gZWRnZS50b05vZGUgPT09IHRoaXNOb2RlLmlkXHJcblx0KTtcclxuXHJcblx0Y29uc3QgY29ubmVjdGlvbnMgPSBbLi4uY29ubmVjdGluZ1RvLCAuLi5jb25uZWN0aW5nRnJvbV07XHJcblxyXG5cdGZvciAobGV0IGNvbm5lY3Rpb24gb2YgY29ubmVjdGlvbnMpIHtcclxuXHRcdC8vIGdldCB0aGUgZmlsZSB0aGF0IHRoZSBjb25uZWN0aW9uIGlzIHBvaW50aW5nIHRvIGFuZCB0aGUgaW50ZXJmYWNlIG5hbWVcclxuXHRcdGNvbnN0IGludCA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KFxyXG5cdFx0XHRjb25uZWN0aW9uLmxhYmVsLFxyXG5cdFx0XHRcIlwiXHJcblx0XHQpIGFzIFRGaWxlO1xyXG5cclxuXHRcdGNvbnN0IG5vZGUgPSBjb25uZWN0aW9uc0pzb24ubm9kZXMuZmluZChcclxuXHRcdFx0KG5vZGU6IGFueSkgPT5cclxuXHRcdFx0XHQoY29ubmVjdGlvbi5mcm9tTm9kZSA9PT0gbm9kZS5pZCAmJlxyXG5cdFx0XHRcdFx0Y29ubmVjdGlvbi50b05vZGUgPT09IHRoaXNOb2RlLmlkKSB8fFxyXG5cdFx0XHRcdChjb25uZWN0aW9uLnRvTm9kZSA9PT0gbm9kZS5pZCAmJlxyXG5cdFx0XHRcdFx0Y29ubmVjdGlvbi5mcm9tTm9kZSA9PT0gdGhpc05vZGUuaWQpXHJcblx0XHQpO1xyXG5cclxuXHRcdGNvbnN0IG5vZGVGaWxlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3Qobm9kZS5maWxlLCBcIlwiKTtcclxuXHJcblx0XHRyZW5kZXIucHVzaChbXHJcblx0XHRcdGludCA/IGBbWyR7aW50LmJhc2VuYW1lfV1dYCA6IFwiTm9uZVx1MjZBMFx1RkUwRlwiLFxyXG5cdFx0XHRgW1ske25vZGVGaWxlPy5iYXNlbmFtZX1dXWAsXHJcblx0XHRdKTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHRhYmxlTWFya2Rvd24gPSByZW5kZXIubGVuZ3RoXHJcblx0XHQ/IFwiXFxuXCIgKyBkdi5tYXJrZG93blRhYmxlKFtcIkludGVyZmFjZSBOYW1lXCIsIFwiQ29ubmVjdGluZyBUb1wiXSwgcmVuZGVyKVxyXG5cdFx0OiBcIlwiO1xyXG5cdHJldHVybiB0YWJsZU1hcmtkb3duO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdHNUYWJsZShmaWxlOiBURmlsZSkge1xyXG5cdGNvbnN0IHsgZGF0YXZpZXc6IGR2LCBza2Ffc2UgfSA9IHBsdWdpbkhhbmRsZXIuZ2V0UGx1Z2lucygpO1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlIGFzIFRGaWxlKTtcclxuXHJcblx0Y29uc3QgdGVzdHMgPSBkdlxyXG5cdFx0LnBhZ2VzKGBcIiR7c2thX3NlLnNldHRpbmdzLnRlc3RfZG9jdW1lbnRhdGlvbl9yb290X2ZvbGRlcn1cImApXHJcblx0XHQud2hlcmUoKHRlc3Q6IGFueSkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gdGVzdC5TeXN0ZW0gJiYgdGVzdC5TeXN0ZW0ucGF0aC5pbmNsdWRlcyhmaWxlLnBhdGgpO1xyXG5cdFx0fSkudmFsdWVzO1xyXG5cclxuXHRpZiAodGVzdHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcclxuXHJcblx0Ly9tb2RpZnkgdGhlIHRlc3RzIGxpc3QuIDEuIEZpbmQgcG9zaXRpb24gb2YgdGhlIGhlYWRlciBcIlN5c3RlbSBUZXN0c1wiLiAyLiBpbnNlcnQgdGhlIHRlc3RzIGxpc3QgYWZ0ZXIgdGhlIGhlYWRlclxyXG5cdGNvbnN0IHRlc3RzU2VjdGlvbiA9IGNhY2hlPy5oZWFkaW5ncz8uZmluZChcclxuXHRcdChoKSA9PiBoLmhlYWRpbmcgPT09IFwiU3lzdGVtIFRlc3RzXCJcclxuXHQpO1xyXG5cdGNvbnN0IHRlc3RzSGVhZGluZ0luZGV4ID0gY2FjaGU/LnNlY3Rpb25zPy5maW5kSW5kZXgoXHJcblx0XHQoc2VjdGlvbikgPT5cclxuXHRcdFx0c2VjdGlvbi5wb3NpdGlvbi5zdGFydC5saW5lID09PSB0ZXN0c1NlY3Rpb24/LnBvc2l0aW9uLnN0YXJ0LmxpbmVcclxuXHQpO1xyXG5cclxuXHRjb25zdCBsaXN0RGF0YSA9XHJcblx0XHRcIlxcblwiICtcclxuXHRcdGR2Lm1hcmtkb3duTGlzdChcclxuXHRcdFx0dGVzdHMubWFwKFxyXG5cdFx0XHRcdCh0ZXN0OiBhbnkpID0+XHJcblx0XHRcdFx0XHRgW1ske3Rlc3QuZmlsZS5wYXRofXwke3Rlc3QuZmlsZS5uYW1lfV1dICR7XHJcblx0XHRcdFx0XHRcdHRlc3QuU3RhdHVzID09PSBcInN1Y2Nlc3NcIiA/IFwiXFx0XHUyNzA1XCIgOiBcIlxcdFx1Mjc0Q1wiXHJcblx0XHRcdFx0XHR9YFxyXG5cdFx0XHQpXHJcblx0XHQpO1xyXG5cclxuXHRyZXR1cm4gbGlzdERhdGEgPz8gXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVpcmVtZW50c1RhYmxlMihmaWxlOiBURmlsZSkge1xyXG5cdGNvbnN0IHsgZGF0YXZpZXc6IGR2LCBza2Ffc2UgfSA9IHBsdWdpbkhhbmRsZXIuZ2V0UGx1Z2lucygpO1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlIGFzIFRGaWxlKTtcclxuXHJcblx0Y29uc3QgdGhpc1JlcXVpcmVtZW50cyA9IGR2XHJcblx0XHQucGFnZXMoYFwiJHtza2Ffc2Uuc2V0dGluZ3Muc3lzdGVtX2Rlc2lnbl9yb290X2ZvbGRlcn0vUmVxdWlyZW1lbnRzXCJgKVxyXG5cdFx0LndoZXJlKChyZXE6IGFueSkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gcmVxLlN5c3RlbSAmJiByZXEuU3lzdGVtID09IGNhY2hlPy5mcm9udG1hdHRlcj8uSUQ7XHJcblx0XHR9KS52YWx1ZXM7XHJcblxyXG5cdGlmICh0aGlzUmVxdWlyZW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiXCI7XHJcblxyXG5cdC8vIGV4dHJhY3QgdGhlIHJlcXVpcmVtZW50cyBkYXRhIGZyb20gdGhlIHRoaXNSZXF1aXJlbWVudHMgbGlzdFxyXG5cclxuXHRjb25zdCB0YWJsZVZhbHVlczogW3N0cmluZywgc3RyaW5nXVtdID0gW107XHJcblxyXG5cdGZvciAoY29uc3QgcmVxIG9mIHRoaXNSZXF1aXJlbWVudHMpIHtcclxuXHRcdGNvbnN0IHRvUmV0dXJuOiBbc3RyaW5nLCBzdHJpbmddID0gW1wiXCIsIFwiXCJdO1xyXG5cdFx0dG9SZXR1cm5bMF0gPSBhd2FpdCBnZXRFbWJlZE1hcmtkb3duKHtcclxuXHRcdFx0cGF0aDogcmVxLmZpbGUucGF0aCxcclxuXHRcdFx0c3VicGF0aDogXCJEZXNjcmlwdGlvblwiLFxyXG5cdFx0fSk7XHJcblx0XHR0b1JldHVyblsxXSA9IFwiW1tcIiArIHJlcS5maWxlLnBhdGguc3BsaXQoXCIvXCIpLnBvcCgpICsgXCJdXVwiO1xyXG5cdFx0dGFibGVWYWx1ZXMucHVzaCh0b1JldHVybik7XHJcblx0fVxyXG5cclxuXHRjb25zdCB0YWJsZUhlYWRlcnMgPSBbXCJEZXNjcmlwdGlvblwiLCBcIlNvdXJjZVwiXTtcclxuXHJcblx0Y29uc3QgdGFibGVNYXJrZG93biA9IFwiXFxuXCIgKyBkdi5tYXJrZG93blRhYmxlKHRhYmxlSGVhZGVycywgdGFibGVWYWx1ZXMpO1xyXG5cdHJldHVybiB0YWJsZU1hcmtkb3duID8/IFwiXCI7XHJcbn1cclxuXHJcbnR5cGUgVmVjdG9yVHlwZSA9IHtcclxuXHRpZDogc3RyaW5nO1xyXG5cdGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcblx0c291cmNlOiBzdHJpbmc7XHJcblx0c3lzdGVtOiBzdHJpbmc7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcGFyZVJlcXVpcmVtZW50cyhcclxuXHRyZXM6IFBpbmVjb25lUmVjb3JkPFJlY29yZE1ldGFkYXRhPiB8IHVuZGVmaW5lZFxyXG4pIHtcclxuXHQvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSBhIHNlYXJjaCBpbiBhIHZlY3RvciBkYXRhYmFzZSBhbmQgcmV0dXJuIGEgbGlzdCBvZiByZXF1aXJlbWVudHMgdGhhdCBtYXRjaCB0aGUgc2VhcmNoIGFib3ZlIGEgY2VydGFpbiB0aHJlc2hvbGRcclxuXHQvLyB0aGUgdGhyZXNob2xkIGlzIHNldCB0byAwLjcgZm9yIG5vdywgYnV0IGNhbiBiZSBjaGFuZ2VkIGxhdGVyXHJcblx0Ly8gaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMsIGNvbmZsaWN0aW5nIHJlcXVpcmVtZW50IHNob3VsZCBiZSByZXR1cm5lZFxyXG5cclxuXHRpZiAoIXJlcykgcmV0dXJuO1xyXG5cclxuXHRjb25zdCBzZWFyY2hSZXN1bHQgPSBhd2FpdCBwaW5lY29uZS5pbmRleChcInJlcXVpcmVtZW50c1wiKS5xdWVyeSh7XHJcblx0XHR2ZWN0b3I6IHJlcy52YWx1ZXMsXHJcblx0XHR0b3BLOiAxMCxcclxuXHRcdGluY2x1ZGVNZXRhZGF0YTogdHJ1ZSxcclxuXHR9KTtcclxuXHJcblx0Y29uc3QgcG90ZW50aWFsQ29uZmxpY3RzID0gc2VhcmNoUmVzdWx0Lm1hdGNoZXNcclxuXHRcdD8uZmlsdGVyKFxyXG5cdFx0XHQobWF0Y2gpID0+XHJcblx0XHRcdFx0bWF0Y2guc2NvcmUgJiZcclxuXHRcdFx0XHRtYXRjaC5zY29yZSA+IDAuOSAmJlxyXG5cdFx0XHRcdG1hdGNoLnNjb3JlIDwgMC45OSAmJlxyXG5cdFx0XHRcdG1hdGNoLm1ldGFkYXRhPy5kZXNjcmlwdGlvbiAhPT0gcmVzLm1ldGFkYXRhPy5kZXNjcmlwdGlvblxyXG5cdFx0KVxyXG5cdFx0Lm1hcChcclxuXHRcdFx0KG1hdGNoKSA9PlxyXG5cdFx0XHRcdFwiLSBcIiArXHJcblx0XHRcdFx0bWF0Y2gubWV0YWRhdGE/LmRlc2NyaXB0aW9uICtcclxuXHRcdFx0XHRgXFxuRmlsZSBwYXRoOiAke21hdGNoLm1ldGFkYXRhPy5wYXRofWBcclxuXHRcdClcclxuXHRcdC5qb2luKFwiXFxuXFxuXCIpO1xyXG5cclxuXHRpZiAoIXBvdGVudGlhbENvbmZsaWN0cyB8fCBwb3RlbnRpYWxDb25mbGljdHMgPT09IFwiXCIpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiTm8gY29uZmxpY3RzIGZvdW5kXCIpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0Y29uc29sZS5sb2cocG90ZW50aWFsQ29uZmxpY3RzKTtcclxuXHJcblx0Y29uc3QgcHJvbXB0ID0gYEdpdmVuIHJlcXVpcmVtZW50OlxyXG5cdFx0JHtyZXMubWV0YWRhdGE/LmRlc2NyaXB0aW9ufVxyXG5cdFx0XHJcblx0XHRSZXF1aXJlbWVudHMgdG8gY29tcGFyZSB0bzpcclxuXHRcdCR7cG90ZW50aWFsQ29uZmxpY3RzfVxyXG5cclxuXHRcdC0tLVxyXG5cdFx0QXJlIHRoZXJlIGFueSBjb25mbGljdHMgYmV0d2VlbiB0aGUgZ2l2ZW4gcmVxdWlyZW1lbnQgYW5kIHRoZSByZXF1aXJlbWVudHMgdG8gY29tcGFyZT8gWUVTL05PIC0gc2hvcnQgcmVhc29uaW5nIC0gW1tmaWxlIHBhdGhdXWA7XHJcblxyXG5cdGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XHJcblx0XHRtb2RlbDogXCJncHQtNFwiLFxyXG5cdFx0bWVzc2FnZXM6IFtcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJvbGU6IFwic3lzdGVtXCIsXHJcblx0XHRcdFx0Y29udGVudDogYFlvdSBhcmUgYW4gZW5naW5lZXJpbmcgYXNzaXN0YW50IHRhc2tlZCB3aXRoIGNvbXBhcmluZyBhIHNldCBvZiByZXF1aXJlbWVudHMgYW5kIGRldGVjdGluZyBpZiB0aGVyZSBhcmUgYW55IHBvdGVudGlhbCBjb25mbGljdHMgYmV0d2VlbiB0aGVtLlxyXG5cdFx0XHRcdFx0WW91IHNob3VsZCBvbmx5IHJlc3BvbmQgaW4gYSBmb2xsb3dpbmcgZm9ybWF0OiBZRVMvTk8vVU5DTEVBUiAtIHNob3J0IHJlYXNvbmluZyAtIFtbZmlsZSBwYXRoXV0uIFJlbWVtYmVyIGFib3V0IHRoZSBkb3VibGUgYnJhY2tldHMgYXJvdW5kIHRoZSBmaWxlIHBhdGguXHJcblx0XHRcdFx0XHRSZW1lbWJlciB0byBwcm92aWRlIHJlYXNvbmluZyBpbiBhIHNob3J0IGJ1dCBjbGVhciB3YXkuIElmIHRoZSBhbnN3ZXIgaXMgWUVTLCB5b3Ugc2hvdWxkIGFsc28gcHJvdmlkZSBhIGJyaWVmIGRlc2NyaXB0aW9uIG9mIGEgcG9zc2libGUgd2F5cyB0byByZXNvbHZlIHRoZSBpc3N1ZS5cclxuXHRcdFx0XHRcdElmIHRoZSBhbnN3ZXIgaXMgVU5DTEVBUiBwcm92aWRlIGEgc2hvcnQgaW5zdHJ1Y3Rpb24gb24gaG93IHRoZSByZXF1aXJlbWVudCBjYW4gYmUgaW1wcm92ZWQuIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb25mbGljdHMsIHByb3ZpZGUgYSByZXNwb25zZSBvbmx5IGZvciB0aGUgb25lIHRoYXQgaXMgY29uZmxpY3RpbmdgLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0cm9sZTogXCJ1c2VyXCIsXHJcblx0XHRcdFx0Y29udGVudDogcHJvbXB0LFxyXG5cdFx0XHR9LFxyXG5cdFx0XSxcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdC5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZEVtYmVkKHZhbHVlOiBWZWN0b3JUeXBlLCBmaWxlOiB7IHBhdGg6IHN0cmluZyB9KSB7XHJcblx0Ly8gdGhpcyBjYW4gYmUgYWRqdXN0ZWQgdG8gY3JlYXRlIGEgYmV0dGVyIGVtYmVkZGluZywgYWRkaW5nIG1vcmUgY29udGV4dCB0byB0aGUgaW5wdXRcclxuXHRjb25zdCB0ZXh0ID0gYFN5c3RlbTogXHJcblx0XHQke3ZhbHVlLnN5c3RlbX1cclxuXHJcblx0XHREZXNjcmlwdGlvbjpcclxuXHRcdCR7dmFsdWUuZGVzY3JpcHRpb259XHJcblxyXG5cdFx0U291cmNlOlxyXG5cdFx0JHt2YWx1ZS5zb3VyY2V9YDtcclxuXHJcblx0Y29uc3QgcmVzID0gKGF3YWl0IHBpbmVjb25lLmluZGV4KFwicmVxdWlyZW1lbnRzXCIpLmZldGNoKFt2YWx1ZS5pZF0pKVxyXG5cdFx0LnJlY29yZHM/Llt2YWx1ZS5pZF07XHJcblxyXG5cdC8vY29tcGFyZSB0aGUgcmVzIG9iamVjdCB3aXRoIHRoZSBwYXNzZWQgdmFsdWVcclxuXHQvL2lmIHRoZXkgYXJlIHRoZSBzYW1lLCByZXR1cm5cclxuXHQvL2Vsc2UsIHVwZGF0ZSB0aGUgZW1iZWRkaW5nXHJcblx0aWYgKFxyXG5cdFx0cmVzPy5tZXRhZGF0YT8uZGVzY3JpcHRpb24gPT09IHZhbHVlLmRlc2NyaXB0aW9uICYmXHJcblx0XHRyZXMubWV0YWRhdGEuc291cmNlID09PSB2YWx1ZS5zb3VyY2VcclxuXHQpIHtcclxuXHRcdGlmIChyZXM/Lm1ldGFkYXRhPy5wYXRoICE9PSBmaWxlLnBhdGgpIHtcclxuXHRcdFx0YXdhaXQgcGluZWNvbmVcclxuXHRcdFx0XHQuaW5kZXgoXCJyZXF1aXJlbWVudHNcIilcclxuXHRcdFx0XHQudXBkYXRlKHsgaWQ6IHJlcy5pZCwgbWV0YWRhdGE6IHsgcGF0aDogZmlsZS5wYXRoIH0gfSk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Li4ucmVzLFxyXG5cdFx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0XHQuLi5yZXMubWV0YWRhdGEsXHJcblx0XHRcdFx0XHRwYXRoOiBmaWxlLnBhdGgsXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiByZXM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjb25zdCBlbWJlZGRpbmcgPSBhd2FpdCBvcGVuYWkuZW1iZWRkaW5ncy5jcmVhdGUoe1xyXG5cdFx0aW5wdXQ6IHRleHQsXHJcblx0XHRtb2RlbDogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsXHJcblx0fSk7XHJcblxyXG5cdGF3YWl0IHBpbmVjb25lLmluZGV4KFwicmVxdWlyZW1lbnRzXCIpLnVwc2VydChbXHJcblx0XHR7XHJcblx0XHRcdGlkOiB2YWx1ZS5pZCxcclxuXHRcdFx0dmFsdWVzOiBlbWJlZGRpbmcuZGF0YVswXS5lbWJlZGRpbmcsXHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uLFxyXG5cdFx0XHRcdHNvdXJjZTogdmFsdWUuc291cmNlLFxyXG5cdFx0XHRcdHN5c3RlbTogdmFsdWUuc3lzdGVtLFxyXG5cdFx0XHRcdHBhdGg6IGZpbGUucGF0aCxcclxuXHRcdFx0fSxcclxuXHRcdH0sXHJcblx0XSk7XHJcblxyXG5cdGNvbnN0IHJlc0FkZGVkID0gKGF3YWl0IHBpbmVjb25lLmluZGV4KFwicmVxdWlyZW1lbnRzXCIpLmZldGNoKFt2YWx1ZS5pZF0pKVxyXG5cdFx0LnJlY29yZHM/Llt2YWx1ZS5pZF07XHJcblxyXG5cdHJldHVybiByZXNBZGRlZDtcclxufVxyXG4iLCAiaW1wb3J0IHsgVEZpbGUsIFRGb2xkZXIsIFdvcmtzcGFjZVNwbGl0IH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBwbHVnaW5IYW5kbGVyIGZyb20gXCIuL2dsb2JhbEhhbmRsZXJzXCI7XHJcbmltcG9ydCB7IHJlYWRGaWxlIH0gZnJvbSBcImZzL3Byb21pc2VzXCI7XHJcblxyXG50eXBlIEFkZFJlcXVpcmVtZW50QXJncyA9IHtcclxuXHRkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG5cdHNvdXJjZTogc3RyaW5nO1xyXG5cdHN5c3RlbTogc3RyaW5nO1xyXG5cdGlkPzogc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZFJlcXVpcmVtZW50KGFyZ3M6IEFkZFJlcXVpcmVtZW50QXJncykge1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cdGNvbnN0IHsgc2thX3NlIH0gPSBwbHVnaW5IYW5kbGVyLmdldFBsdWdpbnMoKTtcclxuXHJcblx0Y29uc3QgcmVxdWlyZW1lbnRUZW1wbGF0ZSA9IGF3YWl0IHJlYWRGaWxlKFxyXG5cdFx0YXBwLnZhdWx0LmFkYXB0ZXIuZ2V0QmFzZVBhdGgoKSArXHJcblx0XHRcdFwiLy5vYnNpZGlhbi9wbHVnaW5zL3NrYV9zZS90ZW1wbGF0ZXMvcmVxdWlyZW1lbnQudGVtcGxhdGUubWRcIlxyXG5cdCk7XHJcblxyXG5cdC8vIHJlcGxhY2UgJXN5c3RlbSUgd2l0aCBzeXN0ZW0ncyBuYW1lIGFuZCAlaWQlIHdpdGggY29tcG9uZW50J3MgaWQgd2hpY2ggaXMgc3lzdGVtIG5hbWUgKyBjb21wb25lbnQgbmFtZVxyXG5cdGxldCBkYXRhID0gcmVxdWlyZW1lbnRUZW1wbGF0ZVxyXG5cdFx0LnRvU3RyaW5nKClcclxuXHRcdC5yZXBsYWNlKC8lc3lzdGVtJS9nLCBhcmdzLnN5c3RlbSlcclxuXHRcdC5yZXBsYWNlKC8lZGVzY3JpcHRpb24lL2csIGFyZ3MuZGVzY3JpcHRpb24pXHJcblx0XHQucmVwbGFjZSgvJXNvdXJjZSUvZywgYXJncy5zb3VyY2UpO1xyXG5cclxuXHRpZiAoIWFyZ3MuaWQpIHtcclxuXHRcdGNvbnN0IG51bV9lcXVpcmVtZW50cyA9IGFwcC52YXVsdFxyXG5cdFx0XHQuZ2V0RmlsZXMoKVxyXG5cdFx0XHQuZmlsdGVyKChmaWxlKSA9PlxyXG5cdFx0XHRcdGZpbGUuYmFzZW5hbWUuc3RhcnRzV2l0aChgUkVRLiR7YXJncy5zeXN0ZW19LmApXHJcblx0XHRcdCkubGVuZ3RoO1xyXG5cdFx0YXJncy5pZCA9IGBSRVEuJHthcmdzLnN5c3RlbX0uJHtudW1fZXF1aXJlbWVudHMgKyAxfWA7XHJcblx0fVxyXG5cclxuXHRpZiAoYXJncy5pZCkge1xyXG5cdFx0ZGF0YSA9IGRhdGEucmVwbGFjZSgvJWlkJS9nLCBhcmdzLmlkLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikpO1xyXG5cdH1cclxuXHJcblx0Y29uc3Qgcm9vdFBhdGggPSBza2Ffc2Uuc2V0dGluZ3Muc3lzdGVtX2Rlc2lnbl9yb290X2ZvbGRlcjtcclxuXHJcblx0cmV0dXJuIGF3YWl0IGFwcC52YXVsdC5jcmVhdGUoXHJcblx0XHRyb290UGF0aCArIFwiL1JlcXVpcmVtZW50cy9cIiArIGFyZ3MuaWQgKyBcIi5tZFwiLFxyXG5cdFx0ZGF0YVxyXG5cdCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRDb21wb25lbnQoe1xyXG5cdHN5c3RlbSxcclxuXHRwYXRoLFxyXG5cdGZpbGVOYW1lLFxyXG5cdGlkLFxyXG59OiB7XHJcblx0c3lzdGVtOiBzdHJpbmc7XHJcblx0cGF0aDogc3RyaW5nO1xyXG5cdGZpbGVOYW1lOiBzdHJpbmc7XHJcblx0aWQ/OiBzdHJpbmc7XHJcbn0pIHtcclxuXHRjb25zdCBhcHAgPSBwbHVnaW5IYW5kbGVyLmFwcDtcclxuXHJcblx0Y29uc3QgY29tcG9uZW50VGVtcGxhdGUgPSBhd2FpdCByZWFkRmlsZShcclxuXHRcdGFwcC52YXVsdC5hZGFwdGVyLmdldEJhc2VQYXRoKCkgK1xyXG5cdFx0XHRcIi8ub2JzaWRpYW4vcGx1Z2lucy9za2Ffc2UvdGVtcGxhdGVzL2NvbXBvbmVudC50ZW1wbGF0ZS5tZFwiXHJcblx0KTtcclxuXHJcblx0Ly8gcmVwbGFjZSAlc3lzdGVtJSB3aXRoIHN5c3RlbSdzIG5hbWUgYW5kICVpZCUgd2l0aCBjb21wb25lbnQncyBpZCB3aGljaCBpcyBzeXN0ZW0gbmFtZSArIGNvbXBvbmVudCBuYW1lXHJcblx0bGV0IGRhdGEgPSBjb21wb25lbnRUZW1wbGF0ZS50b1N0cmluZygpLnJlcGxhY2UoLyVzeXN0ZW0lL2csIHN5c3RlbSk7XHJcblxyXG5cdGlmIChpZCkge1xyXG5cdFx0ZGF0YSA9IGRhdGEucmVwbGFjZSgvJWlkJS9nLCBpZC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLyAvZywgXCJfXCIpKTtcclxuXHR9XHJcblxyXG5cdGF3YWl0IGFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGF0aCArIFwiL1wiICsgZmlsZU5hbWUpO1xyXG5cclxuXHRyZXR1cm4gYXdhaXQgYXBwLnZhdWx0LmNyZWF0ZShcclxuXHRcdHBhdGggKyBcIi9cIiArIGZpbGVOYW1lICsgXCIvXCIgKyBmaWxlTmFtZSArIFwiLm1kXCIsXHJcblx0XHRkYXRhXHJcblx0KTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZFRvU3lzdGVtRGlhZ3JhbSh7XHJcblx0ZmlsZSxcclxuXHRpc0NvbXBvbmVudCxcclxufToge1xyXG5cdGZpbGU6IFRGaWxlO1xyXG5cdGlzQ29tcG9uZW50PzogYm9vbGVhbjtcclxufSkge1xyXG5cdGNvbnN0IGFwcCA9IHBsdWdpbkhhbmRsZXIuYXBwO1xyXG5cdGNvbnN0IHN5c3RlbURpYWdyYW0gPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChcclxuXHRcdFwiU3lzdGVtIERpYWdyYW0uY2FudmFzXCIsXHJcblx0XHRcIlwiXHJcblx0KTtcclxuXHRjb25zb2xlLmxvZyhzeXN0ZW1EaWFncmFtKTtcclxuXHRpZiAoIXN5c3RlbURpYWdyYW0pIHRocm93IG5ldyBFcnJvcihcIk5vIHN5c3RlbSBkaWFncmFtIGZvdW5kXCIpO1xyXG5cdGNvbnN0IGQgPSBhd2FpdCBhcHAudmF1bHQuY2FjaGVkUmVhZChzeXN0ZW1EaWFncmFtKTtcclxuXHRjb25zdCBkYXRhSnNvbiA9IEpTT04ucGFyc2UoZCk7XHJcblxyXG5cdC8ve1widHlwZVwiOlwiZ3JvdXBcIixcImlkXCI6XCI5NmVkYjQ1MmEyZTI3ZmYwXCIsXCJmaWxlXCI6XCJSb2NrZXQgU3lzdGVtcy9Qcm9wdWxzaW9uL1Byb3B1bHNpb24ubWRcIixcInhcIjotMTY0MCxcInlcIjotMTg2MCxcIndpZHRoXCI6NzQwLFwiaGVpZ2h0XCI6NzAwLFwibGFiZWxcIjpcIlByb3B1bHNpb25cIn1cclxuXHJcblx0Ly8gdHJhbnNmb3JtOiB0cmFuc2xhdGUoNDgwLjVweCwgNDkzLjVweCkgc2NhbGUoMC44MDI0OTYpIHRyYW5zbGF0ZSgtMzc5LjAzM3B4LCAxMzQuMTcxcHgpO1xyXG5cdC8vIGdldCBjYW52YXMgdHJhbnNsYXRlIGFzIHggYW5kIHlcclxuXHRjb25zdCBjYW52YXNTdHlsZSA9IGFwcC53b3Jrc3BhY2VcclxuXHRcdC5nZXRMZWFmKClcclxuXHRcdC5nZXRDb250YWluZXIoKVxyXG5cdFx0Py5kb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNhbnZhc1wiKVswXVxyXG5cdFx0Py5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcclxuXHJcblx0Y29uc3QgY2FudmFzVHJhbnNsYXRlID0gY2FudmFzU3R5bGVcclxuXHRcdD8uc3BsaXQoXCJ0cmFuc2xhdGUoXCIpWzJdXHJcblx0XHQ/LnNwbGl0KFwicHgpXCIpWzBdXHJcblx0XHQ/LnNwbGl0KFwicHgsIFwiKSA/PyBbMCwgMF07XHJcblxyXG5cdGRhdGFKc29uLm5vZGVzLnB1c2goe1xyXG5cdFx0dHlwZTogaXNDb21wb25lbnQgPyBcInRleHRcIiA6IFwiZ3JvdXBcIixcclxuXHRcdGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTQpLFxyXG5cdFx0ZmlsZTogZmlsZS5wYXRoLFxyXG5cdFx0eDogTnVtYmVyKC1jYW52YXNUcmFuc2xhdGVbMF0pIC0gMTUwLFxyXG5cdFx0eTogTnVtYmVyKC1jYW52YXNUcmFuc2xhdGVbMV0pIC0gMTAwLFxyXG5cdFx0d2lkdGg6IDMwMCxcclxuXHRcdGhlaWdodDogMjAwLFxyXG5cdFx0bGFiZWw6IGZpbGUuYmFzZW5hbWUsXHJcblx0XHQuLi4oaXNDb21wb25lbnQgPyB7IHRleHQ6IGZpbGUuYmFzZW5hbWUgfSA6IHt9KSxcclxuXHR9KTtcclxuXHJcblx0YXdhaXQgYXBwLnZhdWx0Lm1vZGlmeShzeXN0ZW1EaWFncmFtLCBKU09OLnN0cmluZ2lmeShkYXRhSnNvbikpO1xyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Im5hbWVzIjogWyJDb25maWd1cmF0aW9uIiwgIl9hIiwgIkJhc2VBUEkiLCAiUmVzcG9uc2VFcnJvciIsICJGZXRjaEVycm9yIiwgIlJlcXVpcmVkRXJyb3IiLCAiSlNPTkFwaVJlc3BvbnNlIiwgIlZvaWRBcGlSZXNwb25zZSIsICJCbG9iQXBpUmVzcG9uc2UiLCAiVGV4dEFwaVJlc3BvbnNlIiwgIkluZGV4T3BlcmF0aW9uc0FwaSIsICJfYSIsICJWZWN0b3JPcGVyYXRpb25zQXBpIiwgIl9hIiwgIkJhc2VQaW5lY29uZUVycm9yIiwgIlBpbmVjb25lQ29uZmlndXJhdGlvbkVycm9yIiwgIlBpbmVjb25lVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IiLCAiUGluZWNvbmVFbnZpcm9ubWVudFZhcnNOb3RTdXBwb3J0ZWRFcnJvciIsICJQaW5lY29uZVVua25vd25SZXF1ZXN0RmFpbHVyZSIsICJQaW5lY29uZUJhZFJlcXVlc3RFcnJvciIsICJQaW5lY29uZUF1dGhvcml6YXRpb25FcnJvciIsICJQaW5lY29uZU5vdEZvdW5kRXJyb3IiLCAiUGluZWNvbmVDb25mbGljdEVycm9yIiwgIlBpbmVjb25lSW50ZXJuYWxTZXJ2ZXJFcnJvciIsICJQaW5lY29uZU5vdEltcGxlbWVudGVkRXJyb3IiLCAiUGluZWNvbmVVbm1hcHBlZEh0dHBFcnJvciIsICJQaW5lY29uZUNvbm5lY3Rpb25FcnJvciIsICJQaW5lY29uZUFyZ3VtZW50RXJyb3IiLCAiX2EiLCAiX2EiLCAiUGluZWNvbmVCYXRjaFVwc2VydEVycm9yIiwgIl9hIiwgIlVzZWRWYWx1ZVN0YXRlIiwgIl9hIiwgIl9hIiwgInNlbGYiLCAiVHlwZSIsICJhZGRFcnJvciIsICJzZWxmIiwgIl9hIiwgIkRhdGFUeXBlIiwgIl9hIiwgInNlbGYiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJiYXNlSWQiLCAic2VsZiIsICJfYSIsICJtb2R1bGUiLCAibWVyZ2UiLCAic2V0cyIsICJsZW5ndGgiLCAic2xpY2UiLCAieGwiLCAieCIsICJqb2luIiwgInN1YmV4cCIsICJzdHIiLCAidHlwZU9mIiwgIm8iLCAidW5kZWZpbmVkIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiY2FsbCIsICJzcGxpdCIsICJwb3AiLCAic2hpZnQiLCAidG9Mb3dlckNhc2UiLCAidG9VcHBlckNhc2UiLCAidG9BcnJheSIsICJvYmoiLCAiQXJyYXkiLCAic2V0SW50ZXJ2YWwiLCAiYXNzaWduIiwgInRhcmdldCIsICJzb3VyY2UiLCAia2V5IiwgImJ1aWxkRXhwcyIsICJpc0lSSSIsICJBTFBIQSQkIiwgIkNSJCIsICJESUdJVCQkIiwgIkRRVU9URSQkIiwgIkhFWERJRyQkIiwgIlNQJCQiLCAiUENUX0VOQ09ERUQkIiwgIlNVQl9ERUxJTVMkJCIsICJSRVNFUlZFRCQkIiwgIkdFTl9ERUxJTVMkJCIsICJVQ1NDSEFSJCQiLCAiU0NIRU1FJCIsICJVU0VSSU5GTyQiLCAiVU5SRVNFUlZFRCQkIiwgIkRFQ19PQ1RFVCQiLCAiREVDX09DVEVUX1JFTEFYRUQkIiwgIkgxNiQiLCAiTFMzMiQiLCAiSVBWNEFERFJFU1MkIiwgIklQVjZBRERSRVNTMSQiLCAiSVBWNkFERFJFU1MyJCIsICJJUFY2QUREUkVTUzMkIiwgIklQVjZBRERSRVNTNCQiLCAiSVBWNkFERFJFU1M1JCIsICJJUFY2QUREUkVTUzYkIiwgIklQVjZBRERSRVNTNyQiLCAiSVBWNkFERFJFU1M4JCIsICJJUFY2QUREUkVTUzkkIiwgIlpPTkVJRCQiLCAiSVBWNkFERFJFU1MkIiwgIklQX0xJVEVSQUwkIiwgIklQVjZBRERSWl9SRUxBWEVEJCIsICJJUFZGVVRVUkUkIiwgIkhPU1QkIiwgIlJFR19OQU1FJCIsICJQT1JUJCIsICJBVVRIT1JJVFkkIiwgIlBDSEFSJCIsICJTRUdNRU5UJCIsICJTRUdNRU5UX05aJCIsICJTRUdNRU5UX05aX05DJCIsICJQQVRIX0FCRU1QVFkkIiwgIlBBVEhfQUJTT0xVVEUkIiwgIlBBVEgkIiwgIlBBVEhfTk9TQ0hFTUUkIiwgIlBBVEhfUk9PVExFU1MkIiwgIlBBVEhfRU1QVFkkIiwgIlFVRVJZJCIsICJJUFJJVkFURSQkIiwgIkZSQUdNRU5UJCIsICJISUVSX1BBUlQkIiwgIlVSSSQiLCAiUkVMQVRJVkVfUEFSVCQiLCAiUkVMQVRJVkUkIiwgIlVSSV9SRUZFUkVOQ0UkIiwgIkFCU09MVVRFX1VSSSQiLCAiR0VORVJJQ19SRUYkIiwgIlJFTEFUSVZFX1JFRiQiLCAiQUJTT0xVVEVfUkVGJCIsICJTQU1FRE9DX1JFRiQiLCAiQVVUSE9SSVRZX1JFRiQiLCAiUmVnRXhwIiwgIm1heEludCIsICJiYXNlIiwgInRNaW4iLCAidE1heCIsICJza2V3IiwgImRhbXAiLCAiaW5pdGlhbEJpYXMiLCAiaW5pdGlhbE4iLCAiZGVsaW1pdGVyIiwgInJlZ2V4UHVueWNvZGUiLCAicmVnZXhOb25BU0NJSSIsICJyZWdleFNlcGFyYXRvcnMiLCAiZXJyb3JzIiwgImJhc2VNaW51c1RNaW4iLCAiZmxvb3IiLCAiTWF0aCIsICJzdHJpbmdGcm9tQ2hhckNvZGUiLCAiU3RyaW5nIiwgImZyb21DaGFyQ29kZSIsICJlcnJvciIsICJ0eXBlIiwgIlJhbmdlRXJyb3IiLCAibWFwIiwgImFycmF5IiwgImZuIiwgInJlc3VsdCIsICJtYXBEb21haW4iLCAic3RyaW5nIiwgInBhcnRzIiwgInJlcGxhY2UiLCAibGFiZWxzIiwgImVuY29kZWQiLCAidWNzMmRlY29kZSIsICJvdXRwdXQiLCAiY291bnRlciIsICJ2YWx1ZSIsICJjaGFyQ29kZUF0IiwgImV4dHJhIiwgInB1c2giLCAidWNzMmVuY29kZSIsICJmcm9tQ29kZVBvaW50IiwgImJhc2ljVG9EaWdpdCIsICJjb2RlUG9pbnQiLCAiZGlnaXRUb0Jhc2ljIiwgImRpZ2l0IiwgImZsYWciLCAiYWRhcHQiLCAiZGVsdGEiLCAibnVtUG9pbnRzIiwgImZpcnN0VGltZSIsICJrIiwgImRlY29kZSIsICJpbnB1dCIsICJpbnB1dExlbmd0aCIsICJpIiwgIm4iLCAiYmlhcyIsICJiYXNpYyIsICJsYXN0SW5kZXhPZiIsICJqIiwgImluZGV4IiwgIm9sZGkiLCAidyIsICJ0IiwgImJhc2VNaW51c1QiLCAib3V0IiwgInNwbGljZSIsICJlbmNvZGUiLCAiY3VycmVudFZhbHVlIiwgImJhc2ljTGVuZ3RoIiwgImhhbmRsZWRDUENvdW50IiwgIm0iLCAiaGFuZGxlZENQQ291bnRQbHVzT25lIiwgInEiLCAicU1pbnVzVCIsICJ0b1VuaWNvZGUiLCAidGVzdCIsICJ0b0FTQ0lJIiwgInB1bnljb2RlIiwgIlNDSEVNRVMiLCAicGN0RW5jQ2hhciIsICJjaHIiLCAiYyIsICJlIiwgInBjdERlY0NoYXJzIiwgIm5ld1N0ciIsICJpbCIsICJwYXJzZUludCIsICJzdWJzdHIiLCAiYzIiLCAiYzMiLCAiX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIiwgImNvbXBvbmVudHMiLCAicHJvdG9jb2wiLCAiZGVjb2RlVW5yZXNlcnZlZCIsICJkZWNTdHIiLCAibWF0Y2giLCAiVU5SRVNFUlZFRCIsICJzY2hlbWUiLCAiUENUX0VOQ09ERUQiLCAiTk9UX1NDSEVNRSIsICJ1c2VyaW5mbyIsICJOT1RfVVNFUklORk8iLCAiaG9zdCIsICJOT1RfSE9TVCIsICJwYXRoIiwgIk5PVF9QQVRIIiwgIk5PVF9QQVRIX05PU0NIRU1FIiwgInF1ZXJ5IiwgIk5PVF9RVUVSWSIsICJmcmFnbWVudCIsICJOT1RfRlJBR01FTlQiLCAiX3N0cmlwTGVhZGluZ1plcm9zIiwgIl9ub3JtYWxpemVJUHY0IiwgIm1hdGNoZXMiLCAiSVBWNEFERFJFU1MiLCAiYWRkcmVzcyIsICJfbm9ybWFsaXplSVB2NiIsICJJUFY2QUREUkVTUyIsICJ6b25lIiwgInJldmVyc2UiLCAibGFzdCIsICJmaXJzdCIsICJmaXJzdEZpZWxkcyIsICJsYXN0RmllbGRzIiwgImlzTGFzdEZpZWxkSVB2NEFkZHJlc3MiLCAiZmllbGRDb3VudCIsICJsYXN0RmllbGRzU3RhcnQiLCAiZmllbGRzIiwgImFsbFplcm9GaWVsZHMiLCAicmVkdWNlIiwgImFjYyIsICJmaWVsZCIsICJsYXN0TG9uZ2VzdCIsICJsb25nZXN0WmVyb0ZpZWxkcyIsICJzb3J0IiwgImEiLCAiYiIsICJuZXdIb3N0IiwgIm5ld0ZpcnN0IiwgIm5ld0xhc3QiLCAiVVJJX1BBUlNFIiwgIk5PX01BVENIX0lTX1VOREVGSU5FRCIsICJwYXJzZSIsICJ1cmlTdHJpbmciLCAib3B0aW9ucyIsICJpcmkiLCAiSVJJX1BST1RPQ09MIiwgIlVSSV9QUk9UT0NPTCIsICJyZWZlcmVuY2UiLCAicG9ydCIsICJpc05hTiIsICJpbmRleE9mIiwgInNjaGVtZUhhbmRsZXIiLCAidW5pY29kZVN1cHBvcnQiLCAiZG9tYWluSG9zdCIsICJfcmVjb21wb3NlQXV0aG9yaXR5IiwgInVyaVRva2VucyIsICJfIiwgIiQxIiwgIiQyIiwgIlJEUzEiLCAiUkRTMiIsICJSRFMzIiwgIlJEUzUiLCAicmVtb3ZlRG90U2VnbWVudHMiLCAiaW0iLCAicyIsICJFcnJvciIsICJzZXJpYWxpemUiLCAiYXV0aG9yaXR5IiwgImNoYXJBdCIsICJhYnNvbHV0ZVBhdGgiLCAicmVzb2x2ZUNvbXBvbmVudHMiLCAicmVsYXRpdmUiLCAic2tpcE5vcm1hbGl6YXRpb24iLCAidG9sZXJhbnQiLCAicmVzb2x2ZSIsICJiYXNlVVJJIiwgInJlbGF0aXZlVVJJIiwgInNjaGVtZWxlc3NPcHRpb25zIiwgIm5vcm1hbGl6ZSIsICJ1cmkiLCAiZXF1YWwiLCAidXJpQSIsICJ1cmlCIiwgImVzY2FwZUNvbXBvbmVudCIsICJFU0NBUEUiLCAidW5lc2NhcGVDb21wb25lbnQiLCAiaGFuZGxlciIsICJzZWN1cmUiLCAiaHR0cCIsICJpc1NlY3VyZSIsICJ3c0NvbXBvbmVudHMiLCAicmVzb3VyY2VOYW1lIiwgIndzIiwgIk8iLCAiQVRFWFQkJCIsICJRVEVYVCQkIiwgIlZDSEFSJCQiLCAiU09NRV9ERUxJTVMkJCIsICJOT1RfTE9DQUxfUEFSVCIsICJOT1RfSEZOQU1FIiwgIk5PVF9IRlZBTFVFIiwgIm1haWx0b0NvbXBvbmVudHMiLCAidG8iLCAidW5rbm93bkhlYWRlcnMiLCAiaGVhZGVycyIsICJoZmllbGRzIiwgImhmaWVsZCIsICJ0b0FkZHJzIiwgInN1YmplY3QiLCAiYm9keSIsICJhZGRyIiwgInRvQWRkciIsICJhdElkeCIsICJsb2NhbFBhcnQiLCAiZG9tYWluIiwgIm5hbWUiLCAiVVJOX1BBUlNFIiwgInVybkNvbXBvbmVudHMiLCAibmlkIiwgIm5zcyIsICJ1cm5TY2hlbWUiLCAidXJpQ29tcG9uZW50cyIsICJVVUlEIiwgInV1aWRDb21wb25lbnRzIiwgInV1aWQiLCAiaHR0cHMiLCAid3NzIiwgIm1haWx0byIsICJ1cm4iLCAiX2EiLCAic2VsZiIsICJfYSIsICJzZWxmIiwgIkRpc2NyRXJyb3IiLCAiX2EiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ2YWxpZGF0aW9uRXJyb3JzIiwgImVycm9yIiwgIl9hIiwgIl9hIiwgIlR5cGVSZWdpc3RyeSIsICJraW5kIiwgIlNldCIsICJGb3JtYXRSZWdpc3RyeSIsICJUeXBlR3VhcmQiLCAic2NoZW1hIiwgIkV4dGVuZHNVbmRlZmluZWQiLCAiVHlwZUV4dGVuZHNSZXN1bHQiLCAiVHlwZUV4dGVuZHMiLCAiQXJyYXkiLCAiQm9vbGVhbiIsICJEYXRlIiwgIkZ1bmN0aW9uIiwgIk51bWJlciIsICJPYmplY3QiLCAiUHJvbWlzZSIsICJTdHJpbmciLCAiU3ltYm9sIiwgIlVpbnQ4QXJyYXkiLCAiVHlwZUNsb25lIiwgInZhbHVlIiwgIkluZGV4ZWRBY2Nlc3NvciIsICJPYmplY3RNYXAiLCAiTWFwIiwgIktleVJlc29sdmVyIiwgIktleUFycmF5UmVzb2x2ZXIiLCAiVW5pb25SZXNvbHZlciIsICJUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuIiwgIlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyIiwgIlRlbXBsYXRlTGl0ZXJhbFBhcnNlciIsICJyYW5nZSIsICJwYXR0ZXJuIiwgIlRlbXBsYXRlTGl0ZXJhbEZpbml0ZSIsICJUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IiLCAiVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyIiwgImtleSIsICJfYSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImdsb2JhbCIsICJzZWxmIiwgImV4cG9ydHMiLCAiSGVhZGVycyIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgImZldGNoIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgIlVwc2VydENvbW1hbmQiLCAiX2EiLCAiRmV0Y2hDb21tYW5kIiwgIl9hIiwgIlVwZGF0ZUNvbW1hbmQiLCAiX2EiLCAiUXVlcnlDb21tYW5kIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgIl9hIiwgImZldGNoIiwgIl9hIiwgIlZlY3Rvck9wZXJhdGlvbnNQcm92aWRlciIsICJfYSIsICJJbmRleCIsICJfYSIsICJQaW5lY29uZSIsICJfYSIsICJDb25maWd1cmF0aW9uIiwgIl9hIiwgIkJhc2VBUEkiLCAiUmVzcG9uc2VFcnJvciIsICJGZXRjaEVycm9yIiwgIlJlcXVpcmVkRXJyb3IiLCAiSlNPTkFwaVJlc3BvbnNlIiwgIlZvaWRBcGlSZXNwb25zZSIsICJCbG9iQXBpUmVzcG9uc2UiLCAiVGV4dEFwaVJlc3BvbnNlIiwgIkluZGV4T3BlcmF0aW9uc0FwaSIsICJfYSIsICJWZWN0b3JPcGVyYXRpb25zQXBpIiwgIl9hIiwgInNlbGYiLCAiZXhwb3J0cyIsICJIZWFkZXJzIiwgIlJlcXVlc3QiLCAiUmVzcG9uc2UiLCAiZmV0Y2giLCAiUGluZWNvbmVFcnJvciIsICJfYSIsICJwcm9wIiwgIlBpbmVjb25lQ2xpZW50IiwgIl9hIiwgImltcG9ydF9wcm9taXNlcyIsICJhcHAiLCAiYXBwIiwgIl9hIiwgImhlYWRpbmciLCAiX2EiLCAiZmV0Y2giLCAiUmVxdWVzdCIsICJSZXNwb25zZSIsICJIZWFkZXJzIiwgIkZvcm1EYXRhIiwgIkJsb2IiLCAiRmlsZSIsICJfYSIsICJGaWxlIiwgIkZvcm1EYXRhIiwgImZldGNoIiwgIm9wdHMiLCAiUGFnZSIsICJfYSIsICJQYWdlIiwgIl9hIiwgIl9hIiwgIlRyYW5zY3JpcHRpb25zIiwgIlRyYW5zbGF0aW9ucyIsICJBdWRpbyIsICJfYSIsICJDb21wbGV0aW9ucyIsICJDaGF0IiwgIkNvbXBsZXRpb25zIiwgIl9hIiwgIkVtYmVkZGluZ3MiLCAiRWRpdHMiLCAiRmlsZXMiLCAiX2EiLCAiRmluZVR1bmVzIiwgIkpvYnMiLCAiRmluZVR1bmluZyIsICJJbWFnZXMiLCAiTW9kZWxzIiwgIk1vZGVyYXRpb25zIiwgIkNvbXBsZXRpb25zIiwgIk9wZW5BSUVycm9yIiwgIkFQSUVycm9yIiwgIkFQSUNvbm5lY3Rpb25FcnJvciIsICJBUElDb25uZWN0aW9uVGltZW91dEVycm9yIiwgIkFQSVVzZXJBYm9ydEVycm9yIiwgIk5vdEZvdW5kRXJyb3IiLCAiQ29uZmxpY3RFcnJvciIsICJSYXRlTGltaXRFcnJvciIsICJCYWRSZXF1ZXN0RXJyb3IiLCAiQXV0aGVudGljYXRpb25FcnJvciIsICJJbnRlcm5hbFNlcnZlckVycm9yIiwgIlBlcm1pc3Npb25EZW5pZWRFcnJvciIsICJVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IiLCAiT3BlbkFJIiwgIkNvbXBsZXRpb25zIiwgIl9hIiwgImFwcCIsICJub2RlIiwgIl9iIiwgImFwcCIsICJfYSIsICJfYSIsICJhcHAiLCAiZWRnZSIsICJ0b0ZpbGUiXQp9Cg==
